""" Cisco_IOS_XR_ip_tcp_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR ip\-tcp package operational data.

This module contains definitions
for the following management objects\:
  tcp\-connection\: TCP connection operational data
  tcp\: tcp
  tcp\-nsr\: tcp nsr

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class AddrFamily(Enum):
    """
    AddrFamily

    Address Family Types

    .. data:: internetwork = 2

    	Internetwork: UDP, TCP, etc.

    .. data:: ip_version6 = 10

    	IP version 6

    """

    internetwork = Enum.YLeaf(2, "internetwork")

    ip_version6 = Enum.YLeaf(10, "ip-version6")


class MessageTypeIcmp(Enum):
    """
    MessageTypeIcmp

    LPTS ICMP message types

    .. data:: echo_reply = 0

    	ICMP Packet type: Echo reply

    .. data:: destination_unreachable = 3

    	ICMP Packet type: Destination unreachable

    .. data:: source_quench = 4

    	ICMP Packet type: Source quench

    .. data:: redirect = 5

    	ICMP Packet type: Redirect

    .. data:: alternate_host_address = 6

    	ICMP Packet type: Alternate host address

    .. data:: echo = 8

    	ICMP Packet type: Echo

    .. data:: router_advertisement = 9

    	ICMP Packet type: Router advertisement

    .. data:: router_selection = 10

    	ICMP Packet type: Router selection

    .. data:: time_exceeded = 11

    	ICMP Packet type: Time exceeded

    .. data:: parameter_problem = 12

    	ICMP Packet type: Parameter problem

    .. data:: time_stamp = 13

    	ICMP Packet type: Time stamp

    .. data:: time_stamp_reply = 14

    	ICMP Packet type: Time stamp reply

    .. data:: information_request = 15

    	ICMP Packet type: Information request

    .. data:: information_reply = 16

    	ICMP Packet type: Information reply

    .. data:: address_mask_request = 17

    	ICMP Packet type: Address mask request

    .. data:: address_mask_reply = 18

    	ICMP Packet type: Address mask reply

    .. data:: trace_route = 30

    	ICMP Packet type: Trace route

    .. data:: datagram_conversion_error = 31

    	ICMP Packet type: Datagram Conversion error

    .. data:: mobile_host_redirect = 32

    	ICMP Packet type: Mobile host redirect

    .. data:: where_are_you = 33

    	ICMP Packet type: IPv6 where-are-you

    .. data:: iam_here = 34

    	ICMP Packet type: IPv6 i-am-here

    .. data:: mobile_registration_request = 35

    	ICMP Packet type: Mobile registration request

    .. data:: mobile_registration_reply = 36

    	ICMP Packet type: Mobile registration reply

    .. data:: domain_name_request = 37

    	ICMP Packet type: Domain name request

    """

    echo_reply = Enum.YLeaf(0, "echo-reply")

    destination_unreachable = Enum.YLeaf(3, "destination-unreachable")

    source_quench = Enum.YLeaf(4, "source-quench")

    redirect = Enum.YLeaf(5, "redirect")

    alternate_host_address = Enum.YLeaf(6, "alternate-host-address")

    echo = Enum.YLeaf(8, "echo")

    router_advertisement = Enum.YLeaf(9, "router-advertisement")

    router_selection = Enum.YLeaf(10, "router-selection")

    time_exceeded = Enum.YLeaf(11, "time-exceeded")

    parameter_problem = Enum.YLeaf(12, "parameter-problem")

    time_stamp = Enum.YLeaf(13, "time-stamp")

    time_stamp_reply = Enum.YLeaf(14, "time-stamp-reply")

    information_request = Enum.YLeaf(15, "information-request")

    information_reply = Enum.YLeaf(16, "information-reply")

    address_mask_request = Enum.YLeaf(17, "address-mask-request")

    address_mask_reply = Enum.YLeaf(18, "address-mask-reply")

    trace_route = Enum.YLeaf(30, "trace-route")

    datagram_conversion_error = Enum.YLeaf(31, "datagram-conversion-error")

    mobile_host_redirect = Enum.YLeaf(32, "mobile-host-redirect")

    where_are_you = Enum.YLeaf(33, "where-are-you")

    iam_here = Enum.YLeaf(34, "iam-here")

    mobile_registration_request = Enum.YLeaf(35, "mobile-registration-request")

    mobile_registration_reply = Enum.YLeaf(36, "mobile-registration-reply")

    domain_name_request = Enum.YLeaf(37, "domain-name-request")


class MessageTypeIcmp(Enum):
    """
    MessageTypeIcmp

    LPTS ICMP message types

    .. data:: echo_reply = 0

    	ICMP Packet type: Echo reply

    .. data:: destination_unreachable = 3

    	ICMP Packet type: Destination unreachable

    .. data:: source_quench = 4

    	ICMP Packet type: Source quench

    .. data:: redirect = 5

    	ICMP Packet type: Redirect

    .. data:: alternate_host_address = 6

    	ICMP Packet type: Alternate host address

    .. data:: echo = 8

    	ICMP Packet type: Echo

    .. data:: router_advertisement = 9

    	ICMP Packet type: Router advertisement

    .. data:: router_selection = 10

    	ICMP Packet type: Router selection

    .. data:: time_exceeded = 11

    	ICMP Packet type: Time exceeded

    .. data:: parameter_problem = 12

    	ICMP Packet type: Parameter problem

    .. data:: time_stamp = 13

    	ICMP Packet type: Time stamp

    .. data:: time_stamp_reply = 14

    	ICMP Packet type: Time stamp reply

    .. data:: information_request = 15

    	ICMP Packet type: Information request

    .. data:: information_reply = 16

    	ICMP Packet type: Information reply

    .. data:: address_mask_request = 17

    	ICMP Packet type: Address mask request

    .. data:: address_mask_reply = 18

    	ICMP Packet type: Address mask reply

    .. data:: trace_route = 30

    	ICMP Packet type: Trace route

    .. data:: datagram_conversion_error = 31

    	ICMP Packet type: Datagram Conversion error

    .. data:: mobile_host_redirect = 32

    	ICMP Packet type: Mobile host redirect

    .. data:: where_are_you = 33

    	ICMP Packet type: IPv6 where-are-you

    .. data:: iam_here = 34

    	ICMP Packet type: IPv6 i-am-here

    .. data:: mobile_registration_request = 35

    	ICMP Packet type: Mobile registration request

    .. data:: mobile_registration_reply = 36

    	ICMP Packet type: Mobile registration reply

    .. data:: domain_name_request = 37

    	ICMP Packet type: Domain name request

    """

    echo_reply = Enum.YLeaf(0, "echo-reply")

    destination_unreachable = Enum.YLeaf(3, "destination-unreachable")

    source_quench = Enum.YLeaf(4, "source-quench")

    redirect = Enum.YLeaf(5, "redirect")

    alternate_host_address = Enum.YLeaf(6, "alternate-host-address")

    echo = Enum.YLeaf(8, "echo")

    router_advertisement = Enum.YLeaf(9, "router-advertisement")

    router_selection = Enum.YLeaf(10, "router-selection")

    time_exceeded = Enum.YLeaf(11, "time-exceeded")

    parameter_problem = Enum.YLeaf(12, "parameter-problem")

    time_stamp = Enum.YLeaf(13, "time-stamp")

    time_stamp_reply = Enum.YLeaf(14, "time-stamp-reply")

    information_request = Enum.YLeaf(15, "information-request")

    information_reply = Enum.YLeaf(16, "information-reply")

    address_mask_request = Enum.YLeaf(17, "address-mask-request")

    address_mask_reply = Enum.YLeaf(18, "address-mask-reply")

    trace_route = Enum.YLeaf(30, "trace-route")

    datagram_conversion_error = Enum.YLeaf(31, "datagram-conversion-error")

    mobile_host_redirect = Enum.YLeaf(32, "mobile-host-redirect")

    where_are_you = Enum.YLeaf(33, "where-are-you")

    iam_here = Enum.YLeaf(34, "iam-here")

    mobile_registration_request = Enum.YLeaf(35, "mobile-registration-request")

    mobile_registration_reply = Enum.YLeaf(36, "mobile-registration-reply")

    domain_name_request = Enum.YLeaf(37, "domain-name-request")


class MessageTypeIcmpv6(Enum):
    """
    MessageTypeIcmpv6

    LPTS ICMPv6 message types

    .. data:: destination_unreachable = 1

    	ICMPv6 Packet type: Destination unreachable

    .. data:: packet_too_big = 2

    	ICMPv6 Packet type: packet too big

    .. data:: time_exceeded = 3

    	ICMPv6 Packet type: Time exceeded

    .. data:: parameter_problem = 4

    	ICMPv6 Packet type: Parameter problem

    .. data:: echo_request = 128

    	ICMPv6 Packet type: Echo request

    .. data:: echo_reply = 129

    	ICMPv6 Packet type: Echo reply

    .. data:: multicast_listener_query = 130

    	ICMPv6 Packet type: Multicast listener query

    .. data:: multicast_listener_report = 131

    	ICMPv6 Packet type: Multicast listener report

    .. data:: multicast_listener_done = 132

    	ICMPv6 Packet type: Multicast listener done

    .. data:: router_solicitation = 133

    	ICMPv6 Packet type: Router solicitation

    .. data:: router_advertisement = 134

    	ICMPv6 Packet type: Router advertisement

    .. data:: neighbor_solicitation = 135

    	ICMPv6 Packet type: Neighbor solicitation

    .. data:: neighbor_advertisement = 136

    	ICMPv6 Packet type: Neighbor advertisement

    .. data:: redirect_message = 137

    	ICMPv6 Packet type: Redirect message

    .. data:: router_renumbering = 138

    	ICMPv6 Packet type: Router renumbering

    .. data:: node_information_query = 139

    	ICMPv6 Packet type: Node information query

    .. data:: node_information_reply = 140

    	ICMPv6 Packet type: Node information reply

    .. data:: inverse_neighbor_discovery_solicitaion = 141

    	ICMPv6 Packet type: Inverse neighbor discovery

    	solicitation message

    .. data:: inverse_neighbor_discover_advertisement = 142

    	ICMPv6 Packet type: Inverse neighbor discovery

    	advertisement message

    .. data:: v2_multicast_listener_report = 143

    	ICMPv6 Packet type: Version 2 multicast

    	listener report

    .. data:: home_agent_address_discovery_request = 144

    	ICMPv6 Packet type: Home agent address

    	discovery request message

    .. data:: home_agent_address_discovery_reply = 145

    	ICMPv6 Packet type: Home agent address

    	discovery reply message

    .. data:: mobile_prefix_solicitation = 146

    	ICMPv6 Packet type: Mobile prefix solicitation

    .. data:: mobile_prefix_advertisement = 147

    	ICMPv6 Packet type: Mobile prefix advertisement

    .. data:: certification_path_solicitation_message = 148

    	ICMPv6 Packet type: Certification path

    	solicitation message

    .. data:: certification_path_advertisement_message = 149

    	ICMPv6 Packet type: Certification path

    	advertisement message

    .. data:: experimental_mobility_protocols = 150

    	ICMPv6 Packet type: ICMP messages utilized by

    	experimental mobility  protocols such as

    	seamoby

    .. data:: multicast_router_advertisement = 151

    	ICMPv6 Packet type: Multicast router

    	advertisement

    .. data:: multicast_router_solicitation = 152

    	ICMPv6 Packet type: Multicast router

    	solicitation

    .. data:: multicast_router_termination = 153

    	ICMPv6 Packet type: Multicast router

    	termination

    .. data:: fmipv6_messages = 154

    	ICMPv6 Packet type: FMIPv6 messages

    """

    destination_unreachable = Enum.YLeaf(1, "destination-unreachable")

    packet_too_big = Enum.YLeaf(2, "packet-too-big")

    time_exceeded = Enum.YLeaf(3, "time-exceeded")

    parameter_problem = Enum.YLeaf(4, "parameter-problem")

    echo_request = Enum.YLeaf(128, "echo-request")

    echo_reply = Enum.YLeaf(129, "echo-reply")

    multicast_listener_query = Enum.YLeaf(130, "multicast-listener-query")

    multicast_listener_report = Enum.YLeaf(131, "multicast-listener-report")

    multicast_listener_done = Enum.YLeaf(132, "multicast-listener-done")

    router_solicitation = Enum.YLeaf(133, "router-solicitation")

    router_advertisement = Enum.YLeaf(134, "router-advertisement")

    neighbor_solicitation = Enum.YLeaf(135, "neighbor-solicitation")

    neighbor_advertisement = Enum.YLeaf(136, "neighbor-advertisement")

    redirect_message = Enum.YLeaf(137, "redirect-message")

    router_renumbering = Enum.YLeaf(138, "router-renumbering")

    node_information_query = Enum.YLeaf(139, "node-information-query")

    node_information_reply = Enum.YLeaf(140, "node-information-reply")

    inverse_neighbor_discovery_solicitaion = Enum.YLeaf(141, "inverse-neighbor-discovery-solicitaion")

    inverse_neighbor_discover_advertisement = Enum.YLeaf(142, "inverse-neighbor-discover-advertisement")

    v2_multicast_listener_report = Enum.YLeaf(143, "v2-multicast-listener-report")

    home_agent_address_discovery_request = Enum.YLeaf(144, "home-agent-address-discovery-request")

    home_agent_address_discovery_reply = Enum.YLeaf(145, "home-agent-address-discovery-reply")

    mobile_prefix_solicitation = Enum.YLeaf(146, "mobile-prefix-solicitation")

    mobile_prefix_advertisement = Enum.YLeaf(147, "mobile-prefix-advertisement")

    certification_path_solicitation_message = Enum.YLeaf(148, "certification-path-solicitation-message")

    certification_path_advertisement_message = Enum.YLeaf(149, "certification-path-advertisement-message")

    experimental_mobility_protocols = Enum.YLeaf(150, "experimental-mobility-protocols")

    multicast_router_advertisement = Enum.YLeaf(151, "multicast-router-advertisement")

    multicast_router_solicitation = Enum.YLeaf(152, "multicast-router-solicitation")

    multicast_router_termination = Enum.YLeaf(153, "multicast-router-termination")

    fmipv6_messages = Enum.YLeaf(154, "fmipv6-messages")


class MessageTypeIcmpv6(Enum):
    """
    MessageTypeIcmpv6

    LPTS ICMPv6 message types

    .. data:: destination_unreachable = 1

    	ICMPv6 Packet type: Destination unreachable

    .. data:: packet_too_big = 2

    	ICMPv6 Packet type: packet too big

    .. data:: time_exceeded = 3

    	ICMPv6 Packet type: Time exceeded

    .. data:: parameter_problem = 4

    	ICMPv6 Packet type: Parameter problem

    .. data:: echo_request = 128

    	ICMPv6 Packet type: Echo request

    .. data:: echo_reply = 129

    	ICMPv6 Packet type: Echo reply

    .. data:: multicast_listener_query = 130

    	ICMPv6 Packet type: Multicast listener query

    .. data:: multicast_listener_report = 131

    	ICMPv6 Packet type: Multicast listener report

    .. data:: multicast_listener_done = 132

    	ICMPv6 Packet type: Multicast listener done

    .. data:: router_solicitation = 133

    	ICMPv6 Packet type: Router solicitation

    .. data:: router_advertisement = 134

    	ICMPv6 Packet type: Router advertisement

    .. data:: neighbor_solicitation = 135

    	ICMPv6 Packet type: Neighbor solicitation

    .. data:: neighbor_advertisement = 136

    	ICMPv6 Packet type: Neighbor advertisement

    .. data:: redirect_message = 137

    	ICMPv6 Packet type: Redirect message

    .. data:: router_renumbering = 138

    	ICMPv6 Packet type: Router renumbering

    .. data:: node_information_query = 139

    	ICMPv6 Packet type: Node information query

    .. data:: node_information_reply = 140

    	ICMPv6 Packet type: Node information reply

    .. data:: inverse_neighbor_discovery_solicitaion = 141

    	ICMPv6 Packet type: Inverse neighbor discovery

    	solicitation message

    .. data:: inverse_neighbor_discover_advertisement = 142

    	ICMPv6 Packet type: Inverse neighbor discovery

    	advertisement message

    .. data:: v2_multicast_listener_report = 143

    	ICMPv6 Packet type: Version 2 multicast

    	listener report

    .. data:: home_agent_address_discovery_request = 144

    	ICMPv6 Packet type: Home agent address

    	discovery request message

    .. data:: home_agent_address_discovery_reply = 145

    	ICMPv6 Packet type: Home agent address

    	discovery reply message

    .. data:: mobile_prefix_solicitation = 146

    	ICMPv6 Packet type: Mobile prefix solicitation

    .. data:: mobile_prefix_advertisement = 147

    	ICMPv6 Packet type: Mobile prefix advertisement

    .. data:: certification_path_solicitation_message = 148

    	ICMPv6 Packet type: Certification path

    	solicitation message

    .. data:: certification_path_advertisement_message = 149

    	ICMPv6 Packet type: Certification path

    	advertisement message

    .. data:: experimental_mobility_protocols = 150

    	ICMPv6 Packet type: ICMP messages utilized by

    	experimental mobility  protocols such as

    	seamoby

    .. data:: multicast_router_advertisement = 151

    	ICMPv6 Packet type: Multicast router

    	advertisement

    .. data:: multicast_router_solicitation = 152

    	ICMPv6 Packet type: Multicast router

    	solicitation

    .. data:: multicast_router_termination = 153

    	ICMPv6 Packet type: Multicast router

    	termination

    .. data:: fmipv6_messages = 154

    	ICMPv6 Packet type: FMIPv6 messages

    """

    destination_unreachable = Enum.YLeaf(1, "destination-unreachable")

    packet_too_big = Enum.YLeaf(2, "packet-too-big")

    time_exceeded = Enum.YLeaf(3, "time-exceeded")

    parameter_problem = Enum.YLeaf(4, "parameter-problem")

    echo_request = Enum.YLeaf(128, "echo-request")

    echo_reply = Enum.YLeaf(129, "echo-reply")

    multicast_listener_query = Enum.YLeaf(130, "multicast-listener-query")

    multicast_listener_report = Enum.YLeaf(131, "multicast-listener-report")

    multicast_listener_done = Enum.YLeaf(132, "multicast-listener-done")

    router_solicitation = Enum.YLeaf(133, "router-solicitation")

    router_advertisement = Enum.YLeaf(134, "router-advertisement")

    neighbor_solicitation = Enum.YLeaf(135, "neighbor-solicitation")

    neighbor_advertisement = Enum.YLeaf(136, "neighbor-advertisement")

    redirect_message = Enum.YLeaf(137, "redirect-message")

    router_renumbering = Enum.YLeaf(138, "router-renumbering")

    node_information_query = Enum.YLeaf(139, "node-information-query")

    node_information_reply = Enum.YLeaf(140, "node-information-reply")

    inverse_neighbor_discovery_solicitaion = Enum.YLeaf(141, "inverse-neighbor-discovery-solicitaion")

    inverse_neighbor_discover_advertisement = Enum.YLeaf(142, "inverse-neighbor-discover-advertisement")

    v2_multicast_listener_report = Enum.YLeaf(143, "v2-multicast-listener-report")

    home_agent_address_discovery_request = Enum.YLeaf(144, "home-agent-address-discovery-request")

    home_agent_address_discovery_reply = Enum.YLeaf(145, "home-agent-address-discovery-reply")

    mobile_prefix_solicitation = Enum.YLeaf(146, "mobile-prefix-solicitation")

    mobile_prefix_advertisement = Enum.YLeaf(147, "mobile-prefix-advertisement")

    certification_path_solicitation_message = Enum.YLeaf(148, "certification-path-solicitation-message")

    certification_path_advertisement_message = Enum.YLeaf(149, "certification-path-advertisement-message")

    experimental_mobility_protocols = Enum.YLeaf(150, "experimental-mobility-protocols")

    multicast_router_advertisement = Enum.YLeaf(151, "multicast-router-advertisement")

    multicast_router_solicitation = Enum.YLeaf(152, "multicast-router-solicitation")

    multicast_router_termination = Enum.YLeaf(153, "multicast-router-termination")

    fmipv6_messages = Enum.YLeaf(154, "fmipv6-messages")


class MessageTypeIgmp(Enum):
    """
    MessageTypeIgmp

    LPTS IGMP message types

    .. data:: membership_query = 17

    	IGMP Packet type: Membership query

    .. data:: v1_membership_report = 18

    	IGMP Packet type: V1 membership report

    .. data:: dvmrp = 19

    	IGMP Packet type: DVMRP

    .. data:: pi_mv1 = 20

    	IGMP Packet type: PIM version 1

    .. data:: cisco_trace_messages = 21

    	IGMP Packet type: Cisco Trace Messages

    .. data:: v2_membership_report = 22

    	IGMP Packet type: V2 membership report

    .. data:: v2_leave_group = 23

    	IGMP Packet type: V2 leave group

    .. data:: multicast_traceroute_response = 30

    	IGMP Packet type: Multicast traceroute response

    .. data:: multicast_traceroute = 31

    	IGMP Packet type: MulticastTraceroute

    .. data:: v3_membership_report = 34

    	IGMP Packet type: V3 membership report

    .. data:: multicast_router_advertisement = 48

    	IGMP Packet type: Multicast router

    	advertisement

    .. data:: multicast_router_solicitation = 49

    	IGMP Packet type: Multicast router solicitation

    .. data:: multicast_router_termination = 50

    	IGMP Packet type: Multicast router termination

    """

    membership_query = Enum.YLeaf(17, "membership-query")

    v1_membership_report = Enum.YLeaf(18, "v1-membership-report")

    dvmrp = Enum.YLeaf(19, "dvmrp")

    pi_mv1 = Enum.YLeaf(20, "pi-mv1")

    cisco_trace_messages = Enum.YLeaf(21, "cisco-trace-messages")

    v2_membership_report = Enum.YLeaf(22, "v2-membership-report")

    v2_leave_group = Enum.YLeaf(23, "v2-leave-group")

    multicast_traceroute_response = Enum.YLeaf(30, "multicast-traceroute-response")

    multicast_traceroute = Enum.YLeaf(31, "multicast-traceroute")

    v3_membership_report = Enum.YLeaf(34, "v3-membership-report")

    multicast_router_advertisement = Enum.YLeaf(48, "multicast-router-advertisement")

    multicast_router_solicitation = Enum.YLeaf(49, "multicast-router-solicitation")

    multicast_router_termination = Enum.YLeaf(50, "multicast-router-termination")


class MessageTypeIgmp(Enum):
    """
    MessageTypeIgmp

    LPTS IGMP message types

    .. data:: membership_query = 17

    	IGMP Packet type: Membership query

    .. data:: v1_membership_report = 18

    	IGMP Packet type: V1 membership report

    .. data:: dvmrp = 19

    	IGMP Packet type: DVMRP

    .. data:: pi_mv1 = 20

    	IGMP Packet type: PIM version 1

    .. data:: cisco_trace_messages = 21

    	IGMP Packet type: Cisco Trace Messages

    .. data:: v2_membership_report = 22

    	IGMP Packet type: V2 membership report

    .. data:: v2_leave_group = 23

    	IGMP Packet type: V2 leave group

    .. data:: multicast_traceroute_response = 30

    	IGMP Packet type: Multicast traceroute response

    .. data:: multicast_traceroute = 31

    	IGMP Packet type: MulticastTraceroute

    .. data:: v3_membership_report = 34

    	IGMP Packet type: V3 membership report

    .. data:: multicast_router_advertisement = 48

    	IGMP Packet type: Multicast router

    	advertisement

    .. data:: multicast_router_solicitation = 49

    	IGMP Packet type: Multicast router solicitation

    .. data:: multicast_router_termination = 50

    	IGMP Packet type: Multicast router termination

    """

    membership_query = Enum.YLeaf(17, "membership-query")

    v1_membership_report = Enum.YLeaf(18, "v1-membership-report")

    dvmrp = Enum.YLeaf(19, "dvmrp")

    pi_mv1 = Enum.YLeaf(20, "pi-mv1")

    cisco_trace_messages = Enum.YLeaf(21, "cisco-trace-messages")

    v2_membership_report = Enum.YLeaf(22, "v2-membership-report")

    v2_leave_group = Enum.YLeaf(23, "v2-leave-group")

    multicast_traceroute_response = Enum.YLeaf(30, "multicast-traceroute-response")

    multicast_traceroute = Enum.YLeaf(31, "multicast-traceroute")

    v3_membership_report = Enum.YLeaf(34, "v3-membership-report")

    multicast_router_advertisement = Enum.YLeaf(48, "multicast-router-advertisement")

    multicast_router_solicitation = Enum.YLeaf(49, "multicast-router-solicitation")

    multicast_router_termination = Enum.YLeaf(50, "multicast-router-termination")


class NsrDownReason(Enum):
    """
    NsrDownReason

    NSR\-Down Reasons

    .. data:: none = 0

    	None, i.e. NSR was never up

    .. data:: init_sync_aborted = 1

    	Initial sync was aborted

    .. data:: client_disabled = 2

    	Disabled by Active APP

    .. data:: client_disconnect = 3

    	Standby APP disconnected

    .. data:: tcp_disconnect = 4

    	Standby TCP disconnected

    .. data:: failover = 5

    	RP/DRP Failover occurred

    .. data:: nsr_clear = 6

    	Clear nsr command

    .. data:: internal_error = 7

    	Internal error occurred

    .. data:: retransmit_threshold_exceed = 8

    	Retransmission threshold exceededprobably

    	becauseS-TCP was not healthy

    .. data:: init_sync_failure_thresh_exceeded = 9

    	Init-sync repeat failures have exceeded

    	threshold

    .. data:: audit_timeout = 10

    	Audit operation timed out

    .. data:: audit_failed = 11

    	Audit operation failed

    .. data:: standby_sscb_deleted = 12

    	Standby SSCB deleted

    .. data:: standby_session_close = 13

    	Session was closed on standby

    .. data:: standby_rxpath_frozen = 14

    	RX-Path was frozen on standby

    .. data:: partner_deleted = 15

    	Partner was deleted from set

    """

    none = Enum.YLeaf(0, "none")

    init_sync_aborted = Enum.YLeaf(1, "init-sync-aborted")

    client_disabled = Enum.YLeaf(2, "client-disabled")

    client_disconnect = Enum.YLeaf(3, "client-disconnect")

    tcp_disconnect = Enum.YLeaf(4, "tcp-disconnect")

    failover = Enum.YLeaf(5, "failover")

    nsr_clear = Enum.YLeaf(6, "nsr-clear")

    internal_error = Enum.YLeaf(7, "internal-error")

    retransmit_threshold_exceed = Enum.YLeaf(8, "retransmit-threshold-exceed")

    init_sync_failure_thresh_exceeded = Enum.YLeaf(9, "init-sync-failure-thresh-exceeded")

    audit_timeout = Enum.YLeaf(10, "audit-timeout")

    audit_failed = Enum.YLeaf(11, "audit-failed")

    standby_sscb_deleted = Enum.YLeaf(12, "standby-sscb-deleted")

    standby_session_close = Enum.YLeaf(13, "standby-session-close")

    standby_rxpath_frozen = Enum.YLeaf(14, "standby-rxpath-frozen")

    partner_deleted = Enum.YLeaf(15, "partner-deleted")


class NsrStatus(Enum):
    """
    NsrStatus

    NSR Stream Status

    .. data:: down = 0

    	NSR Stream Down

    .. data:: up = 1

    	NSR Stream Up

    .. data:: na = 2

    	NSR Stream Not applicable

    """

    down = Enum.YLeaf(0, "down")

    up = Enum.YLeaf(1, "up")

    na = Enum.YLeaf(2, "na")


class Packet(Enum):
    """
    Packet

    Packet type

    .. data:: icmp = 0

    	ICMP packet type

    .. data:: icm_pv6 = 1

    	ICMPv6 packet type

    .. data:: igmp = 2

    	IGMP packet type

    .. data:: unknown = 3

    	Packet type unknown

    """

    icmp = Enum.YLeaf(0, "icmp")

    icm_pv6 = Enum.YLeaf(1, "icm-pv6")

    igmp = Enum.YLeaf(2, "igmp")

    unknown = Enum.YLeaf(3, "unknown")


class PakPrio(Enum):
    """
    PakPrio

    Packet Priority Types

    .. data:: unspecified_packet = 0

    	Unspecified

    .. data:: normal_packet = 1

    	Normal: all traffic routed via this router,

    	Telnet/FTP traffic generated from within this

    	router

    .. data:: medium_packet = 2

    	Medium: Packets with low drop probability e.g.

    	Routing updates & requests

    .. data:: high_packet = 3

    	High: Packets with very low drop probability

    	and normal delivery e.g. L3 Keepalives like

    	OSPF/ISIS Hellos

    .. data:: crucial_packet = 4

    	Crucial: Packets with very low drop probability

    	and expedited delivery e.g L2 keepalives, HDLC

    	Keepalives

    """

    unspecified_packet = Enum.YLeaf(0, "unspecified-packet")

    normal_packet = Enum.YLeaf(1, "normal-packet")

    medium_packet = Enum.YLeaf(2, "medium-packet")

    high_packet = Enum.YLeaf(3, "high-packet")

    crucial_packet = Enum.YLeaf(4, "crucial-packet")


class Show(Enum):
    """
    Show

    Show

    .. data:: all = 0

    	To dispay all

    .. data:: static_policy = 1

    	To display static policy

    .. data:: interface_filter = 2

    	To display interface filter

    .. data:: packet_filter = 3

    	To display packet type filter

    """

    all = Enum.YLeaf(0, "all")

    static_policy = Enum.YLeaf(1, "static-policy")

    interface_filter = Enum.YLeaf(2, "interface-filter")

    packet_filter = Enum.YLeaf(3, "packet-filter")


class TcpAddressFamily(Enum):
    """
    TcpAddressFamily

    Address Family Type

    .. data:: ipv4 = 2

    	IPv4

    .. data:: ipv6 = 10

    	IPv6

    """

    ipv4 = Enum.YLeaf(2, "ipv4")

    ipv6 = Enum.YLeaf(10, "ipv6")


class TcpConnState(Enum):
    """
    TcpConnState

    TCP Connection State

    .. data:: closed = 0

    	Closed

    .. data:: listen = 1

    	Listen

    .. data:: syn_sent = 2

    	Syn sent

    .. data:: syn_received = 3

    	Syn received

    .. data:: established = 4

    	Established

    .. data:: close_wait = 5

    	Close wait

    .. data:: fin_wait1 = 6

    	FIN Wait1

    .. data:: closing = 7

    	Closing

    .. data:: last_ack = 8

    	Last ack

    .. data:: fin_wait2 = 9

    	FIN Wait2

    .. data:: time_wait = 10

    	Time wait

    """

    closed = Enum.YLeaf(0, "closed")

    listen = Enum.YLeaf(1, "listen")

    syn_sent = Enum.YLeaf(2, "syn-sent")

    syn_received = Enum.YLeaf(3, "syn-received")

    established = Enum.YLeaf(4, "established")

    close_wait = Enum.YLeaf(5, "close-wait")

    fin_wait1 = Enum.YLeaf(6, "fin-wait1")

    closing = Enum.YLeaf(7, "closing")

    last_ack = Enum.YLeaf(8, "last-ack")

    fin_wait2 = Enum.YLeaf(9, "fin-wait2")

    time_wait = Enum.YLeaf(10, "time-wait")


class TcpTimer(Enum):
    """
    TcpTimer

    TCP Timer Type

    .. data:: retransmission_timer = 0

    	Retransmission timer

    .. data:: window_probe_timer = 1

    	Send Window Probe timer

    .. data:: timewait_state_timer = 2

    	TIMEWAIT state timer

    .. data:: ack_hold_timer = 3

    	ACK Hold timer

    .. data:: keep_alive_timer = 4

    	Keep Alive timer

    .. data:: pmtu_ager_timer = 5

    	PMTU Ager Timer

    .. data:: retransmission_giveup_timer = 6

    	Retransmission Giveup timer

    .. data:: throttle_timer = 7

    	Throttle (for PAW/xipc) timer

    """

    retransmission_timer = Enum.YLeaf(0, "retransmission-timer")

    window_probe_timer = Enum.YLeaf(1, "window-probe-timer")

    timewait_state_timer = Enum.YLeaf(2, "timewait-state-timer")

    ack_hold_timer = Enum.YLeaf(3, "ack-hold-timer")

    keep_alive_timer = Enum.YLeaf(4, "keep-alive-timer")

    pmtu_ager_timer = Enum.YLeaf(5, "pmtu-ager-timer")

    retransmission_giveup_timer = Enum.YLeaf(6, "retransmission-giveup-timer")

    throttle_timer = Enum.YLeaf(7, "throttle-timer")



class TcpConnection(Entity):
    """
    TCP connection operational data
    
    .. attribute:: nodes
    
    	Table of information about all nodes present on the system
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes>`
    
    

    """

    _prefix = 'ip-tcp-oper'
    _revision = '2016-02-26'

    def __init__(self):
        super(TcpConnection, self).__init__()
        self._top_entity = None

        self.yang_name = "tcp-connection"
        self.yang_parent_name = "Cisco-IOS-XR-ip-tcp-oper"

        self.nodes = TcpConnection.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")


    class Nodes(Entity):
        """
        Table of information about all nodes present on
        the system
        
        .. attribute:: node
        
        	Information about a single node
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node>`
        
        

        """

        _prefix = 'ip-tcp-oper'
        _revision = '2016-02-26'

        def __init__(self):
            super(TcpConnection.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "tcp-connection"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(TcpConnection.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(TcpConnection.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            Information about a single node
            
            .. attribute:: id  <key>
            
            	Describing a location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: brief_informations
            
            	Table listing connections for which brief information is provided.Note that not all connections are listed in the brief table
            	**type**\:   :py:class:`BriefInformations <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.BriefInformations>`
            
            .. attribute:: detail_informations
            
            	Table listing TCP connections for which detailed information is provided
            	**type**\:   :py:class:`DetailInformations <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations>`
            
            .. attribute:: extended_information
            
            	Extended Filter related Information
            	**type**\:   :py:class:`ExtendedInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation>`
            
            .. attribute:: statistics
            
            	Statistics of all TCP connections
            	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics>`
            
            

            """

            _prefix = 'ip-tcp-oper'
            _revision = '2016-02-26'

            def __init__(self):
                super(TcpConnection.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.id = YLeaf(YType.str, "id")

                self.brief_informations = TcpConnection.Nodes.Node.BriefInformations()
                self.brief_informations.parent = self
                self._children_name_map["brief_informations"] = "brief-informations"
                self._children_yang_names.add("brief-informations")

                self.detail_informations = TcpConnection.Nodes.Node.DetailInformations()
                self.detail_informations.parent = self
                self._children_name_map["detail_informations"] = "detail-informations"
                self._children_yang_names.add("detail-informations")

                self.extended_information = TcpConnection.Nodes.Node.ExtendedInformation()
                self.extended_information.parent = self
                self._children_name_map["extended_information"] = "extended-information"
                self._children_yang_names.add("extended-information")

                self.statistics = TcpConnection.Nodes.Node.Statistics()
                self.statistics.parent = self
                self._children_name_map["statistics"] = "statistics"
                self._children_yang_names.add("statistics")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(TcpConnection.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(TcpConnection.Nodes.Node, self).__setattr__(name, value)


            class Statistics(Entity):
                """
                Statistics of all TCP connections
                
                .. attribute:: clients
                
                	Table listing clients
                	**type**\:   :py:class:`Clients <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Clients>`
                
                .. attribute:: pcbs
                
                	Table listing the TCP connections for which statistics are provided
                	**type**\:   :py:class:`Pcbs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Pcbs>`
                
                .. attribute:: summary
                
                	Summary statistics across all TCP connections
                	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Summary>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpConnection.Nodes.Node.Statistics, self).__init__()

                    self.yang_name = "statistics"
                    self.yang_parent_name = "node"

                    self.clients = TcpConnection.Nodes.Node.Statistics.Clients()
                    self.clients.parent = self
                    self._children_name_map["clients"] = "clients"
                    self._children_yang_names.add("clients")

                    self.pcbs = TcpConnection.Nodes.Node.Statistics.Pcbs()
                    self.pcbs.parent = self
                    self._children_name_map["pcbs"] = "pcbs"
                    self._children_yang_names.add("pcbs")

                    self.summary = TcpConnection.Nodes.Node.Statistics.Summary()
                    self.summary.parent = self
                    self._children_name_map["summary"] = "summary"
                    self._children_yang_names.add("summary")


                class Clients(Entity):
                    """
                    Table listing clients
                    
                    .. attribute:: client
                    
                    	Describing Client ID
                    	**type**\: list of    :py:class:`Client <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Clients.Client>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpConnection.Nodes.Node.Statistics.Clients, self).__init__()

                        self.yang_name = "clients"
                        self.yang_parent_name = "statistics"

                        self.client = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpConnection.Nodes.Node.Statistics.Clients, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpConnection.Nodes.Node.Statistics.Clients, self).__setattr__(name, value)


                    class Client(Entity):
                        """
                        Describing Client ID
                        
                        .. attribute:: client_id  <key>
                        
                        	Displaying client's aggregated statistics
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: client_jid
                        
                        	Job ID of the transport client
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: client_name
                        
                        	Transport client name
                        	**type**\:  str
                        
                        	**length:** 0..21
                        
                        .. attribute:: ipv4_received_packets
                        
                        	Total IPv4 packets received from client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ipv4_sent_packets
                        
                        	Total IPv4 packets sent to client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ipv6_received_packets
                        
                        	Total IPv6 packets received from app
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ipv6_sent_packets
                        
                        	Total IPv6 packets sent to app
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.Statistics.Clients.Client, self).__init__()

                            self.yang_name = "client"
                            self.yang_parent_name = "clients"

                            self.client_id = YLeaf(YType.uint32, "client-id")

                            self.client_jid = YLeaf(YType.int32, "client-jid")

                            self.client_name = YLeaf(YType.str, "client-name")

                            self.ipv4_received_packets = YLeaf(YType.uint32, "ipv4-received-packets")

                            self.ipv4_sent_packets = YLeaf(YType.uint32, "ipv4-sent-packets")

                            self.ipv6_received_packets = YLeaf(YType.uint32, "ipv6-received-packets")

                            self.ipv6_sent_packets = YLeaf(YType.uint32, "ipv6-sent-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("client_id",
                                            "client_jid",
                                            "client_name",
                                            "ipv4_received_packets",
                                            "ipv4_sent_packets",
                                            "ipv6_received_packets",
                                            "ipv6_sent_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.Statistics.Clients.Client, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.Statistics.Clients.Client, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.client_id.is_set or
                                self.client_jid.is_set or
                                self.client_name.is_set or
                                self.ipv4_received_packets.is_set or
                                self.ipv4_sent_packets.is_set or
                                self.ipv6_received_packets.is_set or
                                self.ipv6_sent_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.client_id.yfilter != YFilter.not_set or
                                self.client_jid.yfilter != YFilter.not_set or
                                self.client_name.yfilter != YFilter.not_set or
                                self.ipv4_received_packets.yfilter != YFilter.not_set or
                                self.ipv4_sent_packets.yfilter != YFilter.not_set or
                                self.ipv6_received_packets.yfilter != YFilter.not_set or
                                self.ipv6_sent_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "client" + "[client-id='" + self.client_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.client_id.is_set or self.client_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.client_id.get_name_leafdata())
                            if (self.client_jid.is_set or self.client_jid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.client_jid.get_name_leafdata())
                            if (self.client_name.is_set or self.client_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.client_name.get_name_leafdata())
                            if (self.ipv4_received_packets.is_set or self.ipv4_received_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4_received_packets.get_name_leafdata())
                            if (self.ipv4_sent_packets.is_set or self.ipv4_sent_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4_sent_packets.get_name_leafdata())
                            if (self.ipv6_received_packets.is_set or self.ipv6_received_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6_received_packets.get_name_leafdata())
                            if (self.ipv6_sent_packets.is_set or self.ipv6_sent_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6_sent_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "client-id" or name == "client-jid" or name == "client-name" or name == "ipv4-received-packets" or name == "ipv4-sent-packets" or name == "ipv6-received-packets" or name == "ipv6-sent-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "client-id"):
                                self.client_id = value
                                self.client_id.value_namespace = name_space
                                self.client_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "client-jid"):
                                self.client_jid = value
                                self.client_jid.value_namespace = name_space
                                self.client_jid.value_namespace_prefix = name_space_prefix
                            if(value_path == "client-name"):
                                self.client_name = value
                                self.client_name.value_namespace = name_space
                                self.client_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4-received-packets"):
                                self.ipv4_received_packets = value
                                self.ipv4_received_packets.value_namespace = name_space
                                self.ipv4_received_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4-sent-packets"):
                                self.ipv4_sent_packets = value
                                self.ipv4_sent_packets.value_namespace = name_space
                                self.ipv4_sent_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6-received-packets"):
                                self.ipv6_received_packets = value
                                self.ipv6_received_packets.value_namespace = name_space
                                self.ipv6_received_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6-sent-packets"):
                                self.ipv6_sent_packets = value
                                self.ipv6_sent_packets.value_namespace = name_space
                                self.ipv6_sent_packets.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.client:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.client:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "clients" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "client"):
                            for c in self.client:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpConnection.Nodes.Node.Statistics.Clients.Client()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.client.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "client"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Pcbs(Entity):
                    """
                    Table listing the TCP connections for which
                    statistics are provided
                    
                    .. attribute:: pcb
                    
                    	Protocol Control Block ID
                    	**type**\: list of    :py:class:`Pcb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpConnection.Nodes.Node.Statistics.Pcbs, self).__init__()

                        self.yang_name = "pcbs"
                        self.yang_parent_name = "statistics"

                        self.pcb = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpConnection.Nodes.Node.Statistics.Pcbs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpConnection.Nodes.Node.Statistics.Pcbs, self).__setattr__(name, value)


                    class Pcb(Entity):
                        """
                        Protocol Control Block ID
                        
                        .. attribute:: id  <key>
                        
                        	Displaying statistics associated with a particular PCB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: async_session_stats
                        
                        	Statistics of Async TCP Sessions
                        	**type**\:   :py:class:`AsyncSessionStats <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.AsyncSessionStats>`
                        
                        .. attribute:: is_paw_socket
                        
                        	PAW or non\-PAW socket?
                        	**type**\:  bool
                        
                        .. attribute:: packets_received
                        
                        	Packets received from network
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: packets_sent
                        
                        	Packets received from application
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: pcb
                        
                        	PCB Address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: read_io_counts
                        
                        	Read  I/O counts
                        	**type**\:   :py:class:`ReadIoCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.ReadIoCounts>`
                        
                        .. attribute:: read_io_time
                        
                        	Time at which receive buffer was last read from
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: receive_queue_failed
                        
                        	Received packets failed to be queued to application
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: received_packets_queued
                        
                        	Received packets queued to application
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: segment_instruction_received
                        
                        	Segment Instruction received from partner node
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: send_packets_queued
                        
                        	Packets queued to v4/v6 IO
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: send_packets_queued_net_io
                        
                        	Packets queued to NetIO
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: send_queue_failed
                        
                        	Packets failed to be queued to v4/v6 IO
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: send_queue_net_io_failed
                        
                        	Packets failed to be queued to NetIO
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: send_window_shrink_ignored
                        
                        	No. of times send window shrinkage by peer was ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: vrf_id
                        
                        	VRF Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: write_io_counts
                        
                        	Write I/O counts
                        	**type**\:   :py:class:`WriteIoCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.WriteIoCounts>`
                        
                        .. attribute:: write_io_time
                        
                        	Time at which send buffer was last written to
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: xipc_pulse_received
                        
                        	XIPC pulses received from application
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb, self).__init__()

                            self.yang_name = "pcb"
                            self.yang_parent_name = "pcbs"

                            self.id = YLeaf(YType.uint32, "id")

                            self.is_paw_socket = YLeaf(YType.boolean, "is-paw-socket")

                            self.packets_received = YLeaf(YType.uint64, "packets-received")

                            self.packets_sent = YLeaf(YType.uint64, "packets-sent")

                            self.pcb = YLeaf(YType.uint64, "pcb")

                            self.read_io_time = YLeaf(YType.uint32, "read-io-time")

                            self.receive_queue_failed = YLeaf(YType.uint32, "receive-queue-failed")

                            self.received_packets_queued = YLeaf(YType.uint64, "received-packets-queued")

                            self.segment_instruction_received = YLeaf(YType.uint32, "segment-instruction-received")

                            self.send_packets_queued = YLeaf(YType.uint64, "send-packets-queued")

                            self.send_packets_queued_net_io = YLeaf(YType.uint64, "send-packets-queued-net-io")

                            self.send_queue_failed = YLeaf(YType.uint32, "send-queue-failed")

                            self.send_queue_net_io_failed = YLeaf(YType.uint32, "send-queue-net-io-failed")

                            self.send_window_shrink_ignored = YLeaf(YType.uint32, "send-window-shrink-ignored")

                            self.vrf_id = YLeaf(YType.uint32, "vrf-id")

                            self.write_io_time = YLeaf(YType.uint32, "write-io-time")

                            self.xipc_pulse_received = YLeaf(YType.uint64, "xipc-pulse-received")

                            self.async_session_stats = TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.AsyncSessionStats()
                            self.async_session_stats.parent = self
                            self._children_name_map["async_session_stats"] = "async-session-stats"
                            self._children_yang_names.add("async-session-stats")

                            self.read_io_counts = TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.ReadIoCounts()
                            self.read_io_counts.parent = self
                            self._children_name_map["read_io_counts"] = "read-io-counts"
                            self._children_yang_names.add("read-io-counts")

                            self.write_io_counts = TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.WriteIoCounts()
                            self.write_io_counts.parent = self
                            self._children_name_map["write_io_counts"] = "write-io-counts"
                            self._children_yang_names.add("write-io-counts")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "is_paw_socket",
                                            "packets_received",
                                            "packets_sent",
                                            "pcb",
                                            "read_io_time",
                                            "receive_queue_failed",
                                            "received_packets_queued",
                                            "segment_instruction_received",
                                            "send_packets_queued",
                                            "send_packets_queued_net_io",
                                            "send_queue_failed",
                                            "send_queue_net_io_failed",
                                            "send_window_shrink_ignored",
                                            "vrf_id",
                                            "write_io_time",
                                            "xipc_pulse_received") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb, self).__setattr__(name, value)


                        class ReadIoCounts(Entity):
                            """
                            Read  I/O counts
                            
                            .. attribute:: arm_count
                            
                            	How many times socket was armed by application
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: autoarm_count
                            
                            	How many times socket was auto\-armed by TCP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: io_count
                            
                            	Number of I/O operations done by application
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unarm_count
                            
                            	How many times socket was unarmed by application
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.ReadIoCounts, self).__init__()

                                self.yang_name = "read-io-counts"
                                self.yang_parent_name = "pcb"

                                self.arm_count = YLeaf(YType.uint32, "arm-count")

                                self.autoarm_count = YLeaf(YType.uint32, "autoarm-count")

                                self.io_count = YLeaf(YType.uint32, "io-count")

                                self.unarm_count = YLeaf(YType.uint32, "unarm-count")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("arm_count",
                                                "autoarm_count",
                                                "io_count",
                                                "unarm_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.ReadIoCounts, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.ReadIoCounts, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.arm_count.is_set or
                                    self.autoarm_count.is_set or
                                    self.io_count.is_set or
                                    self.unarm_count.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.arm_count.yfilter != YFilter.not_set or
                                    self.autoarm_count.yfilter != YFilter.not_set or
                                    self.io_count.yfilter != YFilter.not_set or
                                    self.unarm_count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "read-io-counts" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.arm_count.is_set or self.arm_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.arm_count.get_name_leafdata())
                                if (self.autoarm_count.is_set or self.autoarm_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.autoarm_count.get_name_leafdata())
                                if (self.io_count.is_set or self.io_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.io_count.get_name_leafdata())
                                if (self.unarm_count.is_set or self.unarm_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unarm_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "arm-count" or name == "autoarm-count" or name == "io-count" or name == "unarm-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "arm-count"):
                                    self.arm_count = value
                                    self.arm_count.value_namespace = name_space
                                    self.arm_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "autoarm-count"):
                                    self.autoarm_count = value
                                    self.autoarm_count.value_namespace = name_space
                                    self.autoarm_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "io-count"):
                                    self.io_count = value
                                    self.io_count.value_namespace = name_space
                                    self.io_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "unarm-count"):
                                    self.unarm_count = value
                                    self.unarm_count.value_namespace = name_space
                                    self.unarm_count.value_namespace_prefix = name_space_prefix


                        class WriteIoCounts(Entity):
                            """
                            Write I/O counts
                            
                            .. attribute:: arm_count
                            
                            	How many times socket was armed by application
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: autoarm_count
                            
                            	How many times socket was auto\-armed by TCP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: io_count
                            
                            	Number of I/O operations done by application
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unarm_count
                            
                            	How many times socket was unarmed by application
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.WriteIoCounts, self).__init__()

                                self.yang_name = "write-io-counts"
                                self.yang_parent_name = "pcb"

                                self.arm_count = YLeaf(YType.uint32, "arm-count")

                                self.autoarm_count = YLeaf(YType.uint32, "autoarm-count")

                                self.io_count = YLeaf(YType.uint32, "io-count")

                                self.unarm_count = YLeaf(YType.uint32, "unarm-count")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("arm_count",
                                                "autoarm_count",
                                                "io_count",
                                                "unarm_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.WriteIoCounts, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.WriteIoCounts, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.arm_count.is_set or
                                    self.autoarm_count.is_set or
                                    self.io_count.is_set or
                                    self.unarm_count.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.arm_count.yfilter != YFilter.not_set or
                                    self.autoarm_count.yfilter != YFilter.not_set or
                                    self.io_count.yfilter != YFilter.not_set or
                                    self.unarm_count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "write-io-counts" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.arm_count.is_set or self.arm_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.arm_count.get_name_leafdata())
                                if (self.autoarm_count.is_set or self.autoarm_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.autoarm_count.get_name_leafdata())
                                if (self.io_count.is_set or self.io_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.io_count.get_name_leafdata())
                                if (self.unarm_count.is_set or self.unarm_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unarm_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "arm-count" or name == "autoarm-count" or name == "io-count" or name == "unarm-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "arm-count"):
                                    self.arm_count = value
                                    self.arm_count.value_namespace = name_space
                                    self.arm_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "autoarm-count"):
                                    self.autoarm_count = value
                                    self.autoarm_count.value_namespace = name_space
                                    self.autoarm_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "io-count"):
                                    self.io_count = value
                                    self.io_count.value_namespace = name_space
                                    self.io_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "unarm-count"):
                                    self.unarm_count = value
                                    self.unarm_count.value_namespace = name_space
                                    self.unarm_count.value_namespace_prefix = name_space_prefix


                        class AsyncSessionStats(Entity):
                            """
                            Statistics of Async TCP Sessions
                            
                            .. attribute:: async_session
                            
                            	Flag of async session
                            	**type**\:  bool
                            
                            .. attribute:: control_read_error_num
                            
                            	Number of failed control read from XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: control_read_success_num
                            
                            	Number of successful control read to XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: control_write_error_num
                            
                            	Number of failed control write to XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: control_write_success_num
                            
                            	Number of successful control write to XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_read_byte
                            
                            	Number of bytes data has been read
                            	**type**\:  list of int
                            
                            	**range:** 0..18446744073709551615
                            
                            	**units**\: byte
                            
                            .. attribute:: data_read_error_num
                            
                            	Number of failed data read from XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_read_success_num
                            
                            	Number of successful data read from XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_write_byte
                            
                            	Number of bytes data has been written
                            	**type**\:  list of int
                            
                            	**range:** 0..18446744073709551615
                            
                            	**units**\: byte
                            
                            .. attribute:: data_write_error_num
                            
                            	Number of failed data write to XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_write_success_num
                            
                            	Number of successful data write to XIPC
                            	**type**\:  list of int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.AsyncSessionStats, self).__init__()

                                self.yang_name = "async-session-stats"
                                self.yang_parent_name = "pcb"

                                self.async_session = YLeaf(YType.boolean, "async-session")

                                self.control_read_error_num = YLeafList(YType.uint32, "control-read-error-num")

                                self.control_read_success_num = YLeafList(YType.uint32, "control-read-success-num")

                                self.control_write_error_num = YLeafList(YType.uint32, "control-write-error-num")

                                self.control_write_success_num = YLeafList(YType.uint32, "control-write-success-num")

                                self.data_read_byte = YLeafList(YType.uint64, "data-read-byte")

                                self.data_read_error_num = YLeafList(YType.uint32, "data-read-error-num")

                                self.data_read_success_num = YLeafList(YType.uint32, "data-read-success-num")

                                self.data_write_byte = YLeafList(YType.uint64, "data-write-byte")

                                self.data_write_error_num = YLeafList(YType.uint32, "data-write-error-num")

                                self.data_write_success_num = YLeafList(YType.uint32, "data-write-success-num")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("async_session",
                                                "control_read_error_num",
                                                "control_read_success_num",
                                                "control_write_error_num",
                                                "control_write_success_num",
                                                "data_read_byte",
                                                "data_read_error_num",
                                                "data_read_success_num",
                                                "data_write_byte",
                                                "data_write_error_num",
                                                "data_write_success_num") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.AsyncSessionStats, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.AsyncSessionStats, self).__setattr__(name, value)

                            def has_data(self):
                                for leaf in self.control_read_error_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.control_read_success_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.control_write_error_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.control_write_success_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.data_read_byte.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.data_read_error_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.data_read_success_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.data_write_byte.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.data_write_error_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.data_write_success_num.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return self.async_session.is_set

                            def has_operation(self):
                                for leaf in self.control_read_error_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.control_read_success_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.control_write_error_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.control_write_success_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.data_read_byte.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.data_read_error_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.data_read_success_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.data_write_byte.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.data_write_error_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.data_write_success_num.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.async_session.yfilter != YFilter.not_set or
                                    self.control_read_error_num.yfilter != YFilter.not_set or
                                    self.control_read_success_num.yfilter != YFilter.not_set or
                                    self.control_write_error_num.yfilter != YFilter.not_set or
                                    self.control_write_success_num.yfilter != YFilter.not_set or
                                    self.data_read_byte.yfilter != YFilter.not_set or
                                    self.data_read_error_num.yfilter != YFilter.not_set or
                                    self.data_read_success_num.yfilter != YFilter.not_set or
                                    self.data_write_byte.yfilter != YFilter.not_set or
                                    self.data_write_error_num.yfilter != YFilter.not_set or
                                    self.data_write_success_num.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "async-session-stats" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.async_session.is_set or self.async_session.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.async_session.get_name_leafdata())

                                leaf_name_data.extend(self.control_read_error_num.get_name_leafdata())

                                leaf_name_data.extend(self.control_read_success_num.get_name_leafdata())

                                leaf_name_data.extend(self.control_write_error_num.get_name_leafdata())

                                leaf_name_data.extend(self.control_write_success_num.get_name_leafdata())

                                leaf_name_data.extend(self.data_read_byte.get_name_leafdata())

                                leaf_name_data.extend(self.data_read_error_num.get_name_leafdata())

                                leaf_name_data.extend(self.data_read_success_num.get_name_leafdata())

                                leaf_name_data.extend(self.data_write_byte.get_name_leafdata())

                                leaf_name_data.extend(self.data_write_error_num.get_name_leafdata())

                                leaf_name_data.extend(self.data_write_success_num.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "async-session" or name == "control-read-error-num" or name == "control-read-success-num" or name == "control-write-error-num" or name == "control-write-success-num" or name == "data-read-byte" or name == "data-read-error-num" or name == "data-read-success-num" or name == "data-write-byte" or name == "data-write-error-num" or name == "data-write-success-num"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "async-session"):
                                    self.async_session = value
                                    self.async_session.value_namespace = name_space
                                    self.async_session.value_namespace_prefix = name_space_prefix
                                if(value_path == "control-read-error-num"):
                                    self.control_read_error_num.append(value)
                                if(value_path == "control-read-success-num"):
                                    self.control_read_success_num.append(value)
                                if(value_path == "control-write-error-num"):
                                    self.control_write_error_num.append(value)
                                if(value_path == "control-write-success-num"):
                                    self.control_write_success_num.append(value)
                                if(value_path == "data-read-byte"):
                                    self.data_read_byte.append(value)
                                if(value_path == "data-read-error-num"):
                                    self.data_read_error_num.append(value)
                                if(value_path == "data-read-success-num"):
                                    self.data_read_success_num.append(value)
                                if(value_path == "data-write-byte"):
                                    self.data_write_byte.append(value)
                                if(value_path == "data-write-error-num"):
                                    self.data_write_error_num.append(value)
                                if(value_path == "data-write-success-num"):
                                    self.data_write_success_num.append(value)

                        def has_data(self):
                            return (
                                self.id.is_set or
                                self.is_paw_socket.is_set or
                                self.packets_received.is_set or
                                self.packets_sent.is_set or
                                self.pcb.is_set or
                                self.read_io_time.is_set or
                                self.receive_queue_failed.is_set or
                                self.received_packets_queued.is_set or
                                self.segment_instruction_received.is_set or
                                self.send_packets_queued.is_set or
                                self.send_packets_queued_net_io.is_set or
                                self.send_queue_failed.is_set or
                                self.send_queue_net_io_failed.is_set or
                                self.send_window_shrink_ignored.is_set or
                                self.vrf_id.is_set or
                                self.write_io_time.is_set or
                                self.xipc_pulse_received.is_set or
                                (self.async_session_stats is not None and self.async_session_stats.has_data()) or
                                (self.read_io_counts is not None and self.read_io_counts.has_data()) or
                                (self.write_io_counts is not None and self.write_io_counts.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.is_paw_socket.yfilter != YFilter.not_set or
                                self.packets_received.yfilter != YFilter.not_set or
                                self.packets_sent.yfilter != YFilter.not_set or
                                self.pcb.yfilter != YFilter.not_set or
                                self.read_io_time.yfilter != YFilter.not_set or
                                self.receive_queue_failed.yfilter != YFilter.not_set or
                                self.received_packets_queued.yfilter != YFilter.not_set or
                                self.segment_instruction_received.yfilter != YFilter.not_set or
                                self.send_packets_queued.yfilter != YFilter.not_set or
                                self.send_packets_queued_net_io.yfilter != YFilter.not_set or
                                self.send_queue_failed.yfilter != YFilter.not_set or
                                self.send_queue_net_io_failed.yfilter != YFilter.not_set or
                                self.send_window_shrink_ignored.yfilter != YFilter.not_set or
                                self.vrf_id.yfilter != YFilter.not_set or
                                self.write_io_time.yfilter != YFilter.not_set or
                                self.xipc_pulse_received.yfilter != YFilter.not_set or
                                (self.async_session_stats is not None and self.async_session_stats.has_operation()) or
                                (self.read_io_counts is not None and self.read_io_counts.has_operation()) or
                                (self.write_io_counts is not None and self.write_io_counts.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "pcb" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.is_paw_socket.is_set or self.is_paw_socket.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_paw_socket.get_name_leafdata())
                            if (self.packets_received.is_set or self.packets_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.packets_received.get_name_leafdata())
                            if (self.packets_sent.is_set or self.packets_sent.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.packets_sent.get_name_leafdata())
                            if (self.pcb.is_set or self.pcb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcb.get_name_leafdata())
                            if (self.read_io_time.is_set or self.read_io_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.read_io_time.get_name_leafdata())
                            if (self.receive_queue_failed.is_set or self.receive_queue_failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.receive_queue_failed.get_name_leafdata())
                            if (self.received_packets_queued.is_set or self.received_packets_queued.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_packets_queued.get_name_leafdata())
                            if (self.segment_instruction_received.is_set or self.segment_instruction_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.segment_instruction_received.get_name_leafdata())
                            if (self.send_packets_queued.is_set or self.send_packets_queued.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_packets_queued.get_name_leafdata())
                            if (self.send_packets_queued_net_io.is_set or self.send_packets_queued_net_io.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_packets_queued_net_io.get_name_leafdata())
                            if (self.send_queue_failed.is_set or self.send_queue_failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_queue_failed.get_name_leafdata())
                            if (self.send_queue_net_io_failed.is_set or self.send_queue_net_io_failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_queue_net_io_failed.get_name_leafdata())
                            if (self.send_window_shrink_ignored.is_set or self.send_window_shrink_ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_window_shrink_ignored.get_name_leafdata())
                            if (self.vrf_id.is_set or self.vrf_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.vrf_id.get_name_leafdata())
                            if (self.write_io_time.is_set or self.write_io_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.write_io_time.get_name_leafdata())
                            if (self.xipc_pulse_received.is_set or self.xipc_pulse_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.xipc_pulse_received.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "async-session-stats"):
                                if (self.async_session_stats is None):
                                    self.async_session_stats = TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.AsyncSessionStats()
                                    self.async_session_stats.parent = self
                                    self._children_name_map["async_session_stats"] = "async-session-stats"
                                return self.async_session_stats

                            if (child_yang_name == "read-io-counts"):
                                if (self.read_io_counts is None):
                                    self.read_io_counts = TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.ReadIoCounts()
                                    self.read_io_counts.parent = self
                                    self._children_name_map["read_io_counts"] = "read-io-counts"
                                return self.read_io_counts

                            if (child_yang_name == "write-io-counts"):
                                if (self.write_io_counts is None):
                                    self.write_io_counts = TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb.WriteIoCounts()
                                    self.write_io_counts.parent = self
                                    self._children_name_map["write_io_counts"] = "write-io-counts"
                                return self.write_io_counts

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "async-session-stats" or name == "read-io-counts" or name == "write-io-counts" or name == "id" or name == "is-paw-socket" or name == "packets-received" or name == "packets-sent" or name == "pcb" or name == "read-io-time" or name == "receive-queue-failed" or name == "received-packets-queued" or name == "segment-instruction-received" or name == "send-packets-queued" or name == "send-packets-queued-net-io" or name == "send-queue-failed" or name == "send-queue-net-io-failed" or name == "send-window-shrink-ignored" or name == "vrf-id" or name == "write-io-time" or name == "xipc-pulse-received"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-paw-socket"):
                                self.is_paw_socket = value
                                self.is_paw_socket.value_namespace = name_space
                                self.is_paw_socket.value_namespace_prefix = name_space_prefix
                            if(value_path == "packets-received"):
                                self.packets_received = value
                                self.packets_received.value_namespace = name_space
                                self.packets_received.value_namespace_prefix = name_space_prefix
                            if(value_path == "packets-sent"):
                                self.packets_sent = value
                                self.packets_sent.value_namespace = name_space
                                self.packets_sent.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcb"):
                                self.pcb = value
                                self.pcb.value_namespace = name_space
                                self.pcb.value_namespace_prefix = name_space_prefix
                            if(value_path == "read-io-time"):
                                self.read_io_time = value
                                self.read_io_time.value_namespace = name_space
                                self.read_io_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "receive-queue-failed"):
                                self.receive_queue_failed = value
                                self.receive_queue_failed.value_namespace = name_space
                                self.receive_queue_failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-packets-queued"):
                                self.received_packets_queued = value
                                self.received_packets_queued.value_namespace = name_space
                                self.received_packets_queued.value_namespace_prefix = name_space_prefix
                            if(value_path == "segment-instruction-received"):
                                self.segment_instruction_received = value
                                self.segment_instruction_received.value_namespace = name_space
                                self.segment_instruction_received.value_namespace_prefix = name_space_prefix
                            if(value_path == "send-packets-queued"):
                                self.send_packets_queued = value
                                self.send_packets_queued.value_namespace = name_space
                                self.send_packets_queued.value_namespace_prefix = name_space_prefix
                            if(value_path == "send-packets-queued-net-io"):
                                self.send_packets_queued_net_io = value
                                self.send_packets_queued_net_io.value_namespace = name_space
                                self.send_packets_queued_net_io.value_namespace_prefix = name_space_prefix
                            if(value_path == "send-queue-failed"):
                                self.send_queue_failed = value
                                self.send_queue_failed.value_namespace = name_space
                                self.send_queue_failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "send-queue-net-io-failed"):
                                self.send_queue_net_io_failed = value
                                self.send_queue_net_io_failed.value_namespace = name_space
                                self.send_queue_net_io_failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "send-window-shrink-ignored"):
                                self.send_window_shrink_ignored = value
                                self.send_window_shrink_ignored.value_namespace = name_space
                                self.send_window_shrink_ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "vrf-id"):
                                self.vrf_id = value
                                self.vrf_id.value_namespace = name_space
                                self.vrf_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "write-io-time"):
                                self.write_io_time = value
                                self.write_io_time.value_namespace = name_space
                                self.write_io_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "xipc-pulse-received"):
                                self.xipc_pulse_received = value
                                self.xipc_pulse_received.value_namespace = name_space
                                self.xipc_pulse_received.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.pcb:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.pcb:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "pcbs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "pcb"):
                            for c in self.pcb:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpConnection.Nodes.Node.Statistics.Pcbs.Pcb()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.pcb.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "pcb"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Summary(Entity):
                    """
                    Summary statistics across all TCP connections
                    
                    .. attribute:: ack_only_packets_sent
                    
                    	Ack only packets sent (incl. delay)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ack_packets_for_unsent_received
                    
                    	Ack packets for unsent data
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ack_packets_received
                    
                    	Ack packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ackbytes_received
                    
                    	Bytes acked by ack packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: after_window_bytes_received
                    
                    	After\-window bytes received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: after_window_packets_received
                    
                    	After\-window packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: bad_checksum_packets_received
                    
                    	Packets received with bad checksum
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: bytes_retransmitted
                    
                    	Data bytes retransmitted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: connection_rate_limited
                    
                    	Connections rate\-limited
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connections_accepted
                    
                    	Connection requests accepted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connections_closed
                    
                    	connections closed (incl. drops)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connections_dropped
                    
                    	connections dropped
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connections_established
                    
                    	Connections established
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connections_failed
                    
                    	Connections failed
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connections_forcibly_closed
                    
                    	Connections forcibly closed
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connections_requested
                    
                    	Connection requests sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: control_packets_sent
                    
                    	Control (SYN\|FIN\|RST) packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: data_bytes_received_in_sequence
                    
                    	Data bytes received in sequence
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: data_bytes_sent
                    
                    	Data bytes sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: data_packets_received_in_sequence
                    
                    	Data packets received in sequence
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: data_pakets_sent
                    
                    	Data packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: delay_ack_packets_sent
                    
                    	Delay ack packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: duplicate_bytes_received
                    
                    	Duplicate bytes received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: duplicate_packets_received
                    
                    	Duplicate packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: duplicated_ack_packets_received
                    
                    	Duplicate ack packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: embryonic_connection_dropped
                    
                    	Embryonic connections dropped
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: established_connections_reset
                    
                    	Established connections reset
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: high_water_mark_throttle
                    
                    	Number of times high water mark throttle was on
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iq_sock_aborts
                    
                    	Number of aborted socket\-lib writes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iq_sock_retries
                    
                    	Number of retried write attempts
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iq_sock_writes
                    
                    	Number of write attempts from socket\-lib into an IQ
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: keep_alive_dropped
                    
                    	Connection drops due to keepalive timeouts
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: keep_alive_probes
                    
                    	Keepalive probes sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: keep_alive_timeouts
                    
                    	Keepalive timeouts
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: low_water_mark_throttle
                    
                    	Number of times low water mark throttle was on
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: malformed_packets_received
                    
                    	Packets received with malformed header
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: mss_down
                    
                    	Number of times MSS was decreased
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: mss_up
                    
                    	Number of times MSS was increased
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: no_port_packets_received
                    
                    	Packets rcceived with no wild listener
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: no_throttle
                    
                    	Number of times throttle mode was off
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: num_open_sockets
                    
                    	Number of Open sockets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: out_of_order_bytes_received
                    
                    	Out\-of\-order bytes received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: out_of_order_packets_received
                    
                    	Out\-of\-order packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: packet_failures
                    
                    	Packet allocation errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: packets_received_after_close_packet
                    
                    	Packets received after close
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: packets_retransmitted
                    
                    	Data packets retransmitted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: partial_duplicate_ack_received
                    
                    	Packets with partial dup data
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: partial_duplicate_bytes_received
                    
                    	Bytes with partial dup data
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: paws_dropped
                    
                    	Segments dropped due to PAWS
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: persist_dropped
                    
                    	Segments dropped due to window probe
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: pulse_errors
                    
                    	Punt (down to ip) failures
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: reassembly_packets
                    
                    	Packets owned by TCP reassembly
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: received_auth_packets_dropped
                    
                    	Received packets dropped due to authentication failures
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: received_packets_dropped
                    
                    	Received packets dropped due to general failures
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: received_packets_dropped_stale_c_hdr
                    
                    	Received packets dropped due to stale cached header
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: recovered_packets
                    
                    	Packets freed after starvation
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: retransmit_dropped
                    
                    	Connection drops during retransmit timeouts
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: retransmit_timeouts
                    
                    	Retransmit timeouts (incl. data packets)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rst_packets_sent
                    
                    	RST packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_auth_packets_dropped
                    
                    	Total transmit packets dropped due to authentication failures
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_packets_dropped
                    
                    	Total transmit packets dropped due to general failures
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: socket_layer_packets
                    
                    	Packets owned by the socket layer
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: stalled_timer_tickle_count
                    
                    	Number of times a stalled tcp timer was tickled
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: stalled_timer_tickle_time
                    
                    	Last timestamp when a stalled tcp timer was tickled
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_aborted
                    
                    	SYN Cache entries aborted (no mem)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_added
                    
                    	SYN Cache entries added
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_bucket_oflow
                    
                    	SYN Cache entries dropped due to bucket overflow
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_completed
                    
                    	SYN Cache connections completed
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_count
                    
                    	Current number of SYN cache entries
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_dropped
                    
                    	SYN Cache entries dropped (no route/mem)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_duplicate_sy_ns
                    
                    	SYN Cache duplicate SYNs received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_overflow
                    
                    	SYN Cache entries dropped due to overflow
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_reset
                    
                    	SYN Cache entries dropped due to RST
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_timed_out
                    
                    	SYN Cache entries timed out
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: syn_cache_unreach
                    
                    	SYN Cache entries dropped due to ICMP unreach
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: synacl_match_pkts_dropped
                    
                    	Received packets dropped due to ACL DENY on SYN pkts
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: too_short_packets_received
                    
                    	Packets received with too short size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_packets_received
                    
                    	Total packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_pakets_sent
                    
                    	Total packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: truncated_write_iov
                    
                    	Segments truncated due to insufficient Write I/O vectors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: try_lock_dropped
                    
                    	Segments dropped due to trylock fail
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: urgent_only_packets_sent
                    
                    	Urgent only packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: window_probe_packets_received
                    
                    	Window probe packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: window_probe_packets_sent
                    
                    	Window probe packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: window_update_packets_received
                    
                    	Window update packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: window_update_packets_sent
                    
                    	Window update packets sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpConnection.Nodes.Node.Statistics.Summary, self).__init__()

                        self.yang_name = "summary"
                        self.yang_parent_name = "statistics"

                        self.ack_only_packets_sent = YLeaf(YType.uint32, "ack-only-packets-sent")

                        self.ack_packets_for_unsent_received = YLeaf(YType.uint32, "ack-packets-for-unsent-received")

                        self.ack_packets_received = YLeaf(YType.uint32, "ack-packets-received")

                        self.ackbytes_received = YLeaf(YType.uint32, "ackbytes-received")

                        self.after_window_bytes_received = YLeaf(YType.uint32, "after-window-bytes-received")

                        self.after_window_packets_received = YLeaf(YType.uint32, "after-window-packets-received")

                        self.bad_checksum_packets_received = YLeaf(YType.uint32, "bad-checksum-packets-received")

                        self.bytes_retransmitted = YLeaf(YType.uint32, "bytes-retransmitted")

                        self.connection_rate_limited = YLeaf(YType.uint32, "connection-rate-limited")

                        self.connections_accepted = YLeaf(YType.uint32, "connections-accepted")

                        self.connections_closed = YLeaf(YType.uint32, "connections-closed")

                        self.connections_dropped = YLeaf(YType.uint32, "connections-dropped")

                        self.connections_established = YLeaf(YType.uint32, "connections-established")

                        self.connections_failed = YLeaf(YType.uint32, "connections-failed")

                        self.connections_forcibly_closed = YLeaf(YType.uint32, "connections-forcibly-closed")

                        self.connections_requested = YLeaf(YType.uint32, "connections-requested")

                        self.control_packets_sent = YLeaf(YType.uint32, "control-packets-sent")

                        self.data_bytes_received_in_sequence = YLeaf(YType.uint32, "data-bytes-received-in-sequence")

                        self.data_bytes_sent = YLeaf(YType.uint32, "data-bytes-sent")

                        self.data_packets_received_in_sequence = YLeaf(YType.uint32, "data-packets-received-in-sequence")

                        self.data_pakets_sent = YLeaf(YType.uint32, "data-pakets-sent")

                        self.delay_ack_packets_sent = YLeaf(YType.uint32, "delay-ack-packets-sent")

                        self.duplicate_bytes_received = YLeaf(YType.uint32, "duplicate-bytes-received")

                        self.duplicate_packets_received = YLeaf(YType.uint32, "duplicate-packets-received")

                        self.duplicated_ack_packets_received = YLeaf(YType.uint32, "duplicated-ack-packets-received")

                        self.embryonic_connection_dropped = YLeaf(YType.uint32, "embryonic-connection-dropped")

                        self.established_connections_reset = YLeaf(YType.uint32, "established-connections-reset")

                        self.high_water_mark_throttle = YLeaf(YType.uint32, "high-water-mark-throttle")

                        self.iq_sock_aborts = YLeaf(YType.uint32, "iq-sock-aborts")

                        self.iq_sock_retries = YLeaf(YType.uint32, "iq-sock-retries")

                        self.iq_sock_writes = YLeaf(YType.uint32, "iq-sock-writes")

                        self.keep_alive_dropped = YLeaf(YType.uint32, "keep-alive-dropped")

                        self.keep_alive_probes = YLeaf(YType.uint32, "keep-alive-probes")

                        self.keep_alive_timeouts = YLeaf(YType.uint32, "keep-alive-timeouts")

                        self.low_water_mark_throttle = YLeaf(YType.uint32, "low-water-mark-throttle")

                        self.malformed_packets_received = YLeaf(YType.uint32, "malformed-packets-received")

                        self.mss_down = YLeaf(YType.uint32, "mss-down")

                        self.mss_up = YLeaf(YType.uint32, "mss-up")

                        self.no_port_packets_received = YLeaf(YType.uint32, "no-port-packets-received")

                        self.no_throttle = YLeaf(YType.uint32, "no-throttle")

                        self.num_open_sockets = YLeaf(YType.uint32, "num-open-sockets")

                        self.out_of_order_bytes_received = YLeaf(YType.uint32, "out-of-order-bytes-received")

                        self.out_of_order_packets_received = YLeaf(YType.uint32, "out-of-order-packets-received")

                        self.packet_failures = YLeaf(YType.uint32, "packet-failures")

                        self.packets_received_after_close_packet = YLeaf(YType.uint32, "packets-received-after-close-packet")

                        self.packets_retransmitted = YLeaf(YType.uint32, "packets-retransmitted")

                        self.partial_duplicate_ack_received = YLeaf(YType.uint32, "partial-duplicate-ack-received")

                        self.partial_duplicate_bytes_received = YLeaf(YType.uint32, "partial-duplicate-bytes-received")

                        self.paws_dropped = YLeaf(YType.uint32, "paws-dropped")

                        self.persist_dropped = YLeaf(YType.uint32, "persist-dropped")

                        self.pulse_errors = YLeaf(YType.uint32, "pulse-errors")

                        self.reassembly_packets = YLeaf(YType.uint32, "reassembly-packets")

                        self.received_auth_packets_dropped = YLeaf(YType.uint32, "received-auth-packets-dropped")

                        self.received_packets_dropped = YLeaf(YType.uint32, "received-packets-dropped")

                        self.received_packets_dropped_stale_c_hdr = YLeaf(YType.uint32, "received-packets-dropped-stale-c-hdr")

                        self.recovered_packets = YLeaf(YType.uint32, "recovered-packets")

                        self.retransmit_dropped = YLeaf(YType.uint32, "retransmit-dropped")

                        self.retransmit_timeouts = YLeaf(YType.uint32, "retransmit-timeouts")

                        self.rst_packets_sent = YLeaf(YType.uint32, "rst-packets-sent")

                        self.send_auth_packets_dropped = YLeaf(YType.uint32, "send-auth-packets-dropped")

                        self.send_packets_dropped = YLeaf(YType.uint32, "send-packets-dropped")

                        self.socket_layer_packets = YLeaf(YType.uint32, "socket-layer-packets")

                        self.stalled_timer_tickle_count = YLeaf(YType.uint32, "stalled-timer-tickle-count")

                        self.stalled_timer_tickle_time = YLeaf(YType.uint32, "stalled-timer-tickle-time")

                        self.syn_cache_aborted = YLeaf(YType.uint32, "syn-cache-aborted")

                        self.syn_cache_added = YLeaf(YType.uint32, "syn-cache-added")

                        self.syn_cache_bucket_oflow = YLeaf(YType.uint32, "syn-cache-bucket-oflow")

                        self.syn_cache_completed = YLeaf(YType.uint32, "syn-cache-completed")

                        self.syn_cache_count = YLeaf(YType.uint32, "syn-cache-count")

                        self.syn_cache_dropped = YLeaf(YType.uint32, "syn-cache-dropped")

                        self.syn_cache_duplicate_sy_ns = YLeaf(YType.uint32, "syn-cache-duplicate-sy-ns")

                        self.syn_cache_overflow = YLeaf(YType.uint32, "syn-cache-overflow")

                        self.syn_cache_reset = YLeaf(YType.uint32, "syn-cache-reset")

                        self.syn_cache_timed_out = YLeaf(YType.uint32, "syn-cache-timed-out")

                        self.syn_cache_unreach = YLeaf(YType.uint32, "syn-cache-unreach")

                        self.synacl_match_pkts_dropped = YLeaf(YType.uint32, "synacl-match-pkts-dropped")

                        self.too_short_packets_received = YLeaf(YType.uint32, "too-short-packets-received")

                        self.total_packets_received = YLeaf(YType.uint32, "total-packets-received")

                        self.total_pakets_sent = YLeaf(YType.uint32, "total-pakets-sent")

                        self.truncated_write_iov = YLeaf(YType.uint32, "truncated-write-iov")

                        self.try_lock_dropped = YLeaf(YType.uint32, "try-lock-dropped")

                        self.urgent_only_packets_sent = YLeaf(YType.uint32, "urgent-only-packets-sent")

                        self.window_probe_packets_received = YLeaf(YType.uint32, "window-probe-packets-received")

                        self.window_probe_packets_sent = YLeaf(YType.uint32, "window-probe-packets-sent")

                        self.window_update_packets_received = YLeaf(YType.uint32, "window-update-packets-received")

                        self.window_update_packets_sent = YLeaf(YType.uint32, "window-update-packets-sent")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ack_only_packets_sent",
                                        "ack_packets_for_unsent_received",
                                        "ack_packets_received",
                                        "ackbytes_received",
                                        "after_window_bytes_received",
                                        "after_window_packets_received",
                                        "bad_checksum_packets_received",
                                        "bytes_retransmitted",
                                        "connection_rate_limited",
                                        "connections_accepted",
                                        "connections_closed",
                                        "connections_dropped",
                                        "connections_established",
                                        "connections_failed",
                                        "connections_forcibly_closed",
                                        "connections_requested",
                                        "control_packets_sent",
                                        "data_bytes_received_in_sequence",
                                        "data_bytes_sent",
                                        "data_packets_received_in_sequence",
                                        "data_pakets_sent",
                                        "delay_ack_packets_sent",
                                        "duplicate_bytes_received",
                                        "duplicate_packets_received",
                                        "duplicated_ack_packets_received",
                                        "embryonic_connection_dropped",
                                        "established_connections_reset",
                                        "high_water_mark_throttle",
                                        "iq_sock_aborts",
                                        "iq_sock_retries",
                                        "iq_sock_writes",
                                        "keep_alive_dropped",
                                        "keep_alive_probes",
                                        "keep_alive_timeouts",
                                        "low_water_mark_throttle",
                                        "malformed_packets_received",
                                        "mss_down",
                                        "mss_up",
                                        "no_port_packets_received",
                                        "no_throttle",
                                        "num_open_sockets",
                                        "out_of_order_bytes_received",
                                        "out_of_order_packets_received",
                                        "packet_failures",
                                        "packets_received_after_close_packet",
                                        "packets_retransmitted",
                                        "partial_duplicate_ack_received",
                                        "partial_duplicate_bytes_received",
                                        "paws_dropped",
                                        "persist_dropped",
                                        "pulse_errors",
                                        "reassembly_packets",
                                        "received_auth_packets_dropped",
                                        "received_packets_dropped",
                                        "received_packets_dropped_stale_c_hdr",
                                        "recovered_packets",
                                        "retransmit_dropped",
                                        "retransmit_timeouts",
                                        "rst_packets_sent",
                                        "send_auth_packets_dropped",
                                        "send_packets_dropped",
                                        "socket_layer_packets",
                                        "stalled_timer_tickle_count",
                                        "stalled_timer_tickle_time",
                                        "syn_cache_aborted",
                                        "syn_cache_added",
                                        "syn_cache_bucket_oflow",
                                        "syn_cache_completed",
                                        "syn_cache_count",
                                        "syn_cache_dropped",
                                        "syn_cache_duplicate_sy_ns",
                                        "syn_cache_overflow",
                                        "syn_cache_reset",
                                        "syn_cache_timed_out",
                                        "syn_cache_unreach",
                                        "synacl_match_pkts_dropped",
                                        "too_short_packets_received",
                                        "total_packets_received",
                                        "total_pakets_sent",
                                        "truncated_write_iov",
                                        "try_lock_dropped",
                                        "urgent_only_packets_sent",
                                        "window_probe_packets_received",
                                        "window_probe_packets_sent",
                                        "window_update_packets_received",
                                        "window_update_packets_sent") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpConnection.Nodes.Node.Statistics.Summary, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpConnection.Nodes.Node.Statistics.Summary, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.ack_only_packets_sent.is_set or
                            self.ack_packets_for_unsent_received.is_set or
                            self.ack_packets_received.is_set or
                            self.ackbytes_received.is_set or
                            self.after_window_bytes_received.is_set or
                            self.after_window_packets_received.is_set or
                            self.bad_checksum_packets_received.is_set or
                            self.bytes_retransmitted.is_set or
                            self.connection_rate_limited.is_set or
                            self.connections_accepted.is_set or
                            self.connections_closed.is_set or
                            self.connections_dropped.is_set or
                            self.connections_established.is_set or
                            self.connections_failed.is_set or
                            self.connections_forcibly_closed.is_set or
                            self.connections_requested.is_set or
                            self.control_packets_sent.is_set or
                            self.data_bytes_received_in_sequence.is_set or
                            self.data_bytes_sent.is_set or
                            self.data_packets_received_in_sequence.is_set or
                            self.data_pakets_sent.is_set or
                            self.delay_ack_packets_sent.is_set or
                            self.duplicate_bytes_received.is_set or
                            self.duplicate_packets_received.is_set or
                            self.duplicated_ack_packets_received.is_set or
                            self.embryonic_connection_dropped.is_set or
                            self.established_connections_reset.is_set or
                            self.high_water_mark_throttle.is_set or
                            self.iq_sock_aborts.is_set or
                            self.iq_sock_retries.is_set or
                            self.iq_sock_writes.is_set or
                            self.keep_alive_dropped.is_set or
                            self.keep_alive_probes.is_set or
                            self.keep_alive_timeouts.is_set or
                            self.low_water_mark_throttle.is_set or
                            self.malformed_packets_received.is_set or
                            self.mss_down.is_set or
                            self.mss_up.is_set or
                            self.no_port_packets_received.is_set or
                            self.no_throttle.is_set or
                            self.num_open_sockets.is_set or
                            self.out_of_order_bytes_received.is_set or
                            self.out_of_order_packets_received.is_set or
                            self.packet_failures.is_set or
                            self.packets_received_after_close_packet.is_set or
                            self.packets_retransmitted.is_set or
                            self.partial_duplicate_ack_received.is_set or
                            self.partial_duplicate_bytes_received.is_set or
                            self.paws_dropped.is_set or
                            self.persist_dropped.is_set or
                            self.pulse_errors.is_set or
                            self.reassembly_packets.is_set or
                            self.received_auth_packets_dropped.is_set or
                            self.received_packets_dropped.is_set or
                            self.received_packets_dropped_stale_c_hdr.is_set or
                            self.recovered_packets.is_set or
                            self.retransmit_dropped.is_set or
                            self.retransmit_timeouts.is_set or
                            self.rst_packets_sent.is_set or
                            self.send_auth_packets_dropped.is_set or
                            self.send_packets_dropped.is_set or
                            self.socket_layer_packets.is_set or
                            self.stalled_timer_tickle_count.is_set or
                            self.stalled_timer_tickle_time.is_set or
                            self.syn_cache_aborted.is_set or
                            self.syn_cache_added.is_set or
                            self.syn_cache_bucket_oflow.is_set or
                            self.syn_cache_completed.is_set or
                            self.syn_cache_count.is_set or
                            self.syn_cache_dropped.is_set or
                            self.syn_cache_duplicate_sy_ns.is_set or
                            self.syn_cache_overflow.is_set or
                            self.syn_cache_reset.is_set or
                            self.syn_cache_timed_out.is_set or
                            self.syn_cache_unreach.is_set or
                            self.synacl_match_pkts_dropped.is_set or
                            self.too_short_packets_received.is_set or
                            self.total_packets_received.is_set or
                            self.total_pakets_sent.is_set or
                            self.truncated_write_iov.is_set or
                            self.try_lock_dropped.is_set or
                            self.urgent_only_packets_sent.is_set or
                            self.window_probe_packets_received.is_set or
                            self.window_probe_packets_sent.is_set or
                            self.window_update_packets_received.is_set or
                            self.window_update_packets_sent.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ack_only_packets_sent.yfilter != YFilter.not_set or
                            self.ack_packets_for_unsent_received.yfilter != YFilter.not_set or
                            self.ack_packets_received.yfilter != YFilter.not_set or
                            self.ackbytes_received.yfilter != YFilter.not_set or
                            self.after_window_bytes_received.yfilter != YFilter.not_set or
                            self.after_window_packets_received.yfilter != YFilter.not_set or
                            self.bad_checksum_packets_received.yfilter != YFilter.not_set or
                            self.bytes_retransmitted.yfilter != YFilter.not_set or
                            self.connection_rate_limited.yfilter != YFilter.not_set or
                            self.connections_accepted.yfilter != YFilter.not_set or
                            self.connections_closed.yfilter != YFilter.not_set or
                            self.connections_dropped.yfilter != YFilter.not_set or
                            self.connections_established.yfilter != YFilter.not_set or
                            self.connections_failed.yfilter != YFilter.not_set or
                            self.connections_forcibly_closed.yfilter != YFilter.not_set or
                            self.connections_requested.yfilter != YFilter.not_set or
                            self.control_packets_sent.yfilter != YFilter.not_set or
                            self.data_bytes_received_in_sequence.yfilter != YFilter.not_set or
                            self.data_bytes_sent.yfilter != YFilter.not_set or
                            self.data_packets_received_in_sequence.yfilter != YFilter.not_set or
                            self.data_pakets_sent.yfilter != YFilter.not_set or
                            self.delay_ack_packets_sent.yfilter != YFilter.not_set or
                            self.duplicate_bytes_received.yfilter != YFilter.not_set or
                            self.duplicate_packets_received.yfilter != YFilter.not_set or
                            self.duplicated_ack_packets_received.yfilter != YFilter.not_set or
                            self.embryonic_connection_dropped.yfilter != YFilter.not_set or
                            self.established_connections_reset.yfilter != YFilter.not_set or
                            self.high_water_mark_throttle.yfilter != YFilter.not_set or
                            self.iq_sock_aborts.yfilter != YFilter.not_set or
                            self.iq_sock_retries.yfilter != YFilter.not_set or
                            self.iq_sock_writes.yfilter != YFilter.not_set or
                            self.keep_alive_dropped.yfilter != YFilter.not_set or
                            self.keep_alive_probes.yfilter != YFilter.not_set or
                            self.keep_alive_timeouts.yfilter != YFilter.not_set or
                            self.low_water_mark_throttle.yfilter != YFilter.not_set or
                            self.malformed_packets_received.yfilter != YFilter.not_set or
                            self.mss_down.yfilter != YFilter.not_set or
                            self.mss_up.yfilter != YFilter.not_set or
                            self.no_port_packets_received.yfilter != YFilter.not_set or
                            self.no_throttle.yfilter != YFilter.not_set or
                            self.num_open_sockets.yfilter != YFilter.not_set or
                            self.out_of_order_bytes_received.yfilter != YFilter.not_set or
                            self.out_of_order_packets_received.yfilter != YFilter.not_set or
                            self.packet_failures.yfilter != YFilter.not_set or
                            self.packets_received_after_close_packet.yfilter != YFilter.not_set or
                            self.packets_retransmitted.yfilter != YFilter.not_set or
                            self.partial_duplicate_ack_received.yfilter != YFilter.not_set or
                            self.partial_duplicate_bytes_received.yfilter != YFilter.not_set or
                            self.paws_dropped.yfilter != YFilter.not_set or
                            self.persist_dropped.yfilter != YFilter.not_set or
                            self.pulse_errors.yfilter != YFilter.not_set or
                            self.reassembly_packets.yfilter != YFilter.not_set or
                            self.received_auth_packets_dropped.yfilter != YFilter.not_set or
                            self.received_packets_dropped.yfilter != YFilter.not_set or
                            self.received_packets_dropped_stale_c_hdr.yfilter != YFilter.not_set or
                            self.recovered_packets.yfilter != YFilter.not_set or
                            self.retransmit_dropped.yfilter != YFilter.not_set or
                            self.retransmit_timeouts.yfilter != YFilter.not_set or
                            self.rst_packets_sent.yfilter != YFilter.not_set or
                            self.send_auth_packets_dropped.yfilter != YFilter.not_set or
                            self.send_packets_dropped.yfilter != YFilter.not_set or
                            self.socket_layer_packets.yfilter != YFilter.not_set or
                            self.stalled_timer_tickle_count.yfilter != YFilter.not_set or
                            self.stalled_timer_tickle_time.yfilter != YFilter.not_set or
                            self.syn_cache_aborted.yfilter != YFilter.not_set or
                            self.syn_cache_added.yfilter != YFilter.not_set or
                            self.syn_cache_bucket_oflow.yfilter != YFilter.not_set or
                            self.syn_cache_completed.yfilter != YFilter.not_set or
                            self.syn_cache_count.yfilter != YFilter.not_set or
                            self.syn_cache_dropped.yfilter != YFilter.not_set or
                            self.syn_cache_duplicate_sy_ns.yfilter != YFilter.not_set or
                            self.syn_cache_overflow.yfilter != YFilter.not_set or
                            self.syn_cache_reset.yfilter != YFilter.not_set or
                            self.syn_cache_timed_out.yfilter != YFilter.not_set or
                            self.syn_cache_unreach.yfilter != YFilter.not_set or
                            self.synacl_match_pkts_dropped.yfilter != YFilter.not_set or
                            self.too_short_packets_received.yfilter != YFilter.not_set or
                            self.total_packets_received.yfilter != YFilter.not_set or
                            self.total_pakets_sent.yfilter != YFilter.not_set or
                            self.truncated_write_iov.yfilter != YFilter.not_set or
                            self.try_lock_dropped.yfilter != YFilter.not_set or
                            self.urgent_only_packets_sent.yfilter != YFilter.not_set or
                            self.window_probe_packets_received.yfilter != YFilter.not_set or
                            self.window_probe_packets_sent.yfilter != YFilter.not_set or
                            self.window_update_packets_received.yfilter != YFilter.not_set or
                            self.window_update_packets_sent.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "summary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ack_only_packets_sent.is_set or self.ack_only_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ack_only_packets_sent.get_name_leafdata())
                        if (self.ack_packets_for_unsent_received.is_set or self.ack_packets_for_unsent_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ack_packets_for_unsent_received.get_name_leafdata())
                        if (self.ack_packets_received.is_set or self.ack_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ack_packets_received.get_name_leafdata())
                        if (self.ackbytes_received.is_set or self.ackbytes_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ackbytes_received.get_name_leafdata())
                        if (self.after_window_bytes_received.is_set or self.after_window_bytes_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.after_window_bytes_received.get_name_leafdata())
                        if (self.after_window_packets_received.is_set or self.after_window_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.after_window_packets_received.get_name_leafdata())
                        if (self.bad_checksum_packets_received.is_set or self.bad_checksum_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bad_checksum_packets_received.get_name_leafdata())
                        if (self.bytes_retransmitted.is_set or self.bytes_retransmitted.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bytes_retransmitted.get_name_leafdata())
                        if (self.connection_rate_limited.is_set or self.connection_rate_limited.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connection_rate_limited.get_name_leafdata())
                        if (self.connections_accepted.is_set or self.connections_accepted.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connections_accepted.get_name_leafdata())
                        if (self.connections_closed.is_set or self.connections_closed.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connections_closed.get_name_leafdata())
                        if (self.connections_dropped.is_set or self.connections_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connections_dropped.get_name_leafdata())
                        if (self.connections_established.is_set or self.connections_established.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connections_established.get_name_leafdata())
                        if (self.connections_failed.is_set or self.connections_failed.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connections_failed.get_name_leafdata())
                        if (self.connections_forcibly_closed.is_set or self.connections_forcibly_closed.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connections_forcibly_closed.get_name_leafdata())
                        if (self.connections_requested.is_set or self.connections_requested.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connections_requested.get_name_leafdata())
                        if (self.control_packets_sent.is_set or self.control_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_packets_sent.get_name_leafdata())
                        if (self.data_bytes_received_in_sequence.is_set or self.data_bytes_received_in_sequence.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.data_bytes_received_in_sequence.get_name_leafdata())
                        if (self.data_bytes_sent.is_set or self.data_bytes_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.data_bytes_sent.get_name_leafdata())
                        if (self.data_packets_received_in_sequence.is_set or self.data_packets_received_in_sequence.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.data_packets_received_in_sequence.get_name_leafdata())
                        if (self.data_pakets_sent.is_set or self.data_pakets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.data_pakets_sent.get_name_leafdata())
                        if (self.delay_ack_packets_sent.is_set or self.delay_ack_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.delay_ack_packets_sent.get_name_leafdata())
                        if (self.duplicate_bytes_received.is_set or self.duplicate_bytes_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.duplicate_bytes_received.get_name_leafdata())
                        if (self.duplicate_packets_received.is_set or self.duplicate_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.duplicate_packets_received.get_name_leafdata())
                        if (self.duplicated_ack_packets_received.is_set or self.duplicated_ack_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.duplicated_ack_packets_received.get_name_leafdata())
                        if (self.embryonic_connection_dropped.is_set or self.embryonic_connection_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.embryonic_connection_dropped.get_name_leafdata())
                        if (self.established_connections_reset.is_set or self.established_connections_reset.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.established_connections_reset.get_name_leafdata())
                        if (self.high_water_mark_throttle.is_set or self.high_water_mark_throttle.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.high_water_mark_throttle.get_name_leafdata())
                        if (self.iq_sock_aborts.is_set or self.iq_sock_aborts.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iq_sock_aborts.get_name_leafdata())
                        if (self.iq_sock_retries.is_set or self.iq_sock_retries.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iq_sock_retries.get_name_leafdata())
                        if (self.iq_sock_writes.is_set or self.iq_sock_writes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iq_sock_writes.get_name_leafdata())
                        if (self.keep_alive_dropped.is_set or self.keep_alive_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_dropped.get_name_leafdata())
                        if (self.keep_alive_probes.is_set or self.keep_alive_probes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_probes.get_name_leafdata())
                        if (self.keep_alive_timeouts.is_set or self.keep_alive_timeouts.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_timeouts.get_name_leafdata())
                        if (self.low_water_mark_throttle.is_set or self.low_water_mark_throttle.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.low_water_mark_throttle.get_name_leafdata())
                        if (self.malformed_packets_received.is_set or self.malformed_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.malformed_packets_received.get_name_leafdata())
                        if (self.mss_down.is_set or self.mss_down.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mss_down.get_name_leafdata())
                        if (self.mss_up.is_set or self.mss_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mss_up.get_name_leafdata())
                        if (self.no_port_packets_received.is_set or self.no_port_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.no_port_packets_received.get_name_leafdata())
                        if (self.no_throttle.is_set or self.no_throttle.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.no_throttle.get_name_leafdata())
                        if (self.num_open_sockets.is_set or self.num_open_sockets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_open_sockets.get_name_leafdata())
                        if (self.out_of_order_bytes_received.is_set or self.out_of_order_bytes_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.out_of_order_bytes_received.get_name_leafdata())
                        if (self.out_of_order_packets_received.is_set or self.out_of_order_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.out_of_order_packets_received.get_name_leafdata())
                        if (self.packet_failures.is_set or self.packet_failures.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packet_failures.get_name_leafdata())
                        if (self.packets_received_after_close_packet.is_set or self.packets_received_after_close_packet.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packets_received_after_close_packet.get_name_leafdata())
                        if (self.packets_retransmitted.is_set or self.packets_retransmitted.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packets_retransmitted.get_name_leafdata())
                        if (self.partial_duplicate_ack_received.is_set or self.partial_duplicate_ack_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.partial_duplicate_ack_received.get_name_leafdata())
                        if (self.partial_duplicate_bytes_received.is_set or self.partial_duplicate_bytes_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.partial_duplicate_bytes_received.get_name_leafdata())
                        if (self.paws_dropped.is_set or self.paws_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.paws_dropped.get_name_leafdata())
                        if (self.persist_dropped.is_set or self.persist_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.persist_dropped.get_name_leafdata())
                        if (self.pulse_errors.is_set or self.pulse_errors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pulse_errors.get_name_leafdata())
                        if (self.reassembly_packets.is_set or self.reassembly_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reassembly_packets.get_name_leafdata())
                        if (self.received_auth_packets_dropped.is_set or self.received_auth_packets_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.received_auth_packets_dropped.get_name_leafdata())
                        if (self.received_packets_dropped.is_set or self.received_packets_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.received_packets_dropped.get_name_leafdata())
                        if (self.received_packets_dropped_stale_c_hdr.is_set or self.received_packets_dropped_stale_c_hdr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.received_packets_dropped_stale_c_hdr.get_name_leafdata())
                        if (self.recovered_packets.is_set or self.recovered_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recovered_packets.get_name_leafdata())
                        if (self.retransmit_dropped.is_set or self.retransmit_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.retransmit_dropped.get_name_leafdata())
                        if (self.retransmit_timeouts.is_set or self.retransmit_timeouts.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.retransmit_timeouts.get_name_leafdata())
                        if (self.rst_packets_sent.is_set or self.rst_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rst_packets_sent.get_name_leafdata())
                        if (self.send_auth_packets_dropped.is_set or self.send_auth_packets_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_auth_packets_dropped.get_name_leafdata())
                        if (self.send_packets_dropped.is_set or self.send_packets_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_packets_dropped.get_name_leafdata())
                        if (self.socket_layer_packets.is_set or self.socket_layer_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.socket_layer_packets.get_name_leafdata())
                        if (self.stalled_timer_tickle_count.is_set or self.stalled_timer_tickle_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stalled_timer_tickle_count.get_name_leafdata())
                        if (self.stalled_timer_tickle_time.is_set or self.stalled_timer_tickle_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stalled_timer_tickle_time.get_name_leafdata())
                        if (self.syn_cache_aborted.is_set or self.syn_cache_aborted.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_aborted.get_name_leafdata())
                        if (self.syn_cache_added.is_set or self.syn_cache_added.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_added.get_name_leafdata())
                        if (self.syn_cache_bucket_oflow.is_set or self.syn_cache_bucket_oflow.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_bucket_oflow.get_name_leafdata())
                        if (self.syn_cache_completed.is_set or self.syn_cache_completed.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_completed.get_name_leafdata())
                        if (self.syn_cache_count.is_set or self.syn_cache_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_count.get_name_leafdata())
                        if (self.syn_cache_dropped.is_set or self.syn_cache_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_dropped.get_name_leafdata())
                        if (self.syn_cache_duplicate_sy_ns.is_set or self.syn_cache_duplicate_sy_ns.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_duplicate_sy_ns.get_name_leafdata())
                        if (self.syn_cache_overflow.is_set or self.syn_cache_overflow.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_overflow.get_name_leafdata())
                        if (self.syn_cache_reset.is_set or self.syn_cache_reset.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_reset.get_name_leafdata())
                        if (self.syn_cache_timed_out.is_set or self.syn_cache_timed_out.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_timed_out.get_name_leafdata())
                        if (self.syn_cache_unreach.is_set or self.syn_cache_unreach.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_cache_unreach.get_name_leafdata())
                        if (self.synacl_match_pkts_dropped.is_set or self.synacl_match_pkts_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.synacl_match_pkts_dropped.get_name_leafdata())
                        if (self.too_short_packets_received.is_set or self.too_short_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.too_short_packets_received.get_name_leafdata())
                        if (self.total_packets_received.is_set or self.total_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_packets_received.get_name_leafdata())
                        if (self.total_pakets_sent.is_set or self.total_pakets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_pakets_sent.get_name_leafdata())
                        if (self.truncated_write_iov.is_set or self.truncated_write_iov.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.truncated_write_iov.get_name_leafdata())
                        if (self.try_lock_dropped.is_set or self.try_lock_dropped.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.try_lock_dropped.get_name_leafdata())
                        if (self.urgent_only_packets_sent.is_set or self.urgent_only_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.urgent_only_packets_sent.get_name_leafdata())
                        if (self.window_probe_packets_received.is_set or self.window_probe_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.window_probe_packets_received.get_name_leafdata())
                        if (self.window_probe_packets_sent.is_set or self.window_probe_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.window_probe_packets_sent.get_name_leafdata())
                        if (self.window_update_packets_received.is_set or self.window_update_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.window_update_packets_received.get_name_leafdata())
                        if (self.window_update_packets_sent.is_set or self.window_update_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.window_update_packets_sent.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ack-only-packets-sent" or name == "ack-packets-for-unsent-received" or name == "ack-packets-received" or name == "ackbytes-received" or name == "after-window-bytes-received" or name == "after-window-packets-received" or name == "bad-checksum-packets-received" or name == "bytes-retransmitted" or name == "connection-rate-limited" or name == "connections-accepted" or name == "connections-closed" or name == "connections-dropped" or name == "connections-established" or name == "connections-failed" or name == "connections-forcibly-closed" or name == "connections-requested" or name == "control-packets-sent" or name == "data-bytes-received-in-sequence" or name == "data-bytes-sent" or name == "data-packets-received-in-sequence" or name == "data-pakets-sent" or name == "delay-ack-packets-sent" or name == "duplicate-bytes-received" or name == "duplicate-packets-received" or name == "duplicated-ack-packets-received" or name == "embryonic-connection-dropped" or name == "established-connections-reset" or name == "high-water-mark-throttle" or name == "iq-sock-aborts" or name == "iq-sock-retries" or name == "iq-sock-writes" or name == "keep-alive-dropped" or name == "keep-alive-probes" or name == "keep-alive-timeouts" or name == "low-water-mark-throttle" or name == "malformed-packets-received" or name == "mss-down" or name == "mss-up" or name == "no-port-packets-received" or name == "no-throttle" or name == "num-open-sockets" or name == "out-of-order-bytes-received" or name == "out-of-order-packets-received" or name == "packet-failures" or name == "packets-received-after-close-packet" or name == "packets-retransmitted" or name == "partial-duplicate-ack-received" or name == "partial-duplicate-bytes-received" or name == "paws-dropped" or name == "persist-dropped" or name == "pulse-errors" or name == "reassembly-packets" or name == "received-auth-packets-dropped" or name == "received-packets-dropped" or name == "received-packets-dropped-stale-c-hdr" or name == "recovered-packets" or name == "retransmit-dropped" or name == "retransmit-timeouts" or name == "rst-packets-sent" or name == "send-auth-packets-dropped" or name == "send-packets-dropped" or name == "socket-layer-packets" or name == "stalled-timer-tickle-count" or name == "stalled-timer-tickle-time" or name == "syn-cache-aborted" or name == "syn-cache-added" or name == "syn-cache-bucket-oflow" or name == "syn-cache-completed" or name == "syn-cache-count" or name == "syn-cache-dropped" or name == "syn-cache-duplicate-sy-ns" or name == "syn-cache-overflow" or name == "syn-cache-reset" or name == "syn-cache-timed-out" or name == "syn-cache-unreach" or name == "synacl-match-pkts-dropped" or name == "too-short-packets-received" or name == "total-packets-received" or name == "total-pakets-sent" or name == "truncated-write-iov" or name == "try-lock-dropped" or name == "urgent-only-packets-sent" or name == "window-probe-packets-received" or name == "window-probe-packets-sent" or name == "window-update-packets-received" or name == "window-update-packets-sent"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ack-only-packets-sent"):
                            self.ack_only_packets_sent = value
                            self.ack_only_packets_sent.value_namespace = name_space
                            self.ack_only_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "ack-packets-for-unsent-received"):
                            self.ack_packets_for_unsent_received = value
                            self.ack_packets_for_unsent_received.value_namespace = name_space
                            self.ack_packets_for_unsent_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "ack-packets-received"):
                            self.ack_packets_received = value
                            self.ack_packets_received.value_namespace = name_space
                            self.ack_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "ackbytes-received"):
                            self.ackbytes_received = value
                            self.ackbytes_received.value_namespace = name_space
                            self.ackbytes_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "after-window-bytes-received"):
                            self.after_window_bytes_received = value
                            self.after_window_bytes_received.value_namespace = name_space
                            self.after_window_bytes_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "after-window-packets-received"):
                            self.after_window_packets_received = value
                            self.after_window_packets_received.value_namespace = name_space
                            self.after_window_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "bad-checksum-packets-received"):
                            self.bad_checksum_packets_received = value
                            self.bad_checksum_packets_received.value_namespace = name_space
                            self.bad_checksum_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "bytes-retransmitted"):
                            self.bytes_retransmitted = value
                            self.bytes_retransmitted.value_namespace = name_space
                            self.bytes_retransmitted.value_namespace_prefix = name_space_prefix
                        if(value_path == "connection-rate-limited"):
                            self.connection_rate_limited = value
                            self.connection_rate_limited.value_namespace = name_space
                            self.connection_rate_limited.value_namespace_prefix = name_space_prefix
                        if(value_path == "connections-accepted"):
                            self.connections_accepted = value
                            self.connections_accepted.value_namespace = name_space
                            self.connections_accepted.value_namespace_prefix = name_space_prefix
                        if(value_path == "connections-closed"):
                            self.connections_closed = value
                            self.connections_closed.value_namespace = name_space
                            self.connections_closed.value_namespace_prefix = name_space_prefix
                        if(value_path == "connections-dropped"):
                            self.connections_dropped = value
                            self.connections_dropped.value_namespace = name_space
                            self.connections_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "connections-established"):
                            self.connections_established = value
                            self.connections_established.value_namespace = name_space
                            self.connections_established.value_namespace_prefix = name_space_prefix
                        if(value_path == "connections-failed"):
                            self.connections_failed = value
                            self.connections_failed.value_namespace = name_space
                            self.connections_failed.value_namespace_prefix = name_space_prefix
                        if(value_path == "connections-forcibly-closed"):
                            self.connections_forcibly_closed = value
                            self.connections_forcibly_closed.value_namespace = name_space
                            self.connections_forcibly_closed.value_namespace_prefix = name_space_prefix
                        if(value_path == "connections-requested"):
                            self.connections_requested = value
                            self.connections_requested.value_namespace = name_space
                            self.connections_requested.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-packets-sent"):
                            self.control_packets_sent = value
                            self.control_packets_sent.value_namespace = name_space
                            self.control_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "data-bytes-received-in-sequence"):
                            self.data_bytes_received_in_sequence = value
                            self.data_bytes_received_in_sequence.value_namespace = name_space
                            self.data_bytes_received_in_sequence.value_namespace_prefix = name_space_prefix
                        if(value_path == "data-bytes-sent"):
                            self.data_bytes_sent = value
                            self.data_bytes_sent.value_namespace = name_space
                            self.data_bytes_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "data-packets-received-in-sequence"):
                            self.data_packets_received_in_sequence = value
                            self.data_packets_received_in_sequence.value_namespace = name_space
                            self.data_packets_received_in_sequence.value_namespace_prefix = name_space_prefix
                        if(value_path == "data-pakets-sent"):
                            self.data_pakets_sent = value
                            self.data_pakets_sent.value_namespace = name_space
                            self.data_pakets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "delay-ack-packets-sent"):
                            self.delay_ack_packets_sent = value
                            self.delay_ack_packets_sent.value_namespace = name_space
                            self.delay_ack_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "duplicate-bytes-received"):
                            self.duplicate_bytes_received = value
                            self.duplicate_bytes_received.value_namespace = name_space
                            self.duplicate_bytes_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "duplicate-packets-received"):
                            self.duplicate_packets_received = value
                            self.duplicate_packets_received.value_namespace = name_space
                            self.duplicate_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "duplicated-ack-packets-received"):
                            self.duplicated_ack_packets_received = value
                            self.duplicated_ack_packets_received.value_namespace = name_space
                            self.duplicated_ack_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "embryonic-connection-dropped"):
                            self.embryonic_connection_dropped = value
                            self.embryonic_connection_dropped.value_namespace = name_space
                            self.embryonic_connection_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "established-connections-reset"):
                            self.established_connections_reset = value
                            self.established_connections_reset.value_namespace = name_space
                            self.established_connections_reset.value_namespace_prefix = name_space_prefix
                        if(value_path == "high-water-mark-throttle"):
                            self.high_water_mark_throttle = value
                            self.high_water_mark_throttle.value_namespace = name_space
                            self.high_water_mark_throttle.value_namespace_prefix = name_space_prefix
                        if(value_path == "iq-sock-aborts"):
                            self.iq_sock_aborts = value
                            self.iq_sock_aborts.value_namespace = name_space
                            self.iq_sock_aborts.value_namespace_prefix = name_space_prefix
                        if(value_path == "iq-sock-retries"):
                            self.iq_sock_retries = value
                            self.iq_sock_retries.value_namespace = name_space
                            self.iq_sock_retries.value_namespace_prefix = name_space_prefix
                        if(value_path == "iq-sock-writes"):
                            self.iq_sock_writes = value
                            self.iq_sock_writes.value_namespace = name_space
                            self.iq_sock_writes.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-dropped"):
                            self.keep_alive_dropped = value
                            self.keep_alive_dropped.value_namespace = name_space
                            self.keep_alive_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-probes"):
                            self.keep_alive_probes = value
                            self.keep_alive_probes.value_namespace = name_space
                            self.keep_alive_probes.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-timeouts"):
                            self.keep_alive_timeouts = value
                            self.keep_alive_timeouts.value_namespace = name_space
                            self.keep_alive_timeouts.value_namespace_prefix = name_space_prefix
                        if(value_path == "low-water-mark-throttle"):
                            self.low_water_mark_throttle = value
                            self.low_water_mark_throttle.value_namespace = name_space
                            self.low_water_mark_throttle.value_namespace_prefix = name_space_prefix
                        if(value_path == "malformed-packets-received"):
                            self.malformed_packets_received = value
                            self.malformed_packets_received.value_namespace = name_space
                            self.malformed_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "mss-down"):
                            self.mss_down = value
                            self.mss_down.value_namespace = name_space
                            self.mss_down.value_namespace_prefix = name_space_prefix
                        if(value_path == "mss-up"):
                            self.mss_up = value
                            self.mss_up.value_namespace = name_space
                            self.mss_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "no-port-packets-received"):
                            self.no_port_packets_received = value
                            self.no_port_packets_received.value_namespace = name_space
                            self.no_port_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "no-throttle"):
                            self.no_throttle = value
                            self.no_throttle.value_namespace = name_space
                            self.no_throttle.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-open-sockets"):
                            self.num_open_sockets = value
                            self.num_open_sockets.value_namespace = name_space
                            self.num_open_sockets.value_namespace_prefix = name_space_prefix
                        if(value_path == "out-of-order-bytes-received"):
                            self.out_of_order_bytes_received = value
                            self.out_of_order_bytes_received.value_namespace = name_space
                            self.out_of_order_bytes_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "out-of-order-packets-received"):
                            self.out_of_order_packets_received = value
                            self.out_of_order_packets_received.value_namespace = name_space
                            self.out_of_order_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "packet-failures"):
                            self.packet_failures = value
                            self.packet_failures.value_namespace = name_space
                            self.packet_failures.value_namespace_prefix = name_space_prefix
                        if(value_path == "packets-received-after-close-packet"):
                            self.packets_received_after_close_packet = value
                            self.packets_received_after_close_packet.value_namespace = name_space
                            self.packets_received_after_close_packet.value_namespace_prefix = name_space_prefix
                        if(value_path == "packets-retransmitted"):
                            self.packets_retransmitted = value
                            self.packets_retransmitted.value_namespace = name_space
                            self.packets_retransmitted.value_namespace_prefix = name_space_prefix
                        if(value_path == "partial-duplicate-ack-received"):
                            self.partial_duplicate_ack_received = value
                            self.partial_duplicate_ack_received.value_namespace = name_space
                            self.partial_duplicate_ack_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "partial-duplicate-bytes-received"):
                            self.partial_duplicate_bytes_received = value
                            self.partial_duplicate_bytes_received.value_namespace = name_space
                            self.partial_duplicate_bytes_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "paws-dropped"):
                            self.paws_dropped = value
                            self.paws_dropped.value_namespace = name_space
                            self.paws_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "persist-dropped"):
                            self.persist_dropped = value
                            self.persist_dropped.value_namespace = name_space
                            self.persist_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "pulse-errors"):
                            self.pulse_errors = value
                            self.pulse_errors.value_namespace = name_space
                            self.pulse_errors.value_namespace_prefix = name_space_prefix
                        if(value_path == "reassembly-packets"):
                            self.reassembly_packets = value
                            self.reassembly_packets.value_namespace = name_space
                            self.reassembly_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "received-auth-packets-dropped"):
                            self.received_auth_packets_dropped = value
                            self.received_auth_packets_dropped.value_namespace = name_space
                            self.received_auth_packets_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "received-packets-dropped"):
                            self.received_packets_dropped = value
                            self.received_packets_dropped.value_namespace = name_space
                            self.received_packets_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "received-packets-dropped-stale-c-hdr"):
                            self.received_packets_dropped_stale_c_hdr = value
                            self.received_packets_dropped_stale_c_hdr.value_namespace = name_space
                            self.received_packets_dropped_stale_c_hdr.value_namespace_prefix = name_space_prefix
                        if(value_path == "recovered-packets"):
                            self.recovered_packets = value
                            self.recovered_packets.value_namespace = name_space
                            self.recovered_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "retransmit-dropped"):
                            self.retransmit_dropped = value
                            self.retransmit_dropped.value_namespace = name_space
                            self.retransmit_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "retransmit-timeouts"):
                            self.retransmit_timeouts = value
                            self.retransmit_timeouts.value_namespace = name_space
                            self.retransmit_timeouts.value_namespace_prefix = name_space_prefix
                        if(value_path == "rst-packets-sent"):
                            self.rst_packets_sent = value
                            self.rst_packets_sent.value_namespace = name_space
                            self.rst_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-auth-packets-dropped"):
                            self.send_auth_packets_dropped = value
                            self.send_auth_packets_dropped.value_namespace = name_space
                            self.send_auth_packets_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-packets-dropped"):
                            self.send_packets_dropped = value
                            self.send_packets_dropped.value_namespace = name_space
                            self.send_packets_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "socket-layer-packets"):
                            self.socket_layer_packets = value
                            self.socket_layer_packets.value_namespace = name_space
                            self.socket_layer_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "stalled-timer-tickle-count"):
                            self.stalled_timer_tickle_count = value
                            self.stalled_timer_tickle_count.value_namespace = name_space
                            self.stalled_timer_tickle_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "stalled-timer-tickle-time"):
                            self.stalled_timer_tickle_time = value
                            self.stalled_timer_tickle_time.value_namespace = name_space
                            self.stalled_timer_tickle_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-aborted"):
                            self.syn_cache_aborted = value
                            self.syn_cache_aborted.value_namespace = name_space
                            self.syn_cache_aborted.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-added"):
                            self.syn_cache_added = value
                            self.syn_cache_added.value_namespace = name_space
                            self.syn_cache_added.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-bucket-oflow"):
                            self.syn_cache_bucket_oflow = value
                            self.syn_cache_bucket_oflow.value_namespace = name_space
                            self.syn_cache_bucket_oflow.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-completed"):
                            self.syn_cache_completed = value
                            self.syn_cache_completed.value_namespace = name_space
                            self.syn_cache_completed.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-count"):
                            self.syn_cache_count = value
                            self.syn_cache_count.value_namespace = name_space
                            self.syn_cache_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-dropped"):
                            self.syn_cache_dropped = value
                            self.syn_cache_dropped.value_namespace = name_space
                            self.syn_cache_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-duplicate-sy-ns"):
                            self.syn_cache_duplicate_sy_ns = value
                            self.syn_cache_duplicate_sy_ns.value_namespace = name_space
                            self.syn_cache_duplicate_sy_ns.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-overflow"):
                            self.syn_cache_overflow = value
                            self.syn_cache_overflow.value_namespace = name_space
                            self.syn_cache_overflow.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-reset"):
                            self.syn_cache_reset = value
                            self.syn_cache_reset.value_namespace = name_space
                            self.syn_cache_reset.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-timed-out"):
                            self.syn_cache_timed_out = value
                            self.syn_cache_timed_out.value_namespace = name_space
                            self.syn_cache_timed_out.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-cache-unreach"):
                            self.syn_cache_unreach = value
                            self.syn_cache_unreach.value_namespace = name_space
                            self.syn_cache_unreach.value_namespace_prefix = name_space_prefix
                        if(value_path == "synacl-match-pkts-dropped"):
                            self.synacl_match_pkts_dropped = value
                            self.synacl_match_pkts_dropped.value_namespace = name_space
                            self.synacl_match_pkts_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "too-short-packets-received"):
                            self.too_short_packets_received = value
                            self.too_short_packets_received.value_namespace = name_space
                            self.too_short_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-packets-received"):
                            self.total_packets_received = value
                            self.total_packets_received.value_namespace = name_space
                            self.total_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-pakets-sent"):
                            self.total_pakets_sent = value
                            self.total_pakets_sent.value_namespace = name_space
                            self.total_pakets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "truncated-write-iov"):
                            self.truncated_write_iov = value
                            self.truncated_write_iov.value_namespace = name_space
                            self.truncated_write_iov.value_namespace_prefix = name_space_prefix
                        if(value_path == "try-lock-dropped"):
                            self.try_lock_dropped = value
                            self.try_lock_dropped.value_namespace = name_space
                            self.try_lock_dropped.value_namespace_prefix = name_space_prefix
                        if(value_path == "urgent-only-packets-sent"):
                            self.urgent_only_packets_sent = value
                            self.urgent_only_packets_sent.value_namespace = name_space
                            self.urgent_only_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "window-probe-packets-received"):
                            self.window_probe_packets_received = value
                            self.window_probe_packets_received.value_namespace = name_space
                            self.window_probe_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "window-probe-packets-sent"):
                            self.window_probe_packets_sent = value
                            self.window_probe_packets_sent.value_namespace = name_space
                            self.window_probe_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "window-update-packets-received"):
                            self.window_update_packets_received = value
                            self.window_update_packets_received.value_namespace = name_space
                            self.window_update_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "window-update-packets-sent"):
                            self.window_update_packets_sent = value
                            self.window_update_packets_sent.value_namespace = name_space
                            self.window_update_packets_sent.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.clients is not None and self.clients.has_data()) or
                        (self.pcbs is not None and self.pcbs.has_data()) or
                        (self.summary is not None and self.summary.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.clients is not None and self.clients.has_operation()) or
                        (self.pcbs is not None and self.pcbs.has_operation()) or
                        (self.summary is not None and self.summary.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "statistics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "clients"):
                        if (self.clients is None):
                            self.clients = TcpConnection.Nodes.Node.Statistics.Clients()
                            self.clients.parent = self
                            self._children_name_map["clients"] = "clients"
                        return self.clients

                    if (child_yang_name == "pcbs"):
                        if (self.pcbs is None):
                            self.pcbs = TcpConnection.Nodes.Node.Statistics.Pcbs()
                            self.pcbs.parent = self
                            self._children_name_map["pcbs"] = "pcbs"
                        return self.pcbs

                    if (child_yang_name == "summary"):
                        if (self.summary is None):
                            self.summary = TcpConnection.Nodes.Node.Statistics.Summary()
                            self.summary.parent = self
                            self._children_name_map["summary"] = "summary"
                        return self.summary

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "clients" or name == "pcbs" or name == "summary"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class ExtendedInformation(Entity):
                """
                Extended Filter related Information
                
                .. attribute:: display_types
                
                	Table listing display types
                	**type**\:   :py:class:`DisplayTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpConnection.Nodes.Node.ExtendedInformation, self).__init__()

                    self.yang_name = "extended-information"
                    self.yang_parent_name = "node"

                    self.display_types = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes()
                    self.display_types.parent = self
                    self._children_name_map["display_types"] = "display-types"
                    self._children_yang_names.add("display-types")


                class DisplayTypes(Entity):
                    """
                    Table listing display types
                    
                    .. attribute:: display_type
                    
                    	Describing particular display type
                    	**type**\: list of    :py:class:`DisplayType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes, self).__init__()

                        self.yang_name = "display-types"
                        self.yang_parent_name = "extended-information"

                        self.display_type = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes, self).__setattr__(name, value)


                    class DisplayType(Entity):
                        """
                        Describing particular display type
                        
                        .. attribute:: disp_type  <key>
                        
                        	Specifying display type
                        	**type**\:   :py:class:`Show <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.Show>`
                        
                        .. attribute:: connection_id
                        
                        	Describing connection ID
                        	**type**\: list of    :py:class:`ConnectionId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId>`
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType, self).__init__()

                            self.yang_name = "display-type"
                            self.yang_parent_name = "display-types"

                            self.disp_type = YLeaf(YType.enumeration, "disp-type")

                            self.connection_id = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("disp_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType, self).__setattr__(name, value)


                        class ConnectionId(Entity):
                            """
                            Describing connection ID
                            
                            .. attribute:: pcb_id  <key>
                            
                            	Displaying inforamtion based on selected display type associatedwith a particular PCB
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: common
                            
                            	Common PCB information
                            	**type**\:   :py:class:`Common <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common>`
                            
                            .. attribute:: foreign_address
                            
                            	Remote IP address
                            	**type**\:   :py:class:`ForeignAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.ForeignAddress>`
                            
                            .. attribute:: foreign_port
                            
                            	Remote port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: l4_protocol
                            
                            	Layer 4 protocol
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_address
                            
                            	Local IP address
                            	**type**\:   :py:class:`LocalAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.LocalAddress>`
                            
                            .. attribute:: local_port
                            
                            	Local port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId, self).__init__()

                                self.yang_name = "connection-id"
                                self.yang_parent_name = "display-type"

                                self.pcb_id = YLeaf(YType.uint32, "pcb-id")

                                self.foreign_port = YLeaf(YType.uint16, "foreign-port")

                                self.l4_protocol = YLeaf(YType.uint32, "l4-protocol")

                                self.local_port = YLeaf(YType.uint16, "local-port")

                                self.common = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common()
                                self.common.parent = self
                                self._children_name_map["common"] = "common"
                                self._children_yang_names.add("common")

                                self.foreign_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.ForeignAddress()
                                self.foreign_address.parent = self
                                self._children_name_map["foreign_address"] = "foreign-address"
                                self._children_yang_names.add("foreign-address")

                                self.local_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.LocalAddress()
                                self.local_address.parent = self
                                self._children_name_map["local_address"] = "local-address"
                                self._children_yang_names.add("local-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("pcb_id",
                                                "foreign_port",
                                                "l4_protocol",
                                                "local_port") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId, self).__setattr__(name, value)


                            class LocalAddress(Entity):
                                """
                                Local IP address
                                
                                .. attribute:: af_name
                                
                                	AFName
                                	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: ipv6_address
                                
                                	IPv6 address
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'ip-tcp-oper'
                                _revision = '2016-02-26'

                                def __init__(self):
                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.LocalAddress, self).__init__()

                                    self.yang_name = "local-address"
                                    self.yang_parent_name = "connection-id"

                                    self.af_name = YLeaf(YType.enumeration, "af-name")

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("af_name",
                                                    "ipv4_address",
                                                    "ipv6_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.LocalAddress, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.LocalAddress, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.af_name.is_set or
                                        self.ipv4_address.is_set or
                                        self.ipv6_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.af_name.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.ipv6_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "local-address" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.af_name.get_name_leafdata())
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "af-name"):
                                        self.af_name = value
                                        self.af_name.value_namespace = name_space
                                        self.af_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ipv6-address"):
                                        self.ipv6_address = value
                                        self.ipv6_address.value_namespace = name_space
                                        self.ipv6_address.value_namespace_prefix = name_space_prefix


                            class ForeignAddress(Entity):
                                """
                                Remote IP address
                                
                                .. attribute:: af_name
                                
                                	AFName
                                	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: ipv6_address
                                
                                	IPv6 address
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'ip-tcp-oper'
                                _revision = '2016-02-26'

                                def __init__(self):
                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.ForeignAddress, self).__init__()

                                    self.yang_name = "foreign-address"
                                    self.yang_parent_name = "connection-id"

                                    self.af_name = YLeaf(YType.enumeration, "af-name")

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("af_name",
                                                    "ipv4_address",
                                                    "ipv6_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.ForeignAddress, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.ForeignAddress, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.af_name.is_set or
                                        self.ipv4_address.is_set or
                                        self.ipv6_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.af_name.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.ipv6_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "foreign-address" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.af_name.get_name_leafdata())
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "af-name"):
                                        self.af_name = value
                                        self.af_name.value_namespace = name_space
                                        self.af_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ipv6-address"):
                                        self.ipv6_address = value
                                        self.ipv6_address.value_namespace = name_space
                                        self.ipv6_address.value_namespace_prefix = name_space_prefix


                            class Common(Entity):
                                """
                                Common PCB information
                                
                                .. attribute:: af_name
                                
                                	Address Family
                                	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                                
                                .. attribute:: lpts_pcb
                                
                                	LPTS PCB information
                                	**type**\:   :py:class:`LptsPcb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb>`
                                
                                

                                """

                                _prefix = 'ip-tcp-oper'
                                _revision = '2016-02-26'

                                def __init__(self):
                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common, self).__init__()

                                    self.yang_name = "common"
                                    self.yang_parent_name = "connection-id"

                                    self.af_name = YLeaf(YType.enumeration, "af-name")

                                    self.lpts_pcb = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb()
                                    self.lpts_pcb.parent = self
                                    self._children_name_map["lpts_pcb"] = "lpts-pcb"
                                    self._children_yang_names.add("lpts-pcb")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("af_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common, self).__setattr__(name, value)


                                class LptsPcb(Entity):
                                    """
                                    LPTS PCB information
                                    
                                    .. attribute:: accept_mask
                                    
                                    	AcceptMask
                                    	**type**\:   :py:class:`AcceptMask <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.AcceptMask>`
                                    
                                    .. attribute:: filter
                                    
                                    	Interface Filters
                                    	**type**\: list of    :py:class:`Filter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter>`
                                    
                                    .. attribute:: flow_types_info
                                    
                                    	flow information
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: lpts_flags
                                    
                                    	LPTS flags
                                    	**type**\:   :py:class:`LptsFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.LptsFlags>`
                                    
                                    .. attribute:: options
                                    
                                    	Receive options
                                    	**type**\:   :py:class:`Options <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Options>`
                                    
                                    .. attribute:: ttl
                                    
                                    	Minimum TTL
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'ip-tcp-oper'
                                    _revision = '2016-02-26'

                                    def __init__(self):
                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb, self).__init__()

                                        self.yang_name = "lpts-pcb"
                                        self.yang_parent_name = "common"

                                        self.flow_types_info = YLeaf(YType.uint32, "flow-types-info")

                                        self.ttl = YLeaf(YType.uint8, "ttl")

                                        self.accept_mask = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.AcceptMask()
                                        self.accept_mask.parent = self
                                        self._children_name_map["accept_mask"] = "accept-mask"
                                        self._children_yang_names.add("accept-mask")

                                        self.lpts_flags = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.LptsFlags()
                                        self.lpts_flags.parent = self
                                        self._children_name_map["lpts_flags"] = "lpts-flags"
                                        self._children_yang_names.add("lpts-flags")

                                        self.options = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Options()
                                        self.options.parent = self
                                        self._children_name_map["options"] = "options"
                                        self._children_yang_names.add("options")

                                        self.filter = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("flow_types_info",
                                                        "ttl") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb, self).__setattr__(name, value)


                                    class Options(Entity):
                                        """
                                        Receive options
                                        
                                        .. attribute:: is_ip_sla
                                        
                                        	IP SLA
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_receive_filter
                                        
                                        	Receive filter enabled
                                        	**type**\:  bool
                                        
                                        

                                        """

                                        _prefix = 'ip-tcp-oper'
                                        _revision = '2016-02-26'

                                        def __init__(self):
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Options, self).__init__()

                                            self.yang_name = "options"
                                            self.yang_parent_name = "lpts-pcb"

                                            self.is_ip_sla = YLeaf(YType.boolean, "is-ip-sla")

                                            self.is_receive_filter = YLeaf(YType.boolean, "is-receive-filter")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("is_ip_sla",
                                                            "is_receive_filter") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Options, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Options, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.is_ip_sla.is_set or
                                                self.is_receive_filter.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.is_ip_sla.yfilter != YFilter.not_set or
                                                self.is_receive_filter.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "options" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.is_ip_sla.is_set or self.is_ip_sla.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_ip_sla.get_name_leafdata())
                                            if (self.is_receive_filter.is_set or self.is_receive_filter.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_receive_filter.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "is-ip-sla" or name == "is-receive-filter"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "is-ip-sla"):
                                                self.is_ip_sla = value
                                                self.is_ip_sla.value_namespace = name_space
                                                self.is_ip_sla.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-receive-filter"):
                                                self.is_receive_filter = value
                                                self.is_receive_filter.value_namespace = name_space
                                                self.is_receive_filter.value_namespace_prefix = name_space_prefix


                                    class LptsFlags(Entity):
                                        """
                                        LPTS flags
                                        
                                        .. attribute:: is_ignore_vrf_filter
                                        
                                        	Ignore VRF Filter
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_local_address_ignore
                                        
                                        	Sent drop packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_pcb_bound
                                        
                                        	PCB bound
                                        	**type**\:  bool
                                        
                                        

                                        """

                                        _prefix = 'ip-tcp-oper'
                                        _revision = '2016-02-26'

                                        def __init__(self):
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.LptsFlags, self).__init__()

                                            self.yang_name = "lpts-flags"
                                            self.yang_parent_name = "lpts-pcb"

                                            self.is_ignore_vrf_filter = YLeaf(YType.boolean, "is-ignore-vrf-filter")

                                            self.is_local_address_ignore = YLeaf(YType.boolean, "is-local-address-ignore")

                                            self.is_pcb_bound = YLeaf(YType.boolean, "is-pcb-bound")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("is_ignore_vrf_filter",
                                                            "is_local_address_ignore",
                                                            "is_pcb_bound") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.LptsFlags, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.LptsFlags, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.is_ignore_vrf_filter.is_set or
                                                self.is_local_address_ignore.is_set or
                                                self.is_pcb_bound.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.is_ignore_vrf_filter.yfilter != YFilter.not_set or
                                                self.is_local_address_ignore.yfilter != YFilter.not_set or
                                                self.is_pcb_bound.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lpts-flags" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.is_ignore_vrf_filter.is_set or self.is_ignore_vrf_filter.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_ignore_vrf_filter.get_name_leafdata())
                                            if (self.is_local_address_ignore.is_set or self.is_local_address_ignore.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_local_address_ignore.get_name_leafdata())
                                            if (self.is_pcb_bound.is_set or self.is_pcb_bound.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_pcb_bound.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "is-ignore-vrf-filter" or name == "is-local-address-ignore" or name == "is-pcb-bound"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "is-ignore-vrf-filter"):
                                                self.is_ignore_vrf_filter = value
                                                self.is_ignore_vrf_filter.value_namespace = name_space
                                                self.is_ignore_vrf_filter.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-local-address-ignore"):
                                                self.is_local_address_ignore = value
                                                self.is_local_address_ignore.value_namespace = name_space
                                                self.is_local_address_ignore.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-pcb-bound"):
                                                self.is_pcb_bound = value
                                                self.is_pcb_bound.value_namespace = name_space
                                                self.is_pcb_bound.value_namespace_prefix = name_space_prefix


                                    class AcceptMask(Entity):
                                        """
                                        AcceptMask
                                        
                                        .. attribute:: is_interface
                                        
                                        	Set interface
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_local_address
                                        
                                        	Set Local Address
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_local_port
                                        
                                        	Set Local Port
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_packet_type
                                        
                                        	Set packet type
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_remote_address
                                        
                                        	Set Remote address
                                        	**type**\:  bool
                                        
                                        .. attribute:: is_remote_port
                                        
                                        	Set Remote Port
                                        	**type**\:  bool
                                        
                                        

                                        """

                                        _prefix = 'ip-tcp-oper'
                                        _revision = '2016-02-26'

                                        def __init__(self):
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.AcceptMask, self).__init__()

                                            self.yang_name = "accept-mask"
                                            self.yang_parent_name = "lpts-pcb"

                                            self.is_interface = YLeaf(YType.boolean, "is-interface")

                                            self.is_local_address = YLeaf(YType.boolean, "is-local-address")

                                            self.is_local_port = YLeaf(YType.boolean, "is-local-port")

                                            self.is_packet_type = YLeaf(YType.boolean, "is-packet-type")

                                            self.is_remote_address = YLeaf(YType.boolean, "is-remote-address")

                                            self.is_remote_port = YLeaf(YType.boolean, "is-remote-port")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("is_interface",
                                                            "is_local_address",
                                                            "is_local_port",
                                                            "is_packet_type",
                                                            "is_remote_address",
                                                            "is_remote_port") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.AcceptMask, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.AcceptMask, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.is_interface.is_set or
                                                self.is_local_address.is_set or
                                                self.is_local_port.is_set or
                                                self.is_packet_type.is_set or
                                                self.is_remote_address.is_set or
                                                self.is_remote_port.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.is_interface.yfilter != YFilter.not_set or
                                                self.is_local_address.yfilter != YFilter.not_set or
                                                self.is_local_port.yfilter != YFilter.not_set or
                                                self.is_packet_type.yfilter != YFilter.not_set or
                                                self.is_remote_address.yfilter != YFilter.not_set or
                                                self.is_remote_port.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "accept-mask" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.is_interface.is_set or self.is_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_interface.get_name_leafdata())
                                            if (self.is_local_address.is_set or self.is_local_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_local_address.get_name_leafdata())
                                            if (self.is_local_port.is_set or self.is_local_port.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_local_port.get_name_leafdata())
                                            if (self.is_packet_type.is_set or self.is_packet_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_packet_type.get_name_leafdata())
                                            if (self.is_remote_address.is_set or self.is_remote_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_remote_address.get_name_leafdata())
                                            if (self.is_remote_port.is_set or self.is_remote_port.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.is_remote_port.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "is-interface" or name == "is-local-address" or name == "is-local-port" or name == "is-packet-type" or name == "is-remote-address" or name == "is-remote-port"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "is-interface"):
                                                self.is_interface = value
                                                self.is_interface.value_namespace = name_space
                                                self.is_interface.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-local-address"):
                                                self.is_local_address = value
                                                self.is_local_address.value_namespace = name_space
                                                self.is_local_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-local-port"):
                                                self.is_local_port = value
                                                self.is_local_port.value_namespace = name_space
                                                self.is_local_port.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-packet-type"):
                                                self.is_packet_type = value
                                                self.is_packet_type.value_namespace = name_space
                                                self.is_packet_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-remote-address"):
                                                self.is_remote_address = value
                                                self.is_remote_address.value_namespace = name_space
                                                self.is_remote_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "is-remote-port"):
                                                self.is_remote_port = value
                                                self.is_remote_port.value_namespace = name_space
                                                self.is_remote_port.value_namespace_prefix = name_space_prefix


                                    class Filter(Entity):
                                        """
                                        Interface Filters
                                        
                                        .. attribute:: flow_types_info
                                        
                                        	flow information
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: interface_name
                                        
                                        	Interface name
                                        	**type**\:  str
                                        
                                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                        
                                        .. attribute:: local_address
                                        
                                        	Local address
                                        	**type**\:   :py:class:`LocalAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.LocalAddress>`
                                        
                                        .. attribute:: local_length
                                        
                                        	Local address length
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        .. attribute:: packet_type
                                        
                                        	Protocol\-specific packet type
                                        	**type**\:   :py:class:`PacketType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.PacketType>`
                                        
                                        .. attribute:: priority
                                        
                                        	Priority
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: receive_local_port
                                        
                                        	Receive Local port
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        .. attribute:: receive_remote_port
                                        
                                        	Receive Remote port
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        .. attribute:: remote_address
                                        
                                        	Remote address
                                        	**type**\:   :py:class:`RemoteAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.RemoteAddress>`
                                        
                                        .. attribute:: remote_length
                                        
                                        	Remote address length
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        .. attribute:: ttl
                                        
                                        	Minimum TTL
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        

                                        """

                                        _prefix = 'ip-tcp-oper'
                                        _revision = '2016-02-26'

                                        def __init__(self):
                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter, self).__init__()

                                            self.yang_name = "filter"
                                            self.yang_parent_name = "lpts-pcb"

                                            self.flow_types_info = YLeaf(YType.uint32, "flow-types-info")

                                            self.interface_name = YLeaf(YType.str, "interface-name")

                                            self.local_length = YLeaf(YType.uint16, "local-length")

                                            self.priority = YLeaf(YType.uint8, "priority")

                                            self.receive_local_port = YLeaf(YType.uint16, "receive-local-port")

                                            self.receive_remote_port = YLeaf(YType.uint16, "receive-remote-port")

                                            self.remote_length = YLeaf(YType.uint16, "remote-length")

                                            self.ttl = YLeaf(YType.uint8, "ttl")

                                            self.local_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.LocalAddress()
                                            self.local_address.parent = self
                                            self._children_name_map["local_address"] = "local-address"
                                            self._children_yang_names.add("local-address")

                                            self.packet_type = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.PacketType()
                                            self.packet_type.parent = self
                                            self._children_name_map["packet_type"] = "packet-type"
                                            self._children_yang_names.add("packet-type")

                                            self.remote_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.RemoteAddress()
                                            self.remote_address.parent = self
                                            self._children_name_map["remote_address"] = "remote-address"
                                            self._children_yang_names.add("remote-address")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("flow_types_info",
                                                            "interface_name",
                                                            "local_length",
                                                            "priority",
                                                            "receive_local_port",
                                                            "receive_remote_port",
                                                            "remote_length",
                                                            "ttl") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter, self).__setattr__(name, value)


                                        class PacketType(Entity):
                                            """
                                            Protocol\-specific packet type
                                            
                                            .. attribute:: icm_pv6_message_type
                                            
                                            	ICMPv6 message type
                                            	**type**\:   :py:class:`MessageTypeIcmpv6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.MessageTypeIcmpv6>`
                                            
                                            .. attribute:: icmp_message_type
                                            
                                            	ICMP message type
                                            	**type**\:   :py:class:`MessageTypeIcmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.MessageTypeIcmp>`
                                            
                                            .. attribute:: igmp_message_type
                                            
                                            	IGMP message type
                                            	**type**\:   :py:class:`MessageTypeIgmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.MessageTypeIgmp>`
                                            
                                            .. attribute:: message_id
                                            
                                            	Message type in number
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: type
                                            
                                            	Type
                                            	**type**\:   :py:class:`Packet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.Packet>`
                                            
                                            

                                            """

                                            _prefix = 'ip-tcp-oper'
                                            _revision = '2016-02-26'

                                            def __init__(self):
                                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.PacketType, self).__init__()

                                                self.yang_name = "packet-type"
                                                self.yang_parent_name = "filter"

                                                self.icm_pv6_message_type = YLeaf(YType.enumeration, "icm-pv6-message-type")

                                                self.icmp_message_type = YLeaf(YType.enumeration, "icmp-message-type")

                                                self.igmp_message_type = YLeaf(YType.enumeration, "igmp-message-type")

                                                self.message_id = YLeaf(YType.uint32, "message-id")

                                                self.type = YLeaf(YType.enumeration, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("icm_pv6_message_type",
                                                                "icmp_message_type",
                                                                "igmp_message_type",
                                                                "message_id",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.PacketType, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.PacketType, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.icm_pv6_message_type.is_set or
                                                    self.icmp_message_type.is_set or
                                                    self.igmp_message_type.is_set or
                                                    self.message_id.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.icm_pv6_message_type.yfilter != YFilter.not_set or
                                                    self.icmp_message_type.yfilter != YFilter.not_set or
                                                    self.igmp_message_type.yfilter != YFilter.not_set or
                                                    self.message_id.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "packet-type" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.icm_pv6_message_type.is_set or self.icm_pv6_message_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.icm_pv6_message_type.get_name_leafdata())
                                                if (self.icmp_message_type.is_set or self.icmp_message_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.icmp_message_type.get_name_leafdata())
                                                if (self.igmp_message_type.is_set or self.igmp_message_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.igmp_message_type.get_name_leafdata())
                                                if (self.message_id.is_set or self.message_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.message_id.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "icm-pv6-message-type" or name == "icmp-message-type" or name == "igmp-message-type" or name == "message-id" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "icm-pv6-message-type"):
                                                    self.icm_pv6_message_type = value
                                                    self.icm_pv6_message_type.value_namespace = name_space
                                                    self.icm_pv6_message_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "icmp-message-type"):
                                                    self.icmp_message_type = value
                                                    self.icmp_message_type.value_namespace = name_space
                                                    self.icmp_message_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "igmp-message-type"):
                                                    self.igmp_message_type = value
                                                    self.igmp_message_type.value_namespace = name_space
                                                    self.igmp_message_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "message-id"):
                                                    self.message_id = value
                                                    self.message_id.value_namespace = name_space
                                                    self.message_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix


                                        class RemoteAddress(Entity):
                                            """
                                            Remote address
                                            
                                            .. attribute:: af_name
                                            
                                            	AFName
                                            	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                                            
                                            .. attribute:: ipv4_address
                                            
                                            	IPv4 address
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: ipv6_address
                                            
                                            	IPv6 address
                                            	**type**\:  str
                                            
                                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                            
                                            

                                            """

                                            _prefix = 'ip-tcp-oper'
                                            _revision = '2016-02-26'

                                            def __init__(self):
                                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.RemoteAddress, self).__init__()

                                                self.yang_name = "remote-address"
                                                self.yang_parent_name = "filter"

                                                self.af_name = YLeaf(YType.enumeration, "af-name")

                                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                                self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("af_name",
                                                                "ipv4_address",
                                                                "ipv6_address") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.RemoteAddress, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.RemoteAddress, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.af_name.is_set or
                                                    self.ipv4_address.is_set or
                                                    self.ipv6_address.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.af_name.yfilter != YFilter.not_set or
                                                    self.ipv4_address.yfilter != YFilter.not_set or
                                                    self.ipv6_address.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "remote-address" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.af_name.get_name_leafdata())
                                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                                if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "af-name"):
                                                    self.af_name = value
                                                    self.af_name.value_namespace = name_space
                                                    self.af_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "ipv4-address"):
                                                    self.ipv4_address = value
                                                    self.ipv4_address.value_namespace = name_space
                                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "ipv6-address"):
                                                    self.ipv6_address = value
                                                    self.ipv6_address.value_namespace = name_space
                                                    self.ipv6_address.value_namespace_prefix = name_space_prefix


                                        class LocalAddress(Entity):
                                            """
                                            Local address
                                            
                                            .. attribute:: af_name
                                            
                                            	AFName
                                            	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                                            
                                            .. attribute:: ipv4_address
                                            
                                            	IPv4 address
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: ipv6_address
                                            
                                            	IPv6 address
                                            	**type**\:  str
                                            
                                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                            
                                            

                                            """

                                            _prefix = 'ip-tcp-oper'
                                            _revision = '2016-02-26'

                                            def __init__(self):
                                                super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.LocalAddress, self).__init__()

                                                self.yang_name = "local-address"
                                                self.yang_parent_name = "filter"

                                                self.af_name = YLeaf(YType.enumeration, "af-name")

                                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                                self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("af_name",
                                                                "ipv4_address",
                                                                "ipv6_address") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.LocalAddress, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.LocalAddress, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.af_name.is_set or
                                                    self.ipv4_address.is_set or
                                                    self.ipv6_address.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.af_name.yfilter != YFilter.not_set or
                                                    self.ipv4_address.yfilter != YFilter.not_set or
                                                    self.ipv6_address.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "local-address" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.af_name.get_name_leafdata())
                                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                                if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "af-name"):
                                                    self.af_name = value
                                                    self.af_name.value_namespace = name_space
                                                    self.af_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "ipv4-address"):
                                                    self.ipv4_address = value
                                                    self.ipv4_address.value_namespace = name_space
                                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "ipv6-address"):
                                                    self.ipv6_address = value
                                                    self.ipv6_address.value_namespace = name_space
                                                    self.ipv6_address.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.flow_types_info.is_set or
                                                self.interface_name.is_set or
                                                self.local_length.is_set or
                                                self.priority.is_set or
                                                self.receive_local_port.is_set or
                                                self.receive_remote_port.is_set or
                                                self.remote_length.is_set or
                                                self.ttl.is_set or
                                                (self.local_address is not None and self.local_address.has_data()) or
                                                (self.packet_type is not None and self.packet_type.has_data()) or
                                                (self.remote_address is not None and self.remote_address.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.flow_types_info.yfilter != YFilter.not_set or
                                                self.interface_name.yfilter != YFilter.not_set or
                                                self.local_length.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set or
                                                self.receive_local_port.yfilter != YFilter.not_set or
                                                self.receive_remote_port.yfilter != YFilter.not_set or
                                                self.remote_length.yfilter != YFilter.not_set or
                                                self.ttl.yfilter != YFilter.not_set or
                                                (self.local_address is not None and self.local_address.has_operation()) or
                                                (self.packet_type is not None and self.packet_type.has_operation()) or
                                                (self.remote_address is not None and self.remote_address.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "filter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.flow_types_info.is_set or self.flow_types_info.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.flow_types_info.get_name_leafdata())
                                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                                            if (self.local_length.is_set or self.local_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.local_length.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())
                                            if (self.receive_local_port.is_set or self.receive_local_port.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.receive_local_port.get_name_leafdata())
                                            if (self.receive_remote_port.is_set or self.receive_remote_port.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.receive_remote_port.get_name_leafdata())
                                            if (self.remote_length.is_set or self.remote_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.remote_length.get_name_leafdata())
                                            if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.ttl.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "local-address"):
                                                if (self.local_address is None):
                                                    self.local_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.LocalAddress()
                                                    self.local_address.parent = self
                                                    self._children_name_map["local_address"] = "local-address"
                                                return self.local_address

                                            if (child_yang_name == "packet-type"):
                                                if (self.packet_type is None):
                                                    self.packet_type = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.PacketType()
                                                    self.packet_type.parent = self
                                                    self._children_name_map["packet_type"] = "packet-type"
                                                return self.packet_type

                                            if (child_yang_name == "remote-address"):
                                                if (self.remote_address is None):
                                                    self.remote_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter.RemoteAddress()
                                                    self.remote_address.parent = self
                                                    self._children_name_map["remote_address"] = "remote-address"
                                                return self.remote_address

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "local-address" or name == "packet-type" or name == "remote-address" or name == "flow-types-info" or name == "interface-name" or name == "local-length" or name == "priority" or name == "receive-local-port" or name == "receive-remote-port" or name == "remote-length" or name == "ttl"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "flow-types-info"):
                                                self.flow_types_info = value
                                                self.flow_types_info.value_namespace = name_space
                                                self.flow_types_info.value_namespace_prefix = name_space_prefix
                                            if(value_path == "interface-name"):
                                                self.interface_name = value
                                                self.interface_name.value_namespace = name_space
                                                self.interface_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "local-length"):
                                                self.local_length = value
                                                self.local_length.value_namespace = name_space
                                                self.local_length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "receive-local-port"):
                                                self.receive_local_port = value
                                                self.receive_local_port.value_namespace = name_space
                                                self.receive_local_port.value_namespace_prefix = name_space_prefix
                                            if(value_path == "receive-remote-port"):
                                                self.receive_remote_port = value
                                                self.receive_remote_port.value_namespace = name_space
                                                self.receive_remote_port.value_namespace_prefix = name_space_prefix
                                            if(value_path == "remote-length"):
                                                self.remote_length = value
                                                self.remote_length.value_namespace = name_space
                                                self.remote_length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "ttl"):
                                                self.ttl = value
                                                self.ttl.value_namespace = name_space
                                                self.ttl.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.filter:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.flow_types_info.is_set or
                                            self.ttl.is_set or
                                            (self.accept_mask is not None and self.accept_mask.has_data()) or
                                            (self.lpts_flags is not None and self.lpts_flags.has_data()) or
                                            (self.options is not None and self.options.has_data()))

                                    def has_operation(self):
                                        for c in self.filter:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.flow_types_info.yfilter != YFilter.not_set or
                                            self.ttl.yfilter != YFilter.not_set or
                                            (self.accept_mask is not None and self.accept_mask.has_operation()) or
                                            (self.lpts_flags is not None and self.lpts_flags.has_operation()) or
                                            (self.options is not None and self.options.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lpts-pcb" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.flow_types_info.is_set or self.flow_types_info.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.flow_types_info.get_name_leafdata())
                                        if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ttl.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "accept-mask"):
                                            if (self.accept_mask is None):
                                                self.accept_mask = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.AcceptMask()
                                                self.accept_mask.parent = self
                                                self._children_name_map["accept_mask"] = "accept-mask"
                                            return self.accept_mask

                                        if (child_yang_name == "filter"):
                                            for c in self.filter:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Filter()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.filter.append(c)
                                            return c

                                        if (child_yang_name == "lpts-flags"):
                                            if (self.lpts_flags is None):
                                                self.lpts_flags = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.LptsFlags()
                                                self.lpts_flags.parent = self
                                                self._children_name_map["lpts_flags"] = "lpts-flags"
                                            return self.lpts_flags

                                        if (child_yang_name == "options"):
                                            if (self.options is None):
                                                self.options = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb.Options()
                                                self.options.parent = self
                                                self._children_name_map["options"] = "options"
                                            return self.options

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "accept-mask" or name == "filter" or name == "lpts-flags" or name == "options" or name == "flow-types-info" or name == "ttl"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "flow-types-info"):
                                            self.flow_types_info = value
                                            self.flow_types_info.value_namespace = name_space
                                            self.flow_types_info.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ttl"):
                                            self.ttl = value
                                            self.ttl.value_namespace = name_space
                                            self.ttl.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.af_name.is_set or
                                        (self.lpts_pcb is not None and self.lpts_pcb.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.af_name.yfilter != YFilter.not_set or
                                        (self.lpts_pcb is not None and self.lpts_pcb.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "common" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.af_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "lpts-pcb"):
                                        if (self.lpts_pcb is None):
                                            self.lpts_pcb = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common.LptsPcb()
                                            self.lpts_pcb.parent = self
                                            self._children_name_map["lpts_pcb"] = "lpts-pcb"
                                        return self.lpts_pcb

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "lpts-pcb" or name == "af-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "af-name"):
                                        self.af_name = value
                                        self.af_name.value_namespace = name_space
                                        self.af_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.pcb_id.is_set or
                                    self.foreign_port.is_set or
                                    self.l4_protocol.is_set or
                                    self.local_port.is_set or
                                    (self.common is not None and self.common.has_data()) or
                                    (self.foreign_address is not None and self.foreign_address.has_data()) or
                                    (self.local_address is not None and self.local_address.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.pcb_id.yfilter != YFilter.not_set or
                                    self.foreign_port.yfilter != YFilter.not_set or
                                    self.l4_protocol.yfilter != YFilter.not_set or
                                    self.local_port.yfilter != YFilter.not_set or
                                    (self.common is not None and self.common.has_operation()) or
                                    (self.foreign_address is not None and self.foreign_address.has_operation()) or
                                    (self.local_address is not None and self.local_address.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "connection-id" + "[pcb-id='" + self.pcb_id.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.pcb_id.is_set or self.pcb_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.pcb_id.get_name_leafdata())
                                if (self.foreign_port.is_set or self.foreign_port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.foreign_port.get_name_leafdata())
                                if (self.l4_protocol.is_set or self.l4_protocol.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.l4_protocol.get_name_leafdata())
                                if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_port.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "common"):
                                    if (self.common is None):
                                        self.common = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.Common()
                                        self.common.parent = self
                                        self._children_name_map["common"] = "common"
                                    return self.common

                                if (child_yang_name == "foreign-address"):
                                    if (self.foreign_address is None):
                                        self.foreign_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.ForeignAddress()
                                        self.foreign_address.parent = self
                                        self._children_name_map["foreign_address"] = "foreign-address"
                                    return self.foreign_address

                                if (child_yang_name == "local-address"):
                                    if (self.local_address is None):
                                        self.local_address = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId.LocalAddress()
                                        self.local_address.parent = self
                                        self._children_name_map["local_address"] = "local-address"
                                    return self.local_address

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "common" or name == "foreign-address" or name == "local-address" or name == "pcb-id" or name == "foreign-port" or name == "l4-protocol" or name == "local-port"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "pcb-id"):
                                    self.pcb_id = value
                                    self.pcb_id.value_namespace = name_space
                                    self.pcb_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "foreign-port"):
                                    self.foreign_port = value
                                    self.foreign_port.value_namespace = name_space
                                    self.foreign_port.value_namespace_prefix = name_space_prefix
                                if(value_path == "l4-protocol"):
                                    self.l4_protocol = value
                                    self.l4_protocol.value_namespace = name_space
                                    self.l4_protocol.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-port"):
                                    self.local_port = value
                                    self.local_port.value_namespace = name_space
                                    self.local_port.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.connection_id:
                                if (c.has_data()):
                                    return True
                            return self.disp_type.is_set

                        def has_operation(self):
                            for c in self.connection_id:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.disp_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "display-type" + "[disp-type='" + self.disp_type.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.disp_type.is_set or self.disp_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.disp_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "connection-id"):
                                for c in self.connection_id:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType.ConnectionId()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.connection_id.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "connection-id" or name == "disp-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "disp-type"):
                                self.disp_type = value
                                self.disp_type.value_namespace = name_space
                                self.disp_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.display_type:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.display_type:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "display-types" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "display-type"):
                            for c in self.display_type:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes.DisplayType()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.display_type.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "display-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (self.display_types is not None and self.display_types.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.display_types is not None and self.display_types.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "extended-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "display-types"):
                        if (self.display_types is None):
                            self.display_types = TcpConnection.Nodes.Node.ExtendedInformation.DisplayTypes()
                            self.display_types.parent = self
                            self._children_name_map["display_types"] = "display-types"
                        return self.display_types

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "display-types"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class DetailInformations(Entity):
                """
                Table listing TCP connections for which
                detailed information is provided
                
                .. attribute:: detail_information
                
                	Protocol Control Block ID
                	**type**\: list of    :py:class:`DetailInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpConnection.Nodes.Node.DetailInformations, self).__init__()

                    self.yang_name = "detail-informations"
                    self.yang_parent_name = "node"

                    self.detail_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(TcpConnection.Nodes.Node.DetailInformations, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(TcpConnection.Nodes.Node.DetailInformations, self).__setattr__(name, value)


                class DetailInformation(Entity):
                    """
                    Protocol Control Block ID
                    
                    .. attribute:: pcb_id  <key>
                    
                    	Detail information about TCP connection, put null for all
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ack_hold_time
                    
                    	ACK hold time (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: address_family
                    
                    	Address Family
                    	**type**\:   :py:class:`TcpAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpAddressFamily>`
                    
                    .. attribute:: auto_rearm
                    
                    	Socket auto rearm state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: connect_retries
                    
                    	Number of times connect will be retried?
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: connect_retry_interval
                    
                    	Connect retry interval in seconds
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: second
                    
                    .. attribute:: connection_state
                    
                    	Connection state
                    	**type**\:   :py:class:`TcpConnState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnState>`
                    
                    .. attribute:: current_receive_queue_packet_size
                    
                    	Current receive queue size in packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: current_receive_queue_size
                    
                    	Current receive queue size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: current_send_queue_size
                    
                    	Current send queue size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: established_time
                    
                    	Time at which connection is established
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: feature_flags
                    
                    	Connection feature flags
                    	**type**\:   :py:class:`FeatureFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.FeatureFlags>`
                    
                    .. attribute:: fib_label_output
                    
                    	Cached Label stack
                    	**type**\:  list of int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: fib_pd_ctx
                    
                    	Cached fib pd context
                    	**type**\:  list of int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: fib_pd_ctx_size
                    
                    	Cached fib pd context size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: foreign_address
                    
                    	Foreign address
                    	**type**\:   :py:class:`ForeignAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ForeignAddress>`
                    
                    .. attribute:: foreign_port
                    
                    	Foreign port
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: giveup_time
                    
                    	Giveup time (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: hash_index
                    
                    	Index of the Hash Bucket
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: is_retrans_forever
                    
                    	Retransimit forever?
                    	**type**\:  bool
                    
                    .. attribute:: keep_alive_time
                    
                    	Keepalive time (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: krtt
                    
                    	Round trip time (karn algorithm) (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: last_ack_sent
                    
                    	ACK number of a sent segment
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: local_address
                    
                    	Local address
                    	**type**\:   :py:class:`LocalAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.LocalAddress>`
                    
                    .. attribute:: local_app_instance
                    
                    	Instance number of the local process
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: local_pid
                    
                    	Id of the local process
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: local_port
                    
                    	Local port
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: max_mss
                    
                    	Highest MSS ever used
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: max_receive_queue_packet_size
                    
                    	Max receive queue size in packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: max_receive_queue_size
                    
                    	Max receive queue size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: max_rtt
                    
                    	Max RTT (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: max_send_queue_size
                    
                    	Max send queue size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: min_mss
                    
                    	Lowest MSS ever used
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: min_rtt
                    
                    	Min RTT (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: mss
                    
                    	Max segment size calculated in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: num_labels
                    
                    	Number of labels returned by fib lookup
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_ifhandle
                    
                    	Cached Outgoing interface  handle
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: packet_priority
                    
                    	Priority given to packets on this socket
                    	**type**\:   :py:class:`PakPrio <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.PakPrio>`
                    
                    .. attribute:: packet_tos
                    
                    	Type of Service value to be applied to transmistted packets
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: packet_ttl
                    
                    	TTL to be applied to transmited packets
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: pcb
                    
                    	PCB Address
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: peer_mss
                    
                    	Max segment size offered by the peer in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: queue_length
                    
                    	Incoming connection queue size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: queue_limit
                    
                    	Incoming connection queue limit
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: queue_zero_length
                    
                    	Incoming half\-connection queue size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: receive_adv_window_size
                    
                    	Receive advertised window size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: receive_buf_state_flags
                    
                    	Receive buffer state flags
                    	**type**\:   :py:class:`ReceiveBufStateFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ReceiveBufStateFlags>`
                    
                    .. attribute:: receive_initial_sequence_num
                    
                    	Initial receive sequence number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: receive_next_sequence_num
                    
                    	Next sequence number expected
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: receive_window_scale
                    
                    	Window scaling for receive window
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: receive_window_size
                    
                    	Receive window size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: recvbuf_datasize
                    
                    	Receive buffer's data size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: recvbuf_hiwat
                    
                    	Receive buffer's high water mark
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: recvbuf_lowwat
                    
                    	Receive buffer's low water mark
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: request_flags
                    
                    	Connection request flags
                    	**type**\:   :py:class:`RequestFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.RequestFlags>`
                    
                    .. attribute:: request_receive_window_scale
                    
                    	Requested receive window scale
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: retries
                    
                    	Number of retries
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rqst_send_wnd_scale
                    
                    	Requested send window scale
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rtto
                    
                    	Round trip timeout (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rxsy_naclname
                    
                    	RX Syn acl name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: sack_blk
                    
                    	Seq nos. of sack blocks
                    	**type**\: list of    :py:class:`SackBlk <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SackBlk>`
                    
                    .. attribute:: save_queue_size
                    
                    	Save queue (out\-of seq data) size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: send_buf_state_flags
                    
                    	Send buffer state flags
                    	**type**\:   :py:class:`SendBufStateFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendBufStateFlags>`
                    
                    .. attribute:: send_congestion_window_size
                    
                    	Send congestion window size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: send_initial_sequence_num
                    
                    	Initial send sequence number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_max_sequence_num
                    
                    	Highest sequence number sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_next_sequence_num
                    
                    	Sequence number of next data to be sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_pdu_count
                    
                    	# of PDU's in Send Buffer
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_sack_hole
                    
                    	Sorted list of sack holes
                    	**type**\: list of    :py:class:`SendSackHole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendSackHole>`
                    
                    .. attribute:: send_unack_sequence_num
                    
                    	Sequence number of unacked data
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_window_scale
                    
                    	Window scaling for send window
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: send_window_size
                    
                    	Send window size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: sendbuf_hiwat
                    
                    	Send buffer's high water mark
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: sendbuf_lowwat
                    
                    	Send buffer's low water mark
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: sendbuf_notify_thresh
                    
                    	Send buffer's notify threshold
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: so
                    
                    	Socket Address
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: sock_error
                    
                    	Socket error code
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: socket_error
                    
                    	Socket error status
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: socket_option_flags
                    
                    	Socket option flags
                    	**type**\:   :py:class:`SocketOptionFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketOptionFlags>`
                    
                    .. attribute:: socket_state_flags
                    
                    	Socket state flags
                    	**type**\:   :py:class:`SocketStateFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketStateFlags>`
                    
                    .. attribute:: soft_error
                    
                    	Error code from ICMP Notify
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: srtt
                    
                    	Smoothed round trip time \* 8 (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: srtv
                    
                    	Smoothed round trip time variance \* 4 (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: state_flags
                    
                    	Connection state flags
                    	**type**\:   :py:class:`StateFlags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.StateFlags>`
                    
                    .. attribute:: syn_wait_time
                    
                    	SYN wait time (msec)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcpcb
                    
                    	TCPCB Address
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: time_stamp_recent
                    
                    	Timestamp from remote host
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: time_stamp_recent_age
                    
                    	Timestamp when last updated
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: timer
                    
                    	Timers
                    	**type**\: list of    :py:class:`Timer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.DetailInformations.DetailInformation.Timer>`
                    
                    .. attribute:: vrf_id
                    
                    	VRF Id
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation, self).__init__()

                        self.yang_name = "detail-information"
                        self.yang_parent_name = "detail-informations"

                        self.pcb_id = YLeaf(YType.uint32, "pcb-id")

                        self.ack_hold_time = YLeaf(YType.uint32, "ack-hold-time")

                        self.address_family = YLeaf(YType.enumeration, "address-family")

                        self.auto_rearm = YLeaf(YType.uint32, "auto-rearm")

                        self.connect_retries = YLeaf(YType.uint16, "connect-retries")

                        self.connect_retry_interval = YLeaf(YType.uint16, "connect-retry-interval")

                        self.connection_state = YLeaf(YType.enumeration, "connection-state")

                        self.current_receive_queue_packet_size = YLeaf(YType.uint32, "current-receive-queue-packet-size")

                        self.current_receive_queue_size = YLeaf(YType.uint32, "current-receive-queue-size")

                        self.current_send_queue_size = YLeaf(YType.uint32, "current-send-queue-size")

                        self.established_time = YLeaf(YType.uint32, "established-time")

                        self.fib_label_output = YLeafList(YType.uint32, "fib-label-output")

                        self.fib_pd_ctx = YLeafList(YType.uint32, "fib-pd-ctx")

                        self.fib_pd_ctx_size = YLeaf(YType.uint32, "fib-pd-ctx-size")

                        self.foreign_port = YLeaf(YType.uint16, "foreign-port")

                        self.giveup_time = YLeaf(YType.uint32, "giveup-time")

                        self.hash_index = YLeaf(YType.uint32, "hash-index")

                        self.is_retrans_forever = YLeaf(YType.boolean, "is-retrans-forever")

                        self.keep_alive_time = YLeaf(YType.uint32, "keep-alive-time")

                        self.krtt = YLeaf(YType.uint32, "krtt")

                        self.last_ack_sent = YLeaf(YType.uint32, "last-ack-sent")

                        self.local_app_instance = YLeaf(YType.uint32, "local-app-instance")

                        self.local_pid = YLeaf(YType.uint32, "local-pid")

                        self.local_port = YLeaf(YType.uint16, "local-port")

                        self.max_mss = YLeaf(YType.uint32, "max-mss")

                        self.max_receive_queue_packet_size = YLeaf(YType.uint32, "max-receive-queue-packet-size")

                        self.max_receive_queue_size = YLeaf(YType.uint32, "max-receive-queue-size")

                        self.max_rtt = YLeaf(YType.uint32, "max-rtt")

                        self.max_send_queue_size = YLeaf(YType.uint32, "max-send-queue-size")

                        self.min_mss = YLeaf(YType.uint32, "min-mss")

                        self.min_rtt = YLeaf(YType.uint32, "min-rtt")

                        self.mss = YLeaf(YType.uint32, "mss")

                        self.num_labels = YLeaf(YType.uint32, "num-labels")

                        self.output_ifhandle = YLeaf(YType.uint32, "output-ifhandle")

                        self.packet_priority = YLeaf(YType.enumeration, "packet-priority")

                        self.packet_tos = YLeaf(YType.uint16, "packet-tos")

                        self.packet_ttl = YLeaf(YType.uint16, "packet-ttl")

                        self.pcb = YLeaf(YType.uint64, "pcb")

                        self.peer_mss = YLeaf(YType.uint32, "peer-mss")

                        self.queue_length = YLeaf(YType.uint32, "queue-length")

                        self.queue_limit = YLeaf(YType.uint32, "queue-limit")

                        self.queue_zero_length = YLeaf(YType.uint32, "queue-zero-length")

                        self.receive_adv_window_size = YLeaf(YType.uint32, "receive-adv-window-size")

                        self.receive_initial_sequence_num = YLeaf(YType.uint32, "receive-initial-sequence-num")

                        self.receive_next_sequence_num = YLeaf(YType.uint32, "receive-next-sequence-num")

                        self.receive_window_scale = YLeaf(YType.uint32, "receive-window-scale")

                        self.receive_window_size = YLeaf(YType.uint32, "receive-window-size")

                        self.recvbuf_datasize = YLeaf(YType.uint32, "recvbuf-datasize")

                        self.recvbuf_hiwat = YLeaf(YType.uint32, "recvbuf-hiwat")

                        self.recvbuf_lowwat = YLeaf(YType.uint32, "recvbuf-lowwat")

                        self.request_receive_window_scale = YLeaf(YType.uint32, "request-receive-window-scale")

                        self.retries = YLeaf(YType.uint32, "retries")

                        self.rqst_send_wnd_scale = YLeaf(YType.uint32, "rqst-send-wnd-scale")

                        self.rtto = YLeaf(YType.uint32, "rtto")

                        self.rxsy_naclname = YLeaf(YType.str, "rxsy-naclname")

                        self.save_queue_size = YLeaf(YType.uint32, "save-queue-size")

                        self.send_congestion_window_size = YLeaf(YType.uint32, "send-congestion-window-size")

                        self.send_initial_sequence_num = YLeaf(YType.uint32, "send-initial-sequence-num")

                        self.send_max_sequence_num = YLeaf(YType.uint32, "send-max-sequence-num")

                        self.send_next_sequence_num = YLeaf(YType.uint32, "send-next-sequence-num")

                        self.send_pdu_count = YLeaf(YType.uint32, "send-pdu-count")

                        self.send_unack_sequence_num = YLeaf(YType.uint32, "send-unack-sequence-num")

                        self.send_window_scale = YLeaf(YType.uint32, "send-window-scale")

                        self.send_window_size = YLeaf(YType.uint32, "send-window-size")

                        self.sendbuf_hiwat = YLeaf(YType.uint32, "sendbuf-hiwat")

                        self.sendbuf_lowwat = YLeaf(YType.uint32, "sendbuf-lowwat")

                        self.sendbuf_notify_thresh = YLeaf(YType.uint32, "sendbuf-notify-thresh")

                        self.so = YLeaf(YType.uint64, "so")

                        self.sock_error = YLeaf(YType.int32, "sock-error")

                        self.socket_error = YLeaf(YType.uint32, "socket-error")

                        self.soft_error = YLeaf(YType.int32, "soft-error")

                        self.srtt = YLeaf(YType.uint32, "srtt")

                        self.srtv = YLeaf(YType.uint32, "srtv")

                        self.syn_wait_time = YLeaf(YType.uint32, "syn-wait-time")

                        self.tcpcb = YLeaf(YType.uint64, "tcpcb")

                        self.time_stamp_recent = YLeaf(YType.uint32, "time-stamp-recent")

                        self.time_stamp_recent_age = YLeaf(YType.uint32, "time-stamp-recent-age")

                        self.vrf_id = YLeaf(YType.uint32, "vrf-id")

                        self.feature_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.FeatureFlags()
                        self.feature_flags.parent = self
                        self._children_name_map["feature_flags"] = "feature-flags"
                        self._children_yang_names.add("feature-flags")

                        self.foreign_address = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ForeignAddress()
                        self.foreign_address.parent = self
                        self._children_name_map["foreign_address"] = "foreign-address"
                        self._children_yang_names.add("foreign-address")

                        self.local_address = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.LocalAddress()
                        self.local_address.parent = self
                        self._children_name_map["local_address"] = "local-address"
                        self._children_yang_names.add("local-address")

                        self.receive_buf_state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ReceiveBufStateFlags()
                        self.receive_buf_state_flags.parent = self
                        self._children_name_map["receive_buf_state_flags"] = "receive-buf-state-flags"
                        self._children_yang_names.add("receive-buf-state-flags")

                        self.request_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.RequestFlags()
                        self.request_flags.parent = self
                        self._children_name_map["request_flags"] = "request-flags"
                        self._children_yang_names.add("request-flags")

                        self.send_buf_state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendBufStateFlags()
                        self.send_buf_state_flags.parent = self
                        self._children_name_map["send_buf_state_flags"] = "send-buf-state-flags"
                        self._children_yang_names.add("send-buf-state-flags")

                        self.socket_option_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketOptionFlags()
                        self.socket_option_flags.parent = self
                        self._children_name_map["socket_option_flags"] = "socket-option-flags"
                        self._children_yang_names.add("socket-option-flags")

                        self.socket_state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketStateFlags()
                        self.socket_state_flags.parent = self
                        self._children_name_map["socket_state_flags"] = "socket-state-flags"
                        self._children_yang_names.add("socket-state-flags")

                        self.state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.StateFlags()
                        self.state_flags.parent = self
                        self._children_name_map["state_flags"] = "state-flags"
                        self._children_yang_names.add("state-flags")

                        self.sack_blk = YList(self)
                        self.send_sack_hole = YList(self)
                        self.timer = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pcb_id",
                                        "ack_hold_time",
                                        "address_family",
                                        "auto_rearm",
                                        "connect_retries",
                                        "connect_retry_interval",
                                        "connection_state",
                                        "current_receive_queue_packet_size",
                                        "current_receive_queue_size",
                                        "current_send_queue_size",
                                        "established_time",
                                        "fib_label_output",
                                        "fib_pd_ctx",
                                        "fib_pd_ctx_size",
                                        "foreign_port",
                                        "giveup_time",
                                        "hash_index",
                                        "is_retrans_forever",
                                        "keep_alive_time",
                                        "krtt",
                                        "last_ack_sent",
                                        "local_app_instance",
                                        "local_pid",
                                        "local_port",
                                        "max_mss",
                                        "max_receive_queue_packet_size",
                                        "max_receive_queue_size",
                                        "max_rtt",
                                        "max_send_queue_size",
                                        "min_mss",
                                        "min_rtt",
                                        "mss",
                                        "num_labels",
                                        "output_ifhandle",
                                        "packet_priority",
                                        "packet_tos",
                                        "packet_ttl",
                                        "pcb",
                                        "peer_mss",
                                        "queue_length",
                                        "queue_limit",
                                        "queue_zero_length",
                                        "receive_adv_window_size",
                                        "receive_initial_sequence_num",
                                        "receive_next_sequence_num",
                                        "receive_window_scale",
                                        "receive_window_size",
                                        "recvbuf_datasize",
                                        "recvbuf_hiwat",
                                        "recvbuf_lowwat",
                                        "request_receive_window_scale",
                                        "retries",
                                        "rqst_send_wnd_scale",
                                        "rtto",
                                        "rxsy_naclname",
                                        "save_queue_size",
                                        "send_congestion_window_size",
                                        "send_initial_sequence_num",
                                        "send_max_sequence_num",
                                        "send_next_sequence_num",
                                        "send_pdu_count",
                                        "send_unack_sequence_num",
                                        "send_window_scale",
                                        "send_window_size",
                                        "sendbuf_hiwat",
                                        "sendbuf_lowwat",
                                        "sendbuf_notify_thresh",
                                        "so",
                                        "sock_error",
                                        "socket_error",
                                        "soft_error",
                                        "srtt",
                                        "srtv",
                                        "syn_wait_time",
                                        "tcpcb",
                                        "time_stamp_recent",
                                        "time_stamp_recent_age",
                                        "vrf_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation, self).__setattr__(name, value)


                    class LocalAddress(Entity):
                        """
                        Local address
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`TcpAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpAddressFamily>`
                        
                        .. attribute:: ipv4_address
                        
                        	IPv4 Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6_address
                        
                        	IPv6 Address
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.LocalAddress, self).__init__()

                            self.yang_name = "local-address"
                            self.yang_parent_name = "detail-information"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                            self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4_address",
                                            "ipv6_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.LocalAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.LocalAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4_address.is_set or
                                self.ipv6_address.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4_address.yfilter != YFilter.not_set or
                                self.ipv6_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "local-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                            if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4-address"):
                                self.ipv4_address = value
                                self.ipv4_address.value_namespace = name_space
                                self.ipv4_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6-address"):
                                self.ipv6_address = value
                                self.ipv6_address.value_namespace = name_space
                                self.ipv6_address.value_namespace_prefix = name_space_prefix


                    class ForeignAddress(Entity):
                        """
                        Foreign address
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`TcpAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpAddressFamily>`
                        
                        .. attribute:: ipv4_address
                        
                        	IPv4 Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6_address
                        
                        	IPv6 Address
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ForeignAddress, self).__init__()

                            self.yang_name = "foreign-address"
                            self.yang_parent_name = "detail-information"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                            self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4_address",
                                            "ipv6_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ForeignAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ForeignAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4_address.is_set or
                                self.ipv6_address.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4_address.yfilter != YFilter.not_set or
                                self.ipv6_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "foreign-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                            if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4-address"):
                                self.ipv4_address = value
                                self.ipv4_address.value_namespace = name_space
                                self.ipv4_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6-address"):
                                self.ipv6_address = value
                                self.ipv6_address.value_namespace = name_space
                                self.ipv6_address.value_namespace_prefix = name_space_prefix


                    class SocketOptionFlags(Entity):
                        """
                        Socket option flags
                        
                        .. attribute:: accept_connection
                        
                        	Socket has had listen()
                        	**type**\:  bool
                        
                        .. attribute:: broadcast
                        
                        	Permit sending of broadcast msgs
                        	**type**\:  bool
                        
                        .. attribute:: debug
                        
                        	Turn on debugging info recording
                        	**type**\:  bool
                        
                        .. attribute:: dont_route
                        
                        	Just use interface addresses
                        	**type**\:  bool
                        
                        .. attribute:: keep_alive
                        
                        	Keep connections alive
                        	**type**\:  bool
                        
                        .. attribute:: linger
                        
                        	Linger on close if data present
                        	**type**\:  bool
                        
                        .. attribute:: nonblocking_io
                        
                        	Nonblocking socket I/O operation
                        	**type**\:  bool
                        
                        .. attribute:: out_of_band_inline
                        
                        	Leave received Out\-of\-band data inline
                        	**type**\:  bool
                        
                        .. attribute:: reuse_address
                        
                        	Allow local address reuse
                        	**type**\:  bool
                        
                        .. attribute:: reuse_port
                        
                        	Allow local address & port reuse
                        	**type**\:  bool
                        
                        .. attribute:: use_loopback
                        
                        	Bypass hardware when possible
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketOptionFlags, self).__init__()

                            self.yang_name = "socket-option-flags"
                            self.yang_parent_name = "detail-information"

                            self.accept_connection = YLeaf(YType.boolean, "accept-connection")

                            self.broadcast = YLeaf(YType.boolean, "broadcast")

                            self.debug = YLeaf(YType.boolean, "debug")

                            self.dont_route = YLeaf(YType.boolean, "dont-route")

                            self.keep_alive = YLeaf(YType.boolean, "keep-alive")

                            self.linger = YLeaf(YType.boolean, "linger")

                            self.nonblocking_io = YLeaf(YType.boolean, "nonblocking-io")

                            self.out_of_band_inline = YLeaf(YType.boolean, "out-of-band-inline")

                            self.reuse_address = YLeaf(YType.boolean, "reuse-address")

                            self.reuse_port = YLeaf(YType.boolean, "reuse-port")

                            self.use_loopback = YLeaf(YType.boolean, "use-loopback")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("accept_connection",
                                            "broadcast",
                                            "debug",
                                            "dont_route",
                                            "keep_alive",
                                            "linger",
                                            "nonblocking_io",
                                            "out_of_band_inline",
                                            "reuse_address",
                                            "reuse_port",
                                            "use_loopback") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketOptionFlags, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketOptionFlags, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.accept_connection.is_set or
                                self.broadcast.is_set or
                                self.debug.is_set or
                                self.dont_route.is_set or
                                self.keep_alive.is_set or
                                self.linger.is_set or
                                self.nonblocking_io.is_set or
                                self.out_of_band_inline.is_set or
                                self.reuse_address.is_set or
                                self.reuse_port.is_set or
                                self.use_loopback.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.accept_connection.yfilter != YFilter.not_set or
                                self.broadcast.yfilter != YFilter.not_set or
                                self.debug.yfilter != YFilter.not_set or
                                self.dont_route.yfilter != YFilter.not_set or
                                self.keep_alive.yfilter != YFilter.not_set or
                                self.linger.yfilter != YFilter.not_set or
                                self.nonblocking_io.yfilter != YFilter.not_set or
                                self.out_of_band_inline.yfilter != YFilter.not_set or
                                self.reuse_address.yfilter != YFilter.not_set or
                                self.reuse_port.yfilter != YFilter.not_set or
                                self.use_loopback.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "socket-option-flags" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.accept_connection.is_set or self.accept_connection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.accept_connection.get_name_leafdata())
                            if (self.broadcast.is_set or self.broadcast.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.broadcast.get_name_leafdata())
                            if (self.debug.is_set or self.debug.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.debug.get_name_leafdata())
                            if (self.dont_route.is_set or self.dont_route.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dont_route.get_name_leafdata())
                            if (self.keep_alive.is_set or self.keep_alive.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.keep_alive.get_name_leafdata())
                            if (self.linger.is_set or self.linger.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.linger.get_name_leafdata())
                            if (self.nonblocking_io.is_set or self.nonblocking_io.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nonblocking_io.get_name_leafdata())
                            if (self.out_of_band_inline.is_set or self.out_of_band_inline.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_of_band_inline.get_name_leafdata())
                            if (self.reuse_address.is_set or self.reuse_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reuse_address.get_name_leafdata())
                            if (self.reuse_port.is_set or self.reuse_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reuse_port.get_name_leafdata())
                            if (self.use_loopback.is_set or self.use_loopback.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.use_loopback.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "accept-connection" or name == "broadcast" or name == "debug" or name == "dont-route" or name == "keep-alive" or name == "linger" or name == "nonblocking-io" or name == "out-of-band-inline" or name == "reuse-address" or name == "reuse-port" or name == "use-loopback"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "accept-connection"):
                                self.accept_connection = value
                                self.accept_connection.value_namespace = name_space
                                self.accept_connection.value_namespace_prefix = name_space_prefix
                            if(value_path == "broadcast"):
                                self.broadcast = value
                                self.broadcast.value_namespace = name_space
                                self.broadcast.value_namespace_prefix = name_space_prefix
                            if(value_path == "debug"):
                                self.debug = value
                                self.debug.value_namespace = name_space
                                self.debug.value_namespace_prefix = name_space_prefix
                            if(value_path == "dont-route"):
                                self.dont_route = value
                                self.dont_route.value_namespace = name_space
                                self.dont_route.value_namespace_prefix = name_space_prefix
                            if(value_path == "keep-alive"):
                                self.keep_alive = value
                                self.keep_alive.value_namespace = name_space
                                self.keep_alive.value_namespace_prefix = name_space_prefix
                            if(value_path == "linger"):
                                self.linger = value
                                self.linger.value_namespace = name_space
                                self.linger.value_namespace_prefix = name_space_prefix
                            if(value_path == "nonblocking-io"):
                                self.nonblocking_io = value
                                self.nonblocking_io.value_namespace = name_space
                                self.nonblocking_io.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-of-band-inline"):
                                self.out_of_band_inline = value
                                self.out_of_band_inline.value_namespace = name_space
                                self.out_of_band_inline.value_namespace_prefix = name_space_prefix
                            if(value_path == "reuse-address"):
                                self.reuse_address = value
                                self.reuse_address.value_namespace = name_space
                                self.reuse_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "reuse-port"):
                                self.reuse_port = value
                                self.reuse_port.value_namespace = name_space
                                self.reuse_port.value_namespace_prefix = name_space_prefix
                            if(value_path == "use-loopback"):
                                self.use_loopback = value
                                self.use_loopback.value_namespace = name_space
                                self.use_loopback.value_namespace_prefix = name_space_prefix


                    class SocketStateFlags(Entity):
                        """
                        Socket state flags
                        
                        .. attribute:: async_io_notify
                        
                        	Async i/o notify
                        	**type**\:  bool
                        
                        .. attribute:: block_close
                        
                        	Close is blocked (i.e. socket is a replicated socket on a standby node
                        	**type**\:  bool
                        
                        .. attribute:: block_receive
                        
                        	Socket is blocked for receive \- while going through SSO initial sync
                        	**type**\:  bool
                        
                        .. attribute:: block_send
                        
                        	Socket is blocked for send (if it is a replicated socket on a standby node)
                        	**type**\:  bool
                        
                        .. attribute:: cant_receive_more
                        
                        	Can't recv more data from peer
                        	**type**\:  bool
                        
                        .. attribute:: cant_send_more
                        
                        	Can't send more data to peer
                        	**type**\:  bool
                        
                        .. attribute:: is_confirming
                        
                        	Deciding to accept connection req
                        	**type**\:  bool
                        
                        .. attribute:: is_connected
                        
                        	Socket is connected to peer
                        	**type**\:  bool
                        
                        .. attribute:: is_connecting
                        
                        	Connecting in progress
                        	**type**\:  bool
                        
                        .. attribute:: is_detached
                        
                        	PCB and socket are detached
                        	**type**\:  bool
                        
                        .. attribute:: is_disconnecting
                        
                        	Disconnecting in progress
                        	**type**\:  bool
                        
                        .. attribute:: is_solock
                        
                        	Mutex acquired by solock()
                        	**type**\:  bool
                        
                        .. attribute:: no_file_descriptor_reference
                        
                        	No file descriptor ref
                        	**type**\:  bool
                        
                        .. attribute:: privileged
                        
                        	Privileged for broadcast, raw..
                        	**type**\:  bool
                        
                        .. attribute:: received_at_mark
                        
                        	At mark on input
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketStateFlags, self).__init__()

                            self.yang_name = "socket-state-flags"
                            self.yang_parent_name = "detail-information"

                            self.async_io_notify = YLeaf(YType.boolean, "async-io-notify")

                            self.block_close = YLeaf(YType.boolean, "block-close")

                            self.block_receive = YLeaf(YType.boolean, "block-receive")

                            self.block_send = YLeaf(YType.boolean, "block-send")

                            self.cant_receive_more = YLeaf(YType.boolean, "cant-receive-more")

                            self.cant_send_more = YLeaf(YType.boolean, "cant-send-more")

                            self.is_confirming = YLeaf(YType.boolean, "is-confirming")

                            self.is_connected = YLeaf(YType.boolean, "is-connected")

                            self.is_connecting = YLeaf(YType.boolean, "is-connecting")

                            self.is_detached = YLeaf(YType.boolean, "is-detached")

                            self.is_disconnecting = YLeaf(YType.boolean, "is-disconnecting")

                            self.is_solock = YLeaf(YType.boolean, "is-solock")

                            self.no_file_descriptor_reference = YLeaf(YType.boolean, "no-file-descriptor-reference")

                            self.privileged = YLeaf(YType.boolean, "privileged")

                            self.received_at_mark = YLeaf(YType.boolean, "received-at-mark")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("async_io_notify",
                                            "block_close",
                                            "block_receive",
                                            "block_send",
                                            "cant_receive_more",
                                            "cant_send_more",
                                            "is_confirming",
                                            "is_connected",
                                            "is_connecting",
                                            "is_detached",
                                            "is_disconnecting",
                                            "is_solock",
                                            "no_file_descriptor_reference",
                                            "privileged",
                                            "received_at_mark") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketStateFlags, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketStateFlags, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.async_io_notify.is_set or
                                self.block_close.is_set or
                                self.block_receive.is_set or
                                self.block_send.is_set or
                                self.cant_receive_more.is_set or
                                self.cant_send_more.is_set or
                                self.is_confirming.is_set or
                                self.is_connected.is_set or
                                self.is_connecting.is_set or
                                self.is_detached.is_set or
                                self.is_disconnecting.is_set or
                                self.is_solock.is_set or
                                self.no_file_descriptor_reference.is_set or
                                self.privileged.is_set or
                                self.received_at_mark.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.async_io_notify.yfilter != YFilter.not_set or
                                self.block_close.yfilter != YFilter.not_set or
                                self.block_receive.yfilter != YFilter.not_set or
                                self.block_send.yfilter != YFilter.not_set or
                                self.cant_receive_more.yfilter != YFilter.not_set or
                                self.cant_send_more.yfilter != YFilter.not_set or
                                self.is_confirming.yfilter != YFilter.not_set or
                                self.is_connected.yfilter != YFilter.not_set or
                                self.is_connecting.yfilter != YFilter.not_set or
                                self.is_detached.yfilter != YFilter.not_set or
                                self.is_disconnecting.yfilter != YFilter.not_set or
                                self.is_solock.yfilter != YFilter.not_set or
                                self.no_file_descriptor_reference.yfilter != YFilter.not_set or
                                self.privileged.yfilter != YFilter.not_set or
                                self.received_at_mark.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "socket-state-flags" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.async_io_notify.is_set or self.async_io_notify.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.async_io_notify.get_name_leafdata())
                            if (self.block_close.is_set or self.block_close.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.block_close.get_name_leafdata())
                            if (self.block_receive.is_set or self.block_receive.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.block_receive.get_name_leafdata())
                            if (self.block_send.is_set or self.block_send.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.block_send.get_name_leafdata())
                            if (self.cant_receive_more.is_set or self.cant_receive_more.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cant_receive_more.get_name_leafdata())
                            if (self.cant_send_more.is_set or self.cant_send_more.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cant_send_more.get_name_leafdata())
                            if (self.is_confirming.is_set or self.is_confirming.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_confirming.get_name_leafdata())
                            if (self.is_connected.is_set or self.is_connected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_connected.get_name_leafdata())
                            if (self.is_connecting.is_set or self.is_connecting.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_connecting.get_name_leafdata())
                            if (self.is_detached.is_set or self.is_detached.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_detached.get_name_leafdata())
                            if (self.is_disconnecting.is_set or self.is_disconnecting.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_disconnecting.get_name_leafdata())
                            if (self.is_solock.is_set or self.is_solock.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_solock.get_name_leafdata())
                            if (self.no_file_descriptor_reference.is_set or self.no_file_descriptor_reference.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.no_file_descriptor_reference.get_name_leafdata())
                            if (self.privileged.is_set or self.privileged.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.privileged.get_name_leafdata())
                            if (self.received_at_mark.is_set or self.received_at_mark.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_at_mark.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "async-io-notify" or name == "block-close" or name == "block-receive" or name == "block-send" or name == "cant-receive-more" or name == "cant-send-more" or name == "is-confirming" or name == "is-connected" or name == "is-connecting" or name == "is-detached" or name == "is-disconnecting" or name == "is-solock" or name == "no-file-descriptor-reference" or name == "privileged" or name == "received-at-mark"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "async-io-notify"):
                                self.async_io_notify = value
                                self.async_io_notify.value_namespace = name_space
                                self.async_io_notify.value_namespace_prefix = name_space_prefix
                            if(value_path == "block-close"):
                                self.block_close = value
                                self.block_close.value_namespace = name_space
                                self.block_close.value_namespace_prefix = name_space_prefix
                            if(value_path == "block-receive"):
                                self.block_receive = value
                                self.block_receive.value_namespace = name_space
                                self.block_receive.value_namespace_prefix = name_space_prefix
                            if(value_path == "block-send"):
                                self.block_send = value
                                self.block_send.value_namespace = name_space
                                self.block_send.value_namespace_prefix = name_space_prefix
                            if(value_path == "cant-receive-more"):
                                self.cant_receive_more = value
                                self.cant_receive_more.value_namespace = name_space
                                self.cant_receive_more.value_namespace_prefix = name_space_prefix
                            if(value_path == "cant-send-more"):
                                self.cant_send_more = value
                                self.cant_send_more.value_namespace = name_space
                                self.cant_send_more.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-confirming"):
                                self.is_confirming = value
                                self.is_confirming.value_namespace = name_space
                                self.is_confirming.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-connected"):
                                self.is_connected = value
                                self.is_connected.value_namespace = name_space
                                self.is_connected.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-connecting"):
                                self.is_connecting = value
                                self.is_connecting.value_namespace = name_space
                                self.is_connecting.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-detached"):
                                self.is_detached = value
                                self.is_detached.value_namespace = name_space
                                self.is_detached.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-disconnecting"):
                                self.is_disconnecting = value
                                self.is_disconnecting.value_namespace = name_space
                                self.is_disconnecting.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-solock"):
                                self.is_solock = value
                                self.is_solock.value_namespace = name_space
                                self.is_solock.value_namespace_prefix = name_space_prefix
                            if(value_path == "no-file-descriptor-reference"):
                                self.no_file_descriptor_reference = value
                                self.no_file_descriptor_reference.value_namespace = name_space
                                self.no_file_descriptor_reference.value_namespace_prefix = name_space_prefix
                            if(value_path == "privileged"):
                                self.privileged = value
                                self.privileged.value_namespace = name_space
                                self.privileged.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-at-mark"):
                                self.received_at_mark = value
                                self.received_at_mark.value_namespace = name_space
                                self.received_at_mark.value_namespace_prefix = name_space_prefix


                    class FeatureFlags(Entity):
                        """
                        Connection feature flags
                        
                        .. attribute:: connection_keep_alive_timer
                        
                        	Keepalive timer is on?
                        	**type**\:  bool
                        
                        .. attribute:: giveup_timer
                        
                        	Giveup timer is on?
                        	**type**\:  bool
                        
                        .. attribute:: md5
                        
                        	MD5 option on?
                        	**type**\:  bool
                        
                        .. attribute:: mss_cisco
                        
                        	tcp mss feature is on?
                        	**type**\:  bool
                        
                        .. attribute:: nagle
                        
                        	Nagle algorithm on?
                        	**type**\:  bool
                        
                        .. attribute:: path_mtu_discovery
                        
                        	Path MTU Discovery feature is on?
                        	**type**\:  bool
                        
                        .. attribute:: selective_ack
                        
                        	Selective ack on?
                        	**type**\:  bool
                        
                        .. attribute:: timestamps
                        
                        	Timestamps on?
                        	**type**\:  bool
                        
                        .. attribute:: window_scaling
                        
                        	Window\-scaling on?
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.FeatureFlags, self).__init__()

                            self.yang_name = "feature-flags"
                            self.yang_parent_name = "detail-information"

                            self.connection_keep_alive_timer = YLeaf(YType.boolean, "connection-keep-alive-timer")

                            self.giveup_timer = YLeaf(YType.boolean, "giveup-timer")

                            self.md5 = YLeaf(YType.boolean, "md5")

                            self.mss_cisco = YLeaf(YType.boolean, "mss-cisco")

                            self.nagle = YLeaf(YType.boolean, "nagle")

                            self.path_mtu_discovery = YLeaf(YType.boolean, "path-mtu-discovery")

                            self.selective_ack = YLeaf(YType.boolean, "selective-ack")

                            self.timestamps = YLeaf(YType.boolean, "timestamps")

                            self.window_scaling = YLeaf(YType.boolean, "window-scaling")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("connection_keep_alive_timer",
                                            "giveup_timer",
                                            "md5",
                                            "mss_cisco",
                                            "nagle",
                                            "path_mtu_discovery",
                                            "selective_ack",
                                            "timestamps",
                                            "window_scaling") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.FeatureFlags, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.FeatureFlags, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.connection_keep_alive_timer.is_set or
                                self.giveup_timer.is_set or
                                self.md5.is_set or
                                self.mss_cisco.is_set or
                                self.nagle.is_set or
                                self.path_mtu_discovery.is_set or
                                self.selective_ack.is_set or
                                self.timestamps.is_set or
                                self.window_scaling.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.connection_keep_alive_timer.yfilter != YFilter.not_set or
                                self.giveup_timer.yfilter != YFilter.not_set or
                                self.md5.yfilter != YFilter.not_set or
                                self.mss_cisco.yfilter != YFilter.not_set or
                                self.nagle.yfilter != YFilter.not_set or
                                self.path_mtu_discovery.yfilter != YFilter.not_set or
                                self.selective_ack.yfilter != YFilter.not_set or
                                self.timestamps.yfilter != YFilter.not_set or
                                self.window_scaling.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "feature-flags" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.connection_keep_alive_timer.is_set or self.connection_keep_alive_timer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connection_keep_alive_timer.get_name_leafdata())
                            if (self.giveup_timer.is_set or self.giveup_timer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.giveup_timer.get_name_leafdata())
                            if (self.md5.is_set or self.md5.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.md5.get_name_leafdata())
                            if (self.mss_cisco.is_set or self.mss_cisco.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mss_cisco.get_name_leafdata())
                            if (self.nagle.is_set or self.nagle.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nagle.get_name_leafdata())
                            if (self.path_mtu_discovery.is_set or self.path_mtu_discovery.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_mtu_discovery.get_name_leafdata())
                            if (self.selective_ack.is_set or self.selective_ack.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.selective_ack.get_name_leafdata())
                            if (self.timestamps.is_set or self.timestamps.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.timestamps.get_name_leafdata())
                            if (self.window_scaling.is_set or self.window_scaling.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.window_scaling.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "connection-keep-alive-timer" or name == "giveup-timer" or name == "md5" or name == "mss-cisco" or name == "nagle" or name == "path-mtu-discovery" or name == "selective-ack" or name == "timestamps" or name == "window-scaling"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "connection-keep-alive-timer"):
                                self.connection_keep_alive_timer = value
                                self.connection_keep_alive_timer.value_namespace = name_space
                                self.connection_keep_alive_timer.value_namespace_prefix = name_space_prefix
                            if(value_path == "giveup-timer"):
                                self.giveup_timer = value
                                self.giveup_timer.value_namespace = name_space
                                self.giveup_timer.value_namespace_prefix = name_space_prefix
                            if(value_path == "md5"):
                                self.md5 = value
                                self.md5.value_namespace = name_space
                                self.md5.value_namespace_prefix = name_space_prefix
                            if(value_path == "mss-cisco"):
                                self.mss_cisco = value
                                self.mss_cisco.value_namespace = name_space
                                self.mss_cisco.value_namespace_prefix = name_space_prefix
                            if(value_path == "nagle"):
                                self.nagle = value
                                self.nagle.value_namespace = name_space
                                self.nagle.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-mtu-discovery"):
                                self.path_mtu_discovery = value
                                self.path_mtu_discovery.value_namespace = name_space
                                self.path_mtu_discovery.value_namespace_prefix = name_space_prefix
                            if(value_path == "selective-ack"):
                                self.selective_ack = value
                                self.selective_ack.value_namespace = name_space
                                self.selective_ack.value_namespace_prefix = name_space_prefix
                            if(value_path == "timestamps"):
                                self.timestamps = value
                                self.timestamps.value_namespace = name_space
                                self.timestamps.value_namespace_prefix = name_space_prefix
                            if(value_path == "window-scaling"):
                                self.window_scaling = value
                                self.window_scaling.value_namespace = name_space
                                self.window_scaling.value_namespace_prefix = name_space_prefix


                    class StateFlags(Entity):
                        """
                        Connection state flags
                        
                        .. attribute:: ack_needed
                        
                        	Send an ACK
                        	**type**\:  bool
                        
                        .. attribute:: fin_sent
                        
                        	FIN has been sent
                        	**type**\:  bool
                        
                        .. attribute:: in_syn_cache
                        
                        	Connection is in SYN cache
                        	**type**\:  bool
                        
                        .. attribute:: nagle_wait
                        
                        	Nagle has delayed output
                        	**type**\:  bool
                        
                        .. attribute:: need_push
                        
                        	Need to push data out
                        	**type**\:  bool
                        
                        .. attribute:: path_mtu_ager
                        
                        	Path MTU aging timer is running
                        	**type**\:  bool
                        
                        .. attribute:: probing
                        
                        	Probing a closed window
                        	**type**\:  bool
                        
                        .. attribute:: pushed
                        
                        	A segment is pushed due to MSG\_PUSH
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.StateFlags, self).__init__()

                            self.yang_name = "state-flags"
                            self.yang_parent_name = "detail-information"

                            self.ack_needed = YLeaf(YType.boolean, "ack-needed")

                            self.fin_sent = YLeaf(YType.boolean, "fin-sent")

                            self.in_syn_cache = YLeaf(YType.boolean, "in-syn-cache")

                            self.nagle_wait = YLeaf(YType.boolean, "nagle-wait")

                            self.need_push = YLeaf(YType.boolean, "need-push")

                            self.path_mtu_ager = YLeaf(YType.boolean, "path-mtu-ager")

                            self.probing = YLeaf(YType.boolean, "probing")

                            self.pushed = YLeaf(YType.boolean, "pushed")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ack_needed",
                                            "fin_sent",
                                            "in_syn_cache",
                                            "nagle_wait",
                                            "need_push",
                                            "path_mtu_ager",
                                            "probing",
                                            "pushed") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.StateFlags, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.StateFlags, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.ack_needed.is_set or
                                self.fin_sent.is_set or
                                self.in_syn_cache.is_set or
                                self.nagle_wait.is_set or
                                self.need_push.is_set or
                                self.path_mtu_ager.is_set or
                                self.probing.is_set or
                                self.pushed.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ack_needed.yfilter != YFilter.not_set or
                                self.fin_sent.yfilter != YFilter.not_set or
                                self.in_syn_cache.yfilter != YFilter.not_set or
                                self.nagle_wait.yfilter != YFilter.not_set or
                                self.need_push.yfilter != YFilter.not_set or
                                self.path_mtu_ager.yfilter != YFilter.not_set or
                                self.probing.yfilter != YFilter.not_set or
                                self.pushed.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state-flags" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ack_needed.is_set or self.ack_needed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ack_needed.get_name_leafdata())
                            if (self.fin_sent.is_set or self.fin_sent.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fin_sent.get_name_leafdata())
                            if (self.in_syn_cache.is_set or self.in_syn_cache.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_syn_cache.get_name_leafdata())
                            if (self.nagle_wait.is_set or self.nagle_wait.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nagle_wait.get_name_leafdata())
                            if (self.need_push.is_set or self.need_push.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.need_push.get_name_leafdata())
                            if (self.path_mtu_ager.is_set or self.path_mtu_ager.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_mtu_ager.get_name_leafdata())
                            if (self.probing.is_set or self.probing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.probing.get_name_leafdata())
                            if (self.pushed.is_set or self.pushed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pushed.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ack-needed" or name == "fin-sent" or name == "in-syn-cache" or name == "nagle-wait" or name == "need-push" or name == "path-mtu-ager" or name == "probing" or name == "pushed"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ack-needed"):
                                self.ack_needed = value
                                self.ack_needed.value_namespace = name_space
                                self.ack_needed.value_namespace_prefix = name_space_prefix
                            if(value_path == "fin-sent"):
                                self.fin_sent = value
                                self.fin_sent.value_namespace = name_space
                                self.fin_sent.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-syn-cache"):
                                self.in_syn_cache = value
                                self.in_syn_cache.value_namespace = name_space
                                self.in_syn_cache.value_namespace_prefix = name_space_prefix
                            if(value_path == "nagle-wait"):
                                self.nagle_wait = value
                                self.nagle_wait.value_namespace = name_space
                                self.nagle_wait.value_namespace_prefix = name_space_prefix
                            if(value_path == "need-push"):
                                self.need_push = value
                                self.need_push.value_namespace = name_space
                                self.need_push.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-mtu-ager"):
                                self.path_mtu_ager = value
                                self.path_mtu_ager.value_namespace = name_space
                                self.path_mtu_ager.value_namespace_prefix = name_space_prefix
                            if(value_path == "probing"):
                                self.probing = value
                                self.probing.value_namespace = name_space
                                self.probing.value_namespace_prefix = name_space_prefix
                            if(value_path == "pushed"):
                                self.pushed = value
                                self.pushed.value_namespace = name_space
                                self.pushed.value_namespace_prefix = name_space_prefix


                    class RequestFlags(Entity):
                        """
                        Connection request flags
                        
                        .. attribute:: connection_keep_alive_timer
                        
                        	Keepalive timer is on?
                        	**type**\:  bool
                        
                        .. attribute:: giveup_timer
                        
                        	Giveup timer is on?
                        	**type**\:  bool
                        
                        .. attribute:: md5
                        
                        	MD5 option on?
                        	**type**\:  bool
                        
                        .. attribute:: mss_cisco
                        
                        	tcp mss feature is on?
                        	**type**\:  bool
                        
                        .. attribute:: nagle
                        
                        	Nagle algorithm on?
                        	**type**\:  bool
                        
                        .. attribute:: path_mtu_discovery
                        
                        	Path MTU Discovery feature is on?
                        	**type**\:  bool
                        
                        .. attribute:: selective_ack
                        
                        	Selective ack on?
                        	**type**\:  bool
                        
                        .. attribute:: timestamps
                        
                        	Timestamps on?
                        	**type**\:  bool
                        
                        .. attribute:: window_scaling
                        
                        	Window\-scaling on?
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.RequestFlags, self).__init__()

                            self.yang_name = "request-flags"
                            self.yang_parent_name = "detail-information"

                            self.connection_keep_alive_timer = YLeaf(YType.boolean, "connection-keep-alive-timer")

                            self.giveup_timer = YLeaf(YType.boolean, "giveup-timer")

                            self.md5 = YLeaf(YType.boolean, "md5")

                            self.mss_cisco = YLeaf(YType.boolean, "mss-cisco")

                            self.nagle = YLeaf(YType.boolean, "nagle")

                            self.path_mtu_discovery = YLeaf(YType.boolean, "path-mtu-discovery")

                            self.selective_ack = YLeaf(YType.boolean, "selective-ack")

                            self.timestamps = YLeaf(YType.boolean, "timestamps")

                            self.window_scaling = YLeaf(YType.boolean, "window-scaling")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("connection_keep_alive_timer",
                                            "giveup_timer",
                                            "md5",
                                            "mss_cisco",
                                            "nagle",
                                            "path_mtu_discovery",
                                            "selective_ack",
                                            "timestamps",
                                            "window_scaling") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.RequestFlags, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.RequestFlags, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.connection_keep_alive_timer.is_set or
                                self.giveup_timer.is_set or
                                self.md5.is_set or
                                self.mss_cisco.is_set or
                                self.nagle.is_set or
                                self.path_mtu_discovery.is_set or
                                self.selective_ack.is_set or
                                self.timestamps.is_set or
                                self.window_scaling.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.connection_keep_alive_timer.yfilter != YFilter.not_set or
                                self.giveup_timer.yfilter != YFilter.not_set or
                                self.md5.yfilter != YFilter.not_set or
                                self.mss_cisco.yfilter != YFilter.not_set or
                                self.nagle.yfilter != YFilter.not_set or
                                self.path_mtu_discovery.yfilter != YFilter.not_set or
                                self.selective_ack.yfilter != YFilter.not_set or
                                self.timestamps.yfilter != YFilter.not_set or
                                self.window_scaling.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "request-flags" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.connection_keep_alive_timer.is_set or self.connection_keep_alive_timer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connection_keep_alive_timer.get_name_leafdata())
                            if (self.giveup_timer.is_set or self.giveup_timer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.giveup_timer.get_name_leafdata())
                            if (self.md5.is_set or self.md5.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.md5.get_name_leafdata())
                            if (self.mss_cisco.is_set or self.mss_cisco.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mss_cisco.get_name_leafdata())
                            if (self.nagle.is_set or self.nagle.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nagle.get_name_leafdata())
                            if (self.path_mtu_discovery.is_set or self.path_mtu_discovery.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_mtu_discovery.get_name_leafdata())
                            if (self.selective_ack.is_set or self.selective_ack.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.selective_ack.get_name_leafdata())
                            if (self.timestamps.is_set or self.timestamps.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.timestamps.get_name_leafdata())
                            if (self.window_scaling.is_set or self.window_scaling.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.window_scaling.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "connection-keep-alive-timer" or name == "giveup-timer" or name == "md5" or name == "mss-cisco" or name == "nagle" or name == "path-mtu-discovery" or name == "selective-ack" or name == "timestamps" or name == "window-scaling"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "connection-keep-alive-timer"):
                                self.connection_keep_alive_timer = value
                                self.connection_keep_alive_timer.value_namespace = name_space
                                self.connection_keep_alive_timer.value_namespace_prefix = name_space_prefix
                            if(value_path == "giveup-timer"):
                                self.giveup_timer = value
                                self.giveup_timer.value_namespace = name_space
                                self.giveup_timer.value_namespace_prefix = name_space_prefix
                            if(value_path == "md5"):
                                self.md5 = value
                                self.md5.value_namespace = name_space
                                self.md5.value_namespace_prefix = name_space_prefix
                            if(value_path == "mss-cisco"):
                                self.mss_cisco = value
                                self.mss_cisco.value_namespace = name_space
                                self.mss_cisco.value_namespace_prefix = name_space_prefix
                            if(value_path == "nagle"):
                                self.nagle = value
                                self.nagle.value_namespace = name_space
                                self.nagle.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-mtu-discovery"):
                                self.path_mtu_discovery = value
                                self.path_mtu_discovery.value_namespace = name_space
                                self.path_mtu_discovery.value_namespace_prefix = name_space_prefix
                            if(value_path == "selective-ack"):
                                self.selective_ack = value
                                self.selective_ack.value_namespace = name_space
                                self.selective_ack.value_namespace_prefix = name_space_prefix
                            if(value_path == "timestamps"):
                                self.timestamps = value
                                self.timestamps.value_namespace = name_space
                                self.timestamps.value_namespace_prefix = name_space_prefix
                            if(value_path == "window-scaling"):
                                self.window_scaling = value
                                self.window_scaling.value_namespace = name_space
                                self.window_scaling.value_namespace_prefix = name_space_prefix


                    class ReceiveBufStateFlags(Entity):
                        """
                        Receive buffer state flags
                        
                        .. attribute:: async_io
                        
                        	Async I/O
                        	**type**\:  bool
                        
                        .. attribute:: connect_wakeup
                        
                        	Connect wakeup pending
                        	**type**\:  bool
                        
                        .. attribute:: delayed_wakeup
                        
                        	Want delayed wakeups
                        	**type**\:  bool
                        
                        .. attribute:: input_select
                        
                        	Buffer is selected for INPUT
                        	**type**\:  bool
                        
                        .. attribute:: io_timer_set
                        
                        	Read/write timer set
                        	**type**\:  bool
                        
                        .. attribute:: locked
                        
                        	Lock on data queue (so\_rcv only)
                        	**type**\:  bool
                        
                        .. attribute:: not_interruptible
                        
                        	Not interruptible
                        	**type**\:  bool
                        
                        .. attribute:: out_of_band_select
                        
                        	Buffer is selected for OBAND
                        	**type**\:  bool
                        
                        .. attribute:: output_select
                        
                        	Buffer is selected for OUTPUT
                        	**type**\:  bool
                        
                        .. attribute:: waiting_for_data
                        
                        	Someone is waiting for data/space
                        	**type**\:  bool
                        
                        .. attribute:: waiting_for_lock
                        
                        	Someone is waiting to lock
                        	**type**\:  bool
                        
                        .. attribute:: wakeup
                        
                        	Read/write wakeup pending
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ReceiveBufStateFlags, self).__init__()

                            self.yang_name = "receive-buf-state-flags"
                            self.yang_parent_name = "detail-information"

                            self.async_io = YLeaf(YType.boolean, "async-io")

                            self.connect_wakeup = YLeaf(YType.boolean, "connect-wakeup")

                            self.delayed_wakeup = YLeaf(YType.boolean, "delayed-wakeup")

                            self.input_select = YLeaf(YType.boolean, "input-select")

                            self.io_timer_set = YLeaf(YType.boolean, "io-timer-set")

                            self.locked = YLeaf(YType.boolean, "locked")

                            self.not_interruptible = YLeaf(YType.boolean, "not-interruptible")

                            self.out_of_band_select = YLeaf(YType.boolean, "out-of-band-select")

                            self.output_select = YLeaf(YType.boolean, "output-select")

                            self.waiting_for_data = YLeaf(YType.boolean, "waiting-for-data")

                            self.waiting_for_lock = YLeaf(YType.boolean, "waiting-for-lock")

                            self.wakeup = YLeaf(YType.boolean, "wakeup")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("async_io",
                                            "connect_wakeup",
                                            "delayed_wakeup",
                                            "input_select",
                                            "io_timer_set",
                                            "locked",
                                            "not_interruptible",
                                            "out_of_band_select",
                                            "output_select",
                                            "waiting_for_data",
                                            "waiting_for_lock",
                                            "wakeup") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ReceiveBufStateFlags, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ReceiveBufStateFlags, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.async_io.is_set or
                                self.connect_wakeup.is_set or
                                self.delayed_wakeup.is_set or
                                self.input_select.is_set or
                                self.io_timer_set.is_set or
                                self.locked.is_set or
                                self.not_interruptible.is_set or
                                self.out_of_band_select.is_set or
                                self.output_select.is_set or
                                self.waiting_for_data.is_set or
                                self.waiting_for_lock.is_set or
                                self.wakeup.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.async_io.yfilter != YFilter.not_set or
                                self.connect_wakeup.yfilter != YFilter.not_set or
                                self.delayed_wakeup.yfilter != YFilter.not_set or
                                self.input_select.yfilter != YFilter.not_set or
                                self.io_timer_set.yfilter != YFilter.not_set or
                                self.locked.yfilter != YFilter.not_set or
                                self.not_interruptible.yfilter != YFilter.not_set or
                                self.out_of_band_select.yfilter != YFilter.not_set or
                                self.output_select.yfilter != YFilter.not_set or
                                self.waiting_for_data.yfilter != YFilter.not_set or
                                self.waiting_for_lock.yfilter != YFilter.not_set or
                                self.wakeup.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "receive-buf-state-flags" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.async_io.is_set or self.async_io.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.async_io.get_name_leafdata())
                            if (self.connect_wakeup.is_set or self.connect_wakeup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connect_wakeup.get_name_leafdata())
                            if (self.delayed_wakeup.is_set or self.delayed_wakeup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.delayed_wakeup.get_name_leafdata())
                            if (self.input_select.is_set or self.input_select.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.input_select.get_name_leafdata())
                            if (self.io_timer_set.is_set or self.io_timer_set.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.io_timer_set.get_name_leafdata())
                            if (self.locked.is_set or self.locked.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.locked.get_name_leafdata())
                            if (self.not_interruptible.is_set or self.not_interruptible.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.not_interruptible.get_name_leafdata())
                            if (self.out_of_band_select.is_set or self.out_of_band_select.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_of_band_select.get_name_leafdata())
                            if (self.output_select.is_set or self.output_select.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.output_select.get_name_leafdata())
                            if (self.waiting_for_data.is_set or self.waiting_for_data.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.waiting_for_data.get_name_leafdata())
                            if (self.waiting_for_lock.is_set or self.waiting_for_lock.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.waiting_for_lock.get_name_leafdata())
                            if (self.wakeup.is_set or self.wakeup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wakeup.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "async-io" or name == "connect-wakeup" or name == "delayed-wakeup" or name == "input-select" or name == "io-timer-set" or name == "locked" or name == "not-interruptible" or name == "out-of-band-select" or name == "output-select" or name == "waiting-for-data" or name == "waiting-for-lock" or name == "wakeup"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "async-io"):
                                self.async_io = value
                                self.async_io.value_namespace = name_space
                                self.async_io.value_namespace_prefix = name_space_prefix
                            if(value_path == "connect-wakeup"):
                                self.connect_wakeup = value
                                self.connect_wakeup.value_namespace = name_space
                                self.connect_wakeup.value_namespace_prefix = name_space_prefix
                            if(value_path == "delayed-wakeup"):
                                self.delayed_wakeup = value
                                self.delayed_wakeup.value_namespace = name_space
                                self.delayed_wakeup.value_namespace_prefix = name_space_prefix
                            if(value_path == "input-select"):
                                self.input_select = value
                                self.input_select.value_namespace = name_space
                                self.input_select.value_namespace_prefix = name_space_prefix
                            if(value_path == "io-timer-set"):
                                self.io_timer_set = value
                                self.io_timer_set.value_namespace = name_space
                                self.io_timer_set.value_namespace_prefix = name_space_prefix
                            if(value_path == "locked"):
                                self.locked = value
                                self.locked.value_namespace = name_space
                                self.locked.value_namespace_prefix = name_space_prefix
                            if(value_path == "not-interruptible"):
                                self.not_interruptible = value
                                self.not_interruptible.value_namespace = name_space
                                self.not_interruptible.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-of-band-select"):
                                self.out_of_band_select = value
                                self.out_of_band_select.value_namespace = name_space
                                self.out_of_band_select.value_namespace_prefix = name_space_prefix
                            if(value_path == "output-select"):
                                self.output_select = value
                                self.output_select.value_namespace = name_space
                                self.output_select.value_namespace_prefix = name_space_prefix
                            if(value_path == "waiting-for-data"):
                                self.waiting_for_data = value
                                self.waiting_for_data.value_namespace = name_space
                                self.waiting_for_data.value_namespace_prefix = name_space_prefix
                            if(value_path == "waiting-for-lock"):
                                self.waiting_for_lock = value
                                self.waiting_for_lock.value_namespace = name_space
                                self.waiting_for_lock.value_namespace_prefix = name_space_prefix
                            if(value_path == "wakeup"):
                                self.wakeup = value
                                self.wakeup.value_namespace = name_space
                                self.wakeup.value_namespace_prefix = name_space_prefix


                    class SendBufStateFlags(Entity):
                        """
                        Send buffer state flags
                        
                        .. attribute:: async_io
                        
                        	Async I/O
                        	**type**\:  bool
                        
                        .. attribute:: connect_wakeup
                        
                        	Connect wakeup pending
                        	**type**\:  bool
                        
                        .. attribute:: delayed_wakeup
                        
                        	Want delayed wakeups
                        	**type**\:  bool
                        
                        .. attribute:: input_select
                        
                        	Buffer is selected for INPUT
                        	**type**\:  bool
                        
                        .. attribute:: io_timer_set
                        
                        	Read/write timer set
                        	**type**\:  bool
                        
                        .. attribute:: locked
                        
                        	Lock on data queue (so\_rcv only)
                        	**type**\:  bool
                        
                        .. attribute:: not_interruptible
                        
                        	Not interruptible
                        	**type**\:  bool
                        
                        .. attribute:: out_of_band_select
                        
                        	Buffer is selected for OBAND
                        	**type**\:  bool
                        
                        .. attribute:: output_select
                        
                        	Buffer is selected for OUTPUT
                        	**type**\:  bool
                        
                        .. attribute:: waiting_for_data
                        
                        	Someone is waiting for data/space
                        	**type**\:  bool
                        
                        .. attribute:: waiting_for_lock
                        
                        	Someone is waiting to lock
                        	**type**\:  bool
                        
                        .. attribute:: wakeup
                        
                        	Read/write wakeup pending
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendBufStateFlags, self).__init__()

                            self.yang_name = "send-buf-state-flags"
                            self.yang_parent_name = "detail-information"

                            self.async_io = YLeaf(YType.boolean, "async-io")

                            self.connect_wakeup = YLeaf(YType.boolean, "connect-wakeup")

                            self.delayed_wakeup = YLeaf(YType.boolean, "delayed-wakeup")

                            self.input_select = YLeaf(YType.boolean, "input-select")

                            self.io_timer_set = YLeaf(YType.boolean, "io-timer-set")

                            self.locked = YLeaf(YType.boolean, "locked")

                            self.not_interruptible = YLeaf(YType.boolean, "not-interruptible")

                            self.out_of_band_select = YLeaf(YType.boolean, "out-of-band-select")

                            self.output_select = YLeaf(YType.boolean, "output-select")

                            self.waiting_for_data = YLeaf(YType.boolean, "waiting-for-data")

                            self.waiting_for_lock = YLeaf(YType.boolean, "waiting-for-lock")

                            self.wakeup = YLeaf(YType.boolean, "wakeup")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("async_io",
                                            "connect_wakeup",
                                            "delayed_wakeup",
                                            "input_select",
                                            "io_timer_set",
                                            "locked",
                                            "not_interruptible",
                                            "out_of_band_select",
                                            "output_select",
                                            "waiting_for_data",
                                            "waiting_for_lock",
                                            "wakeup") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendBufStateFlags, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendBufStateFlags, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.async_io.is_set or
                                self.connect_wakeup.is_set or
                                self.delayed_wakeup.is_set or
                                self.input_select.is_set or
                                self.io_timer_set.is_set or
                                self.locked.is_set or
                                self.not_interruptible.is_set or
                                self.out_of_band_select.is_set or
                                self.output_select.is_set or
                                self.waiting_for_data.is_set or
                                self.waiting_for_lock.is_set or
                                self.wakeup.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.async_io.yfilter != YFilter.not_set or
                                self.connect_wakeup.yfilter != YFilter.not_set or
                                self.delayed_wakeup.yfilter != YFilter.not_set or
                                self.input_select.yfilter != YFilter.not_set or
                                self.io_timer_set.yfilter != YFilter.not_set or
                                self.locked.yfilter != YFilter.not_set or
                                self.not_interruptible.yfilter != YFilter.not_set or
                                self.out_of_band_select.yfilter != YFilter.not_set or
                                self.output_select.yfilter != YFilter.not_set or
                                self.waiting_for_data.yfilter != YFilter.not_set or
                                self.waiting_for_lock.yfilter != YFilter.not_set or
                                self.wakeup.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "send-buf-state-flags" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.async_io.is_set or self.async_io.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.async_io.get_name_leafdata())
                            if (self.connect_wakeup.is_set or self.connect_wakeup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connect_wakeup.get_name_leafdata())
                            if (self.delayed_wakeup.is_set or self.delayed_wakeup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.delayed_wakeup.get_name_leafdata())
                            if (self.input_select.is_set or self.input_select.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.input_select.get_name_leafdata())
                            if (self.io_timer_set.is_set or self.io_timer_set.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.io_timer_set.get_name_leafdata())
                            if (self.locked.is_set or self.locked.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.locked.get_name_leafdata())
                            if (self.not_interruptible.is_set or self.not_interruptible.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.not_interruptible.get_name_leafdata())
                            if (self.out_of_band_select.is_set or self.out_of_band_select.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_of_band_select.get_name_leafdata())
                            if (self.output_select.is_set or self.output_select.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.output_select.get_name_leafdata())
                            if (self.waiting_for_data.is_set or self.waiting_for_data.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.waiting_for_data.get_name_leafdata())
                            if (self.waiting_for_lock.is_set or self.waiting_for_lock.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.waiting_for_lock.get_name_leafdata())
                            if (self.wakeup.is_set or self.wakeup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wakeup.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "async-io" or name == "connect-wakeup" or name == "delayed-wakeup" or name == "input-select" or name == "io-timer-set" or name == "locked" or name == "not-interruptible" or name == "out-of-band-select" or name == "output-select" or name == "waiting-for-data" or name == "waiting-for-lock" or name == "wakeup"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "async-io"):
                                self.async_io = value
                                self.async_io.value_namespace = name_space
                                self.async_io.value_namespace_prefix = name_space_prefix
                            if(value_path == "connect-wakeup"):
                                self.connect_wakeup = value
                                self.connect_wakeup.value_namespace = name_space
                                self.connect_wakeup.value_namespace_prefix = name_space_prefix
                            if(value_path == "delayed-wakeup"):
                                self.delayed_wakeup = value
                                self.delayed_wakeup.value_namespace = name_space
                                self.delayed_wakeup.value_namespace_prefix = name_space_prefix
                            if(value_path == "input-select"):
                                self.input_select = value
                                self.input_select.value_namespace = name_space
                                self.input_select.value_namespace_prefix = name_space_prefix
                            if(value_path == "io-timer-set"):
                                self.io_timer_set = value
                                self.io_timer_set.value_namespace = name_space
                                self.io_timer_set.value_namespace_prefix = name_space_prefix
                            if(value_path == "locked"):
                                self.locked = value
                                self.locked.value_namespace = name_space
                                self.locked.value_namespace_prefix = name_space_prefix
                            if(value_path == "not-interruptible"):
                                self.not_interruptible = value
                                self.not_interruptible.value_namespace = name_space
                                self.not_interruptible.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-of-band-select"):
                                self.out_of_band_select = value
                                self.out_of_band_select.value_namespace = name_space
                                self.out_of_band_select.value_namespace_prefix = name_space_prefix
                            if(value_path == "output-select"):
                                self.output_select = value
                                self.output_select.value_namespace = name_space
                                self.output_select.value_namespace_prefix = name_space_prefix
                            if(value_path == "waiting-for-data"):
                                self.waiting_for_data = value
                                self.waiting_for_data.value_namespace = name_space
                                self.waiting_for_data.value_namespace_prefix = name_space_prefix
                            if(value_path == "waiting-for-lock"):
                                self.waiting_for_lock = value
                                self.waiting_for_lock.value_namespace = name_space
                                self.waiting_for_lock.value_namespace_prefix = name_space_prefix
                            if(value_path == "wakeup"):
                                self.wakeup = value
                                self.wakeup.value_namespace = name_space
                                self.wakeup.value_namespace_prefix = name_space_prefix


                    class Timer(Entity):
                        """
                        Timers
                        
                        .. attribute:: timer_activations
                        
                        	Count of timer activations
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: timer_expirations
                        
                        	Count of timer expirations
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: timer_next_activation
                        
                        	Timer next activation (msec)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: timer_type
                        
                        	Timer Type
                        	**type**\:   :py:class:`TcpTimer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpTimer>`
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.Timer, self).__init__()

                            self.yang_name = "timer"
                            self.yang_parent_name = "detail-information"

                            self.timer_activations = YLeaf(YType.uint32, "timer-activations")

                            self.timer_expirations = YLeaf(YType.uint32, "timer-expirations")

                            self.timer_next_activation = YLeaf(YType.uint32, "timer-next-activation")

                            self.timer_type = YLeaf(YType.enumeration, "timer-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("timer_activations",
                                            "timer_expirations",
                                            "timer_next_activation",
                                            "timer_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.Timer, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.Timer, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.timer_activations.is_set or
                                self.timer_expirations.is_set or
                                self.timer_next_activation.is_set or
                                self.timer_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.timer_activations.yfilter != YFilter.not_set or
                                self.timer_expirations.yfilter != YFilter.not_set or
                                self.timer_next_activation.yfilter != YFilter.not_set or
                                self.timer_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "timer" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.timer_activations.is_set or self.timer_activations.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.timer_activations.get_name_leafdata())
                            if (self.timer_expirations.is_set or self.timer_expirations.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.timer_expirations.get_name_leafdata())
                            if (self.timer_next_activation.is_set or self.timer_next_activation.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.timer_next_activation.get_name_leafdata())
                            if (self.timer_type.is_set or self.timer_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.timer_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "timer-activations" or name == "timer-expirations" or name == "timer-next-activation" or name == "timer-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "timer-activations"):
                                self.timer_activations = value
                                self.timer_activations.value_namespace = name_space
                                self.timer_activations.value_namespace_prefix = name_space_prefix
                            if(value_path == "timer-expirations"):
                                self.timer_expirations = value
                                self.timer_expirations.value_namespace = name_space
                                self.timer_expirations.value_namespace_prefix = name_space_prefix
                            if(value_path == "timer-next-activation"):
                                self.timer_next_activation = value
                                self.timer_next_activation.value_namespace = name_space
                                self.timer_next_activation.value_namespace_prefix = name_space_prefix
                            if(value_path == "timer-type"):
                                self.timer_type = value
                                self.timer_type.value_namespace = name_space
                                self.timer_type.value_namespace_prefix = name_space_prefix


                    class SackBlk(Entity):
                        """
                        Seq nos. of sack blocks
                        
                        .. attribute:: end
                        
                        	End   seq no. of sack block
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start
                        
                        	Start seq no. of sack block
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SackBlk, self).__init__()

                            self.yang_name = "sack-blk"
                            self.yang_parent_name = "detail-information"

                            self.end = YLeaf(YType.uint32, "end")

                            self.start = YLeaf(YType.uint32, "start")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("end",
                                            "start") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SackBlk, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SackBlk, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.end.is_set or
                                self.start.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.end.yfilter != YFilter.not_set or
                                self.start.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sack-blk" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.end.is_set or self.end.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.end.get_name_leafdata())
                            if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "end" or name == "start"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "end"):
                                self.end = value
                                self.end.value_namespace = name_space
                                self.end.value_namespace_prefix = name_space_prefix
                            if(value_path == "start"):
                                self.start = value
                                self.start.value_namespace = name_space
                                self.start.value_namespace_prefix = name_space_prefix


                    class SendSackHole(Entity):
                        """
                        Sorted list of sack holes
                        
                        .. attribute:: duplicated_ack
                        
                        	Number of dup (s)acks for this hole
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: end
                        
                        	End   seq no. of hole
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: retransmitted
                        
                        	Next seq. no in hole to be retransmitted
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start
                        
                        	Start seq no. of hole
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendSackHole, self).__init__()

                            self.yang_name = "send-sack-hole"
                            self.yang_parent_name = "detail-information"

                            self.duplicated_ack = YLeaf(YType.uint32, "duplicated-ack")

                            self.end = YLeaf(YType.uint32, "end")

                            self.retransmitted = YLeaf(YType.uint32, "retransmitted")

                            self.start = YLeaf(YType.uint32, "start")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("duplicated_ack",
                                            "end",
                                            "retransmitted",
                                            "start") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendSackHole, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendSackHole, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.duplicated_ack.is_set or
                                self.end.is_set or
                                self.retransmitted.is_set or
                                self.start.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.duplicated_ack.yfilter != YFilter.not_set or
                                self.end.yfilter != YFilter.not_set or
                                self.retransmitted.yfilter != YFilter.not_set or
                                self.start.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "send-sack-hole" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.duplicated_ack.is_set or self.duplicated_ack.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.duplicated_ack.get_name_leafdata())
                            if (self.end.is_set or self.end.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.end.get_name_leafdata())
                            if (self.retransmitted.is_set or self.retransmitted.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.retransmitted.get_name_leafdata())
                            if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "duplicated-ack" or name == "end" or name == "retransmitted" or name == "start"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "duplicated-ack"):
                                self.duplicated_ack = value
                                self.duplicated_ack.value_namespace = name_space
                                self.duplicated_ack.value_namespace_prefix = name_space_prefix
                            if(value_path == "end"):
                                self.end = value
                                self.end.value_namespace = name_space
                                self.end.value_namespace_prefix = name_space_prefix
                            if(value_path == "retransmitted"):
                                self.retransmitted = value
                                self.retransmitted.value_namespace = name_space
                                self.retransmitted.value_namespace_prefix = name_space_prefix
                            if(value_path == "start"):
                                self.start = value
                                self.start.value_namespace = name_space
                                self.start.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.sack_blk:
                            if (c.has_data()):
                                return True
                        for c in self.send_sack_hole:
                            if (c.has_data()):
                                return True
                        for c in self.timer:
                            if (c.has_data()):
                                return True
                        for leaf in self.fib_label_output.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.fib_pd_ctx.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.pcb_id.is_set or
                            self.ack_hold_time.is_set or
                            self.address_family.is_set or
                            self.auto_rearm.is_set or
                            self.connect_retries.is_set or
                            self.connect_retry_interval.is_set or
                            self.connection_state.is_set or
                            self.current_receive_queue_packet_size.is_set or
                            self.current_receive_queue_size.is_set or
                            self.current_send_queue_size.is_set or
                            self.established_time.is_set or
                            self.fib_pd_ctx_size.is_set or
                            self.foreign_port.is_set or
                            self.giveup_time.is_set or
                            self.hash_index.is_set or
                            self.is_retrans_forever.is_set or
                            self.keep_alive_time.is_set or
                            self.krtt.is_set or
                            self.last_ack_sent.is_set or
                            self.local_app_instance.is_set or
                            self.local_pid.is_set or
                            self.local_port.is_set or
                            self.max_mss.is_set or
                            self.max_receive_queue_packet_size.is_set or
                            self.max_receive_queue_size.is_set or
                            self.max_rtt.is_set or
                            self.max_send_queue_size.is_set or
                            self.min_mss.is_set or
                            self.min_rtt.is_set or
                            self.mss.is_set or
                            self.num_labels.is_set or
                            self.output_ifhandle.is_set or
                            self.packet_priority.is_set or
                            self.packet_tos.is_set or
                            self.packet_ttl.is_set or
                            self.pcb.is_set or
                            self.peer_mss.is_set or
                            self.queue_length.is_set or
                            self.queue_limit.is_set or
                            self.queue_zero_length.is_set or
                            self.receive_adv_window_size.is_set or
                            self.receive_initial_sequence_num.is_set or
                            self.receive_next_sequence_num.is_set or
                            self.receive_window_scale.is_set or
                            self.receive_window_size.is_set or
                            self.recvbuf_datasize.is_set or
                            self.recvbuf_hiwat.is_set or
                            self.recvbuf_lowwat.is_set or
                            self.request_receive_window_scale.is_set or
                            self.retries.is_set or
                            self.rqst_send_wnd_scale.is_set or
                            self.rtto.is_set or
                            self.rxsy_naclname.is_set or
                            self.save_queue_size.is_set or
                            self.send_congestion_window_size.is_set or
                            self.send_initial_sequence_num.is_set or
                            self.send_max_sequence_num.is_set or
                            self.send_next_sequence_num.is_set or
                            self.send_pdu_count.is_set or
                            self.send_unack_sequence_num.is_set or
                            self.send_window_scale.is_set or
                            self.send_window_size.is_set or
                            self.sendbuf_hiwat.is_set or
                            self.sendbuf_lowwat.is_set or
                            self.sendbuf_notify_thresh.is_set or
                            self.so.is_set or
                            self.sock_error.is_set or
                            self.socket_error.is_set or
                            self.soft_error.is_set or
                            self.srtt.is_set or
                            self.srtv.is_set or
                            self.syn_wait_time.is_set or
                            self.tcpcb.is_set or
                            self.time_stamp_recent.is_set or
                            self.time_stamp_recent_age.is_set or
                            self.vrf_id.is_set or
                            (self.feature_flags is not None and self.feature_flags.has_data()) or
                            (self.foreign_address is not None and self.foreign_address.has_data()) or
                            (self.local_address is not None and self.local_address.has_data()) or
                            (self.receive_buf_state_flags is not None and self.receive_buf_state_flags.has_data()) or
                            (self.request_flags is not None and self.request_flags.has_data()) or
                            (self.send_buf_state_flags is not None and self.send_buf_state_flags.has_data()) or
                            (self.socket_option_flags is not None and self.socket_option_flags.has_data()) or
                            (self.socket_state_flags is not None and self.socket_state_flags.has_data()) or
                            (self.state_flags is not None and self.state_flags.has_data()))

                    def has_operation(self):
                        for c in self.sack_blk:
                            if (c.has_operation()):
                                return True
                        for c in self.send_sack_hole:
                            if (c.has_operation()):
                                return True
                        for c in self.timer:
                            if (c.has_operation()):
                                return True
                        for leaf in self.fib_label_output.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.fib_pd_ctx.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pcb_id.yfilter != YFilter.not_set or
                            self.ack_hold_time.yfilter != YFilter.not_set or
                            self.address_family.yfilter != YFilter.not_set or
                            self.auto_rearm.yfilter != YFilter.not_set or
                            self.connect_retries.yfilter != YFilter.not_set or
                            self.connect_retry_interval.yfilter != YFilter.not_set or
                            self.connection_state.yfilter != YFilter.not_set or
                            self.current_receive_queue_packet_size.yfilter != YFilter.not_set or
                            self.current_receive_queue_size.yfilter != YFilter.not_set or
                            self.current_send_queue_size.yfilter != YFilter.not_set or
                            self.established_time.yfilter != YFilter.not_set or
                            self.fib_label_output.yfilter != YFilter.not_set or
                            self.fib_pd_ctx.yfilter != YFilter.not_set or
                            self.fib_pd_ctx_size.yfilter != YFilter.not_set or
                            self.foreign_port.yfilter != YFilter.not_set or
                            self.giveup_time.yfilter != YFilter.not_set or
                            self.hash_index.yfilter != YFilter.not_set or
                            self.is_retrans_forever.yfilter != YFilter.not_set or
                            self.keep_alive_time.yfilter != YFilter.not_set or
                            self.krtt.yfilter != YFilter.not_set or
                            self.last_ack_sent.yfilter != YFilter.not_set or
                            self.local_app_instance.yfilter != YFilter.not_set or
                            self.local_pid.yfilter != YFilter.not_set or
                            self.local_port.yfilter != YFilter.not_set or
                            self.max_mss.yfilter != YFilter.not_set or
                            self.max_receive_queue_packet_size.yfilter != YFilter.not_set or
                            self.max_receive_queue_size.yfilter != YFilter.not_set or
                            self.max_rtt.yfilter != YFilter.not_set or
                            self.max_send_queue_size.yfilter != YFilter.not_set or
                            self.min_mss.yfilter != YFilter.not_set or
                            self.min_rtt.yfilter != YFilter.not_set or
                            self.mss.yfilter != YFilter.not_set or
                            self.num_labels.yfilter != YFilter.not_set or
                            self.output_ifhandle.yfilter != YFilter.not_set or
                            self.packet_priority.yfilter != YFilter.not_set or
                            self.packet_tos.yfilter != YFilter.not_set or
                            self.packet_ttl.yfilter != YFilter.not_set or
                            self.pcb.yfilter != YFilter.not_set or
                            self.peer_mss.yfilter != YFilter.not_set or
                            self.queue_length.yfilter != YFilter.not_set or
                            self.queue_limit.yfilter != YFilter.not_set or
                            self.queue_zero_length.yfilter != YFilter.not_set or
                            self.receive_adv_window_size.yfilter != YFilter.not_set or
                            self.receive_initial_sequence_num.yfilter != YFilter.not_set or
                            self.receive_next_sequence_num.yfilter != YFilter.not_set or
                            self.receive_window_scale.yfilter != YFilter.not_set or
                            self.receive_window_size.yfilter != YFilter.not_set or
                            self.recvbuf_datasize.yfilter != YFilter.not_set or
                            self.recvbuf_hiwat.yfilter != YFilter.not_set or
                            self.recvbuf_lowwat.yfilter != YFilter.not_set or
                            self.request_receive_window_scale.yfilter != YFilter.not_set or
                            self.retries.yfilter != YFilter.not_set or
                            self.rqst_send_wnd_scale.yfilter != YFilter.not_set or
                            self.rtto.yfilter != YFilter.not_set or
                            self.rxsy_naclname.yfilter != YFilter.not_set or
                            self.save_queue_size.yfilter != YFilter.not_set or
                            self.send_congestion_window_size.yfilter != YFilter.not_set or
                            self.send_initial_sequence_num.yfilter != YFilter.not_set or
                            self.send_max_sequence_num.yfilter != YFilter.not_set or
                            self.send_next_sequence_num.yfilter != YFilter.not_set or
                            self.send_pdu_count.yfilter != YFilter.not_set or
                            self.send_unack_sequence_num.yfilter != YFilter.not_set or
                            self.send_window_scale.yfilter != YFilter.not_set or
                            self.send_window_size.yfilter != YFilter.not_set or
                            self.sendbuf_hiwat.yfilter != YFilter.not_set or
                            self.sendbuf_lowwat.yfilter != YFilter.not_set or
                            self.sendbuf_notify_thresh.yfilter != YFilter.not_set or
                            self.so.yfilter != YFilter.not_set or
                            self.sock_error.yfilter != YFilter.not_set or
                            self.socket_error.yfilter != YFilter.not_set or
                            self.soft_error.yfilter != YFilter.not_set or
                            self.srtt.yfilter != YFilter.not_set or
                            self.srtv.yfilter != YFilter.not_set or
                            self.syn_wait_time.yfilter != YFilter.not_set or
                            self.tcpcb.yfilter != YFilter.not_set or
                            self.time_stamp_recent.yfilter != YFilter.not_set or
                            self.time_stamp_recent_age.yfilter != YFilter.not_set or
                            self.vrf_id.yfilter != YFilter.not_set or
                            (self.feature_flags is not None and self.feature_flags.has_operation()) or
                            (self.foreign_address is not None and self.foreign_address.has_operation()) or
                            (self.local_address is not None and self.local_address.has_operation()) or
                            (self.receive_buf_state_flags is not None and self.receive_buf_state_flags.has_operation()) or
                            (self.request_flags is not None and self.request_flags.has_operation()) or
                            (self.send_buf_state_flags is not None and self.send_buf_state_flags.has_operation()) or
                            (self.socket_option_flags is not None and self.socket_option_flags.has_operation()) or
                            (self.socket_state_flags is not None and self.socket_state_flags.has_operation()) or
                            (self.state_flags is not None and self.state_flags.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "detail-information" + "[pcb-id='" + self.pcb_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pcb_id.is_set or self.pcb_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcb_id.get_name_leafdata())
                        if (self.ack_hold_time.is_set or self.ack_hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ack_hold_time.get_name_leafdata())
                        if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address_family.get_name_leafdata())
                        if (self.auto_rearm.is_set or self.auto_rearm.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.auto_rearm.get_name_leafdata())
                        if (self.connect_retries.is_set or self.connect_retries.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connect_retries.get_name_leafdata())
                        if (self.connect_retry_interval.is_set or self.connect_retry_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connect_retry_interval.get_name_leafdata())
                        if (self.connection_state.is_set or self.connection_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connection_state.get_name_leafdata())
                        if (self.current_receive_queue_packet_size.is_set or self.current_receive_queue_packet_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.current_receive_queue_packet_size.get_name_leafdata())
                        if (self.current_receive_queue_size.is_set or self.current_receive_queue_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.current_receive_queue_size.get_name_leafdata())
                        if (self.current_send_queue_size.is_set or self.current_send_queue_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.current_send_queue_size.get_name_leafdata())
                        if (self.established_time.is_set or self.established_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.established_time.get_name_leafdata())
                        if (self.fib_pd_ctx_size.is_set or self.fib_pd_ctx_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.fib_pd_ctx_size.get_name_leafdata())
                        if (self.foreign_port.is_set or self.foreign_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.foreign_port.get_name_leafdata())
                        if (self.giveup_time.is_set or self.giveup_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.giveup_time.get_name_leafdata())
                        if (self.hash_index.is_set or self.hash_index.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hash_index.get_name_leafdata())
                        if (self.is_retrans_forever.is_set or self.is_retrans_forever.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_retrans_forever.get_name_leafdata())
                        if (self.keep_alive_time.is_set or self.keep_alive_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_time.get_name_leafdata())
                        if (self.krtt.is_set or self.krtt.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.krtt.get_name_leafdata())
                        if (self.last_ack_sent.is_set or self.last_ack_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_ack_sent.get_name_leafdata())
                        if (self.local_app_instance.is_set or self.local_app_instance.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_app_instance.get_name_leafdata())
                        if (self.local_pid.is_set or self.local_pid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_pid.get_name_leafdata())
                        if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_port.get_name_leafdata())
                        if (self.max_mss.is_set or self.max_mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_mss.get_name_leafdata())
                        if (self.max_receive_queue_packet_size.is_set or self.max_receive_queue_packet_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_receive_queue_packet_size.get_name_leafdata())
                        if (self.max_receive_queue_size.is_set or self.max_receive_queue_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_receive_queue_size.get_name_leafdata())
                        if (self.max_rtt.is_set or self.max_rtt.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_rtt.get_name_leafdata())
                        if (self.max_send_queue_size.is_set or self.max_send_queue_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_send_queue_size.get_name_leafdata())
                        if (self.min_mss.is_set or self.min_mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.min_mss.get_name_leafdata())
                        if (self.min_rtt.is_set or self.min_rtt.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.min_rtt.get_name_leafdata())
                        if (self.mss.is_set or self.mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mss.get_name_leafdata())
                        if (self.num_labels.is_set or self.num_labels.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_labels.get_name_leafdata())
                        if (self.output_ifhandle.is_set or self.output_ifhandle.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_ifhandle.get_name_leafdata())
                        if (self.packet_priority.is_set or self.packet_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packet_priority.get_name_leafdata())
                        if (self.packet_tos.is_set or self.packet_tos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packet_tos.get_name_leafdata())
                        if (self.packet_ttl.is_set or self.packet_ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packet_ttl.get_name_leafdata())
                        if (self.pcb.is_set or self.pcb.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcb.get_name_leafdata())
                        if (self.peer_mss.is_set or self.peer_mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_mss.get_name_leafdata())
                        if (self.queue_length.is_set or self.queue_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.queue_length.get_name_leafdata())
                        if (self.queue_limit.is_set or self.queue_limit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.queue_limit.get_name_leafdata())
                        if (self.queue_zero_length.is_set or self.queue_zero_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.queue_zero_length.get_name_leafdata())
                        if (self.receive_adv_window_size.is_set or self.receive_adv_window_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive_adv_window_size.get_name_leafdata())
                        if (self.receive_initial_sequence_num.is_set or self.receive_initial_sequence_num.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive_initial_sequence_num.get_name_leafdata())
                        if (self.receive_next_sequence_num.is_set or self.receive_next_sequence_num.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive_next_sequence_num.get_name_leafdata())
                        if (self.receive_window_scale.is_set or self.receive_window_scale.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive_window_scale.get_name_leafdata())
                        if (self.receive_window_size.is_set or self.receive_window_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive_window_size.get_name_leafdata())
                        if (self.recvbuf_datasize.is_set or self.recvbuf_datasize.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recvbuf_datasize.get_name_leafdata())
                        if (self.recvbuf_hiwat.is_set or self.recvbuf_hiwat.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recvbuf_hiwat.get_name_leafdata())
                        if (self.recvbuf_lowwat.is_set or self.recvbuf_lowwat.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recvbuf_lowwat.get_name_leafdata())
                        if (self.request_receive_window_scale.is_set or self.request_receive_window_scale.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.request_receive_window_scale.get_name_leafdata())
                        if (self.retries.is_set or self.retries.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.retries.get_name_leafdata())
                        if (self.rqst_send_wnd_scale.is_set or self.rqst_send_wnd_scale.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rqst_send_wnd_scale.get_name_leafdata())
                        if (self.rtto.is_set or self.rtto.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rtto.get_name_leafdata())
                        if (self.rxsy_naclname.is_set or self.rxsy_naclname.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rxsy_naclname.get_name_leafdata())
                        if (self.save_queue_size.is_set or self.save_queue_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.save_queue_size.get_name_leafdata())
                        if (self.send_congestion_window_size.is_set or self.send_congestion_window_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_congestion_window_size.get_name_leafdata())
                        if (self.send_initial_sequence_num.is_set or self.send_initial_sequence_num.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_initial_sequence_num.get_name_leafdata())
                        if (self.send_max_sequence_num.is_set or self.send_max_sequence_num.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_max_sequence_num.get_name_leafdata())
                        if (self.send_next_sequence_num.is_set or self.send_next_sequence_num.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_next_sequence_num.get_name_leafdata())
                        if (self.send_pdu_count.is_set or self.send_pdu_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_pdu_count.get_name_leafdata())
                        if (self.send_unack_sequence_num.is_set or self.send_unack_sequence_num.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_unack_sequence_num.get_name_leafdata())
                        if (self.send_window_scale.is_set or self.send_window_scale.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_window_scale.get_name_leafdata())
                        if (self.send_window_size.is_set or self.send_window_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_window_size.get_name_leafdata())
                        if (self.sendbuf_hiwat.is_set or self.sendbuf_hiwat.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sendbuf_hiwat.get_name_leafdata())
                        if (self.sendbuf_lowwat.is_set or self.sendbuf_lowwat.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sendbuf_lowwat.get_name_leafdata())
                        if (self.sendbuf_notify_thresh.is_set or self.sendbuf_notify_thresh.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sendbuf_notify_thresh.get_name_leafdata())
                        if (self.so.is_set or self.so.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.so.get_name_leafdata())
                        if (self.sock_error.is_set or self.sock_error.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sock_error.get_name_leafdata())
                        if (self.socket_error.is_set or self.socket_error.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.socket_error.get_name_leafdata())
                        if (self.soft_error.is_set or self.soft_error.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.soft_error.get_name_leafdata())
                        if (self.srtt.is_set or self.srtt.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.srtt.get_name_leafdata())
                        if (self.srtv.is_set or self.srtv.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.srtv.get_name_leafdata())
                        if (self.syn_wait_time.is_set or self.syn_wait_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.syn_wait_time.get_name_leafdata())
                        if (self.tcpcb.is_set or self.tcpcb.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcpcb.get_name_leafdata())
                        if (self.time_stamp_recent.is_set or self.time_stamp_recent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.time_stamp_recent.get_name_leafdata())
                        if (self.time_stamp_recent_age.is_set or self.time_stamp_recent_age.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.time_stamp_recent_age.get_name_leafdata())
                        if (self.vrf_id.is_set or self.vrf_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_id.get_name_leafdata())

                        leaf_name_data.extend(self.fib_label_output.get_name_leafdata())

                        leaf_name_data.extend(self.fib_pd_ctx.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "feature-flags"):
                            if (self.feature_flags is None):
                                self.feature_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.FeatureFlags()
                                self.feature_flags.parent = self
                                self._children_name_map["feature_flags"] = "feature-flags"
                            return self.feature_flags

                        if (child_yang_name == "foreign-address"):
                            if (self.foreign_address is None):
                                self.foreign_address = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ForeignAddress()
                                self.foreign_address.parent = self
                                self._children_name_map["foreign_address"] = "foreign-address"
                            return self.foreign_address

                        if (child_yang_name == "local-address"):
                            if (self.local_address is None):
                                self.local_address = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.LocalAddress()
                                self.local_address.parent = self
                                self._children_name_map["local_address"] = "local-address"
                            return self.local_address

                        if (child_yang_name == "receive-buf-state-flags"):
                            if (self.receive_buf_state_flags is None):
                                self.receive_buf_state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.ReceiveBufStateFlags()
                                self.receive_buf_state_flags.parent = self
                                self._children_name_map["receive_buf_state_flags"] = "receive-buf-state-flags"
                            return self.receive_buf_state_flags

                        if (child_yang_name == "request-flags"):
                            if (self.request_flags is None):
                                self.request_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.RequestFlags()
                                self.request_flags.parent = self
                                self._children_name_map["request_flags"] = "request-flags"
                            return self.request_flags

                        if (child_yang_name == "sack-blk"):
                            for c in self.sack_blk:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SackBlk()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.sack_blk.append(c)
                            return c

                        if (child_yang_name == "send-buf-state-flags"):
                            if (self.send_buf_state_flags is None):
                                self.send_buf_state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendBufStateFlags()
                                self.send_buf_state_flags.parent = self
                                self._children_name_map["send_buf_state_flags"] = "send-buf-state-flags"
                            return self.send_buf_state_flags

                        if (child_yang_name == "send-sack-hole"):
                            for c in self.send_sack_hole:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SendSackHole()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.send_sack_hole.append(c)
                            return c

                        if (child_yang_name == "socket-option-flags"):
                            if (self.socket_option_flags is None):
                                self.socket_option_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketOptionFlags()
                                self.socket_option_flags.parent = self
                                self._children_name_map["socket_option_flags"] = "socket-option-flags"
                            return self.socket_option_flags

                        if (child_yang_name == "socket-state-flags"):
                            if (self.socket_state_flags is None):
                                self.socket_state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.SocketStateFlags()
                                self.socket_state_flags.parent = self
                                self._children_name_map["socket_state_flags"] = "socket-state-flags"
                            return self.socket_state_flags

                        if (child_yang_name == "state-flags"):
                            if (self.state_flags is None):
                                self.state_flags = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.StateFlags()
                                self.state_flags.parent = self
                                self._children_name_map["state_flags"] = "state-flags"
                            return self.state_flags

                        if (child_yang_name == "timer"):
                            for c in self.timer:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpConnection.Nodes.Node.DetailInformations.DetailInformation.Timer()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.timer.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "feature-flags" or name == "foreign-address" or name == "local-address" or name == "receive-buf-state-flags" or name == "request-flags" or name == "sack-blk" or name == "send-buf-state-flags" or name == "send-sack-hole" or name == "socket-option-flags" or name == "socket-state-flags" or name == "state-flags" or name == "timer" or name == "pcb-id" or name == "ack-hold-time" or name == "address-family" or name == "auto-rearm" or name == "connect-retries" or name == "connect-retry-interval" or name == "connection-state" or name == "current-receive-queue-packet-size" or name == "current-receive-queue-size" or name == "current-send-queue-size" or name == "established-time" or name == "fib-label-output" or name == "fib-pd-ctx" or name == "fib-pd-ctx-size" or name == "foreign-port" or name == "giveup-time" or name == "hash-index" or name == "is-retrans-forever" or name == "keep-alive-time" or name == "krtt" or name == "last-ack-sent" or name == "local-app-instance" or name == "local-pid" or name == "local-port" or name == "max-mss" or name == "max-receive-queue-packet-size" or name == "max-receive-queue-size" or name == "max-rtt" or name == "max-send-queue-size" or name == "min-mss" or name == "min-rtt" or name == "mss" or name == "num-labels" or name == "output-ifhandle" or name == "packet-priority" or name == "packet-tos" or name == "packet-ttl" or name == "pcb" or name == "peer-mss" or name == "queue-length" or name == "queue-limit" or name == "queue-zero-length" or name == "receive-adv-window-size" or name == "receive-initial-sequence-num" or name == "receive-next-sequence-num" or name == "receive-window-scale" or name == "receive-window-size" or name == "recvbuf-datasize" or name == "recvbuf-hiwat" or name == "recvbuf-lowwat" or name == "request-receive-window-scale" or name == "retries" or name == "rqst-send-wnd-scale" or name == "rtto" or name == "rxsy-naclname" or name == "save-queue-size" or name == "send-congestion-window-size" or name == "send-initial-sequence-num" or name == "send-max-sequence-num" or name == "send-next-sequence-num" or name == "send-pdu-count" or name == "send-unack-sequence-num" or name == "send-window-scale" or name == "send-window-size" or name == "sendbuf-hiwat" or name == "sendbuf-lowwat" or name == "sendbuf-notify-thresh" or name == "so" or name == "sock-error" or name == "socket-error" or name == "soft-error" or name == "srtt" or name == "srtv" or name == "syn-wait-time" or name == "tcpcb" or name == "time-stamp-recent" or name == "time-stamp-recent-age" or name == "vrf-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pcb-id"):
                            self.pcb_id = value
                            self.pcb_id.value_namespace = name_space
                            self.pcb_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ack-hold-time"):
                            self.ack_hold_time = value
                            self.ack_hold_time.value_namespace = name_space
                            self.ack_hold_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "address-family"):
                            self.address_family = value
                            self.address_family.value_namespace = name_space
                            self.address_family.value_namespace_prefix = name_space_prefix
                        if(value_path == "auto-rearm"):
                            self.auto_rearm = value
                            self.auto_rearm.value_namespace = name_space
                            self.auto_rearm.value_namespace_prefix = name_space_prefix
                        if(value_path == "connect-retries"):
                            self.connect_retries = value
                            self.connect_retries.value_namespace = name_space
                            self.connect_retries.value_namespace_prefix = name_space_prefix
                        if(value_path == "connect-retry-interval"):
                            self.connect_retry_interval = value
                            self.connect_retry_interval.value_namespace = name_space
                            self.connect_retry_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "connection-state"):
                            self.connection_state = value
                            self.connection_state.value_namespace = name_space
                            self.connection_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "current-receive-queue-packet-size"):
                            self.current_receive_queue_packet_size = value
                            self.current_receive_queue_packet_size.value_namespace = name_space
                            self.current_receive_queue_packet_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "current-receive-queue-size"):
                            self.current_receive_queue_size = value
                            self.current_receive_queue_size.value_namespace = name_space
                            self.current_receive_queue_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "current-send-queue-size"):
                            self.current_send_queue_size = value
                            self.current_send_queue_size.value_namespace = name_space
                            self.current_send_queue_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "established-time"):
                            self.established_time = value
                            self.established_time.value_namespace = name_space
                            self.established_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "fib-label-output"):
                            self.fib_label_output.append(value)
                        if(value_path == "fib-pd-ctx"):
                            self.fib_pd_ctx.append(value)
                        if(value_path == "fib-pd-ctx-size"):
                            self.fib_pd_ctx_size = value
                            self.fib_pd_ctx_size.value_namespace = name_space
                            self.fib_pd_ctx_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "foreign-port"):
                            self.foreign_port = value
                            self.foreign_port.value_namespace = name_space
                            self.foreign_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "giveup-time"):
                            self.giveup_time = value
                            self.giveup_time.value_namespace = name_space
                            self.giveup_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "hash-index"):
                            self.hash_index = value
                            self.hash_index.value_namespace = name_space
                            self.hash_index.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-retrans-forever"):
                            self.is_retrans_forever = value
                            self.is_retrans_forever.value_namespace = name_space
                            self.is_retrans_forever.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-time"):
                            self.keep_alive_time = value
                            self.keep_alive_time.value_namespace = name_space
                            self.keep_alive_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "krtt"):
                            self.krtt = value
                            self.krtt.value_namespace = name_space
                            self.krtt.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-ack-sent"):
                            self.last_ack_sent = value
                            self.last_ack_sent.value_namespace = name_space
                            self.last_ack_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-app-instance"):
                            self.local_app_instance = value
                            self.local_app_instance.value_namespace = name_space
                            self.local_app_instance.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-pid"):
                            self.local_pid = value
                            self.local_pid.value_namespace = name_space
                            self.local_pid.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-port"):
                            self.local_port = value
                            self.local_port.value_namespace = name_space
                            self.local_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "max-mss"):
                            self.max_mss = value
                            self.max_mss.value_namespace = name_space
                            self.max_mss.value_namespace_prefix = name_space_prefix
                        if(value_path == "max-receive-queue-packet-size"):
                            self.max_receive_queue_packet_size = value
                            self.max_receive_queue_packet_size.value_namespace = name_space
                            self.max_receive_queue_packet_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "max-receive-queue-size"):
                            self.max_receive_queue_size = value
                            self.max_receive_queue_size.value_namespace = name_space
                            self.max_receive_queue_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "max-rtt"):
                            self.max_rtt = value
                            self.max_rtt.value_namespace = name_space
                            self.max_rtt.value_namespace_prefix = name_space_prefix
                        if(value_path == "max-send-queue-size"):
                            self.max_send_queue_size = value
                            self.max_send_queue_size.value_namespace = name_space
                            self.max_send_queue_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "min-mss"):
                            self.min_mss = value
                            self.min_mss.value_namespace = name_space
                            self.min_mss.value_namespace_prefix = name_space_prefix
                        if(value_path == "min-rtt"):
                            self.min_rtt = value
                            self.min_rtt.value_namespace = name_space
                            self.min_rtt.value_namespace_prefix = name_space_prefix
                        if(value_path == "mss"):
                            self.mss = value
                            self.mss.value_namespace = name_space
                            self.mss.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-labels"):
                            self.num_labels = value
                            self.num_labels.value_namespace = name_space
                            self.num_labels.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-ifhandle"):
                            self.output_ifhandle = value
                            self.output_ifhandle.value_namespace = name_space
                            self.output_ifhandle.value_namespace_prefix = name_space_prefix
                        if(value_path == "packet-priority"):
                            self.packet_priority = value
                            self.packet_priority.value_namespace = name_space
                            self.packet_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "packet-tos"):
                            self.packet_tos = value
                            self.packet_tos.value_namespace = name_space
                            self.packet_tos.value_namespace_prefix = name_space_prefix
                        if(value_path == "packet-ttl"):
                            self.packet_ttl = value
                            self.packet_ttl.value_namespace = name_space
                            self.packet_ttl.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcb"):
                            self.pcb = value
                            self.pcb.value_namespace = name_space
                            self.pcb.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-mss"):
                            self.peer_mss = value
                            self.peer_mss.value_namespace = name_space
                            self.peer_mss.value_namespace_prefix = name_space_prefix
                        if(value_path == "queue-length"):
                            self.queue_length = value
                            self.queue_length.value_namespace = name_space
                            self.queue_length.value_namespace_prefix = name_space_prefix
                        if(value_path == "queue-limit"):
                            self.queue_limit = value
                            self.queue_limit.value_namespace = name_space
                            self.queue_limit.value_namespace_prefix = name_space_prefix
                        if(value_path == "queue-zero-length"):
                            self.queue_zero_length = value
                            self.queue_zero_length.value_namespace = name_space
                            self.queue_zero_length.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive-adv-window-size"):
                            self.receive_adv_window_size = value
                            self.receive_adv_window_size.value_namespace = name_space
                            self.receive_adv_window_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive-initial-sequence-num"):
                            self.receive_initial_sequence_num = value
                            self.receive_initial_sequence_num.value_namespace = name_space
                            self.receive_initial_sequence_num.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive-next-sequence-num"):
                            self.receive_next_sequence_num = value
                            self.receive_next_sequence_num.value_namespace = name_space
                            self.receive_next_sequence_num.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive-window-scale"):
                            self.receive_window_scale = value
                            self.receive_window_scale.value_namespace = name_space
                            self.receive_window_scale.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive-window-size"):
                            self.receive_window_size = value
                            self.receive_window_size.value_namespace = name_space
                            self.receive_window_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "recvbuf-datasize"):
                            self.recvbuf_datasize = value
                            self.recvbuf_datasize.value_namespace = name_space
                            self.recvbuf_datasize.value_namespace_prefix = name_space_prefix
                        if(value_path == "recvbuf-hiwat"):
                            self.recvbuf_hiwat = value
                            self.recvbuf_hiwat.value_namespace = name_space
                            self.recvbuf_hiwat.value_namespace_prefix = name_space_prefix
                        if(value_path == "recvbuf-lowwat"):
                            self.recvbuf_lowwat = value
                            self.recvbuf_lowwat.value_namespace = name_space
                            self.recvbuf_lowwat.value_namespace_prefix = name_space_prefix
                        if(value_path == "request-receive-window-scale"):
                            self.request_receive_window_scale = value
                            self.request_receive_window_scale.value_namespace = name_space
                            self.request_receive_window_scale.value_namespace_prefix = name_space_prefix
                        if(value_path == "retries"):
                            self.retries = value
                            self.retries.value_namespace = name_space
                            self.retries.value_namespace_prefix = name_space_prefix
                        if(value_path == "rqst-send-wnd-scale"):
                            self.rqst_send_wnd_scale = value
                            self.rqst_send_wnd_scale.value_namespace = name_space
                            self.rqst_send_wnd_scale.value_namespace_prefix = name_space_prefix
                        if(value_path == "rtto"):
                            self.rtto = value
                            self.rtto.value_namespace = name_space
                            self.rtto.value_namespace_prefix = name_space_prefix
                        if(value_path == "rxsy-naclname"):
                            self.rxsy_naclname = value
                            self.rxsy_naclname.value_namespace = name_space
                            self.rxsy_naclname.value_namespace_prefix = name_space_prefix
                        if(value_path == "save-queue-size"):
                            self.save_queue_size = value
                            self.save_queue_size.value_namespace = name_space
                            self.save_queue_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-congestion-window-size"):
                            self.send_congestion_window_size = value
                            self.send_congestion_window_size.value_namespace = name_space
                            self.send_congestion_window_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-initial-sequence-num"):
                            self.send_initial_sequence_num = value
                            self.send_initial_sequence_num.value_namespace = name_space
                            self.send_initial_sequence_num.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-max-sequence-num"):
                            self.send_max_sequence_num = value
                            self.send_max_sequence_num.value_namespace = name_space
                            self.send_max_sequence_num.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-next-sequence-num"):
                            self.send_next_sequence_num = value
                            self.send_next_sequence_num.value_namespace = name_space
                            self.send_next_sequence_num.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-pdu-count"):
                            self.send_pdu_count = value
                            self.send_pdu_count.value_namespace = name_space
                            self.send_pdu_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-unack-sequence-num"):
                            self.send_unack_sequence_num = value
                            self.send_unack_sequence_num.value_namespace = name_space
                            self.send_unack_sequence_num.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-window-scale"):
                            self.send_window_scale = value
                            self.send_window_scale.value_namespace = name_space
                            self.send_window_scale.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-window-size"):
                            self.send_window_size = value
                            self.send_window_size.value_namespace = name_space
                            self.send_window_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "sendbuf-hiwat"):
                            self.sendbuf_hiwat = value
                            self.sendbuf_hiwat.value_namespace = name_space
                            self.sendbuf_hiwat.value_namespace_prefix = name_space_prefix
                        if(value_path == "sendbuf-lowwat"):
                            self.sendbuf_lowwat = value
                            self.sendbuf_lowwat.value_namespace = name_space
                            self.sendbuf_lowwat.value_namespace_prefix = name_space_prefix
                        if(value_path == "sendbuf-notify-thresh"):
                            self.sendbuf_notify_thresh = value
                            self.sendbuf_notify_thresh.value_namespace = name_space
                            self.sendbuf_notify_thresh.value_namespace_prefix = name_space_prefix
                        if(value_path == "so"):
                            self.so = value
                            self.so.value_namespace = name_space
                            self.so.value_namespace_prefix = name_space_prefix
                        if(value_path == "sock-error"):
                            self.sock_error = value
                            self.sock_error.value_namespace = name_space
                            self.sock_error.value_namespace_prefix = name_space_prefix
                        if(value_path == "socket-error"):
                            self.socket_error = value
                            self.socket_error.value_namespace = name_space
                            self.socket_error.value_namespace_prefix = name_space_prefix
                        if(value_path == "soft-error"):
                            self.soft_error = value
                            self.soft_error.value_namespace = name_space
                            self.soft_error.value_namespace_prefix = name_space_prefix
                        if(value_path == "srtt"):
                            self.srtt = value
                            self.srtt.value_namespace = name_space
                            self.srtt.value_namespace_prefix = name_space_prefix
                        if(value_path == "srtv"):
                            self.srtv = value
                            self.srtv.value_namespace = name_space
                            self.srtv.value_namespace_prefix = name_space_prefix
                        if(value_path == "syn-wait-time"):
                            self.syn_wait_time = value
                            self.syn_wait_time.value_namespace = name_space
                            self.syn_wait_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcpcb"):
                            self.tcpcb = value
                            self.tcpcb.value_namespace = name_space
                            self.tcpcb.value_namespace_prefix = name_space_prefix
                        if(value_path == "time-stamp-recent"):
                            self.time_stamp_recent = value
                            self.time_stamp_recent.value_namespace = name_space
                            self.time_stamp_recent.value_namespace_prefix = name_space_prefix
                        if(value_path == "time-stamp-recent-age"):
                            self.time_stamp_recent_age = value
                            self.time_stamp_recent_age.value_namespace = name_space
                            self.time_stamp_recent_age.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-id"):
                            self.vrf_id = value
                            self.vrf_id.value_namespace = name_space
                            self.vrf_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.detail_information:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.detail_information:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "detail-informations" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "detail-information"):
                        for c in self.detail_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = TcpConnection.Nodes.Node.DetailInformations.DetailInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.detail_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "detail-information"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class BriefInformations(Entity):
                """
                Table listing connections for which brief
                information is provided.Note that not all
                connections are listed in the brief table.
                
                .. attribute:: brief_information
                
                	Brief information about a TCP connection
                	**type**\: list of    :py:class:`BriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.BriefInformations.BriefInformation>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpConnection.Nodes.Node.BriefInformations, self).__init__()

                    self.yang_name = "brief-informations"
                    self.yang_parent_name = "node"

                    self.brief_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(TcpConnection.Nodes.Node.BriefInformations, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(TcpConnection.Nodes.Node.BriefInformations, self).__setattr__(name, value)


                class BriefInformation(Entity):
                    """
                    Brief information about a TCP connection
                    
                    .. attribute:: pcb_id  <key>
                    
                    	Protocol Control Block ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: af_name
                    
                    	Address family
                    	**type**\:   :py:class:`TcpAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpAddressFamily>`
                    
                    .. attribute:: connection_state
                    
                    	Connection state
                    	**type**\:   :py:class:`TcpConnState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnState>`
                    
                    .. attribute:: current_receive_queue_size
                    
                    	Current receive queue size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: current_send_queue_size
                    
                    	Current send queue size in bytes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: byte
                    
                    .. attribute:: foreign_address
                    
                    	Foreign address
                    	**type**\:   :py:class:`ForeignAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.BriefInformations.BriefInformation.ForeignAddress>`
                    
                    .. attribute:: foreign_port
                    
                    	Foreign port
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: local_address
                    
                    	Local address
                    	**type**\:   :py:class:`LocalAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpConnection.Nodes.Node.BriefInformations.BriefInformation.LocalAddress>`
                    
                    .. attribute:: local_pid
                    
                    	Id of the local process
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: local_port
                    
                    	Local port
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: pcb
                    
                    	PCB Address
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: vrf_id
                    
                    	VRF ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation, self).__init__()

                        self.yang_name = "brief-information"
                        self.yang_parent_name = "brief-informations"

                        self.pcb_id = YLeaf(YType.uint32, "pcb-id")

                        self.af_name = YLeaf(YType.enumeration, "af-name")

                        self.connection_state = YLeaf(YType.enumeration, "connection-state")

                        self.current_receive_queue_size = YLeaf(YType.uint32, "current-receive-queue-size")

                        self.current_send_queue_size = YLeaf(YType.uint32, "current-send-queue-size")

                        self.foreign_port = YLeaf(YType.uint16, "foreign-port")

                        self.local_pid = YLeaf(YType.uint32, "local-pid")

                        self.local_port = YLeaf(YType.uint16, "local-port")

                        self.pcb = YLeaf(YType.uint64, "pcb")

                        self.vrf_id = YLeaf(YType.uint32, "vrf-id")

                        self.foreign_address = TcpConnection.Nodes.Node.BriefInformations.BriefInformation.ForeignAddress()
                        self.foreign_address.parent = self
                        self._children_name_map["foreign_address"] = "foreign-address"
                        self._children_yang_names.add("foreign-address")

                        self.local_address = TcpConnection.Nodes.Node.BriefInformations.BriefInformation.LocalAddress()
                        self.local_address.parent = self
                        self._children_name_map["local_address"] = "local-address"
                        self._children_yang_names.add("local-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pcb_id",
                                        "af_name",
                                        "connection_state",
                                        "current_receive_queue_size",
                                        "current_send_queue_size",
                                        "foreign_port",
                                        "local_pid",
                                        "local_port",
                                        "pcb",
                                        "vrf_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation, self).__setattr__(name, value)


                    class LocalAddress(Entity):
                        """
                        Local address
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`TcpAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpAddressFamily>`
                        
                        .. attribute:: ipv4_address
                        
                        	IPv4 Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6_address
                        
                        	IPv6 Address
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation.LocalAddress, self).__init__()

                            self.yang_name = "local-address"
                            self.yang_parent_name = "brief-information"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                            self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4_address",
                                            "ipv6_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation.LocalAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation.LocalAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4_address.is_set or
                                self.ipv6_address.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4_address.yfilter != YFilter.not_set or
                                self.ipv6_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "local-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                            if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4-address"):
                                self.ipv4_address = value
                                self.ipv4_address.value_namespace = name_space
                                self.ipv4_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6-address"):
                                self.ipv6_address = value
                                self.ipv6_address.value_namespace = name_space
                                self.ipv6_address.value_namespace_prefix = name_space_prefix


                    class ForeignAddress(Entity):
                        """
                        Foreign address
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`TcpAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpAddressFamily>`
                        
                        .. attribute:: ipv4_address
                        
                        	IPv4 Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6_address
                        
                        	IPv6 Address
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation.ForeignAddress, self).__init__()

                            self.yang_name = "foreign-address"
                            self.yang_parent_name = "brief-information"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                            self.ipv6_address = YLeaf(YType.str, "ipv6-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4_address",
                                            "ipv6_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation.ForeignAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpConnection.Nodes.Node.BriefInformations.BriefInformation.ForeignAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4_address.is_set or
                                self.ipv6_address.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4_address.yfilter != YFilter.not_set or
                                self.ipv6_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "foreign-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                            if (self.ipv6_address.is_set or self.ipv6_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4-address" or name == "ipv6-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4-address"):
                                self.ipv4_address = value
                                self.ipv4_address.value_namespace = name_space
                                self.ipv4_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6-address"):
                                self.ipv6_address = value
                                self.ipv6_address.value_namespace = name_space
                                self.ipv6_address.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.pcb_id.is_set or
                            self.af_name.is_set or
                            self.connection_state.is_set or
                            self.current_receive_queue_size.is_set or
                            self.current_send_queue_size.is_set or
                            self.foreign_port.is_set or
                            self.local_pid.is_set or
                            self.local_port.is_set or
                            self.pcb.is_set or
                            self.vrf_id.is_set or
                            (self.foreign_address is not None and self.foreign_address.has_data()) or
                            (self.local_address is not None and self.local_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pcb_id.yfilter != YFilter.not_set or
                            self.af_name.yfilter != YFilter.not_set or
                            self.connection_state.yfilter != YFilter.not_set or
                            self.current_receive_queue_size.yfilter != YFilter.not_set or
                            self.current_send_queue_size.yfilter != YFilter.not_set or
                            self.foreign_port.yfilter != YFilter.not_set or
                            self.local_pid.yfilter != YFilter.not_set or
                            self.local_port.yfilter != YFilter.not_set or
                            self.pcb.yfilter != YFilter.not_set or
                            self.vrf_id.yfilter != YFilter.not_set or
                            (self.foreign_address is not None and self.foreign_address.has_operation()) or
                            (self.local_address is not None and self.local_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-information" + "[pcb-id='" + self.pcb_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pcb_id.is_set or self.pcb_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcb_id.get_name_leafdata())
                        if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.af_name.get_name_leafdata())
                        if (self.connection_state.is_set or self.connection_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connection_state.get_name_leafdata())
                        if (self.current_receive_queue_size.is_set or self.current_receive_queue_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.current_receive_queue_size.get_name_leafdata())
                        if (self.current_send_queue_size.is_set or self.current_send_queue_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.current_send_queue_size.get_name_leafdata())
                        if (self.foreign_port.is_set or self.foreign_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.foreign_port.get_name_leafdata())
                        if (self.local_pid.is_set or self.local_pid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_pid.get_name_leafdata())
                        if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_port.get_name_leafdata())
                        if (self.pcb.is_set or self.pcb.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcb.get_name_leafdata())
                        if (self.vrf_id.is_set or self.vrf_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "foreign-address"):
                            if (self.foreign_address is None):
                                self.foreign_address = TcpConnection.Nodes.Node.BriefInformations.BriefInformation.ForeignAddress()
                                self.foreign_address.parent = self
                                self._children_name_map["foreign_address"] = "foreign-address"
                            return self.foreign_address

                        if (child_yang_name == "local-address"):
                            if (self.local_address is None):
                                self.local_address = TcpConnection.Nodes.Node.BriefInformations.BriefInformation.LocalAddress()
                                self.local_address.parent = self
                                self._children_name_map["local_address"] = "local-address"
                            return self.local_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "foreign-address" or name == "local-address" or name == "pcb-id" or name == "af-name" or name == "connection-state" or name == "current-receive-queue-size" or name == "current-send-queue-size" or name == "foreign-port" or name == "local-pid" or name == "local-port" or name == "pcb" or name == "vrf-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pcb-id"):
                            self.pcb_id = value
                            self.pcb_id.value_namespace = name_space
                            self.pcb_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "af-name"):
                            self.af_name = value
                            self.af_name.value_namespace = name_space
                            self.af_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "connection-state"):
                            self.connection_state = value
                            self.connection_state.value_namespace = name_space
                            self.connection_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "current-receive-queue-size"):
                            self.current_receive_queue_size = value
                            self.current_receive_queue_size.value_namespace = name_space
                            self.current_receive_queue_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "current-send-queue-size"):
                            self.current_send_queue_size = value
                            self.current_send_queue_size.value_namespace = name_space
                            self.current_send_queue_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "foreign-port"):
                            self.foreign_port = value
                            self.foreign_port.value_namespace = name_space
                            self.foreign_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-pid"):
                            self.local_pid = value
                            self.local_pid.value_namespace = name_space
                            self.local_pid.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-port"):
                            self.local_port = value
                            self.local_port.value_namespace = name_space
                            self.local_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcb"):
                            self.pcb = value
                            self.pcb.value_namespace = name_space
                            self.pcb.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-id"):
                            self.vrf_id = value
                            self.vrf_id.value_namespace = name_space
                            self.vrf_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.brief_information:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.brief_information:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "brief-informations" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-information"):
                        for c in self.brief_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = TcpConnection.Nodes.Node.BriefInformations.BriefInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.brief_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-information"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.id.is_set or
                    (self.brief_informations is not None and self.brief_informations.has_data()) or
                    (self.detail_informations is not None and self.detail_informations.has_data()) or
                    (self.extended_information is not None and self.extended_information.has_data()) or
                    (self.statistics is not None and self.statistics.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.id.yfilter != YFilter.not_set or
                    (self.brief_informations is not None and self.brief_informations.has_operation()) or
                    (self.detail_informations is not None and self.detail_informations.has_operation()) or
                    (self.extended_information is not None and self.extended_information.has_operation()) or
                    (self.statistics is not None and self.statistics.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[id='" + self.id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp-connection/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "brief-informations"):
                    if (self.brief_informations is None):
                        self.brief_informations = TcpConnection.Nodes.Node.BriefInformations()
                        self.brief_informations.parent = self
                        self._children_name_map["brief_informations"] = "brief-informations"
                    return self.brief_informations

                if (child_yang_name == "detail-informations"):
                    if (self.detail_informations is None):
                        self.detail_informations = TcpConnection.Nodes.Node.DetailInformations()
                        self.detail_informations.parent = self
                        self._children_name_map["detail_informations"] = "detail-informations"
                    return self.detail_informations

                if (child_yang_name == "extended-information"):
                    if (self.extended_information is None):
                        self.extended_information = TcpConnection.Nodes.Node.ExtendedInformation()
                        self.extended_information.parent = self
                        self._children_name_map["extended_information"] = "extended-information"
                    return self.extended_information

                if (child_yang_name == "statistics"):
                    if (self.statistics is None):
                        self.statistics = TcpConnection.Nodes.Node.Statistics()
                        self.statistics.parent = self
                        self._children_name_map["statistics"] = "statistics"
                    return self.statistics

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "brief-informations" or name == "detail-informations" or name == "extended-information" or name == "statistics" or name == "id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "id"):
                    self.id = value
                    self.id.value_namespace = name_space
                    self.id.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp-connection/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = TcpConnection.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (self.nodes is not None and self.nodes.has_data())

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.nodes is not None and self.nodes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp-connection" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = TcpConnection.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "nodes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = TcpConnection()
        return self._top_entity

class Tcp(Entity):
    """
    tcp
    
    .. attribute:: nodes
    
    	Node\-specific TCP operational data
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.Tcp.Nodes>`
    
    

    """

    _prefix = 'ip-tcp-oper'
    _revision = '2016-02-26'

    def __init__(self):
        super(Tcp, self).__init__()
        self._top_entity = None

        self.yang_name = "tcp"
        self.yang_parent_name = "Cisco-IOS-XR-ip-tcp-oper"

        self.nodes = Tcp.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")


    class Nodes(Entity):
        """
        Node\-specific TCP operational data
        
        .. attribute:: node
        
        	TCP operational data for a particular node
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.Tcp.Nodes.Node>`
        
        

        """

        _prefix = 'ip-tcp-oper'
        _revision = '2016-02-26'

        def __init__(self):
            super(Tcp.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "tcp"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Tcp.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Tcp.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            TCP operational data for a particular node
            
            .. attribute:: node_name  <key>
            
            	Node name
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: statistics
            
            	Statistical TCP operational data for a node
            	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.Tcp.Nodes.Node.Statistics>`
            
            

            """

            _prefix = 'ip-tcp-oper'
            _revision = '2016-02-26'

            def __init__(self):
                super(Tcp.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.node_name = YLeaf(YType.str, "node-name")

                self.statistics = Tcp.Nodes.Node.Statistics()
                self.statistics.parent = self
                self._children_name_map["statistics"] = "statistics"
                self._children_yang_names.add("statistics")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Tcp.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Tcp.Nodes.Node, self).__setattr__(name, value)


            class Statistics(Entity):
                """
                Statistical TCP operational data for a node
                
                .. attribute:: ipv4_traffic
                
                	TCP Traffic statistics for IPv4
                	**type**\:   :py:class:`Ipv4Traffic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.Tcp.Nodes.Node.Statistics.Ipv4Traffic>`
                
                .. attribute:: ipv6_traffic
                
                	TCP Traffic statistics for IPv6
                	**type**\:   :py:class:`Ipv6Traffic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.Tcp.Nodes.Node.Statistics.Ipv6Traffic>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(Tcp.Nodes.Node.Statistics, self).__init__()

                    self.yang_name = "statistics"
                    self.yang_parent_name = "node"

                    self.ipv4_traffic = Tcp.Nodes.Node.Statistics.Ipv4Traffic()
                    self.ipv4_traffic.parent = self
                    self._children_name_map["ipv4_traffic"] = "ipv4-traffic"
                    self._children_yang_names.add("ipv4-traffic")

                    self.ipv6_traffic = Tcp.Nodes.Node.Statistics.Ipv6Traffic()
                    self.ipv6_traffic.parent = self
                    self._children_name_map["ipv6_traffic"] = "ipv6-traffic"
                    self._children_yang_names.add("ipv6-traffic")


                class Ipv4Traffic(Entity):
                    """
                    TCP Traffic statistics for IPv4
                    
                    .. attribute:: tcp_checksum_error_packets
                    
                    	TCP packets with checksum errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_dropped_packets
                    
                    	TCP packets dropped (no port)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_input_packets
                    
                    	TCP packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_output_packets
                    
                    	TCP packets transmitted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_retransmitted_packets
                    
                    	TCP packets retransmitted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(Tcp.Nodes.Node.Statistics.Ipv4Traffic, self).__init__()

                        self.yang_name = "ipv4-traffic"
                        self.yang_parent_name = "statistics"

                        self.tcp_checksum_error_packets = YLeaf(YType.uint32, "tcp-checksum-error-packets")

                        self.tcp_dropped_packets = YLeaf(YType.uint32, "tcp-dropped-packets")

                        self.tcp_input_packets = YLeaf(YType.uint32, "tcp-input-packets")

                        self.tcp_output_packets = YLeaf(YType.uint32, "tcp-output-packets")

                        self.tcp_retransmitted_packets = YLeaf(YType.uint32, "tcp-retransmitted-packets")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("tcp_checksum_error_packets",
                                        "tcp_dropped_packets",
                                        "tcp_input_packets",
                                        "tcp_output_packets",
                                        "tcp_retransmitted_packets") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Tcp.Nodes.Node.Statistics.Ipv4Traffic, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Tcp.Nodes.Node.Statistics.Ipv4Traffic, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.tcp_checksum_error_packets.is_set or
                            self.tcp_dropped_packets.is_set or
                            self.tcp_input_packets.is_set or
                            self.tcp_output_packets.is_set or
                            self.tcp_retransmitted_packets.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.tcp_checksum_error_packets.yfilter != YFilter.not_set or
                            self.tcp_dropped_packets.yfilter != YFilter.not_set or
                            self.tcp_input_packets.yfilter != YFilter.not_set or
                            self.tcp_output_packets.yfilter != YFilter.not_set or
                            self.tcp_retransmitted_packets.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipv4-traffic" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.tcp_checksum_error_packets.is_set or self.tcp_checksum_error_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_checksum_error_packets.get_name_leafdata())
                        if (self.tcp_dropped_packets.is_set or self.tcp_dropped_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_dropped_packets.get_name_leafdata())
                        if (self.tcp_input_packets.is_set or self.tcp_input_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_input_packets.get_name_leafdata())
                        if (self.tcp_output_packets.is_set or self.tcp_output_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_output_packets.get_name_leafdata())
                        if (self.tcp_retransmitted_packets.is_set or self.tcp_retransmitted_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_retransmitted_packets.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "tcp-checksum-error-packets" or name == "tcp-dropped-packets" or name == "tcp-input-packets" or name == "tcp-output-packets" or name == "tcp-retransmitted-packets"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "tcp-checksum-error-packets"):
                            self.tcp_checksum_error_packets = value
                            self.tcp_checksum_error_packets.value_namespace = name_space
                            self.tcp_checksum_error_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-dropped-packets"):
                            self.tcp_dropped_packets = value
                            self.tcp_dropped_packets.value_namespace = name_space
                            self.tcp_dropped_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-input-packets"):
                            self.tcp_input_packets = value
                            self.tcp_input_packets.value_namespace = name_space
                            self.tcp_input_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-output-packets"):
                            self.tcp_output_packets = value
                            self.tcp_output_packets.value_namespace = name_space
                            self.tcp_output_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-retransmitted-packets"):
                            self.tcp_retransmitted_packets = value
                            self.tcp_retransmitted_packets.value_namespace = name_space
                            self.tcp_retransmitted_packets.value_namespace_prefix = name_space_prefix


                class Ipv6Traffic(Entity):
                    """
                    TCP Traffic statistics for IPv6
                    
                    .. attribute:: tcp_checksum_error_packets
                    
                    	TCP packets with checksum errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_dropped_packets
                    
                    	TCP packets dropped (no port)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_input_packets
                    
                    	TCP packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_output_packets
                    
                    	TCP packets transmitted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tcp_retransmitted_packets
                    
                    	TCP packets retransmitted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(Tcp.Nodes.Node.Statistics.Ipv6Traffic, self).__init__()

                        self.yang_name = "ipv6-traffic"
                        self.yang_parent_name = "statistics"

                        self.tcp_checksum_error_packets = YLeaf(YType.uint32, "tcp-checksum-error-packets")

                        self.tcp_dropped_packets = YLeaf(YType.uint32, "tcp-dropped-packets")

                        self.tcp_input_packets = YLeaf(YType.uint32, "tcp-input-packets")

                        self.tcp_output_packets = YLeaf(YType.uint32, "tcp-output-packets")

                        self.tcp_retransmitted_packets = YLeaf(YType.uint32, "tcp-retransmitted-packets")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("tcp_checksum_error_packets",
                                        "tcp_dropped_packets",
                                        "tcp_input_packets",
                                        "tcp_output_packets",
                                        "tcp_retransmitted_packets") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Tcp.Nodes.Node.Statistics.Ipv6Traffic, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Tcp.Nodes.Node.Statistics.Ipv6Traffic, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.tcp_checksum_error_packets.is_set or
                            self.tcp_dropped_packets.is_set or
                            self.tcp_input_packets.is_set or
                            self.tcp_output_packets.is_set or
                            self.tcp_retransmitted_packets.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.tcp_checksum_error_packets.yfilter != YFilter.not_set or
                            self.tcp_dropped_packets.yfilter != YFilter.not_set or
                            self.tcp_input_packets.yfilter != YFilter.not_set or
                            self.tcp_output_packets.yfilter != YFilter.not_set or
                            self.tcp_retransmitted_packets.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipv6-traffic" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.tcp_checksum_error_packets.is_set or self.tcp_checksum_error_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_checksum_error_packets.get_name_leafdata())
                        if (self.tcp_dropped_packets.is_set or self.tcp_dropped_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_dropped_packets.get_name_leafdata())
                        if (self.tcp_input_packets.is_set or self.tcp_input_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_input_packets.get_name_leafdata())
                        if (self.tcp_output_packets.is_set or self.tcp_output_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_output_packets.get_name_leafdata())
                        if (self.tcp_retransmitted_packets.is_set or self.tcp_retransmitted_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_retransmitted_packets.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "tcp-checksum-error-packets" or name == "tcp-dropped-packets" or name == "tcp-input-packets" or name == "tcp-output-packets" or name == "tcp-retransmitted-packets"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "tcp-checksum-error-packets"):
                            self.tcp_checksum_error_packets = value
                            self.tcp_checksum_error_packets.value_namespace = name_space
                            self.tcp_checksum_error_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-dropped-packets"):
                            self.tcp_dropped_packets = value
                            self.tcp_dropped_packets.value_namespace = name_space
                            self.tcp_dropped_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-input-packets"):
                            self.tcp_input_packets = value
                            self.tcp_input_packets.value_namespace = name_space
                            self.tcp_input_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-output-packets"):
                            self.tcp_output_packets = value
                            self.tcp_output_packets.value_namespace = name_space
                            self.tcp_output_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-retransmitted-packets"):
                            self.tcp_retransmitted_packets = value
                            self.tcp_retransmitted_packets.value_namespace = name_space
                            self.tcp_retransmitted_packets.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.ipv4_traffic is not None and self.ipv4_traffic.has_data()) or
                        (self.ipv6_traffic is not None and self.ipv6_traffic.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.ipv4_traffic is not None and self.ipv4_traffic.has_operation()) or
                        (self.ipv6_traffic is not None and self.ipv6_traffic.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "statistics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ipv4-traffic"):
                        if (self.ipv4_traffic is None):
                            self.ipv4_traffic = Tcp.Nodes.Node.Statistics.Ipv4Traffic()
                            self.ipv4_traffic.parent = self
                            self._children_name_map["ipv4_traffic"] = "ipv4-traffic"
                        return self.ipv4_traffic

                    if (child_yang_name == "ipv6-traffic"):
                        if (self.ipv6_traffic is None):
                            self.ipv6_traffic = Tcp.Nodes.Node.Statistics.Ipv6Traffic()
                            self.ipv6_traffic.parent = self
                            self._children_name_map["ipv6_traffic"] = "ipv6-traffic"
                        return self.ipv6_traffic

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ipv4-traffic" or name == "ipv6-traffic"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.node_name.is_set or
                    (self.statistics is not None and self.statistics.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_name.yfilter != YFilter.not_set or
                    (self.statistics is not None and self.statistics.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[node-name='" + self.node_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "statistics"):
                    if (self.statistics is None):
                        self.statistics = Tcp.Nodes.Node.Statistics()
                        self.statistics.parent = self
                        self._children_name_map["statistics"] = "statistics"
                    return self.statistics

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "statistics" or name == "node-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-name"):
                    self.node_name = value
                    self.node_name.value_namespace = name_space
                    self.node_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Tcp.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (self.nodes is not None and self.nodes.has_data())

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.nodes is not None and self.nodes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = Tcp.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "nodes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Tcp()
        return self._top_entity

class TcpNsr(Entity):
    """
    tcp nsr
    
    .. attribute:: nodes
    
    	Table of information about all nodes present on the system
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes>`
    
    

    """

    _prefix = 'ip-tcp-oper'
    _revision = '2016-02-26'

    def __init__(self):
        super(TcpNsr, self).__init__()
        self._top_entity = None

        self.yang_name = "tcp-nsr"
        self.yang_parent_name = "Cisco-IOS-XR-ip-tcp-oper"

        self.nodes = TcpNsr.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")


    class Nodes(Entity):
        """
        Table of information about all nodes present on
        the system
        
        .. attribute:: node
        
        	Information about a single node
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node>`
        
        

        """

        _prefix = 'ip-tcp-oper'
        _revision = '2016-02-26'

        def __init__(self):
            super(TcpNsr.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "tcp-nsr"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(TcpNsr.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(TcpNsr.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            Information about a single node
            
            .. attribute:: id  <key>
            
            	Describing a location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: client
            
            	Information about TCP NSR Client
            	**type**\:   :py:class:`Client <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Client>`
            
            .. attribute:: session
            
            	Information about TCP NSR Sessions
            	**type**\:   :py:class:`Session <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session>`
            
            .. attribute:: session_set
            
            	Information about TCP NSR Session Sets
            	**type**\:   :py:class:`SessionSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.SessionSet>`
            
            .. attribute:: statistics
            
            	Statis Information about TCP NSR connections
            	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics>`
            
            

            """

            _prefix = 'ip-tcp-oper'
            _revision = '2016-02-26'

            def __init__(self):
                super(TcpNsr.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.id = YLeaf(YType.str, "id")

                self.client = TcpNsr.Nodes.Node.Client()
                self.client.parent = self
                self._children_name_map["client"] = "client"
                self._children_yang_names.add("client")

                self.session = TcpNsr.Nodes.Node.Session()
                self.session.parent = self
                self._children_name_map["session"] = "session"
                self._children_yang_names.add("session")

                self.session_set = TcpNsr.Nodes.Node.SessionSet()
                self.session_set.parent = self
                self._children_name_map["session_set"] = "session-set"
                self._children_yang_names.add("session-set")

                self.statistics = TcpNsr.Nodes.Node.Statistics()
                self.statistics.parent = self
                self._children_name_map["statistics"] = "statistics"
                self._children_yang_names.add("statistics")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(TcpNsr.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(TcpNsr.Nodes.Node, self).__setattr__(name, value)


            class Session(Entity):
                """
                Information about TCP NSR Sessions
                
                .. attribute:: brief_sessions
                
                	Information about TCP NSR Sessions
                	**type**\:   :py:class:`BriefSessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session.BriefSessions>`
                
                .. attribute:: detail_sessions
                
                	Table about TCP NSR Sessions details
                	**type**\:   :py:class:`DetailSessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session.DetailSessions>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpNsr.Nodes.Node.Session, self).__init__()

                    self.yang_name = "session"
                    self.yang_parent_name = "node"

                    self.brief_sessions = TcpNsr.Nodes.Node.Session.BriefSessions()
                    self.brief_sessions.parent = self
                    self._children_name_map["brief_sessions"] = "brief-sessions"
                    self._children_yang_names.add("brief-sessions")

                    self.detail_sessions = TcpNsr.Nodes.Node.Session.DetailSessions()
                    self.detail_sessions.parent = self
                    self._children_name_map["detail_sessions"] = "detail-sessions"
                    self._children_yang_names.add("detail-sessions")


                class BriefSessions(Entity):
                    """
                    Information about TCP NSR Sessions
                    
                    .. attribute:: brief_session
                    
                    	Brief information about NSR Sessions
                    	**type**\: list of    :py:class:`BriefSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session.BriefSessions.BriefSession>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Session.BriefSessions, self).__init__()

                        self.yang_name = "brief-sessions"
                        self.yang_parent_name = "session"

                        self.brief_session = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Session.BriefSessions, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Session.BriefSessions, self).__setattr__(name, value)


                    class BriefSession(Entity):
                        """
                        Brief information about NSR Sessions
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR Sesison
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: address_family
                        
                        	Address family
                        	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                        
                        .. attribute:: foreign_address
                        
                        	Foreign address
                        	**type**\:  list of str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: foreign_port
                        
                        	Foreign port
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: is_admin_configured_up
                        
                        	Is NSR administratively configured?
                        	**type**\:  bool
                        
                        .. attribute:: is_ds_operational_up
                        
                        	Is Downstream NSR operational?
                        	**type**\:   :py:class:`NsrStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.NsrStatus>`
                        
                        .. attribute:: is_only_receive_path_replication
                        
                        	Is replication limited to receive\-path only
                        	**type**\:  bool
                        
                        .. attribute:: is_us_operational_up
                        
                        	Is Upstream NSR operational?
                        	**type**\:   :py:class:`NsrStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.NsrStatus>`
                        
                        .. attribute:: local_address
                        
                        	Local address
                        	**type**\:  list of str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: local_port
                        
                        	Local port
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: pcb
                        
                        	PCB Address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: sscb
                        
                        	SSCB Address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: vrf_id
                        
                        	VRF Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Session.BriefSessions.BriefSession, self).__init__()

                            self.yang_name = "brief-session"
                            self.yang_parent_name = "brief-sessions"

                            self.id = YLeaf(YType.str, "id")

                            self.address_family = YLeaf(YType.enumeration, "address-family")

                            self.foreign_address = YLeafList(YType.str, "foreign-address")

                            self.foreign_port = YLeaf(YType.uint16, "foreign-port")

                            self.is_admin_configured_up = YLeaf(YType.boolean, "is-admin-configured-up")

                            self.is_ds_operational_up = YLeaf(YType.enumeration, "is-ds-operational-up")

                            self.is_only_receive_path_replication = YLeaf(YType.boolean, "is-only-receive-path-replication")

                            self.is_us_operational_up = YLeaf(YType.enumeration, "is-us-operational-up")

                            self.local_address = YLeafList(YType.str, "local-address")

                            self.local_port = YLeaf(YType.uint16, "local-port")

                            self.pcb = YLeaf(YType.uint64, "pcb")

                            self.sscb = YLeaf(YType.uint64, "sscb")

                            self.vrf_id = YLeaf(YType.uint32, "vrf-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "address_family",
                                            "foreign_address",
                                            "foreign_port",
                                            "is_admin_configured_up",
                                            "is_ds_operational_up",
                                            "is_only_receive_path_replication",
                                            "is_us_operational_up",
                                            "local_address",
                                            "local_port",
                                            "pcb",
                                            "sscb",
                                            "vrf_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Session.BriefSessions.BriefSession, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Session.BriefSessions.BriefSession, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.foreign_address.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.local_address.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.id.is_set or
                                self.address_family.is_set or
                                self.foreign_port.is_set or
                                self.is_admin_configured_up.is_set or
                                self.is_ds_operational_up.is_set or
                                self.is_only_receive_path_replication.is_set or
                                self.is_us_operational_up.is_set or
                                self.local_port.is_set or
                                self.pcb.is_set or
                                self.sscb.is_set or
                                self.vrf_id.is_set)

                        def has_operation(self):
                            for leaf in self.foreign_address.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.local_address.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.address_family.yfilter != YFilter.not_set or
                                self.foreign_address.yfilter != YFilter.not_set or
                                self.foreign_port.yfilter != YFilter.not_set or
                                self.is_admin_configured_up.yfilter != YFilter.not_set or
                                self.is_ds_operational_up.yfilter != YFilter.not_set or
                                self.is_only_receive_path_replication.yfilter != YFilter.not_set or
                                self.is_us_operational_up.yfilter != YFilter.not_set or
                                self.local_address.yfilter != YFilter.not_set or
                                self.local_port.yfilter != YFilter.not_set or
                                self.pcb.yfilter != YFilter.not_set or
                                self.sscb.yfilter != YFilter.not_set or
                                self.vrf_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "brief-session" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address_family.get_name_leafdata())
                            if (self.foreign_port.is_set or self.foreign_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.foreign_port.get_name_leafdata())
                            if (self.is_admin_configured_up.is_set or self.is_admin_configured_up.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_admin_configured_up.get_name_leafdata())
                            if (self.is_ds_operational_up.is_set or self.is_ds_operational_up.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_ds_operational_up.get_name_leafdata())
                            if (self.is_only_receive_path_replication.is_set or self.is_only_receive_path_replication.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_only_receive_path_replication.get_name_leafdata())
                            if (self.is_us_operational_up.is_set or self.is_us_operational_up.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_us_operational_up.get_name_leafdata())
                            if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_port.get_name_leafdata())
                            if (self.pcb.is_set or self.pcb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcb.get_name_leafdata())
                            if (self.sscb.is_set or self.sscb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sscb.get_name_leafdata())
                            if (self.vrf_id.is_set or self.vrf_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.vrf_id.get_name_leafdata())

                            leaf_name_data.extend(self.foreign_address.get_name_leafdata())

                            leaf_name_data.extend(self.local_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "id" or name == "address-family" or name == "foreign-address" or name == "foreign-port" or name == "is-admin-configured-up" or name == "is-ds-operational-up" or name == "is-only-receive-path-replication" or name == "is-us-operational-up" or name == "local-address" or name == "local-port" or name == "pcb" or name == "sscb" or name == "vrf-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "address-family"):
                                self.address_family = value
                                self.address_family.value_namespace = name_space
                                self.address_family.value_namespace_prefix = name_space_prefix
                            if(value_path == "foreign-address"):
                                self.foreign_address.append(value)
                            if(value_path == "foreign-port"):
                                self.foreign_port = value
                                self.foreign_port.value_namespace = name_space
                                self.foreign_port.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-admin-configured-up"):
                                self.is_admin_configured_up = value
                                self.is_admin_configured_up.value_namespace = name_space
                                self.is_admin_configured_up.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-ds-operational-up"):
                                self.is_ds_operational_up = value
                                self.is_ds_operational_up.value_namespace = name_space
                                self.is_ds_operational_up.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-only-receive-path-replication"):
                                self.is_only_receive_path_replication = value
                                self.is_only_receive_path_replication.value_namespace = name_space
                                self.is_only_receive_path_replication.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-us-operational-up"):
                                self.is_us_operational_up = value
                                self.is_us_operational_up.value_namespace = name_space
                                self.is_us_operational_up.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-address"):
                                self.local_address.append(value)
                            if(value_path == "local-port"):
                                self.local_port = value
                                self.local_port.value_namespace = name_space
                                self.local_port.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcb"):
                                self.pcb = value
                                self.pcb.value_namespace = name_space
                                self.pcb.value_namespace_prefix = name_space_prefix
                            if(value_path == "sscb"):
                                self.sscb = value
                                self.sscb.value_namespace = name_space
                                self.sscb.value_namespace_prefix = name_space_prefix
                            if(value_path == "vrf-id"):
                                self.vrf_id = value
                                self.vrf_id.value_namespace = name_space
                                self.vrf_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.brief_session:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.brief_session:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-sessions" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "brief-session"):
                            for c in self.brief_session:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Session.BriefSessions.BriefSession()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.brief_session.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "brief-session"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class DetailSessions(Entity):
                    """
                    Table about TCP NSR Sessions details
                    
                    .. attribute:: detail_session
                    
                    	showing detailed information of NSR Sessions
                    	**type**\: list of    :py:class:`DetailSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Session.DetailSessions, self).__init__()

                        self.yang_name = "detail-sessions"
                        self.yang_parent_name = "session"

                        self.detail_session = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Session.DetailSessions, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Session.DetailSessions, self).__setattr__(name, value)


                    class DetailSession(Entity):
                        """
                        showing detailed information of NSR Sessions
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR Sesison
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: address_family
                        
                        	Address family
                        	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                        
                        .. attribute:: cookie
                        
                        	Cookie provided by active APP
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: fist_standby_sequence_number
                        
                        	If initial sync is completed, then the FSSN \- First Standby Sequence Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fist_standby_sequence_number_down_stream
                        
                        	FSSN for the upstream partner
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fist_standby_sequence_number_up_stream
                        
                        	FSSN for the upstream partner
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: foreign_address
                        
                        	Foreign address
                        	**type**\:  list of str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: foreign_port
                        
                        	Foreign port
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: fssn_offset
                        
                        	Offset of FSSN in input stream
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: init_sync_end_time
                        
                        	Time at which the initial sync operation was ended (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_end_time_down_stream
                        
                        	Time at which the initial sync operation was ended (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_end_time_up_stream
                        
                        	Time at which the initial sync operation was ended (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_error
                        
                        	Initial sync failure reason, if any
                        	**type**\:  str
                        
                        .. attribute:: init_sync_flags
                        
                        	Init Sync flags for the session
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: init_sync_start_time
                        
                        	Time at which the initial sync operation was started (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_start_time_down_stream
                        
                        	Time at which the initial sync operation was started (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_start_time_up_stream
                        
                        	Time at which the initial sync operation was started (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: internal_ack_hold_queue
                        
                        	Sequence Number and datalength of each node in hold\_iackqueue
                        	**type**\: list of    :py:class:`InternalAckHoldQueue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.InternalAckHoldQueue>`
                        
                        .. attribute:: is_admin_configured_up
                        
                        	Is NSR administratively configured?
                        	**type**\:  bool
                        
                        .. attribute:: is_ds_operational_up
                        
                        	Is Downstream NSR operational?
                        	**type**\:   :py:class:`NsrStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.NsrStatus>`
                        
                        .. attribute:: is_init_sync_error_local
                        
                        	Initial sync failed due to a local error or remote stack
                        	**type**\:  bool
                        
                        .. attribute:: is_init_sync_in_progress
                        
                        	Is initial\-sync currently in progress?
                        	**type**\:  bool
                        
                        .. attribute:: is_init_sync_second_phase
                        
                        	Is initial sync in the second phase?
                        	**type**\:  bool
                        
                        .. attribute:: is_only_receive_path_replication
                        
                        	Is replication limited to receive\-path only
                        	**type**\:  bool
                        
                        .. attribute:: is_session_replicated
                        
                        	Has the session been replicated to standby?
                        	**type**\:  bool
                        
                        .. attribute:: is_session_synced
                        
                        	Has the session completed initial\-sync?
                        	**type**\:  bool
                        
                        .. attribute:: is_us_operational_up
                        
                        	Is Upstream NSR operational?
                        	**type**\:   :py:class:`NsrStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.NsrStatus>`
                        
                        .. attribute:: local_address
                        
                        	Local address
                        	**type**\:  list of str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: local_port
                        
                        	Local port
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: max_number_of_held_internal_ack
                        
                        	Max number of internal acks have been held
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: max_number_of_held_internal_ack_reach_time
                        
                        	Max number of held internal acks reaches at
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: max_number_of_held_packet
                        
                        	Max number of incoming packets have been held
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: max_number_of_held_packet_reach_time
                        
                        	Max number of held incoming packets reaches at
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: nsr_down_reason
                        
                        	If NSR is not up, the reason for it
                        	**type**\:   :py:class:`NsrDownReason <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.NsrDownReason>`
                        
                        .. attribute:: nsr_down_reason_down_stream
                        
                        	The reason NSR is not up towards the upstream partner
                        	**type**\:   :py:class:`NsrDownReason <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.NsrDownReason>`
                        
                        .. attribute:: nsr_down_reason_up_stream
                        
                        	The reason NSR is not up towards the upstream partner
                        	**type**\:   :py:class:`NsrDownReason <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.NsrDownReason>`
                        
                        .. attribute:: nsr_down_time
                        
                        	Time at which NSR went down
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: nsr_down_time_down_stream
                        
                        	Time at which NSR went down
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: nsr_down_time_up_stream
                        
                        	Time at which NSR went down
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: packet_hold_queue
                        
                        	Sequence Number and datalength of each node in hold\_pakqueue
                        	**type**\: list of    :py:class:`PacketHoldQueue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.PacketHoldQueue>`
                        
                        .. attribute:: pcb
                        
                        	PCB Address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: peer_endp_hdl_down_stream
                        
                        	Peer NCD endp handle
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: peer_endp_hdl_up_stream
                        
                        	Peer NCD endp handle
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: sequence_number_of_init_sync
                        
                        	ID of the Initial sync operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: sequence_number_of_init_sync_down_stream
                        
                        	ID of the Initial sync operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: sequence_number_of_init_sync_up_stream
                        
                        	ID of the Initial sync operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_information
                        
                        	Sesson\-set information
                        	**type**\:   :py:class:`SetInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.SetInformation>`
                        
                        .. attribute:: sscb
                        
                        	SSCB Address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: vrf_id
                        
                        	VRF Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession, self).__init__()

                            self.yang_name = "detail-session"
                            self.yang_parent_name = "detail-sessions"

                            self.id = YLeaf(YType.str, "id")

                            self.address_family = YLeaf(YType.enumeration, "address-family")

                            self.cookie = YLeaf(YType.uint64, "cookie")

                            self.fist_standby_sequence_number = YLeaf(YType.uint32, "fist-standby-sequence-number")

                            self.fist_standby_sequence_number_down_stream = YLeaf(YType.uint32, "fist-standby-sequence-number-down-stream")

                            self.fist_standby_sequence_number_up_stream = YLeaf(YType.uint32, "fist-standby-sequence-number-up-stream")

                            self.foreign_address = YLeafList(YType.str, "foreign-address")

                            self.foreign_port = YLeaf(YType.uint16, "foreign-port")

                            self.fssn_offset = YLeaf(YType.uint32, "fssn-offset")

                            self.init_sync_end_time = YLeaf(YType.uint32, "init-sync-end-time")

                            self.init_sync_end_time_down_stream = YLeaf(YType.uint32, "init-sync-end-time-down-stream")

                            self.init_sync_end_time_up_stream = YLeaf(YType.uint32, "init-sync-end-time-up-stream")

                            self.init_sync_error = YLeaf(YType.str, "init-sync-error")

                            self.init_sync_flags = YLeaf(YType.uint32, "init-sync-flags")

                            self.init_sync_start_time = YLeaf(YType.uint32, "init-sync-start-time")

                            self.init_sync_start_time_down_stream = YLeaf(YType.uint32, "init-sync-start-time-down-stream")

                            self.init_sync_start_time_up_stream = YLeaf(YType.uint32, "init-sync-start-time-up-stream")

                            self.is_admin_configured_up = YLeaf(YType.boolean, "is-admin-configured-up")

                            self.is_ds_operational_up = YLeaf(YType.enumeration, "is-ds-operational-up")

                            self.is_init_sync_error_local = YLeaf(YType.boolean, "is-init-sync-error-local")

                            self.is_init_sync_in_progress = YLeaf(YType.boolean, "is-init-sync-in-progress")

                            self.is_init_sync_second_phase = YLeaf(YType.boolean, "is-init-sync-second-phase")

                            self.is_only_receive_path_replication = YLeaf(YType.boolean, "is-only-receive-path-replication")

                            self.is_session_replicated = YLeaf(YType.boolean, "is-session-replicated")

                            self.is_session_synced = YLeaf(YType.boolean, "is-session-synced")

                            self.is_us_operational_up = YLeaf(YType.enumeration, "is-us-operational-up")

                            self.local_address = YLeafList(YType.str, "local-address")

                            self.local_port = YLeaf(YType.uint16, "local-port")

                            self.max_number_of_held_internal_ack = YLeaf(YType.int32, "max-number-of-held-internal-ack")

                            self.max_number_of_held_internal_ack_reach_time = YLeaf(YType.uint32, "max-number-of-held-internal-ack-reach-time")

                            self.max_number_of_held_packet = YLeaf(YType.int32, "max-number-of-held-packet")

                            self.max_number_of_held_packet_reach_time = YLeaf(YType.uint32, "max-number-of-held-packet-reach-time")

                            self.nsr_down_reason = YLeaf(YType.enumeration, "nsr-down-reason")

                            self.nsr_down_reason_down_stream = YLeaf(YType.enumeration, "nsr-down-reason-down-stream")

                            self.nsr_down_reason_up_stream = YLeaf(YType.enumeration, "nsr-down-reason-up-stream")

                            self.nsr_down_time = YLeaf(YType.uint32, "nsr-down-time")

                            self.nsr_down_time_down_stream = YLeaf(YType.uint32, "nsr-down-time-down-stream")

                            self.nsr_down_time_up_stream = YLeaf(YType.uint32, "nsr-down-time-up-stream")

                            self.pcb = YLeaf(YType.uint64, "pcb")

                            self.peer_endp_hdl_down_stream = YLeaf(YType.uint64, "peer-endp-hdl-down-stream")

                            self.peer_endp_hdl_up_stream = YLeaf(YType.uint64, "peer-endp-hdl-up-stream")

                            self.sequence_number_of_init_sync = YLeaf(YType.uint32, "sequence-number-of-init-sync")

                            self.sequence_number_of_init_sync_down_stream = YLeaf(YType.uint32, "sequence-number-of-init-sync-down-stream")

                            self.sequence_number_of_init_sync_up_stream = YLeaf(YType.uint32, "sequence-number-of-init-sync-up-stream")

                            self.sscb = YLeaf(YType.uint64, "sscb")

                            self.vrf_id = YLeaf(YType.uint32, "vrf-id")

                            self.set_information = TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.SetInformation()
                            self.set_information.parent = self
                            self._children_name_map["set_information"] = "set-information"
                            self._children_yang_names.add("set-information")

                            self.internal_ack_hold_queue = YList(self)
                            self.packet_hold_queue = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "address_family",
                                            "cookie",
                                            "fist_standby_sequence_number",
                                            "fist_standby_sequence_number_down_stream",
                                            "fist_standby_sequence_number_up_stream",
                                            "foreign_address",
                                            "foreign_port",
                                            "fssn_offset",
                                            "init_sync_end_time",
                                            "init_sync_end_time_down_stream",
                                            "init_sync_end_time_up_stream",
                                            "init_sync_error",
                                            "init_sync_flags",
                                            "init_sync_start_time",
                                            "init_sync_start_time_down_stream",
                                            "init_sync_start_time_up_stream",
                                            "is_admin_configured_up",
                                            "is_ds_operational_up",
                                            "is_init_sync_error_local",
                                            "is_init_sync_in_progress",
                                            "is_init_sync_second_phase",
                                            "is_only_receive_path_replication",
                                            "is_session_replicated",
                                            "is_session_synced",
                                            "is_us_operational_up",
                                            "local_address",
                                            "local_port",
                                            "max_number_of_held_internal_ack",
                                            "max_number_of_held_internal_ack_reach_time",
                                            "max_number_of_held_packet",
                                            "max_number_of_held_packet_reach_time",
                                            "nsr_down_reason",
                                            "nsr_down_reason_down_stream",
                                            "nsr_down_reason_up_stream",
                                            "nsr_down_time",
                                            "nsr_down_time_down_stream",
                                            "nsr_down_time_up_stream",
                                            "pcb",
                                            "peer_endp_hdl_down_stream",
                                            "peer_endp_hdl_up_stream",
                                            "sequence_number_of_init_sync",
                                            "sequence_number_of_init_sync_down_stream",
                                            "sequence_number_of_init_sync_up_stream",
                                            "sscb",
                                            "vrf_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession, self).__setattr__(name, value)


                        class SetInformation(Entity):
                            """
                            Sesson\-set information
                            
                            .. attribute:: address_family
                            
                            	Address Family of the sessions in this set
                            	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                            
                            .. attribute:: client_instance
                            
                            	Instance of the Client that owns this Session\-set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: client_name
                            
                            	the name of Clinet that owns this Session\-set
                            	**type**\:  str
                            
                            .. attribute:: is_init_sync_in_progress
                            
                            	Is an initial sync in progress currently?
                            	**type**\:  bool
                            
                            .. attribute:: is_sscb_init_sync_ready
                            
                            	Is the SSCB ready for another initial sync?
                            	**type**\:  bool
                            
                            .. attribute:: local_instance
                            
                            	Instance of the client application on the local node
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_node
                            
                            	Local node of this set
                            	**type**\:  str
                            
                            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                            
                            .. attribute:: mode
                            
                            	Session\-set mode
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: number_of_sessions
                            
                            	Number of Sessions in the set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: number_of_synced_sessions_down_stream
                            
                            	How many sessions are synced with downstream partner
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: number_of_synced_sessions_up_stream
                            
                            	How many sessions are synced with upstream partner
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: pid
                            
                            	PID of the Client that owns this Session\-set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: protect_instance
                            
                            	Instance of the client application on the protection node
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: protect_node
                            
                            	The node protecting this set
                            	**type**\:  str
                            
                            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                            
                            .. attribute:: set_id
                            
                            	ID of this Session\-set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sscb
                            
                            	Address of the Session Set Control Block
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sso_role
                            
                            	TCP role for this set?
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: well_known_port
                            
                            	Well Known Port of the client
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.SetInformation, self).__init__()

                                self.yang_name = "set-information"
                                self.yang_parent_name = "detail-session"

                                self.address_family = YLeaf(YType.enumeration, "address-family")

                                self.client_instance = YLeaf(YType.uint32, "client-instance")

                                self.client_name = YLeaf(YType.str, "client-name")

                                self.is_init_sync_in_progress = YLeaf(YType.boolean, "is-init-sync-in-progress")

                                self.is_sscb_init_sync_ready = YLeaf(YType.boolean, "is-sscb-init-sync-ready")

                                self.local_instance = YLeaf(YType.uint32, "local-instance")

                                self.local_node = YLeaf(YType.str, "local-node")

                                self.mode = YLeaf(YType.uint32, "mode")

                                self.number_of_sessions = YLeaf(YType.uint32, "number-of-sessions")

                                self.number_of_synced_sessions_down_stream = YLeaf(YType.uint32, "number-of-synced-sessions-down-stream")

                                self.number_of_synced_sessions_up_stream = YLeaf(YType.uint32, "number-of-synced-sessions-up-stream")

                                self.pid = YLeaf(YType.uint32, "pid")

                                self.protect_instance = YLeaf(YType.uint32, "protect-instance")

                                self.protect_node = YLeaf(YType.str, "protect-node")

                                self.set_id = YLeaf(YType.uint32, "set-id")

                                self.sscb = YLeaf(YType.uint64, "sscb")

                                self.sso_role = YLeaf(YType.uint32, "sso-role")

                                self.well_known_port = YLeaf(YType.uint16, "well-known-port")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("address_family",
                                                "client_instance",
                                                "client_name",
                                                "is_init_sync_in_progress",
                                                "is_sscb_init_sync_ready",
                                                "local_instance",
                                                "local_node",
                                                "mode",
                                                "number_of_sessions",
                                                "number_of_synced_sessions_down_stream",
                                                "number_of_synced_sessions_up_stream",
                                                "pid",
                                                "protect_instance",
                                                "protect_node",
                                                "set_id",
                                                "sscb",
                                                "sso_role",
                                                "well_known_port") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.SetInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.SetInformation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.address_family.is_set or
                                    self.client_instance.is_set or
                                    self.client_name.is_set or
                                    self.is_init_sync_in_progress.is_set or
                                    self.is_sscb_init_sync_ready.is_set or
                                    self.local_instance.is_set or
                                    self.local_node.is_set or
                                    self.mode.is_set or
                                    self.number_of_sessions.is_set or
                                    self.number_of_synced_sessions_down_stream.is_set or
                                    self.number_of_synced_sessions_up_stream.is_set or
                                    self.pid.is_set or
                                    self.protect_instance.is_set or
                                    self.protect_node.is_set or
                                    self.set_id.is_set or
                                    self.sscb.is_set or
                                    self.sso_role.is_set or
                                    self.well_known_port.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.address_family.yfilter != YFilter.not_set or
                                    self.client_instance.yfilter != YFilter.not_set or
                                    self.client_name.yfilter != YFilter.not_set or
                                    self.is_init_sync_in_progress.yfilter != YFilter.not_set or
                                    self.is_sscb_init_sync_ready.yfilter != YFilter.not_set or
                                    self.local_instance.yfilter != YFilter.not_set or
                                    self.local_node.yfilter != YFilter.not_set or
                                    self.mode.yfilter != YFilter.not_set or
                                    self.number_of_sessions.yfilter != YFilter.not_set or
                                    self.number_of_synced_sessions_down_stream.yfilter != YFilter.not_set or
                                    self.number_of_synced_sessions_up_stream.yfilter != YFilter.not_set or
                                    self.pid.yfilter != YFilter.not_set or
                                    self.protect_instance.yfilter != YFilter.not_set or
                                    self.protect_node.yfilter != YFilter.not_set or
                                    self.set_id.yfilter != YFilter.not_set or
                                    self.sscb.yfilter != YFilter.not_set or
                                    self.sso_role.yfilter != YFilter.not_set or
                                    self.well_known_port.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "set-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address_family.get_name_leafdata())
                                if (self.client_instance.is_set or self.client_instance.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.client_instance.get_name_leafdata())
                                if (self.client_name.is_set or self.client_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.client_name.get_name_leafdata())
                                if (self.is_init_sync_in_progress.is_set or self.is_init_sync_in_progress.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_init_sync_in_progress.get_name_leafdata())
                                if (self.is_sscb_init_sync_ready.is_set or self.is_sscb_init_sync_ready.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_sscb_init_sync_ready.get_name_leafdata())
                                if (self.local_instance.is_set or self.local_instance.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_instance.get_name_leafdata())
                                if (self.local_node.is_set or self.local_node.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_node.get_name_leafdata())
                                if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mode.get_name_leafdata())
                                if (self.number_of_sessions.is_set or self.number_of_sessions.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.number_of_sessions.get_name_leafdata())
                                if (self.number_of_synced_sessions_down_stream.is_set or self.number_of_synced_sessions_down_stream.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.number_of_synced_sessions_down_stream.get_name_leafdata())
                                if (self.number_of_synced_sessions_up_stream.is_set or self.number_of_synced_sessions_up_stream.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.number_of_synced_sessions_up_stream.get_name_leafdata())
                                if (self.pid.is_set or self.pid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.pid.get_name_leafdata())
                                if (self.protect_instance.is_set or self.protect_instance.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protect_instance.get_name_leafdata())
                                if (self.protect_node.is_set or self.protect_node.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protect_node.get_name_leafdata())
                                if (self.set_id.is_set or self.set_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_id.get_name_leafdata())
                                if (self.sscb.is_set or self.sscb.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sscb.get_name_leafdata())
                                if (self.sso_role.is_set or self.sso_role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sso_role.get_name_leafdata())
                                if (self.well_known_port.is_set or self.well_known_port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.well_known_port.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "address-family" or name == "client-instance" or name == "client-name" or name == "is-init-sync-in-progress" or name == "is-sscb-init-sync-ready" or name == "local-instance" or name == "local-node" or name == "mode" or name == "number-of-sessions" or name == "number-of-synced-sessions-down-stream" or name == "number-of-synced-sessions-up-stream" or name == "pid" or name == "protect-instance" or name == "protect-node" or name == "set-id" or name == "sscb" or name == "sso-role" or name == "well-known-port"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "address-family"):
                                    self.address_family = value
                                    self.address_family.value_namespace = name_space
                                    self.address_family.value_namespace_prefix = name_space_prefix
                                if(value_path == "client-instance"):
                                    self.client_instance = value
                                    self.client_instance.value_namespace = name_space
                                    self.client_instance.value_namespace_prefix = name_space_prefix
                                if(value_path == "client-name"):
                                    self.client_name = value
                                    self.client_name.value_namespace = name_space
                                    self.client_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-init-sync-in-progress"):
                                    self.is_init_sync_in_progress = value
                                    self.is_init_sync_in_progress.value_namespace = name_space
                                    self.is_init_sync_in_progress.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-sscb-init-sync-ready"):
                                    self.is_sscb_init_sync_ready = value
                                    self.is_sscb_init_sync_ready.value_namespace = name_space
                                    self.is_sscb_init_sync_ready.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-instance"):
                                    self.local_instance = value
                                    self.local_instance.value_namespace = name_space
                                    self.local_instance.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-node"):
                                    self.local_node = value
                                    self.local_node.value_namespace = name_space
                                    self.local_node.value_namespace_prefix = name_space_prefix
                                if(value_path == "mode"):
                                    self.mode = value
                                    self.mode.value_namespace = name_space
                                    self.mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "number-of-sessions"):
                                    self.number_of_sessions = value
                                    self.number_of_sessions.value_namespace = name_space
                                    self.number_of_sessions.value_namespace_prefix = name_space_prefix
                                if(value_path == "number-of-synced-sessions-down-stream"):
                                    self.number_of_synced_sessions_down_stream = value
                                    self.number_of_synced_sessions_down_stream.value_namespace = name_space
                                    self.number_of_synced_sessions_down_stream.value_namespace_prefix = name_space_prefix
                                if(value_path == "number-of-synced-sessions-up-stream"):
                                    self.number_of_synced_sessions_up_stream = value
                                    self.number_of_synced_sessions_up_stream.value_namespace = name_space
                                    self.number_of_synced_sessions_up_stream.value_namespace_prefix = name_space_prefix
                                if(value_path == "pid"):
                                    self.pid = value
                                    self.pid.value_namespace = name_space
                                    self.pid.value_namespace_prefix = name_space_prefix
                                if(value_path == "protect-instance"):
                                    self.protect_instance = value
                                    self.protect_instance.value_namespace = name_space
                                    self.protect_instance.value_namespace_prefix = name_space_prefix
                                if(value_path == "protect-node"):
                                    self.protect_node = value
                                    self.protect_node.value_namespace = name_space
                                    self.protect_node.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-id"):
                                    self.set_id = value
                                    self.set_id.value_namespace = name_space
                                    self.set_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "sscb"):
                                    self.sscb = value
                                    self.sscb.value_namespace = name_space
                                    self.sscb.value_namespace_prefix = name_space_prefix
                                if(value_path == "sso-role"):
                                    self.sso_role = value
                                    self.sso_role.value_namespace = name_space
                                    self.sso_role.value_namespace_prefix = name_space_prefix
                                if(value_path == "well-known-port"):
                                    self.well_known_port = value
                                    self.well_known_port.value_namespace = name_space
                                    self.well_known_port.value_namespace_prefix = name_space_prefix


                        class PacketHoldQueue(Entity):
                            """
                            Sequence Number and datalength of each node in
                            hold\_pakqueue
                            
                            .. attribute:: acknoledgement_number
                            
                            	Ack Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_length
                            
                            	Data Length
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.PacketHoldQueue, self).__init__()

                                self.yang_name = "packet-hold-queue"
                                self.yang_parent_name = "detail-session"

                                self.acknoledgement_number = YLeaf(YType.uint32, "acknoledgement-number")

                                self.data_length = YLeaf(YType.uint32, "data-length")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknoledgement_number",
                                                "data_length",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.PacketHoldQueue, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.PacketHoldQueue, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknoledgement_number.is_set or
                                    self.data_length.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknoledgement_number.yfilter != YFilter.not_set or
                                    self.data_length.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "packet-hold-queue" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknoledgement_number.is_set or self.acknoledgement_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknoledgement_number.get_name_leafdata())
                                if (self.data_length.is_set or self.data_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_length.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknoledgement-number" or name == "data-length" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknoledgement-number"):
                                    self.acknoledgement_number = value
                                    self.acknoledgement_number.value_namespace = name_space
                                    self.acknoledgement_number.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-length"):
                                    self.data_length = value
                                    self.data_length.value_namespace = name_space
                                    self.data_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class InternalAckHoldQueue(Entity):
                            """
                            Sequence Number and datalength of each node in
                            hold\_iackqueue
                            
                            .. attribute:: acknoledgement_number
                            
                            	Ack Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_length
                            
                            	Data Length
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.InternalAckHoldQueue, self).__init__()

                                self.yang_name = "internal-ack-hold-queue"
                                self.yang_parent_name = "detail-session"

                                self.acknoledgement_number = YLeaf(YType.uint32, "acknoledgement-number")

                                self.data_length = YLeaf(YType.uint32, "data-length")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknoledgement_number",
                                                "data_length",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.InternalAckHoldQueue, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.InternalAckHoldQueue, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknoledgement_number.is_set or
                                    self.data_length.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknoledgement_number.yfilter != YFilter.not_set or
                                    self.data_length.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "internal-ack-hold-queue" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknoledgement_number.is_set or self.acknoledgement_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknoledgement_number.get_name_leafdata())
                                if (self.data_length.is_set or self.data_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_length.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknoledgement-number" or name == "data-length" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknoledgement-number"):
                                    self.acknoledgement_number = value
                                    self.acknoledgement_number.value_namespace = name_space
                                    self.acknoledgement_number.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-length"):
                                    self.data_length = value
                                    self.data_length.value_namespace = name_space
                                    self.data_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.internal_ack_hold_queue:
                                if (c.has_data()):
                                    return True
                            for c in self.packet_hold_queue:
                                if (c.has_data()):
                                    return True
                            for leaf in self.foreign_address.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.local_address.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.id.is_set or
                                self.address_family.is_set or
                                self.cookie.is_set or
                                self.fist_standby_sequence_number.is_set or
                                self.fist_standby_sequence_number_down_stream.is_set or
                                self.fist_standby_sequence_number_up_stream.is_set or
                                self.foreign_port.is_set or
                                self.fssn_offset.is_set or
                                self.init_sync_end_time.is_set or
                                self.init_sync_end_time_down_stream.is_set or
                                self.init_sync_end_time_up_stream.is_set or
                                self.init_sync_error.is_set or
                                self.init_sync_flags.is_set or
                                self.init_sync_start_time.is_set or
                                self.init_sync_start_time_down_stream.is_set or
                                self.init_sync_start_time_up_stream.is_set or
                                self.is_admin_configured_up.is_set or
                                self.is_ds_operational_up.is_set or
                                self.is_init_sync_error_local.is_set or
                                self.is_init_sync_in_progress.is_set or
                                self.is_init_sync_second_phase.is_set or
                                self.is_only_receive_path_replication.is_set or
                                self.is_session_replicated.is_set or
                                self.is_session_synced.is_set or
                                self.is_us_operational_up.is_set or
                                self.local_port.is_set or
                                self.max_number_of_held_internal_ack.is_set or
                                self.max_number_of_held_internal_ack_reach_time.is_set or
                                self.max_number_of_held_packet.is_set or
                                self.max_number_of_held_packet_reach_time.is_set or
                                self.nsr_down_reason.is_set or
                                self.nsr_down_reason_down_stream.is_set or
                                self.nsr_down_reason_up_stream.is_set or
                                self.nsr_down_time.is_set or
                                self.nsr_down_time_down_stream.is_set or
                                self.nsr_down_time_up_stream.is_set or
                                self.pcb.is_set or
                                self.peer_endp_hdl_down_stream.is_set or
                                self.peer_endp_hdl_up_stream.is_set or
                                self.sequence_number_of_init_sync.is_set or
                                self.sequence_number_of_init_sync_down_stream.is_set or
                                self.sequence_number_of_init_sync_up_stream.is_set or
                                self.sscb.is_set or
                                self.vrf_id.is_set or
                                (self.set_information is not None and self.set_information.has_data()))

                        def has_operation(self):
                            for c in self.internal_ack_hold_queue:
                                if (c.has_operation()):
                                    return True
                            for c in self.packet_hold_queue:
                                if (c.has_operation()):
                                    return True
                            for leaf in self.foreign_address.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.local_address.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.address_family.yfilter != YFilter.not_set or
                                self.cookie.yfilter != YFilter.not_set or
                                self.fist_standby_sequence_number.yfilter != YFilter.not_set or
                                self.fist_standby_sequence_number_down_stream.yfilter != YFilter.not_set or
                                self.fist_standby_sequence_number_up_stream.yfilter != YFilter.not_set or
                                self.foreign_address.yfilter != YFilter.not_set or
                                self.foreign_port.yfilter != YFilter.not_set or
                                self.fssn_offset.yfilter != YFilter.not_set or
                                self.init_sync_end_time.yfilter != YFilter.not_set or
                                self.init_sync_end_time_down_stream.yfilter != YFilter.not_set or
                                self.init_sync_end_time_up_stream.yfilter != YFilter.not_set or
                                self.init_sync_error.yfilter != YFilter.not_set or
                                self.init_sync_flags.yfilter != YFilter.not_set or
                                self.init_sync_start_time.yfilter != YFilter.not_set or
                                self.init_sync_start_time_down_stream.yfilter != YFilter.not_set or
                                self.init_sync_start_time_up_stream.yfilter != YFilter.not_set or
                                self.is_admin_configured_up.yfilter != YFilter.not_set or
                                self.is_ds_operational_up.yfilter != YFilter.not_set or
                                self.is_init_sync_error_local.yfilter != YFilter.not_set or
                                self.is_init_sync_in_progress.yfilter != YFilter.not_set or
                                self.is_init_sync_second_phase.yfilter != YFilter.not_set or
                                self.is_only_receive_path_replication.yfilter != YFilter.not_set or
                                self.is_session_replicated.yfilter != YFilter.not_set or
                                self.is_session_synced.yfilter != YFilter.not_set or
                                self.is_us_operational_up.yfilter != YFilter.not_set or
                                self.local_address.yfilter != YFilter.not_set or
                                self.local_port.yfilter != YFilter.not_set or
                                self.max_number_of_held_internal_ack.yfilter != YFilter.not_set or
                                self.max_number_of_held_internal_ack_reach_time.yfilter != YFilter.not_set or
                                self.max_number_of_held_packet.yfilter != YFilter.not_set or
                                self.max_number_of_held_packet_reach_time.yfilter != YFilter.not_set or
                                self.nsr_down_reason.yfilter != YFilter.not_set or
                                self.nsr_down_reason_down_stream.yfilter != YFilter.not_set or
                                self.nsr_down_reason_up_stream.yfilter != YFilter.not_set or
                                self.nsr_down_time.yfilter != YFilter.not_set or
                                self.nsr_down_time_down_stream.yfilter != YFilter.not_set or
                                self.nsr_down_time_up_stream.yfilter != YFilter.not_set or
                                self.pcb.yfilter != YFilter.not_set or
                                self.peer_endp_hdl_down_stream.yfilter != YFilter.not_set or
                                self.peer_endp_hdl_up_stream.yfilter != YFilter.not_set or
                                self.sequence_number_of_init_sync.yfilter != YFilter.not_set or
                                self.sequence_number_of_init_sync_down_stream.yfilter != YFilter.not_set or
                                self.sequence_number_of_init_sync_up_stream.yfilter != YFilter.not_set or
                                self.sscb.yfilter != YFilter.not_set or
                                self.vrf_id.yfilter != YFilter.not_set or
                                (self.set_information is not None and self.set_information.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "detail-session" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address_family.get_name_leafdata())
                            if (self.cookie.is_set or self.cookie.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cookie.get_name_leafdata())
                            if (self.fist_standby_sequence_number.is_set or self.fist_standby_sequence_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fist_standby_sequence_number.get_name_leafdata())
                            if (self.fist_standby_sequence_number_down_stream.is_set or self.fist_standby_sequence_number_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fist_standby_sequence_number_down_stream.get_name_leafdata())
                            if (self.fist_standby_sequence_number_up_stream.is_set or self.fist_standby_sequence_number_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fist_standby_sequence_number_up_stream.get_name_leafdata())
                            if (self.foreign_port.is_set or self.foreign_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.foreign_port.get_name_leafdata())
                            if (self.fssn_offset.is_set or self.fssn_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fssn_offset.get_name_leafdata())
                            if (self.init_sync_end_time.is_set or self.init_sync_end_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_end_time.get_name_leafdata())
                            if (self.init_sync_end_time_down_stream.is_set or self.init_sync_end_time_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_end_time_down_stream.get_name_leafdata())
                            if (self.init_sync_end_time_up_stream.is_set or self.init_sync_end_time_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_end_time_up_stream.get_name_leafdata())
                            if (self.init_sync_error.is_set or self.init_sync_error.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_error.get_name_leafdata())
                            if (self.init_sync_flags.is_set or self.init_sync_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_flags.get_name_leafdata())
                            if (self.init_sync_start_time.is_set or self.init_sync_start_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_start_time.get_name_leafdata())
                            if (self.init_sync_start_time_down_stream.is_set or self.init_sync_start_time_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_start_time_down_stream.get_name_leafdata())
                            if (self.init_sync_start_time_up_stream.is_set or self.init_sync_start_time_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_start_time_up_stream.get_name_leafdata())
                            if (self.is_admin_configured_up.is_set or self.is_admin_configured_up.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_admin_configured_up.get_name_leafdata())
                            if (self.is_ds_operational_up.is_set or self.is_ds_operational_up.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_ds_operational_up.get_name_leafdata())
                            if (self.is_init_sync_error_local.is_set or self.is_init_sync_error_local.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_init_sync_error_local.get_name_leafdata())
                            if (self.is_init_sync_in_progress.is_set or self.is_init_sync_in_progress.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_init_sync_in_progress.get_name_leafdata())
                            if (self.is_init_sync_second_phase.is_set or self.is_init_sync_second_phase.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_init_sync_second_phase.get_name_leafdata())
                            if (self.is_only_receive_path_replication.is_set or self.is_only_receive_path_replication.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_only_receive_path_replication.get_name_leafdata())
                            if (self.is_session_replicated.is_set or self.is_session_replicated.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_session_replicated.get_name_leafdata())
                            if (self.is_session_synced.is_set or self.is_session_synced.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_session_synced.get_name_leafdata())
                            if (self.is_us_operational_up.is_set or self.is_us_operational_up.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_us_operational_up.get_name_leafdata())
                            if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_port.get_name_leafdata())
                            if (self.max_number_of_held_internal_ack.is_set or self.max_number_of_held_internal_ack.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.max_number_of_held_internal_ack.get_name_leafdata())
                            if (self.max_number_of_held_internal_ack_reach_time.is_set or self.max_number_of_held_internal_ack_reach_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.max_number_of_held_internal_ack_reach_time.get_name_leafdata())
                            if (self.max_number_of_held_packet.is_set or self.max_number_of_held_packet.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.max_number_of_held_packet.get_name_leafdata())
                            if (self.max_number_of_held_packet_reach_time.is_set or self.max_number_of_held_packet_reach_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.max_number_of_held_packet_reach_time.get_name_leafdata())
                            if (self.nsr_down_reason.is_set or self.nsr_down_reason.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nsr_down_reason.get_name_leafdata())
                            if (self.nsr_down_reason_down_stream.is_set or self.nsr_down_reason_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nsr_down_reason_down_stream.get_name_leafdata())
                            if (self.nsr_down_reason_up_stream.is_set or self.nsr_down_reason_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nsr_down_reason_up_stream.get_name_leafdata())
                            if (self.nsr_down_time.is_set or self.nsr_down_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nsr_down_time.get_name_leafdata())
                            if (self.nsr_down_time_down_stream.is_set or self.nsr_down_time_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nsr_down_time_down_stream.get_name_leafdata())
                            if (self.nsr_down_time_up_stream.is_set or self.nsr_down_time_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nsr_down_time_up_stream.get_name_leafdata())
                            if (self.pcb.is_set or self.pcb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcb.get_name_leafdata())
                            if (self.peer_endp_hdl_down_stream.is_set or self.peer_endp_hdl_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.peer_endp_hdl_down_stream.get_name_leafdata())
                            if (self.peer_endp_hdl_up_stream.is_set or self.peer_endp_hdl_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.peer_endp_hdl_up_stream.get_name_leafdata())
                            if (self.sequence_number_of_init_sync.is_set or self.sequence_number_of_init_sync.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sequence_number_of_init_sync.get_name_leafdata())
                            if (self.sequence_number_of_init_sync_down_stream.is_set or self.sequence_number_of_init_sync_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sequence_number_of_init_sync_down_stream.get_name_leafdata())
                            if (self.sequence_number_of_init_sync_up_stream.is_set or self.sequence_number_of_init_sync_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sequence_number_of_init_sync_up_stream.get_name_leafdata())
                            if (self.sscb.is_set or self.sscb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sscb.get_name_leafdata())
                            if (self.vrf_id.is_set or self.vrf_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.vrf_id.get_name_leafdata())

                            leaf_name_data.extend(self.foreign_address.get_name_leafdata())

                            leaf_name_data.extend(self.local_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "internal-ack-hold-queue"):
                                for c in self.internal_ack_hold_queue:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.InternalAckHoldQueue()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.internal_ack_hold_queue.append(c)
                                return c

                            if (child_yang_name == "packet-hold-queue"):
                                for c in self.packet_hold_queue:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.PacketHoldQueue()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.packet_hold_queue.append(c)
                                return c

                            if (child_yang_name == "set-information"):
                                if (self.set_information is None):
                                    self.set_information = TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession.SetInformation()
                                    self.set_information.parent = self
                                    self._children_name_map["set_information"] = "set-information"
                                return self.set_information

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "internal-ack-hold-queue" or name == "packet-hold-queue" or name == "set-information" or name == "id" or name == "address-family" or name == "cookie" or name == "fist-standby-sequence-number" or name == "fist-standby-sequence-number-down-stream" or name == "fist-standby-sequence-number-up-stream" or name == "foreign-address" or name == "foreign-port" or name == "fssn-offset" or name == "init-sync-end-time" or name == "init-sync-end-time-down-stream" or name == "init-sync-end-time-up-stream" or name == "init-sync-error" or name == "init-sync-flags" or name == "init-sync-start-time" or name == "init-sync-start-time-down-stream" or name == "init-sync-start-time-up-stream" or name == "is-admin-configured-up" or name == "is-ds-operational-up" or name == "is-init-sync-error-local" or name == "is-init-sync-in-progress" or name == "is-init-sync-second-phase" or name == "is-only-receive-path-replication" or name == "is-session-replicated" or name == "is-session-synced" or name == "is-us-operational-up" or name == "local-address" or name == "local-port" or name == "max-number-of-held-internal-ack" or name == "max-number-of-held-internal-ack-reach-time" or name == "max-number-of-held-packet" or name == "max-number-of-held-packet-reach-time" or name == "nsr-down-reason" or name == "nsr-down-reason-down-stream" or name == "nsr-down-reason-up-stream" or name == "nsr-down-time" or name == "nsr-down-time-down-stream" or name == "nsr-down-time-up-stream" or name == "pcb" or name == "peer-endp-hdl-down-stream" or name == "peer-endp-hdl-up-stream" or name == "sequence-number-of-init-sync" or name == "sequence-number-of-init-sync-down-stream" or name == "sequence-number-of-init-sync-up-stream" or name == "sscb" or name == "vrf-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "address-family"):
                                self.address_family = value
                                self.address_family.value_namespace = name_space
                                self.address_family.value_namespace_prefix = name_space_prefix
                            if(value_path == "cookie"):
                                self.cookie = value
                                self.cookie.value_namespace = name_space
                                self.cookie.value_namespace_prefix = name_space_prefix
                            if(value_path == "fist-standby-sequence-number"):
                                self.fist_standby_sequence_number = value
                                self.fist_standby_sequence_number.value_namespace = name_space
                                self.fist_standby_sequence_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "fist-standby-sequence-number-down-stream"):
                                self.fist_standby_sequence_number_down_stream = value
                                self.fist_standby_sequence_number_down_stream.value_namespace = name_space
                                self.fist_standby_sequence_number_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "fist-standby-sequence-number-up-stream"):
                                self.fist_standby_sequence_number_up_stream = value
                                self.fist_standby_sequence_number_up_stream.value_namespace = name_space
                                self.fist_standby_sequence_number_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "foreign-address"):
                                self.foreign_address.append(value)
                            if(value_path == "foreign-port"):
                                self.foreign_port = value
                                self.foreign_port.value_namespace = name_space
                                self.foreign_port.value_namespace_prefix = name_space_prefix
                            if(value_path == "fssn-offset"):
                                self.fssn_offset = value
                                self.fssn_offset.value_namespace = name_space
                                self.fssn_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-end-time"):
                                self.init_sync_end_time = value
                                self.init_sync_end_time.value_namespace = name_space
                                self.init_sync_end_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-end-time-down-stream"):
                                self.init_sync_end_time_down_stream = value
                                self.init_sync_end_time_down_stream.value_namespace = name_space
                                self.init_sync_end_time_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-end-time-up-stream"):
                                self.init_sync_end_time_up_stream = value
                                self.init_sync_end_time_up_stream.value_namespace = name_space
                                self.init_sync_end_time_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-error"):
                                self.init_sync_error = value
                                self.init_sync_error.value_namespace = name_space
                                self.init_sync_error.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-flags"):
                                self.init_sync_flags = value
                                self.init_sync_flags.value_namespace = name_space
                                self.init_sync_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-start-time"):
                                self.init_sync_start_time = value
                                self.init_sync_start_time.value_namespace = name_space
                                self.init_sync_start_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-start-time-down-stream"):
                                self.init_sync_start_time_down_stream = value
                                self.init_sync_start_time_down_stream.value_namespace = name_space
                                self.init_sync_start_time_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-start-time-up-stream"):
                                self.init_sync_start_time_up_stream = value
                                self.init_sync_start_time_up_stream.value_namespace = name_space
                                self.init_sync_start_time_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-admin-configured-up"):
                                self.is_admin_configured_up = value
                                self.is_admin_configured_up.value_namespace = name_space
                                self.is_admin_configured_up.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-ds-operational-up"):
                                self.is_ds_operational_up = value
                                self.is_ds_operational_up.value_namespace = name_space
                                self.is_ds_operational_up.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-init-sync-error-local"):
                                self.is_init_sync_error_local = value
                                self.is_init_sync_error_local.value_namespace = name_space
                                self.is_init_sync_error_local.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-init-sync-in-progress"):
                                self.is_init_sync_in_progress = value
                                self.is_init_sync_in_progress.value_namespace = name_space
                                self.is_init_sync_in_progress.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-init-sync-second-phase"):
                                self.is_init_sync_second_phase = value
                                self.is_init_sync_second_phase.value_namespace = name_space
                                self.is_init_sync_second_phase.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-only-receive-path-replication"):
                                self.is_only_receive_path_replication = value
                                self.is_only_receive_path_replication.value_namespace = name_space
                                self.is_only_receive_path_replication.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-session-replicated"):
                                self.is_session_replicated = value
                                self.is_session_replicated.value_namespace = name_space
                                self.is_session_replicated.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-session-synced"):
                                self.is_session_synced = value
                                self.is_session_synced.value_namespace = name_space
                                self.is_session_synced.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-us-operational-up"):
                                self.is_us_operational_up = value
                                self.is_us_operational_up.value_namespace = name_space
                                self.is_us_operational_up.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-address"):
                                self.local_address.append(value)
                            if(value_path == "local-port"):
                                self.local_port = value
                                self.local_port.value_namespace = name_space
                                self.local_port.value_namespace_prefix = name_space_prefix
                            if(value_path == "max-number-of-held-internal-ack"):
                                self.max_number_of_held_internal_ack = value
                                self.max_number_of_held_internal_ack.value_namespace = name_space
                                self.max_number_of_held_internal_ack.value_namespace_prefix = name_space_prefix
                            if(value_path == "max-number-of-held-internal-ack-reach-time"):
                                self.max_number_of_held_internal_ack_reach_time = value
                                self.max_number_of_held_internal_ack_reach_time.value_namespace = name_space
                                self.max_number_of_held_internal_ack_reach_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "max-number-of-held-packet"):
                                self.max_number_of_held_packet = value
                                self.max_number_of_held_packet.value_namespace = name_space
                                self.max_number_of_held_packet.value_namespace_prefix = name_space_prefix
                            if(value_path == "max-number-of-held-packet-reach-time"):
                                self.max_number_of_held_packet_reach_time = value
                                self.max_number_of_held_packet_reach_time.value_namespace = name_space
                                self.max_number_of_held_packet_reach_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "nsr-down-reason"):
                                self.nsr_down_reason = value
                                self.nsr_down_reason.value_namespace = name_space
                                self.nsr_down_reason.value_namespace_prefix = name_space_prefix
                            if(value_path == "nsr-down-reason-down-stream"):
                                self.nsr_down_reason_down_stream = value
                                self.nsr_down_reason_down_stream.value_namespace = name_space
                                self.nsr_down_reason_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "nsr-down-reason-up-stream"):
                                self.nsr_down_reason_up_stream = value
                                self.nsr_down_reason_up_stream.value_namespace = name_space
                                self.nsr_down_reason_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "nsr-down-time"):
                                self.nsr_down_time = value
                                self.nsr_down_time.value_namespace = name_space
                                self.nsr_down_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "nsr-down-time-down-stream"):
                                self.nsr_down_time_down_stream = value
                                self.nsr_down_time_down_stream.value_namespace = name_space
                                self.nsr_down_time_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "nsr-down-time-up-stream"):
                                self.nsr_down_time_up_stream = value
                                self.nsr_down_time_up_stream.value_namespace = name_space
                                self.nsr_down_time_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcb"):
                                self.pcb = value
                                self.pcb.value_namespace = name_space
                                self.pcb.value_namespace_prefix = name_space_prefix
                            if(value_path == "peer-endp-hdl-down-stream"):
                                self.peer_endp_hdl_down_stream = value
                                self.peer_endp_hdl_down_stream.value_namespace = name_space
                                self.peer_endp_hdl_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "peer-endp-hdl-up-stream"):
                                self.peer_endp_hdl_up_stream = value
                                self.peer_endp_hdl_up_stream.value_namespace = name_space
                                self.peer_endp_hdl_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "sequence-number-of-init-sync"):
                                self.sequence_number_of_init_sync = value
                                self.sequence_number_of_init_sync.value_namespace = name_space
                                self.sequence_number_of_init_sync.value_namespace_prefix = name_space_prefix
                            if(value_path == "sequence-number-of-init-sync-down-stream"):
                                self.sequence_number_of_init_sync_down_stream = value
                                self.sequence_number_of_init_sync_down_stream.value_namespace = name_space
                                self.sequence_number_of_init_sync_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "sequence-number-of-init-sync-up-stream"):
                                self.sequence_number_of_init_sync_up_stream = value
                                self.sequence_number_of_init_sync_up_stream.value_namespace = name_space
                                self.sequence_number_of_init_sync_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "sscb"):
                                self.sscb = value
                                self.sscb.value_namespace = name_space
                                self.sscb.value_namespace_prefix = name_space_prefix
                            if(value_path == "vrf-id"):
                                self.vrf_id = value
                                self.vrf_id.value_namespace = name_space
                                self.vrf_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.detail_session:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.detail_session:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "detail-sessions" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "detail-session"):
                            for c in self.detail_session:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Session.DetailSessions.DetailSession()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.detail_session.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detail-session"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.brief_sessions is not None and self.brief_sessions.has_data()) or
                        (self.detail_sessions is not None and self.detail_sessions.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.brief_sessions is not None and self.brief_sessions.has_operation()) or
                        (self.detail_sessions is not None and self.detail_sessions.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-sessions"):
                        if (self.brief_sessions is None):
                            self.brief_sessions = TcpNsr.Nodes.Node.Session.BriefSessions()
                            self.brief_sessions.parent = self
                            self._children_name_map["brief_sessions"] = "brief-sessions"
                        return self.brief_sessions

                    if (child_yang_name == "detail-sessions"):
                        if (self.detail_sessions is None):
                            self.detail_sessions = TcpNsr.Nodes.Node.Session.DetailSessions()
                            self.detail_sessions.parent = self
                            self._children_name_map["detail_sessions"] = "detail-sessions"
                        return self.detail_sessions

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-sessions" or name == "detail-sessions"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Client(Entity):
                """
                Information about TCP NSR Client
                
                .. attribute:: brief_clients
                
                	Information about TCP NSR Client
                	**type**\:   :py:class:`BriefClients <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Client.BriefClients>`
                
                .. attribute:: detail_clients
                
                	Table about TCP NSR Client details
                	**type**\:   :py:class:`DetailClients <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Client.DetailClients>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpNsr.Nodes.Node.Client, self).__init__()

                    self.yang_name = "client"
                    self.yang_parent_name = "node"

                    self.brief_clients = TcpNsr.Nodes.Node.Client.BriefClients()
                    self.brief_clients.parent = self
                    self._children_name_map["brief_clients"] = "brief-clients"
                    self._children_yang_names.add("brief-clients")

                    self.detail_clients = TcpNsr.Nodes.Node.Client.DetailClients()
                    self.detail_clients.parent = self
                    self._children_name_map["detail_clients"] = "detail-clients"
                    self._children_yang_names.add("detail-clients")


                class DetailClients(Entity):
                    """
                    Table about TCP NSR Client details
                    
                    .. attribute:: detail_client
                    
                    	showing detailed information of NSR Clients
                    	**type**\: list of    :py:class:`DetailClient <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Client.DetailClients.DetailClient>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Client.DetailClients, self).__init__()

                        self.yang_name = "detail-clients"
                        self.yang_parent_name = "client"

                        self.detail_client = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Client.DetailClients, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Client.DetailClients, self).__setattr__(name, value)


                    class DetailClient(Entity):
                        """
                        showing detailed information of NSR Clients
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR client
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: ccb
                        
                        	Address of the Client Control Block
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: connected_at
                        
                        	Time of connect (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: instance
                        
                        	Instance of the Client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: is_notification_registered
                        
                        	Registered with TCP for notifications?
                        	**type**\:  bool
                        
                        .. attribute:: job_id
                        
                        	JOb ID of Client
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: number_of_sessions
                        
                        	Number of sessions owned by this client 
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_up_sessions
                        
                        	Number of sessions with NSR up
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: numberof_sets
                        
                        	Number of Sets owned by this client 
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: pid
                        
                        	PID of the Client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: process_name
                        
                        	Proc name of Clinet
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Client.DetailClients.DetailClient, self).__init__()

                            self.yang_name = "detail-client"
                            self.yang_parent_name = "detail-clients"

                            self.id = YLeaf(YType.str, "id")

                            self.ccb = YLeaf(YType.uint64, "ccb")

                            self.connected_at = YLeaf(YType.uint32, "connected-at")

                            self.instance = YLeaf(YType.uint32, "instance")

                            self.is_notification_registered = YLeaf(YType.boolean, "is-notification-registered")

                            self.job_id = YLeaf(YType.int32, "job-id")

                            self.number_of_sessions = YLeaf(YType.uint32, "number-of-sessions")

                            self.number_of_up_sessions = YLeaf(YType.uint32, "number-of-up-sessions")

                            self.numberof_sets = YLeaf(YType.uint32, "numberof-sets")

                            self.pid = YLeaf(YType.uint32, "pid")

                            self.process_name = YLeaf(YType.str, "process-name")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "ccb",
                                            "connected_at",
                                            "instance",
                                            "is_notification_registered",
                                            "job_id",
                                            "number_of_sessions",
                                            "number_of_up_sessions",
                                            "numberof_sets",
                                            "pid",
                                            "process_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Client.DetailClients.DetailClient, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Client.DetailClients.DetailClient, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.id.is_set or
                                self.ccb.is_set or
                                self.connected_at.is_set or
                                self.instance.is_set or
                                self.is_notification_registered.is_set or
                                self.job_id.is_set or
                                self.number_of_sessions.is_set or
                                self.number_of_up_sessions.is_set or
                                self.numberof_sets.is_set or
                                self.pid.is_set or
                                self.process_name.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.ccb.yfilter != YFilter.not_set or
                                self.connected_at.yfilter != YFilter.not_set or
                                self.instance.yfilter != YFilter.not_set or
                                self.is_notification_registered.yfilter != YFilter.not_set or
                                self.job_id.yfilter != YFilter.not_set or
                                self.number_of_sessions.yfilter != YFilter.not_set or
                                self.number_of_up_sessions.yfilter != YFilter.not_set or
                                self.numberof_sets.yfilter != YFilter.not_set or
                                self.pid.yfilter != YFilter.not_set or
                                self.process_name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "detail-client" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.ccb.is_set or self.ccb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccb.get_name_leafdata())
                            if (self.connected_at.is_set or self.connected_at.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connected_at.get_name_leafdata())
                            if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance.get_name_leafdata())
                            if (self.is_notification_registered.is_set or self.is_notification_registered.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_notification_registered.get_name_leafdata())
                            if (self.job_id.is_set or self.job_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.job_id.get_name_leafdata())
                            if (self.number_of_sessions.is_set or self.number_of_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_sessions.get_name_leafdata())
                            if (self.number_of_up_sessions.is_set or self.number_of_up_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_up_sessions.get_name_leafdata())
                            if (self.numberof_sets.is_set or self.numberof_sets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.numberof_sets.get_name_leafdata())
                            if (self.pid.is_set or self.pid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pid.get_name_leafdata())
                            if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.process_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "id" or name == "ccb" or name == "connected-at" or name == "instance" or name == "is-notification-registered" or name == "job-id" or name == "number-of-sessions" or name == "number-of-up-sessions" or name == "numberof-sets" or name == "pid" or name == "process-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccb"):
                                self.ccb = value
                                self.ccb.value_namespace = name_space
                                self.ccb.value_namespace_prefix = name_space_prefix
                            if(value_path == "connected-at"):
                                self.connected_at = value
                                self.connected_at.value_namespace = name_space
                                self.connected_at.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance"):
                                self.instance = value
                                self.instance.value_namespace = name_space
                                self.instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-notification-registered"):
                                self.is_notification_registered = value
                                self.is_notification_registered.value_namespace = name_space
                                self.is_notification_registered.value_namespace_prefix = name_space_prefix
                            if(value_path == "job-id"):
                                self.job_id = value
                                self.job_id.value_namespace = name_space
                                self.job_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-sessions"):
                                self.number_of_sessions = value
                                self.number_of_sessions.value_namespace = name_space
                                self.number_of_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-up-sessions"):
                                self.number_of_up_sessions = value
                                self.number_of_up_sessions.value_namespace = name_space
                                self.number_of_up_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "numberof-sets"):
                                self.numberof_sets = value
                                self.numberof_sets.value_namespace = name_space
                                self.numberof_sets.value_namespace_prefix = name_space_prefix
                            if(value_path == "pid"):
                                self.pid = value
                                self.pid.value_namespace = name_space
                                self.pid.value_namespace_prefix = name_space_prefix
                            if(value_path == "process-name"):
                                self.process_name = value
                                self.process_name.value_namespace = name_space
                                self.process_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.detail_client:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.detail_client:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "detail-clients" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "detail-client"):
                            for c in self.detail_client:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Client.DetailClients.DetailClient()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.detail_client.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detail-client"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class BriefClients(Entity):
                    """
                    Information about TCP NSR Client
                    
                    .. attribute:: brief_client
                    
                    	Brief information about NSR Client
                    	**type**\: list of    :py:class:`BriefClient <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Client.BriefClients.BriefClient>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Client.BriefClients, self).__init__()

                        self.yang_name = "brief-clients"
                        self.yang_parent_name = "client"

                        self.brief_client = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Client.BriefClients, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Client.BriefClients, self).__setattr__(name, value)


                    class BriefClient(Entity):
                        """
                        Brief information about NSR Client
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR client
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: ccb
                        
                        	Address of the Client Control Block
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: instance
                        
                        	Instance of the Client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: job_id
                        
                        	JOb ID of Client
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: number_of_sessions
                        
                        	Number of sessions owned by this client 
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_up_sessions
                        
                        	Number of sessions with NSR up 
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: numberof_sets
                        
                        	Number of Sets owned by this client 
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: pid
                        
                        	PID of the Client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: process_name
                        
                        	Proc name of Clinet
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Client.BriefClients.BriefClient, self).__init__()

                            self.yang_name = "brief-client"
                            self.yang_parent_name = "brief-clients"

                            self.id = YLeaf(YType.str, "id")

                            self.ccb = YLeaf(YType.uint64, "ccb")

                            self.instance = YLeaf(YType.uint32, "instance")

                            self.job_id = YLeaf(YType.int32, "job-id")

                            self.number_of_sessions = YLeaf(YType.uint32, "number-of-sessions")

                            self.number_of_up_sessions = YLeaf(YType.uint32, "number-of-up-sessions")

                            self.numberof_sets = YLeaf(YType.uint32, "numberof-sets")

                            self.pid = YLeaf(YType.uint32, "pid")

                            self.process_name = YLeaf(YType.str, "process-name")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "ccb",
                                            "instance",
                                            "job_id",
                                            "number_of_sessions",
                                            "number_of_up_sessions",
                                            "numberof_sets",
                                            "pid",
                                            "process_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Client.BriefClients.BriefClient, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Client.BriefClients.BriefClient, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.id.is_set or
                                self.ccb.is_set or
                                self.instance.is_set or
                                self.job_id.is_set or
                                self.number_of_sessions.is_set or
                                self.number_of_up_sessions.is_set or
                                self.numberof_sets.is_set or
                                self.pid.is_set or
                                self.process_name.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.ccb.yfilter != YFilter.not_set or
                                self.instance.yfilter != YFilter.not_set or
                                self.job_id.yfilter != YFilter.not_set or
                                self.number_of_sessions.yfilter != YFilter.not_set or
                                self.number_of_up_sessions.yfilter != YFilter.not_set or
                                self.numberof_sets.yfilter != YFilter.not_set or
                                self.pid.yfilter != YFilter.not_set or
                                self.process_name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "brief-client" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.ccb.is_set or self.ccb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccb.get_name_leafdata())
                            if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance.get_name_leafdata())
                            if (self.job_id.is_set or self.job_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.job_id.get_name_leafdata())
                            if (self.number_of_sessions.is_set or self.number_of_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_sessions.get_name_leafdata())
                            if (self.number_of_up_sessions.is_set or self.number_of_up_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_up_sessions.get_name_leafdata())
                            if (self.numberof_sets.is_set or self.numberof_sets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.numberof_sets.get_name_leafdata())
                            if (self.pid.is_set or self.pid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pid.get_name_leafdata())
                            if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.process_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "id" or name == "ccb" or name == "instance" or name == "job-id" or name == "number-of-sessions" or name == "number-of-up-sessions" or name == "numberof-sets" or name == "pid" or name == "process-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccb"):
                                self.ccb = value
                                self.ccb.value_namespace = name_space
                                self.ccb.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance"):
                                self.instance = value
                                self.instance.value_namespace = name_space
                                self.instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "job-id"):
                                self.job_id = value
                                self.job_id.value_namespace = name_space
                                self.job_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-sessions"):
                                self.number_of_sessions = value
                                self.number_of_sessions.value_namespace = name_space
                                self.number_of_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-up-sessions"):
                                self.number_of_up_sessions = value
                                self.number_of_up_sessions.value_namespace = name_space
                                self.number_of_up_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "numberof-sets"):
                                self.numberof_sets = value
                                self.numberof_sets.value_namespace = name_space
                                self.numberof_sets.value_namespace_prefix = name_space_prefix
                            if(value_path == "pid"):
                                self.pid = value
                                self.pid.value_namespace = name_space
                                self.pid.value_namespace_prefix = name_space_prefix
                            if(value_path == "process-name"):
                                self.process_name = value
                                self.process_name.value_namespace = name_space
                                self.process_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.brief_client:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.brief_client:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-clients" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "brief-client"):
                            for c in self.brief_client:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Client.BriefClients.BriefClient()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.brief_client.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "brief-client"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.brief_clients is not None and self.brief_clients.has_data()) or
                        (self.detail_clients is not None and self.detail_clients.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.brief_clients is not None and self.brief_clients.has_operation()) or
                        (self.detail_clients is not None and self.detail_clients.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "client" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-clients"):
                        if (self.brief_clients is None):
                            self.brief_clients = TcpNsr.Nodes.Node.Client.BriefClients()
                            self.brief_clients.parent = self
                            self._children_name_map["brief_clients"] = "brief-clients"
                        return self.brief_clients

                    if (child_yang_name == "detail-clients"):
                        if (self.detail_clients is None):
                            self.detail_clients = TcpNsr.Nodes.Node.Client.DetailClients()
                            self.detail_clients.parent = self
                            self._children_name_map["detail_clients"] = "detail-clients"
                        return self.detail_clients

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-clients" or name == "detail-clients"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class SessionSet(Entity):
                """
                Information about TCP NSR Session Sets
                
                .. attribute:: brief_sets
                
                	Information about TCP NSR Session Sets
                	**type**\:   :py:class:`BriefSets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.SessionSet.BriefSets>`
                
                .. attribute:: detail_sets
                
                	Table about TCP NSR Session Sets details
                	**type**\:   :py:class:`DetailSets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.SessionSet.DetailSets>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpNsr.Nodes.Node.SessionSet, self).__init__()

                    self.yang_name = "session-set"
                    self.yang_parent_name = "node"

                    self.brief_sets = TcpNsr.Nodes.Node.SessionSet.BriefSets()
                    self.brief_sets.parent = self
                    self._children_name_map["brief_sets"] = "brief-sets"
                    self._children_yang_names.add("brief-sets")

                    self.detail_sets = TcpNsr.Nodes.Node.SessionSet.DetailSets()
                    self.detail_sets.parent = self
                    self._children_name_map["detail_sets"] = "detail-sets"
                    self._children_yang_names.add("detail-sets")


                class DetailSets(Entity):
                    """
                    Table about TCP NSR Session Sets details
                    
                    .. attribute:: detail_set
                    
                    	showing detailed information of NSR Session Sets
                    	**type**\: list of    :py:class:`DetailSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.SessionSet.DetailSets.DetailSet>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.SessionSet.DetailSets, self).__init__()

                        self.yang_name = "detail-sets"
                        self.yang_parent_name = "session-set"

                        self.detail_set = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.SessionSet.DetailSets, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.SessionSet.DetailSets, self).__setattr__(name, value)


                    class DetailSet(Entity):
                        """
                        showing detailed information of NSR Session
                        Sets
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR Sesison Set
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: address_family
                        
                        	Address Family of the sessions in this set
                        	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                        
                        .. attribute:: audit_end_time
                        
                        	Time at which the last audit operation was ended (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: audit_seq_number
                        
                        	ID of the current or the last audit operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: audit_start_time
                        
                        	Time at which last or current audit operation was started (in seconds since 1st Jan 1970 00\:00 \:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_end_time
                        
                        	Time at which the last initial sync operation was ended (in seconds since 1st Jan 1970 00\:00 \:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_error
                        
                        	Initial sync failure reason, if any
                        	**type**\:  str
                        
                        .. attribute:: init_sync_ready_end_time
                        
                        	Time at which the session set last went not\-ready for initial sync (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_ready_start_time
                        
                        	Time at which the session was ready for initial sync last (in seconds since 1st Jan 1970 00\:00 \:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_start_time
                        
                        	Time at which last or current initial sync operation was started (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: init_sync_timer
                        
                        	Time left on the initial sync timer
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: is_audit_in_progress
                        
                        	Is an audit in progress currently?
                        	**type**\:  bool
                        
                        .. attribute:: is_init_sync_error_local
                        
                        	Initial sync failed due to a local error or remote stack
                        	**type**\:  bool
                        
                        .. attribute:: is_init_sync_in_progress
                        
                        	Is an initial sync in progress currently?
                        	**type**\:  bool
                        
                        .. attribute:: is_init_sync_second_phase
                        
                        	Is initial sync in the second phase?
                        	**type**\:  bool
                        
                        .. attribute:: is_sscb_init_sync_ready
                        
                        	Is the SSCB ready for another initial sync?
                        	**type**\:  bool
                        
                        .. attribute:: local_instance
                        
                        	Instance of the client application on the local node
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_node
                        
                        	Local node of this set
                        	**type**\:  str
                        
                        	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                        
                        .. attribute:: mode
                        
                        	Session\-set mode
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: nsr_reset_time
                        
                        	Time at which NSR was last reset on the session set (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: number_of_init_synced_sessions
                        
                        	Number of sessions that are synced as part of the current initial sync operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_sessions
                        
                        	Number of Sessions in the set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_sessions_init_sync_failed
                        
                        	Number of sessions that failed to sync as part of the current initial sync operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_synced_sessions_down_stream
                        
                        	How many sessions are synced with downstream partner
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_synced_sessions_up_stream
                        
                        	How many sessions are synced with upstream partner
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: pid
                        
                        	PID of the Client that owns this Session\-set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: protect_instance
                        
                        	Instance of the client application on the protection node
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: protect_node
                        
                        	The node protecting this set
                        	**type**\:  str
                        
                        	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                        
                        .. attribute:: sequence_number_of_init_sync
                        
                        	ID of the current or the last initial sync operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_id
                        
                        	ID of this Session\-set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: sscb
                        
                        	Address of the Session Set Control Block
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: sso_role
                        
                        	TCP role for this set?
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_number_of_init_sync_sessions
                        
                        	Number of sessions being synced as part of the current initial sync operation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: well_known_port
                        
                        	Well Known Port of the client
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.SessionSet.DetailSets.DetailSet, self).__init__()

                            self.yang_name = "detail-set"
                            self.yang_parent_name = "detail-sets"

                            self.id = YLeaf(YType.str, "id")

                            self.address_family = YLeaf(YType.enumeration, "address-family")

                            self.audit_end_time = YLeaf(YType.uint32, "audit-end-time")

                            self.audit_seq_number = YLeaf(YType.uint32, "audit-seq-number")

                            self.audit_start_time = YLeaf(YType.uint32, "audit-start-time")

                            self.init_sync_end_time = YLeaf(YType.uint32, "init-sync-end-time")

                            self.init_sync_error = YLeaf(YType.str, "init-sync-error")

                            self.init_sync_ready_end_time = YLeaf(YType.uint32, "init-sync-ready-end-time")

                            self.init_sync_ready_start_time = YLeaf(YType.uint32, "init-sync-ready-start-time")

                            self.init_sync_start_time = YLeaf(YType.uint32, "init-sync-start-time")

                            self.init_sync_timer = YLeaf(YType.uint32, "init-sync-timer")

                            self.is_audit_in_progress = YLeaf(YType.boolean, "is-audit-in-progress")

                            self.is_init_sync_error_local = YLeaf(YType.boolean, "is-init-sync-error-local")

                            self.is_init_sync_in_progress = YLeaf(YType.boolean, "is-init-sync-in-progress")

                            self.is_init_sync_second_phase = YLeaf(YType.boolean, "is-init-sync-second-phase")

                            self.is_sscb_init_sync_ready = YLeaf(YType.boolean, "is-sscb-init-sync-ready")

                            self.local_instance = YLeaf(YType.uint32, "local-instance")

                            self.local_node = YLeaf(YType.str, "local-node")

                            self.mode = YLeaf(YType.uint32, "mode")

                            self.nsr_reset_time = YLeaf(YType.uint32, "nsr-reset-time")

                            self.number_of_init_synced_sessions = YLeaf(YType.uint32, "number-of-init-synced-sessions")

                            self.number_of_sessions = YLeaf(YType.uint32, "number-of-sessions")

                            self.number_of_sessions_init_sync_failed = YLeaf(YType.uint32, "number-of-sessions-init-sync-failed")

                            self.number_of_synced_sessions_down_stream = YLeaf(YType.uint32, "number-of-synced-sessions-down-stream")

                            self.number_of_synced_sessions_up_stream = YLeaf(YType.uint32, "number-of-synced-sessions-up-stream")

                            self.pid = YLeaf(YType.uint32, "pid")

                            self.protect_instance = YLeaf(YType.uint32, "protect-instance")

                            self.protect_node = YLeaf(YType.str, "protect-node")

                            self.sequence_number_of_init_sync = YLeaf(YType.uint32, "sequence-number-of-init-sync")

                            self.set_id = YLeaf(YType.uint32, "set-id")

                            self.sscb = YLeaf(YType.uint64, "sscb")

                            self.sso_role = YLeaf(YType.uint32, "sso-role")

                            self.total_number_of_init_sync_sessions = YLeaf(YType.uint32, "total-number-of-init-sync-sessions")

                            self.well_known_port = YLeaf(YType.uint16, "well-known-port")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "address_family",
                                            "audit_end_time",
                                            "audit_seq_number",
                                            "audit_start_time",
                                            "init_sync_end_time",
                                            "init_sync_error",
                                            "init_sync_ready_end_time",
                                            "init_sync_ready_start_time",
                                            "init_sync_start_time",
                                            "init_sync_timer",
                                            "is_audit_in_progress",
                                            "is_init_sync_error_local",
                                            "is_init_sync_in_progress",
                                            "is_init_sync_second_phase",
                                            "is_sscb_init_sync_ready",
                                            "local_instance",
                                            "local_node",
                                            "mode",
                                            "nsr_reset_time",
                                            "number_of_init_synced_sessions",
                                            "number_of_sessions",
                                            "number_of_sessions_init_sync_failed",
                                            "number_of_synced_sessions_down_stream",
                                            "number_of_synced_sessions_up_stream",
                                            "pid",
                                            "protect_instance",
                                            "protect_node",
                                            "sequence_number_of_init_sync",
                                            "set_id",
                                            "sscb",
                                            "sso_role",
                                            "total_number_of_init_sync_sessions",
                                            "well_known_port") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.SessionSet.DetailSets.DetailSet, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.SessionSet.DetailSets.DetailSet, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.id.is_set or
                                self.address_family.is_set or
                                self.audit_end_time.is_set or
                                self.audit_seq_number.is_set or
                                self.audit_start_time.is_set or
                                self.init_sync_end_time.is_set or
                                self.init_sync_error.is_set or
                                self.init_sync_ready_end_time.is_set or
                                self.init_sync_ready_start_time.is_set or
                                self.init_sync_start_time.is_set or
                                self.init_sync_timer.is_set or
                                self.is_audit_in_progress.is_set or
                                self.is_init_sync_error_local.is_set or
                                self.is_init_sync_in_progress.is_set or
                                self.is_init_sync_second_phase.is_set or
                                self.is_sscb_init_sync_ready.is_set or
                                self.local_instance.is_set or
                                self.local_node.is_set or
                                self.mode.is_set or
                                self.nsr_reset_time.is_set or
                                self.number_of_init_synced_sessions.is_set or
                                self.number_of_sessions.is_set or
                                self.number_of_sessions_init_sync_failed.is_set or
                                self.number_of_synced_sessions_down_stream.is_set or
                                self.number_of_synced_sessions_up_stream.is_set or
                                self.pid.is_set or
                                self.protect_instance.is_set or
                                self.protect_node.is_set or
                                self.sequence_number_of_init_sync.is_set or
                                self.set_id.is_set or
                                self.sscb.is_set or
                                self.sso_role.is_set or
                                self.total_number_of_init_sync_sessions.is_set or
                                self.well_known_port.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.address_family.yfilter != YFilter.not_set or
                                self.audit_end_time.yfilter != YFilter.not_set or
                                self.audit_seq_number.yfilter != YFilter.not_set or
                                self.audit_start_time.yfilter != YFilter.not_set or
                                self.init_sync_end_time.yfilter != YFilter.not_set or
                                self.init_sync_error.yfilter != YFilter.not_set or
                                self.init_sync_ready_end_time.yfilter != YFilter.not_set or
                                self.init_sync_ready_start_time.yfilter != YFilter.not_set or
                                self.init_sync_start_time.yfilter != YFilter.not_set or
                                self.init_sync_timer.yfilter != YFilter.not_set or
                                self.is_audit_in_progress.yfilter != YFilter.not_set or
                                self.is_init_sync_error_local.yfilter != YFilter.not_set or
                                self.is_init_sync_in_progress.yfilter != YFilter.not_set or
                                self.is_init_sync_second_phase.yfilter != YFilter.not_set or
                                self.is_sscb_init_sync_ready.yfilter != YFilter.not_set or
                                self.local_instance.yfilter != YFilter.not_set or
                                self.local_node.yfilter != YFilter.not_set or
                                self.mode.yfilter != YFilter.not_set or
                                self.nsr_reset_time.yfilter != YFilter.not_set or
                                self.number_of_init_synced_sessions.yfilter != YFilter.not_set or
                                self.number_of_sessions.yfilter != YFilter.not_set or
                                self.number_of_sessions_init_sync_failed.yfilter != YFilter.not_set or
                                self.number_of_synced_sessions_down_stream.yfilter != YFilter.not_set or
                                self.number_of_synced_sessions_up_stream.yfilter != YFilter.not_set or
                                self.pid.yfilter != YFilter.not_set or
                                self.protect_instance.yfilter != YFilter.not_set or
                                self.protect_node.yfilter != YFilter.not_set or
                                self.sequence_number_of_init_sync.yfilter != YFilter.not_set or
                                self.set_id.yfilter != YFilter.not_set or
                                self.sscb.yfilter != YFilter.not_set or
                                self.sso_role.yfilter != YFilter.not_set or
                                self.total_number_of_init_sync_sessions.yfilter != YFilter.not_set or
                                self.well_known_port.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "detail-set" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address_family.get_name_leafdata())
                            if (self.audit_end_time.is_set or self.audit_end_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.audit_end_time.get_name_leafdata())
                            if (self.audit_seq_number.is_set or self.audit_seq_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.audit_seq_number.get_name_leafdata())
                            if (self.audit_start_time.is_set or self.audit_start_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.audit_start_time.get_name_leafdata())
                            if (self.init_sync_end_time.is_set or self.init_sync_end_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_end_time.get_name_leafdata())
                            if (self.init_sync_error.is_set or self.init_sync_error.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_error.get_name_leafdata())
                            if (self.init_sync_ready_end_time.is_set or self.init_sync_ready_end_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_ready_end_time.get_name_leafdata())
                            if (self.init_sync_ready_start_time.is_set or self.init_sync_ready_start_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_ready_start_time.get_name_leafdata())
                            if (self.init_sync_start_time.is_set or self.init_sync_start_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_start_time.get_name_leafdata())
                            if (self.init_sync_timer.is_set or self.init_sync_timer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.init_sync_timer.get_name_leafdata())
                            if (self.is_audit_in_progress.is_set or self.is_audit_in_progress.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_audit_in_progress.get_name_leafdata())
                            if (self.is_init_sync_error_local.is_set or self.is_init_sync_error_local.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_init_sync_error_local.get_name_leafdata())
                            if (self.is_init_sync_in_progress.is_set or self.is_init_sync_in_progress.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_init_sync_in_progress.get_name_leafdata())
                            if (self.is_init_sync_second_phase.is_set or self.is_init_sync_second_phase.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_init_sync_second_phase.get_name_leafdata())
                            if (self.is_sscb_init_sync_ready.is_set or self.is_sscb_init_sync_ready.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_sscb_init_sync_ready.get_name_leafdata())
                            if (self.local_instance.is_set or self.local_instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_instance.get_name_leafdata())
                            if (self.local_node.is_set or self.local_node.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_node.get_name_leafdata())
                            if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mode.get_name_leafdata())
                            if (self.nsr_reset_time.is_set or self.nsr_reset_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nsr_reset_time.get_name_leafdata())
                            if (self.number_of_init_synced_sessions.is_set or self.number_of_init_synced_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_init_synced_sessions.get_name_leafdata())
                            if (self.number_of_sessions.is_set or self.number_of_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_sessions.get_name_leafdata())
                            if (self.number_of_sessions_init_sync_failed.is_set or self.number_of_sessions_init_sync_failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_sessions_init_sync_failed.get_name_leafdata())
                            if (self.number_of_synced_sessions_down_stream.is_set or self.number_of_synced_sessions_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_synced_sessions_down_stream.get_name_leafdata())
                            if (self.number_of_synced_sessions_up_stream.is_set or self.number_of_synced_sessions_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_synced_sessions_up_stream.get_name_leafdata())
                            if (self.pid.is_set or self.pid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pid.get_name_leafdata())
                            if (self.protect_instance.is_set or self.protect_instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protect_instance.get_name_leafdata())
                            if (self.protect_node.is_set or self.protect_node.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protect_node.get_name_leafdata())
                            if (self.sequence_number_of_init_sync.is_set or self.sequence_number_of_init_sync.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sequence_number_of_init_sync.get_name_leafdata())
                            if (self.set_id.is_set or self.set_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_id.get_name_leafdata())
                            if (self.sscb.is_set or self.sscb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sscb.get_name_leafdata())
                            if (self.sso_role.is_set or self.sso_role.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sso_role.get_name_leafdata())
                            if (self.total_number_of_init_sync_sessions.is_set or self.total_number_of_init_sync_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_number_of_init_sync_sessions.get_name_leafdata())
                            if (self.well_known_port.is_set or self.well_known_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.well_known_port.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "id" or name == "address-family" or name == "audit-end-time" or name == "audit-seq-number" or name == "audit-start-time" or name == "init-sync-end-time" or name == "init-sync-error" or name == "init-sync-ready-end-time" or name == "init-sync-ready-start-time" or name == "init-sync-start-time" or name == "init-sync-timer" or name == "is-audit-in-progress" or name == "is-init-sync-error-local" or name == "is-init-sync-in-progress" or name == "is-init-sync-second-phase" or name == "is-sscb-init-sync-ready" or name == "local-instance" or name == "local-node" or name == "mode" or name == "nsr-reset-time" or name == "number-of-init-synced-sessions" or name == "number-of-sessions" or name == "number-of-sessions-init-sync-failed" or name == "number-of-synced-sessions-down-stream" or name == "number-of-synced-sessions-up-stream" or name == "pid" or name == "protect-instance" or name == "protect-node" or name == "sequence-number-of-init-sync" or name == "set-id" or name == "sscb" or name == "sso-role" or name == "total-number-of-init-sync-sessions" or name == "well-known-port"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "address-family"):
                                self.address_family = value
                                self.address_family.value_namespace = name_space
                                self.address_family.value_namespace_prefix = name_space_prefix
                            if(value_path == "audit-end-time"):
                                self.audit_end_time = value
                                self.audit_end_time.value_namespace = name_space
                                self.audit_end_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "audit-seq-number"):
                                self.audit_seq_number = value
                                self.audit_seq_number.value_namespace = name_space
                                self.audit_seq_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "audit-start-time"):
                                self.audit_start_time = value
                                self.audit_start_time.value_namespace = name_space
                                self.audit_start_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-end-time"):
                                self.init_sync_end_time = value
                                self.init_sync_end_time.value_namespace = name_space
                                self.init_sync_end_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-error"):
                                self.init_sync_error = value
                                self.init_sync_error.value_namespace = name_space
                                self.init_sync_error.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-ready-end-time"):
                                self.init_sync_ready_end_time = value
                                self.init_sync_ready_end_time.value_namespace = name_space
                                self.init_sync_ready_end_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-ready-start-time"):
                                self.init_sync_ready_start_time = value
                                self.init_sync_ready_start_time.value_namespace = name_space
                                self.init_sync_ready_start_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-start-time"):
                                self.init_sync_start_time = value
                                self.init_sync_start_time.value_namespace = name_space
                                self.init_sync_start_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "init-sync-timer"):
                                self.init_sync_timer = value
                                self.init_sync_timer.value_namespace = name_space
                                self.init_sync_timer.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-audit-in-progress"):
                                self.is_audit_in_progress = value
                                self.is_audit_in_progress.value_namespace = name_space
                                self.is_audit_in_progress.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-init-sync-error-local"):
                                self.is_init_sync_error_local = value
                                self.is_init_sync_error_local.value_namespace = name_space
                                self.is_init_sync_error_local.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-init-sync-in-progress"):
                                self.is_init_sync_in_progress = value
                                self.is_init_sync_in_progress.value_namespace = name_space
                                self.is_init_sync_in_progress.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-init-sync-second-phase"):
                                self.is_init_sync_second_phase = value
                                self.is_init_sync_second_phase.value_namespace = name_space
                                self.is_init_sync_second_phase.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-sscb-init-sync-ready"):
                                self.is_sscb_init_sync_ready = value
                                self.is_sscb_init_sync_ready.value_namespace = name_space
                                self.is_sscb_init_sync_ready.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-instance"):
                                self.local_instance = value
                                self.local_instance.value_namespace = name_space
                                self.local_instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-node"):
                                self.local_node = value
                                self.local_node.value_namespace = name_space
                                self.local_node.value_namespace_prefix = name_space_prefix
                            if(value_path == "mode"):
                                self.mode = value
                                self.mode.value_namespace = name_space
                                self.mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "nsr-reset-time"):
                                self.nsr_reset_time = value
                                self.nsr_reset_time.value_namespace = name_space
                                self.nsr_reset_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-init-synced-sessions"):
                                self.number_of_init_synced_sessions = value
                                self.number_of_init_synced_sessions.value_namespace = name_space
                                self.number_of_init_synced_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-sessions"):
                                self.number_of_sessions = value
                                self.number_of_sessions.value_namespace = name_space
                                self.number_of_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-sessions-init-sync-failed"):
                                self.number_of_sessions_init_sync_failed = value
                                self.number_of_sessions_init_sync_failed.value_namespace = name_space
                                self.number_of_sessions_init_sync_failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-synced-sessions-down-stream"):
                                self.number_of_synced_sessions_down_stream = value
                                self.number_of_synced_sessions_down_stream.value_namespace = name_space
                                self.number_of_synced_sessions_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-synced-sessions-up-stream"):
                                self.number_of_synced_sessions_up_stream = value
                                self.number_of_synced_sessions_up_stream.value_namespace = name_space
                                self.number_of_synced_sessions_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "pid"):
                                self.pid = value
                                self.pid.value_namespace = name_space
                                self.pid.value_namespace_prefix = name_space_prefix
                            if(value_path == "protect-instance"):
                                self.protect_instance = value
                                self.protect_instance.value_namespace = name_space
                                self.protect_instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "protect-node"):
                                self.protect_node = value
                                self.protect_node.value_namespace = name_space
                                self.protect_node.value_namespace_prefix = name_space_prefix
                            if(value_path == "sequence-number-of-init-sync"):
                                self.sequence_number_of_init_sync = value
                                self.sequence_number_of_init_sync.value_namespace = name_space
                                self.sequence_number_of_init_sync.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-id"):
                                self.set_id = value
                                self.set_id.value_namespace = name_space
                                self.set_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "sscb"):
                                self.sscb = value
                                self.sscb.value_namespace = name_space
                                self.sscb.value_namespace_prefix = name_space_prefix
                            if(value_path == "sso-role"):
                                self.sso_role = value
                                self.sso_role.value_namespace = name_space
                                self.sso_role.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-number-of-init-sync-sessions"):
                                self.total_number_of_init_sync_sessions = value
                                self.total_number_of_init_sync_sessions.value_namespace = name_space
                                self.total_number_of_init_sync_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "well-known-port"):
                                self.well_known_port = value
                                self.well_known_port.value_namespace = name_space
                                self.well_known_port.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.detail_set:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.detail_set:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "detail-sets" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "detail-set"):
                            for c in self.detail_set:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.SessionSet.DetailSets.DetailSet()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.detail_set.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detail-set"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class BriefSets(Entity):
                    """
                    Information about TCP NSR Session Sets
                    
                    .. attribute:: brief_set
                    
                    	Brief information about NSR Session Sets
                    	**type**\: list of    :py:class:`BriefSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.SessionSet.BriefSets.BriefSet>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.SessionSet.BriefSets, self).__init__()

                        self.yang_name = "brief-sets"
                        self.yang_parent_name = "session-set"

                        self.brief_set = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.SessionSet.BriefSets, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.SessionSet.BriefSets, self).__setattr__(name, value)


                    class BriefSet(Entity):
                        """
                        Brief information about NSR Session Sets
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR Session Set
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: address_family
                        
                        	Address Family of the sessions in this set
                        	**type**\:   :py:class:`AddrFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.AddrFamily>`
                        
                        .. attribute:: client_instance
                        
                        	Instance of the Client that owns this Session\-set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: client_name
                        
                        	the name of Clinet that owns this Session\-set
                        	**type**\:  str
                        
                        .. attribute:: is_init_sync_in_progress
                        
                        	Is an initial sync in progress currently?
                        	**type**\:  bool
                        
                        .. attribute:: is_sscb_init_sync_ready
                        
                        	Is the SSCB ready for another initial sync?
                        	**type**\:  bool
                        
                        .. attribute:: local_instance
                        
                        	Instance of the client application on the local node
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_node
                        
                        	Local node of this set
                        	**type**\:  str
                        
                        	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                        
                        .. attribute:: mode
                        
                        	Session\-set mode
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_sessions
                        
                        	Number of Sessions in the set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_synced_sessions_down_stream
                        
                        	How many sessions are synced with downstream partner
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_synced_sessions_up_stream
                        
                        	How many sessions are synced with upstream partner
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: pid
                        
                        	PID of the Client that owns this Session\-set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: protect_instance
                        
                        	Instance of the client application on the protection node
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: protect_node
                        
                        	The node protecting this set
                        	**type**\:  str
                        
                        	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                        
                        .. attribute:: set_id
                        
                        	ID of this Session\-set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: sscb
                        
                        	Address of the Session Set Control Block
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: sso_role
                        
                        	TCP role for this set?
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: well_known_port
                        
                        	Well Known Port of the client
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.SessionSet.BriefSets.BriefSet, self).__init__()

                            self.yang_name = "brief-set"
                            self.yang_parent_name = "brief-sets"

                            self.id = YLeaf(YType.str, "id")

                            self.address_family = YLeaf(YType.enumeration, "address-family")

                            self.client_instance = YLeaf(YType.uint32, "client-instance")

                            self.client_name = YLeaf(YType.str, "client-name")

                            self.is_init_sync_in_progress = YLeaf(YType.boolean, "is-init-sync-in-progress")

                            self.is_sscb_init_sync_ready = YLeaf(YType.boolean, "is-sscb-init-sync-ready")

                            self.local_instance = YLeaf(YType.uint32, "local-instance")

                            self.local_node = YLeaf(YType.str, "local-node")

                            self.mode = YLeaf(YType.uint32, "mode")

                            self.number_of_sessions = YLeaf(YType.uint32, "number-of-sessions")

                            self.number_of_synced_sessions_down_stream = YLeaf(YType.uint32, "number-of-synced-sessions-down-stream")

                            self.number_of_synced_sessions_up_stream = YLeaf(YType.uint32, "number-of-synced-sessions-up-stream")

                            self.pid = YLeaf(YType.uint32, "pid")

                            self.protect_instance = YLeaf(YType.uint32, "protect-instance")

                            self.protect_node = YLeaf(YType.str, "protect-node")

                            self.set_id = YLeaf(YType.uint32, "set-id")

                            self.sscb = YLeaf(YType.uint64, "sscb")

                            self.sso_role = YLeaf(YType.uint32, "sso-role")

                            self.well_known_port = YLeaf(YType.uint16, "well-known-port")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "address_family",
                                            "client_instance",
                                            "client_name",
                                            "is_init_sync_in_progress",
                                            "is_sscb_init_sync_ready",
                                            "local_instance",
                                            "local_node",
                                            "mode",
                                            "number_of_sessions",
                                            "number_of_synced_sessions_down_stream",
                                            "number_of_synced_sessions_up_stream",
                                            "pid",
                                            "protect_instance",
                                            "protect_node",
                                            "set_id",
                                            "sscb",
                                            "sso_role",
                                            "well_known_port") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.SessionSet.BriefSets.BriefSet, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.SessionSet.BriefSets.BriefSet, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.id.is_set or
                                self.address_family.is_set or
                                self.client_instance.is_set or
                                self.client_name.is_set or
                                self.is_init_sync_in_progress.is_set or
                                self.is_sscb_init_sync_ready.is_set or
                                self.local_instance.is_set or
                                self.local_node.is_set or
                                self.mode.is_set or
                                self.number_of_sessions.is_set or
                                self.number_of_synced_sessions_down_stream.is_set or
                                self.number_of_synced_sessions_up_stream.is_set or
                                self.pid.is_set or
                                self.protect_instance.is_set or
                                self.protect_node.is_set or
                                self.set_id.is_set or
                                self.sscb.is_set or
                                self.sso_role.is_set or
                                self.well_known_port.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.address_family.yfilter != YFilter.not_set or
                                self.client_instance.yfilter != YFilter.not_set or
                                self.client_name.yfilter != YFilter.not_set or
                                self.is_init_sync_in_progress.yfilter != YFilter.not_set or
                                self.is_sscb_init_sync_ready.yfilter != YFilter.not_set or
                                self.local_instance.yfilter != YFilter.not_set or
                                self.local_node.yfilter != YFilter.not_set or
                                self.mode.yfilter != YFilter.not_set or
                                self.number_of_sessions.yfilter != YFilter.not_set or
                                self.number_of_synced_sessions_down_stream.yfilter != YFilter.not_set or
                                self.number_of_synced_sessions_up_stream.yfilter != YFilter.not_set or
                                self.pid.yfilter != YFilter.not_set or
                                self.protect_instance.yfilter != YFilter.not_set or
                                self.protect_node.yfilter != YFilter.not_set or
                                self.set_id.yfilter != YFilter.not_set or
                                self.sscb.yfilter != YFilter.not_set or
                                self.sso_role.yfilter != YFilter.not_set or
                                self.well_known_port.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "brief-set" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address_family.get_name_leafdata())
                            if (self.client_instance.is_set or self.client_instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.client_instance.get_name_leafdata())
                            if (self.client_name.is_set or self.client_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.client_name.get_name_leafdata())
                            if (self.is_init_sync_in_progress.is_set or self.is_init_sync_in_progress.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_init_sync_in_progress.get_name_leafdata())
                            if (self.is_sscb_init_sync_ready.is_set or self.is_sscb_init_sync_ready.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_sscb_init_sync_ready.get_name_leafdata())
                            if (self.local_instance.is_set or self.local_instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_instance.get_name_leafdata())
                            if (self.local_node.is_set or self.local_node.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_node.get_name_leafdata())
                            if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mode.get_name_leafdata())
                            if (self.number_of_sessions.is_set or self.number_of_sessions.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_sessions.get_name_leafdata())
                            if (self.number_of_synced_sessions_down_stream.is_set or self.number_of_synced_sessions_down_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_synced_sessions_down_stream.get_name_leafdata())
                            if (self.number_of_synced_sessions_up_stream.is_set or self.number_of_synced_sessions_up_stream.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_synced_sessions_up_stream.get_name_leafdata())
                            if (self.pid.is_set or self.pid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pid.get_name_leafdata())
                            if (self.protect_instance.is_set or self.protect_instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protect_instance.get_name_leafdata())
                            if (self.protect_node.is_set or self.protect_node.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protect_node.get_name_leafdata())
                            if (self.set_id.is_set or self.set_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_id.get_name_leafdata())
                            if (self.sscb.is_set or self.sscb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sscb.get_name_leafdata())
                            if (self.sso_role.is_set or self.sso_role.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sso_role.get_name_leafdata())
                            if (self.well_known_port.is_set or self.well_known_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.well_known_port.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "id" or name == "address-family" or name == "client-instance" or name == "client-name" or name == "is-init-sync-in-progress" or name == "is-sscb-init-sync-ready" or name == "local-instance" or name == "local-node" or name == "mode" or name == "number-of-sessions" or name == "number-of-synced-sessions-down-stream" or name == "number-of-synced-sessions-up-stream" or name == "pid" or name == "protect-instance" or name == "protect-node" or name == "set-id" or name == "sscb" or name == "sso-role" or name == "well-known-port"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "address-family"):
                                self.address_family = value
                                self.address_family.value_namespace = name_space
                                self.address_family.value_namespace_prefix = name_space_prefix
                            if(value_path == "client-instance"):
                                self.client_instance = value
                                self.client_instance.value_namespace = name_space
                                self.client_instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "client-name"):
                                self.client_name = value
                                self.client_name.value_namespace = name_space
                                self.client_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-init-sync-in-progress"):
                                self.is_init_sync_in_progress = value
                                self.is_init_sync_in_progress.value_namespace = name_space
                                self.is_init_sync_in_progress.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-sscb-init-sync-ready"):
                                self.is_sscb_init_sync_ready = value
                                self.is_sscb_init_sync_ready.value_namespace = name_space
                                self.is_sscb_init_sync_ready.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-instance"):
                                self.local_instance = value
                                self.local_instance.value_namespace = name_space
                                self.local_instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-node"):
                                self.local_node = value
                                self.local_node.value_namespace = name_space
                                self.local_node.value_namespace_prefix = name_space_prefix
                            if(value_path == "mode"):
                                self.mode = value
                                self.mode.value_namespace = name_space
                                self.mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-sessions"):
                                self.number_of_sessions = value
                                self.number_of_sessions.value_namespace = name_space
                                self.number_of_sessions.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-synced-sessions-down-stream"):
                                self.number_of_synced_sessions_down_stream = value
                                self.number_of_synced_sessions_down_stream.value_namespace = name_space
                                self.number_of_synced_sessions_down_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-synced-sessions-up-stream"):
                                self.number_of_synced_sessions_up_stream = value
                                self.number_of_synced_sessions_up_stream.value_namespace = name_space
                                self.number_of_synced_sessions_up_stream.value_namespace_prefix = name_space_prefix
                            if(value_path == "pid"):
                                self.pid = value
                                self.pid.value_namespace = name_space
                                self.pid.value_namespace_prefix = name_space_prefix
                            if(value_path == "protect-instance"):
                                self.protect_instance = value
                                self.protect_instance.value_namespace = name_space
                                self.protect_instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "protect-node"):
                                self.protect_node = value
                                self.protect_node.value_namespace = name_space
                                self.protect_node.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-id"):
                                self.set_id = value
                                self.set_id.value_namespace = name_space
                                self.set_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "sscb"):
                                self.sscb = value
                                self.sscb.value_namespace = name_space
                                self.sscb.value_namespace_prefix = name_space_prefix
                            if(value_path == "sso-role"):
                                self.sso_role = value
                                self.sso_role.value_namespace = name_space
                                self.sso_role.value_namespace_prefix = name_space_prefix
                            if(value_path == "well-known-port"):
                                self.well_known_port = value
                                self.well_known_port.value_namespace = name_space
                                self.well_known_port.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.brief_set:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.brief_set:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-sets" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "brief-set"):
                            for c in self.brief_set:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.SessionSet.BriefSets.BriefSet()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.brief_set.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "brief-set"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.brief_sets is not None and self.brief_sets.has_data()) or
                        (self.detail_sets is not None and self.detail_sets.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.brief_sets is not None and self.brief_sets.has_operation()) or
                        (self.detail_sets is not None and self.detail_sets.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-set" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-sets"):
                        if (self.brief_sets is None):
                            self.brief_sets = TcpNsr.Nodes.Node.SessionSet.BriefSets()
                            self.brief_sets.parent = self
                            self._children_name_map["brief_sets"] = "brief-sets"
                        return self.brief_sets

                    if (child_yang_name == "detail-sets"):
                        if (self.detail_sets is None):
                            self.detail_sets = TcpNsr.Nodes.Node.SessionSet.DetailSets()
                            self.detail_sets.parent = self
                            self._children_name_map["detail_sets"] = "detail-sets"
                        return self.detail_sets

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-sets" or name == "detail-sets"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Statistics(Entity):
                """
                Statis Information about TCP NSR connections
                
                .. attribute:: statistic_clients
                
                	Table listing NSR connections for which statistic information is provided
                	**type**\:   :py:class:`StatisticClients <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticClients>`
                
                .. attribute:: statistic_sessions
                
                	Table listing NSR connections for which statistic information is provided
                	**type**\:   :py:class:`StatisticSessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticSessions>`
                
                .. attribute:: statistic_sets
                
                	Table listing NSR connections for which statistic information is provided
                	**type**\:   :py:class:`StatisticSets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticSets>`
                
                .. attribute:: summary
                
                	Summary statistics across all NSR connections
                	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary>`
                
                

                """

                _prefix = 'ip-tcp-oper'
                _revision = '2016-02-26'

                def __init__(self):
                    super(TcpNsr.Nodes.Node.Statistics, self).__init__()

                    self.yang_name = "statistics"
                    self.yang_parent_name = "node"

                    self.statistic_clients = TcpNsr.Nodes.Node.Statistics.StatisticClients()
                    self.statistic_clients.parent = self
                    self._children_name_map["statistic_clients"] = "statistic-clients"
                    self._children_yang_names.add("statistic-clients")

                    self.statistic_sessions = TcpNsr.Nodes.Node.Statistics.StatisticSessions()
                    self.statistic_sessions.parent = self
                    self._children_name_map["statistic_sessions"] = "statistic-sessions"
                    self._children_yang_names.add("statistic-sessions")

                    self.statistic_sets = TcpNsr.Nodes.Node.Statistics.StatisticSets()
                    self.statistic_sets.parent = self
                    self._children_name_map["statistic_sets"] = "statistic-sets"
                    self._children_yang_names.add("statistic-sets")

                    self.summary = TcpNsr.Nodes.Node.Statistics.Summary()
                    self.summary.parent = self
                    self._children_name_map["summary"] = "summary"
                    self._children_yang_names.add("summary")


                class Summary(Entity):
                    """
                    Summary statistics across all NSR connections
                    
                    .. attribute:: audit_counters
                    
                    	Aggregate Audit counters
                    	**type**\:   :py:class:`AuditCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters>`
                    
                    .. attribute:: held_packet_drops
                    
                    	Number of held packets dropped because of errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: internal_ack_drops_immediate_match
                    
                    	Number of iACKs not held because of an immediate match
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: internal_ack_drops_initsync_first_phase
                    
                    	Number of iACKs dropped because init\-sync is in 1st phase
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: internal_ack_drops_not_replicated
                    
                    	Number of iACKs dropped because session is not replicated
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: internal_ack_drops_stale
                    
                    	Number of stale iACKs dropped
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: last_cleared_time
                    
                    	Time of last clear (in seconds since 1st Jan 1970 00\:00\:00)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: notification_statistic
                    
                    	Various types of notification stats
                    	**type**\: list of    :py:class:`NotificationStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary.NotificationStatistic>`
                    
                    .. attribute:: number_of_added_sessions
                    
                    	Number of added sessions
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_attempted_init_sync
                    
                    	no. of initial\-sync attempts
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_connected_clients
                    
                    	Number of disconnected clients
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_created_session_sets
                    
                    	Number of created session sets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_current_clients
                    
                    	Number of current  clients
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_current_session_sets
                    
                    	Number of current session sets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_current_sessions
                    
                    	Number of current sessions
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_deleted_sessions
                    
                    	Number of deleted sessions
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_destroyed_session_sets
                    
                    	Number of destroyed session sets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_disconnected_clients
                    
                    	Number of disconnected clients
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_failed_init_sync
                    
                    	no. of initial\-sync fails
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_held_but_dropped_internal_acks
                    
                    	Number of held Internal Acks dropped by Active TCP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_held_but_dropped_packets
                    
                    	Number of held packets dropped by Active TCP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_held_internal_acks
                    
                    	Number of Internal Acks held by Active TCP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_held_packets
                    
                    	Number of Packets held by Active TCP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_internal_ack_drops_no_pcb
                    
                    	Number of iACKs dropped because there is no PCB
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_internal_ack_drops_no_scbdp
                    
                    	Number of iACKs dropped because there is no datapath SCB
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_partner_node
                    
                    	 Number of Parner Nodes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_qad_receive_messages_accepts
                    
                    	Number of messages accepted from partner TCP stack(s)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_qad_receive_messages_drops
                    
                    	Number of dropped messages from partner TCP stack(s)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_qad_receive_messages_unknowns
                    
                    	Number of unknown messages from partner TCP stack(s)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_qad_stale_receive_messages_drops
                    
                    	Number of dropped messages from partner TCP stack(s) because they were out\-of\-order
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_qad_transfer_message_drops
                    
                    	Number of messages failed to be sent to partner TCP stack(s)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_qad_transfer_message_sent
                    
                    	Number of messages sent to partner TCP stack(s)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_received_internal_acks
                    
                    	Number of Internal Acks received by Active TCP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_sent_internal_acks
                    
                    	Number of Internal Acks sent to Active TCP by Standby TCP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_succeeded_init_sync
                    
                    	no. of initial\-sync successes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: snd_counters
                    
                    	Aggregate Send path counters
                    	**type**\:   :py:class:`SndCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary.SndCounters>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Statistics.Summary, self).__init__()

                        self.yang_name = "summary"
                        self.yang_parent_name = "statistics"

                        self.held_packet_drops = YLeaf(YType.uint32, "held-packet-drops")

                        self.internal_ack_drops_immediate_match = YLeaf(YType.uint32, "internal-ack-drops-immediate-match")

                        self.internal_ack_drops_initsync_first_phase = YLeaf(YType.uint32, "internal-ack-drops-initsync-first-phase")

                        self.internal_ack_drops_not_replicated = YLeaf(YType.uint32, "internal-ack-drops-not-replicated")

                        self.internal_ack_drops_stale = YLeaf(YType.uint32, "internal-ack-drops-stale")

                        self.last_cleared_time = YLeaf(YType.uint32, "last-cleared-time")

                        self.number_of_added_sessions = YLeaf(YType.uint32, "number-of-added-sessions")

                        self.number_of_attempted_init_sync = YLeaf(YType.uint32, "number-of-attempted-init-sync")

                        self.number_of_connected_clients = YLeaf(YType.uint32, "number-of-connected-clients")

                        self.number_of_created_session_sets = YLeaf(YType.uint32, "number-of-created-session-sets")

                        self.number_of_current_clients = YLeaf(YType.uint32, "number-of-current-clients")

                        self.number_of_current_session_sets = YLeaf(YType.uint32, "number-of-current-session-sets")

                        self.number_of_current_sessions = YLeaf(YType.uint32, "number-of-current-sessions")

                        self.number_of_deleted_sessions = YLeaf(YType.uint32, "number-of-deleted-sessions")

                        self.number_of_destroyed_session_sets = YLeaf(YType.uint32, "number-of-destroyed-session-sets")

                        self.number_of_disconnected_clients = YLeaf(YType.uint32, "number-of-disconnected-clients")

                        self.number_of_failed_init_sync = YLeaf(YType.uint32, "number-of-failed-init-sync")

                        self.number_of_held_but_dropped_internal_acks = YLeaf(YType.uint32, "number-of-held-but-dropped-internal-acks")

                        self.number_of_held_but_dropped_packets = YLeaf(YType.uint32, "number-of-held-but-dropped-packets")

                        self.number_of_held_internal_acks = YLeaf(YType.uint32, "number-of-held-internal-acks")

                        self.number_of_held_packets = YLeaf(YType.uint32, "number-of-held-packets")

                        self.number_of_internal_ack_drops_no_pcb = YLeaf(YType.uint32, "number-of-internal-ack-drops-no-pcb")

                        self.number_of_internal_ack_drops_no_scbdp = YLeaf(YType.uint32, "number-of-internal-ack-drops-no-scbdp")

                        self.number_of_partner_node = YLeaf(YType.uint32, "number-of-partner-node")

                        self.number_of_qad_receive_messages_accepts = YLeaf(YType.uint32, "number-of-qad-receive-messages-accepts")

                        self.number_of_qad_receive_messages_drops = YLeaf(YType.uint32, "number-of-qad-receive-messages-drops")

                        self.number_of_qad_receive_messages_unknowns = YLeaf(YType.uint32, "number-of-qad-receive-messages-unknowns")

                        self.number_of_qad_stale_receive_messages_drops = YLeaf(YType.uint32, "number-of-qad-stale-receive-messages-drops")

                        self.number_of_qad_transfer_message_drops = YLeaf(YType.uint32, "number-of-qad-transfer-message-drops")

                        self.number_of_qad_transfer_message_sent = YLeaf(YType.uint32, "number-of-qad-transfer-message-sent")

                        self.number_of_received_internal_acks = YLeaf(YType.uint32, "number-of-received-internal-acks")

                        self.number_of_sent_internal_acks = YLeaf(YType.uint32, "number-of-sent-internal-acks")

                        self.number_of_succeeded_init_sync = YLeaf(YType.uint32, "number-of-succeeded-init-sync")

                        self.audit_counters = TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters()
                        self.audit_counters.parent = self
                        self._children_name_map["audit_counters"] = "audit-counters"
                        self._children_yang_names.add("audit-counters")

                        self.snd_counters = TcpNsr.Nodes.Node.Statistics.Summary.SndCounters()
                        self.snd_counters.parent = self
                        self._children_name_map["snd_counters"] = "snd-counters"
                        self._children_yang_names.add("snd-counters")

                        self.notification_statistic = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("held_packet_drops",
                                        "internal_ack_drops_immediate_match",
                                        "internal_ack_drops_initsync_first_phase",
                                        "internal_ack_drops_not_replicated",
                                        "internal_ack_drops_stale",
                                        "last_cleared_time",
                                        "number_of_added_sessions",
                                        "number_of_attempted_init_sync",
                                        "number_of_connected_clients",
                                        "number_of_created_session_sets",
                                        "number_of_current_clients",
                                        "number_of_current_session_sets",
                                        "number_of_current_sessions",
                                        "number_of_deleted_sessions",
                                        "number_of_destroyed_session_sets",
                                        "number_of_disconnected_clients",
                                        "number_of_failed_init_sync",
                                        "number_of_held_but_dropped_internal_acks",
                                        "number_of_held_but_dropped_packets",
                                        "number_of_held_internal_acks",
                                        "number_of_held_packets",
                                        "number_of_internal_ack_drops_no_pcb",
                                        "number_of_internal_ack_drops_no_scbdp",
                                        "number_of_partner_node",
                                        "number_of_qad_receive_messages_accepts",
                                        "number_of_qad_receive_messages_drops",
                                        "number_of_qad_receive_messages_unknowns",
                                        "number_of_qad_stale_receive_messages_drops",
                                        "number_of_qad_transfer_message_drops",
                                        "number_of_qad_transfer_message_sent",
                                        "number_of_received_internal_acks",
                                        "number_of_sent_internal_acks",
                                        "number_of_succeeded_init_sync") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Statistics.Summary, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Statistics.Summary, self).__setattr__(name, value)


                    class SndCounters(Entity):
                        """
                        Aggregate Send path counters
                        
                        .. attribute:: aggr_only
                        
                        	Aggregate only send path counters
                        	**type**\:   :py:class:`AggrOnly <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.AggrOnly>`
                        
                        .. attribute:: common
                        
                        	Common send path counters
                        	**type**\:   :py:class:`Common <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.Common>`
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Statistics.Summary.SndCounters, self).__init__()

                            self.yang_name = "snd-counters"
                            self.yang_parent_name = "summary"

                            self.aggr_only = TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.AggrOnly()
                            self.aggr_only.parent = self
                            self._children_name_map["aggr_only"] = "aggr-only"
                            self._children_yang_names.add("aggr-only")

                            self.common = TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.Common()
                            self.common.parent = self
                            self._children_name_map["common"] = "common"
                            self._children_yang_names.add("common")


                        class Common(Entity):
                            """
                            Common send path counters
                            
                            .. attribute:: cleanup_rcv
                            
                            	Number of received Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_rcv_fail_buffer_trim
                            
                            	Number of Cleanup messages that had trim failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_rcv_success
                            
                            	Number of successfully received Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_send
                            
                            	Number of successful Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_send_drop
                            
                            	Number of failed Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv
                            
                            	Number of received DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_fail_buffer_trim
                            
                            	Number of received DATA transfers that had buffer trim failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_fail_snd_una_out_of_sync
                            
                            	Number of received DATA transfers that had failures because the send path was out of sync
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_success
                            
                            	Number of successfully received DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send
                            
                            	Number of successful DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send_drop
                            
                            	Number of failed DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send_iov_alloc
                            
                            	Number of data transfer msgs., that required new IOV's to be allocated
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send_total
                            
                            	Amount of data transferred
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: nack_rcv
                            
                            	Number of received NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_rcv_fail_data_send
                            
                            	Number of received NACK messages that had failures when sending data in response to the NACK
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_rcv_success
                            
                            	Number of successfully received NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_send
                            
                            	Number of successful NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_send_drop
                            
                            	Number of failed NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv
                            
                            	Number of received Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_fail_buffer_trim
                            
                            	Number of received Segmentation instructions that had buffer trim failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_fail_tcp_process
                            
                            	Number of received Segmentation instructions that had failures during TCP processing
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_success
                            
                            	Number of successfully received Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_send
                            
                            	Number of successful Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_send_drop
                            
                            	Number of failed Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_send_units
                            
                            	Number of segement units transferred via the successful Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.Common, self).__init__()

                                self.yang_name = "common"
                                self.yang_parent_name = "snd-counters"

                                self.cleanup_rcv = YLeaf(YType.uint32, "cleanup-rcv")

                                self.cleanup_rcv_fail_buffer_trim = YLeaf(YType.uint32, "cleanup-rcv-fail-buffer-trim")

                                self.cleanup_rcv_success = YLeaf(YType.uint32, "cleanup-rcv-success")

                                self.cleanup_send = YLeaf(YType.uint32, "cleanup-send")

                                self.cleanup_send_drop = YLeaf(YType.uint32, "cleanup-send-drop")

                                self.data_xfer_rcv = YLeaf(YType.uint32, "data-xfer-rcv")

                                self.data_xfer_rcv_fail_buffer_trim = YLeaf(YType.uint32, "data-xfer-rcv-fail-buffer-trim")

                                self.data_xfer_rcv_fail_snd_una_out_of_sync = YLeaf(YType.uint32, "data-xfer-rcv-fail-snd-una-out-of-sync")

                                self.data_xfer_rcv_success = YLeaf(YType.uint32, "data-xfer-rcv-success")

                                self.data_xfer_send = YLeaf(YType.uint32, "data-xfer-send")

                                self.data_xfer_send_drop = YLeaf(YType.uint32, "data-xfer-send-drop")

                                self.data_xfer_send_iov_alloc = YLeaf(YType.uint32, "data-xfer-send-iov-alloc")

                                self.data_xfer_send_total = YLeaf(YType.uint64, "data-xfer-send-total")

                                self.nack_rcv = YLeaf(YType.uint32, "nack-rcv")

                                self.nack_rcv_fail_data_send = YLeaf(YType.uint32, "nack-rcv-fail-data-send")

                                self.nack_rcv_success = YLeaf(YType.uint32, "nack-rcv-success")

                                self.nack_send = YLeaf(YType.uint32, "nack-send")

                                self.nack_send_drop = YLeaf(YType.uint32, "nack-send-drop")

                                self.seg_instr_rcv = YLeaf(YType.uint32, "seg-instr-rcv")

                                self.seg_instr_rcv_fail_buffer_trim = YLeaf(YType.uint32, "seg-instr-rcv-fail-buffer-trim")

                                self.seg_instr_rcv_fail_tcp_process = YLeaf(YType.uint32, "seg-instr-rcv-fail-tcp-process")

                                self.seg_instr_rcv_success = YLeaf(YType.uint32, "seg-instr-rcv-success")

                                self.seg_instr_send = YLeaf(YType.uint32, "seg-instr-send")

                                self.seg_instr_send_drop = YLeaf(YType.uint32, "seg-instr-send-drop")

                                self.seg_instr_send_units = YLeaf(YType.uint32, "seg-instr-send-units")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cleanup_rcv",
                                                "cleanup_rcv_fail_buffer_trim",
                                                "cleanup_rcv_success",
                                                "cleanup_send",
                                                "cleanup_send_drop",
                                                "data_xfer_rcv",
                                                "data_xfer_rcv_fail_buffer_trim",
                                                "data_xfer_rcv_fail_snd_una_out_of_sync",
                                                "data_xfer_rcv_success",
                                                "data_xfer_send",
                                                "data_xfer_send_drop",
                                                "data_xfer_send_iov_alloc",
                                                "data_xfer_send_total",
                                                "nack_rcv",
                                                "nack_rcv_fail_data_send",
                                                "nack_rcv_success",
                                                "nack_send",
                                                "nack_send_drop",
                                                "seg_instr_rcv",
                                                "seg_instr_rcv_fail_buffer_trim",
                                                "seg_instr_rcv_fail_tcp_process",
                                                "seg_instr_rcv_success",
                                                "seg_instr_send",
                                                "seg_instr_send_drop",
                                                "seg_instr_send_units") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.Common, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.Common, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.cleanup_rcv.is_set or
                                    self.cleanup_rcv_fail_buffer_trim.is_set or
                                    self.cleanup_rcv_success.is_set or
                                    self.cleanup_send.is_set or
                                    self.cleanup_send_drop.is_set or
                                    self.data_xfer_rcv.is_set or
                                    self.data_xfer_rcv_fail_buffer_trim.is_set or
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.is_set or
                                    self.data_xfer_rcv_success.is_set or
                                    self.data_xfer_send.is_set or
                                    self.data_xfer_send_drop.is_set or
                                    self.data_xfer_send_iov_alloc.is_set or
                                    self.data_xfer_send_total.is_set or
                                    self.nack_rcv.is_set or
                                    self.nack_rcv_fail_data_send.is_set or
                                    self.nack_rcv_success.is_set or
                                    self.nack_send.is_set or
                                    self.nack_send_drop.is_set or
                                    self.seg_instr_rcv.is_set or
                                    self.seg_instr_rcv_fail_buffer_trim.is_set or
                                    self.seg_instr_rcv_fail_tcp_process.is_set or
                                    self.seg_instr_rcv_success.is_set or
                                    self.seg_instr_send.is_set or
                                    self.seg_instr_send_drop.is_set or
                                    self.seg_instr_send_units.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cleanup_rcv.yfilter != YFilter.not_set or
                                    self.cleanup_rcv_fail_buffer_trim.yfilter != YFilter.not_set or
                                    self.cleanup_rcv_success.yfilter != YFilter.not_set or
                                    self.cleanup_send.yfilter != YFilter.not_set or
                                    self.cleanup_send_drop.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_fail_buffer_trim.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_success.yfilter != YFilter.not_set or
                                    self.data_xfer_send.yfilter != YFilter.not_set or
                                    self.data_xfer_send_drop.yfilter != YFilter.not_set or
                                    self.data_xfer_send_iov_alloc.yfilter != YFilter.not_set or
                                    self.data_xfer_send_total.yfilter != YFilter.not_set or
                                    self.nack_rcv.yfilter != YFilter.not_set or
                                    self.nack_rcv_fail_data_send.yfilter != YFilter.not_set or
                                    self.nack_rcv_success.yfilter != YFilter.not_set or
                                    self.nack_send.yfilter != YFilter.not_set or
                                    self.nack_send_drop.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_fail_buffer_trim.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_fail_tcp_process.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_success.yfilter != YFilter.not_set or
                                    self.seg_instr_send.yfilter != YFilter.not_set or
                                    self.seg_instr_send_drop.yfilter != YFilter.not_set or
                                    self.seg_instr_send_units.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "common" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cleanup_rcv.is_set or self.cleanup_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv.get_name_leafdata())
                                if (self.cleanup_rcv_fail_buffer_trim.is_set or self.cleanup_rcv_fail_buffer_trim.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv_fail_buffer_trim.get_name_leafdata())
                                if (self.cleanup_rcv_success.is_set or self.cleanup_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv_success.get_name_leafdata())
                                if (self.cleanup_send.is_set or self.cleanup_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_send.get_name_leafdata())
                                if (self.cleanup_send_drop.is_set or self.cleanup_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_send_drop.get_name_leafdata())
                                if (self.data_xfer_rcv.is_set or self.data_xfer_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv.get_name_leafdata())
                                if (self.data_xfer_rcv_fail_buffer_trim.is_set or self.data_xfer_rcv_fail_buffer_trim.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_fail_buffer_trim.get_name_leafdata())
                                if (self.data_xfer_rcv_fail_snd_una_out_of_sync.is_set or self.data_xfer_rcv_fail_snd_una_out_of_sync.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_fail_snd_una_out_of_sync.get_name_leafdata())
                                if (self.data_xfer_rcv_success.is_set or self.data_xfer_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_success.get_name_leafdata())
                                if (self.data_xfer_send.is_set or self.data_xfer_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send.get_name_leafdata())
                                if (self.data_xfer_send_drop.is_set or self.data_xfer_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send_drop.get_name_leafdata())
                                if (self.data_xfer_send_iov_alloc.is_set or self.data_xfer_send_iov_alloc.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send_iov_alloc.get_name_leafdata())
                                if (self.data_xfer_send_total.is_set or self.data_xfer_send_total.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send_total.get_name_leafdata())
                                if (self.nack_rcv.is_set or self.nack_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv.get_name_leafdata())
                                if (self.nack_rcv_fail_data_send.is_set or self.nack_rcv_fail_data_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv_fail_data_send.get_name_leafdata())
                                if (self.nack_rcv_success.is_set or self.nack_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv_success.get_name_leafdata())
                                if (self.nack_send.is_set or self.nack_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_send.get_name_leafdata())
                                if (self.nack_send_drop.is_set or self.nack_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_send_drop.get_name_leafdata())
                                if (self.seg_instr_rcv.is_set or self.seg_instr_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv.get_name_leafdata())
                                if (self.seg_instr_rcv_fail_buffer_trim.is_set or self.seg_instr_rcv_fail_buffer_trim.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_fail_buffer_trim.get_name_leafdata())
                                if (self.seg_instr_rcv_fail_tcp_process.is_set or self.seg_instr_rcv_fail_tcp_process.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_fail_tcp_process.get_name_leafdata())
                                if (self.seg_instr_rcv_success.is_set or self.seg_instr_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_success.get_name_leafdata())
                                if (self.seg_instr_send.is_set or self.seg_instr_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_send.get_name_leafdata())
                                if (self.seg_instr_send_drop.is_set or self.seg_instr_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_send_drop.get_name_leafdata())
                                if (self.seg_instr_send_units.is_set or self.seg_instr_send_units.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_send_units.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cleanup-rcv" or name == "cleanup-rcv-fail-buffer-trim" or name == "cleanup-rcv-success" or name == "cleanup-send" or name == "cleanup-send-drop" or name == "data-xfer-rcv" or name == "data-xfer-rcv-fail-buffer-trim" or name == "data-xfer-rcv-fail-snd-una-out-of-sync" or name == "data-xfer-rcv-success" or name == "data-xfer-send" or name == "data-xfer-send-drop" or name == "data-xfer-send-iov-alloc" or name == "data-xfer-send-total" or name == "nack-rcv" or name == "nack-rcv-fail-data-send" or name == "nack-rcv-success" or name == "nack-send" or name == "nack-send-drop" or name == "seg-instr-rcv" or name == "seg-instr-rcv-fail-buffer-trim" or name == "seg-instr-rcv-fail-tcp-process" or name == "seg-instr-rcv-success" or name == "seg-instr-send" or name == "seg-instr-send-drop" or name == "seg-instr-send-units"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cleanup-rcv"):
                                    self.cleanup_rcv = value
                                    self.cleanup_rcv.value_namespace = name_space
                                    self.cleanup_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-rcv-fail-buffer-trim"):
                                    self.cleanup_rcv_fail_buffer_trim = value
                                    self.cleanup_rcv_fail_buffer_trim.value_namespace = name_space
                                    self.cleanup_rcv_fail_buffer_trim.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-rcv-success"):
                                    self.cleanup_rcv_success = value
                                    self.cleanup_rcv_success.value_namespace = name_space
                                    self.cleanup_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-send"):
                                    self.cleanup_send = value
                                    self.cleanup_send.value_namespace = name_space
                                    self.cleanup_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-send-drop"):
                                    self.cleanup_send_drop = value
                                    self.cleanup_send_drop.value_namespace = name_space
                                    self.cleanup_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv"):
                                    self.data_xfer_rcv = value
                                    self.data_xfer_rcv.value_namespace = name_space
                                    self.data_xfer_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-fail-buffer-trim"):
                                    self.data_xfer_rcv_fail_buffer_trim = value
                                    self.data_xfer_rcv_fail_buffer_trim.value_namespace = name_space
                                    self.data_xfer_rcv_fail_buffer_trim.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-fail-snd-una-out-of-sync"):
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync = value
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.value_namespace = name_space
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-success"):
                                    self.data_xfer_rcv_success = value
                                    self.data_xfer_rcv_success.value_namespace = name_space
                                    self.data_xfer_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send"):
                                    self.data_xfer_send = value
                                    self.data_xfer_send.value_namespace = name_space
                                    self.data_xfer_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send-drop"):
                                    self.data_xfer_send_drop = value
                                    self.data_xfer_send_drop.value_namespace = name_space
                                    self.data_xfer_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send-iov-alloc"):
                                    self.data_xfer_send_iov_alloc = value
                                    self.data_xfer_send_iov_alloc.value_namespace = name_space
                                    self.data_xfer_send_iov_alloc.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send-total"):
                                    self.data_xfer_send_total = value
                                    self.data_xfer_send_total.value_namespace = name_space
                                    self.data_xfer_send_total.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv"):
                                    self.nack_rcv = value
                                    self.nack_rcv.value_namespace = name_space
                                    self.nack_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv-fail-data-send"):
                                    self.nack_rcv_fail_data_send = value
                                    self.nack_rcv_fail_data_send.value_namespace = name_space
                                    self.nack_rcv_fail_data_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv-success"):
                                    self.nack_rcv_success = value
                                    self.nack_rcv_success.value_namespace = name_space
                                    self.nack_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-send"):
                                    self.nack_send = value
                                    self.nack_send.value_namespace = name_space
                                    self.nack_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-send-drop"):
                                    self.nack_send_drop = value
                                    self.nack_send_drop.value_namespace = name_space
                                    self.nack_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv"):
                                    self.seg_instr_rcv = value
                                    self.seg_instr_rcv.value_namespace = name_space
                                    self.seg_instr_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-fail-buffer-trim"):
                                    self.seg_instr_rcv_fail_buffer_trim = value
                                    self.seg_instr_rcv_fail_buffer_trim.value_namespace = name_space
                                    self.seg_instr_rcv_fail_buffer_trim.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-fail-tcp-process"):
                                    self.seg_instr_rcv_fail_tcp_process = value
                                    self.seg_instr_rcv_fail_tcp_process.value_namespace = name_space
                                    self.seg_instr_rcv_fail_tcp_process.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-success"):
                                    self.seg_instr_rcv_success = value
                                    self.seg_instr_rcv_success.value_namespace = name_space
                                    self.seg_instr_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-send"):
                                    self.seg_instr_send = value
                                    self.seg_instr_send.value_namespace = name_space
                                    self.seg_instr_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-send-drop"):
                                    self.seg_instr_send_drop = value
                                    self.seg_instr_send_drop.value_namespace = name_space
                                    self.seg_instr_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-send-units"):
                                    self.seg_instr_send_units = value
                                    self.seg_instr_send_units.value_namespace = name_space
                                    self.seg_instr_send_units.value_namespace_prefix = name_space_prefix


                        class AggrOnly(Entity):
                            """
                            Aggregate only send path counters
                            
                            .. attribute:: cleanup_rcv_drop_no_pcb
                            
                            	Number of Cleanup messages dropped because PCB wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_rcv_drop_no_scb_dp
                            
                            	Number of Cleanup messages dropped because SCB DP wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_drop_no_pcb
                            
                            	Number of Data transfer messages dropped because PCB wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_drop_no_scb_dp
                            
                            	Number of Data transfer messages dropped because SCB DP wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_rcv_drop_no_pcb
                            
                            	Number of NACK messages dropped because PCB wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_rcv_drop_no_scb_dp
                            
                            	Number of NACK messages dropped because SCB DP wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_drop_no_pcb
                            
                            	Number of Segmentation instruction messages dropped because PCB wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_drop_no_scb_dp
                            
                            	Number of Segmentation instruction messages dropped because SCB DP wasn't found
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.AggrOnly, self).__init__()

                                self.yang_name = "aggr-only"
                                self.yang_parent_name = "snd-counters"

                                self.cleanup_rcv_drop_no_pcb = YLeaf(YType.uint32, "cleanup-rcv-drop-no-pcb")

                                self.cleanup_rcv_drop_no_scb_dp = YLeaf(YType.uint32, "cleanup-rcv-drop-no-scb-dp")

                                self.data_xfer_rcv_drop_no_pcb = YLeaf(YType.uint32, "data-xfer-rcv-drop-no-pcb")

                                self.data_xfer_rcv_drop_no_scb_dp = YLeaf(YType.uint32, "data-xfer-rcv-drop-no-scb-dp")

                                self.nack_rcv_drop_no_pcb = YLeaf(YType.uint32, "nack-rcv-drop-no-pcb")

                                self.nack_rcv_drop_no_scb_dp = YLeaf(YType.uint32, "nack-rcv-drop-no-scb-dp")

                                self.seg_instr_rcv_drop_no_pcb = YLeaf(YType.uint32, "seg-instr-rcv-drop-no-pcb")

                                self.seg_instr_rcv_drop_no_scb_dp = YLeaf(YType.uint32, "seg-instr-rcv-drop-no-scb-dp")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cleanup_rcv_drop_no_pcb",
                                                "cleanup_rcv_drop_no_scb_dp",
                                                "data_xfer_rcv_drop_no_pcb",
                                                "data_xfer_rcv_drop_no_scb_dp",
                                                "nack_rcv_drop_no_pcb",
                                                "nack_rcv_drop_no_scb_dp",
                                                "seg_instr_rcv_drop_no_pcb",
                                                "seg_instr_rcv_drop_no_scb_dp") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.AggrOnly, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.AggrOnly, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.cleanup_rcv_drop_no_pcb.is_set or
                                    self.cleanup_rcv_drop_no_scb_dp.is_set or
                                    self.data_xfer_rcv_drop_no_pcb.is_set or
                                    self.data_xfer_rcv_drop_no_scb_dp.is_set or
                                    self.nack_rcv_drop_no_pcb.is_set or
                                    self.nack_rcv_drop_no_scb_dp.is_set or
                                    self.seg_instr_rcv_drop_no_pcb.is_set or
                                    self.seg_instr_rcv_drop_no_scb_dp.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cleanup_rcv_drop_no_pcb.yfilter != YFilter.not_set or
                                    self.cleanup_rcv_drop_no_scb_dp.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_drop_no_pcb.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_drop_no_scb_dp.yfilter != YFilter.not_set or
                                    self.nack_rcv_drop_no_pcb.yfilter != YFilter.not_set or
                                    self.nack_rcv_drop_no_scb_dp.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_drop_no_pcb.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_drop_no_scb_dp.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "aggr-only" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cleanup_rcv_drop_no_pcb.is_set or self.cleanup_rcv_drop_no_pcb.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv_drop_no_pcb.get_name_leafdata())
                                if (self.cleanup_rcv_drop_no_scb_dp.is_set or self.cleanup_rcv_drop_no_scb_dp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv_drop_no_scb_dp.get_name_leafdata())
                                if (self.data_xfer_rcv_drop_no_pcb.is_set or self.data_xfer_rcv_drop_no_pcb.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_drop_no_pcb.get_name_leafdata())
                                if (self.data_xfer_rcv_drop_no_scb_dp.is_set or self.data_xfer_rcv_drop_no_scb_dp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_drop_no_scb_dp.get_name_leafdata())
                                if (self.nack_rcv_drop_no_pcb.is_set or self.nack_rcv_drop_no_pcb.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv_drop_no_pcb.get_name_leafdata())
                                if (self.nack_rcv_drop_no_scb_dp.is_set or self.nack_rcv_drop_no_scb_dp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv_drop_no_scb_dp.get_name_leafdata())
                                if (self.seg_instr_rcv_drop_no_pcb.is_set or self.seg_instr_rcv_drop_no_pcb.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_drop_no_pcb.get_name_leafdata())
                                if (self.seg_instr_rcv_drop_no_scb_dp.is_set or self.seg_instr_rcv_drop_no_scb_dp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_drop_no_scb_dp.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cleanup-rcv-drop-no-pcb" or name == "cleanup-rcv-drop-no-scb-dp" or name == "data-xfer-rcv-drop-no-pcb" or name == "data-xfer-rcv-drop-no-scb-dp" or name == "nack-rcv-drop-no-pcb" or name == "nack-rcv-drop-no-scb-dp" or name == "seg-instr-rcv-drop-no-pcb" or name == "seg-instr-rcv-drop-no-scb-dp"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cleanup-rcv-drop-no-pcb"):
                                    self.cleanup_rcv_drop_no_pcb = value
                                    self.cleanup_rcv_drop_no_pcb.value_namespace = name_space
                                    self.cleanup_rcv_drop_no_pcb.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-rcv-drop-no-scb-dp"):
                                    self.cleanup_rcv_drop_no_scb_dp = value
                                    self.cleanup_rcv_drop_no_scb_dp.value_namespace = name_space
                                    self.cleanup_rcv_drop_no_scb_dp.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-drop-no-pcb"):
                                    self.data_xfer_rcv_drop_no_pcb = value
                                    self.data_xfer_rcv_drop_no_pcb.value_namespace = name_space
                                    self.data_xfer_rcv_drop_no_pcb.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-drop-no-scb-dp"):
                                    self.data_xfer_rcv_drop_no_scb_dp = value
                                    self.data_xfer_rcv_drop_no_scb_dp.value_namespace = name_space
                                    self.data_xfer_rcv_drop_no_scb_dp.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv-drop-no-pcb"):
                                    self.nack_rcv_drop_no_pcb = value
                                    self.nack_rcv_drop_no_pcb.value_namespace = name_space
                                    self.nack_rcv_drop_no_pcb.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv-drop-no-scb-dp"):
                                    self.nack_rcv_drop_no_scb_dp = value
                                    self.nack_rcv_drop_no_scb_dp.value_namespace = name_space
                                    self.nack_rcv_drop_no_scb_dp.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-drop-no-pcb"):
                                    self.seg_instr_rcv_drop_no_pcb = value
                                    self.seg_instr_rcv_drop_no_pcb.value_namespace = name_space
                                    self.seg_instr_rcv_drop_no_pcb.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-drop-no-scb-dp"):
                                    self.seg_instr_rcv_drop_no_scb_dp = value
                                    self.seg_instr_rcv_drop_no_scb_dp.value_namespace = name_space
                                    self.seg_instr_rcv_drop_no_scb_dp.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.aggr_only is not None and self.aggr_only.has_data()) or
                                (self.common is not None and self.common.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.aggr_only is not None and self.aggr_only.has_operation()) or
                                (self.common is not None and self.common.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "snd-counters" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "aggr-only"):
                                if (self.aggr_only is None):
                                    self.aggr_only = TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.AggrOnly()
                                    self.aggr_only.parent = self
                                    self._children_name_map["aggr_only"] = "aggr-only"
                                return self.aggr_only

                            if (child_yang_name == "common"):
                                if (self.common is None):
                                    self.common = TcpNsr.Nodes.Node.Statistics.Summary.SndCounters.Common()
                                    self.common.parent = self
                                    self._children_name_map["common"] = "common"
                                return self.common

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "aggr-only" or name == "common"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class AuditCounters(Entity):
                        """
                        Aggregate Audit counters
                        
                        .. attribute:: aggr_only
                        
                        	Aggregate only audit counters
                        	**type**\:   :py:class:`AggrOnly <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.AggrOnly>`
                        
                        .. attribute:: common
                        
                        	Common audit counters
                        	**type**\:   :py:class:`Common <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.Common>`
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters, self).__init__()

                            self.yang_name = "audit-counters"
                            self.yang_parent_name = "summary"

                            self.aggr_only = TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.AggrOnly()
                            self.aggr_only.parent = self
                            self._children_name_map["aggr_only"] = "aggr-only"
                            self._children_yang_names.add("aggr-only")

                            self.common = TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.Common()
                            self.common.parent = self
                            self._children_name_map["common"] = "common"
                            self._children_yang_names.add("common")


                        class Common(Entity):
                            """
                            Common audit counters
                            
                            .. attribute:: abort
                            
                            	Number of times the active aborted an audit session
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_ack_rcv
                            
                            	Number of audit mark acks received by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_ack_rcv_drop
                            
                            	Number of audit mark acks dropped by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_ack_send
                            
                            	Number of successful audit mark acks sent by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_ack_send_drop
                            
                            	Number of audit mark acks that couldn't be sent by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_nack_rcv
                            
                            	Number of audit mark nacks received by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_nack_rcv_drop
                            
                            	Number of audit mark nacks dropped by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_nack_send
                            
                            	Number of successful audit mark nacks sent by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_nack_send_drop
                            
                            	Number of audit mark nacks that couldn't be sent by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_rcv
                            
                            	Number of successful session\-set Mark's received by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_rcv_drop
                            
                            	Number of session\-set Mark's dropped by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_send
                            
                            	Number of successful session\-set Mark's sent by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_send_drop
                            
                            	Number of failed session\-set Mark's
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_rcv
                            
                            	Number of session audits received by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_rcv_drop
                            
                            	Number of session audits dropped by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_send
                            
                            	Number of successful session audits sent by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_send_drop
                            
                            	Number of session audits that couldn't be sent by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_set_response_rcv
                            
                            	Number of audit responses received by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_set_response_rcv_drop
                            
                            	Number of audit responses dropped by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_set_response_send
                            
                            	Number of successful audit responses sent by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_set_response_send_drop
                            
                            	Number of audit responses that couldn't be sent by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sweep_session_set_rcv
                            
                            	Number of successful session\-set Sweep's received by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sweep_session_set_rcv_drop
                            
                            	Number of session\-set Sweep's dropped by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sweep_session_set_send
                            
                            	Number of successful session\-set Sweep's sent by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sweep_session_set_send_drop
                            
                            	Number of failed session\-set Sweep's
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.Common, self).__init__()

                                self.yang_name = "common"
                                self.yang_parent_name = "audit-counters"

                                self.abort = YLeaf(YType.uint32, "abort")

                                self.mark_session_set_ack_rcv = YLeaf(YType.uint32, "mark-session-set-ack-rcv")

                                self.mark_session_set_ack_rcv_drop = YLeaf(YType.uint32, "mark-session-set-ack-rcv-drop")

                                self.mark_session_set_ack_send = YLeaf(YType.uint32, "mark-session-set-ack-send")

                                self.mark_session_set_ack_send_drop = YLeaf(YType.uint32, "mark-session-set-ack-send-drop")

                                self.mark_session_set_nack_rcv = YLeaf(YType.uint32, "mark-session-set-nack-rcv")

                                self.mark_session_set_nack_rcv_drop = YLeaf(YType.uint32, "mark-session-set-nack-rcv-drop")

                                self.mark_session_set_nack_send = YLeaf(YType.uint32, "mark-session-set-nack-send")

                                self.mark_session_set_nack_send_drop = YLeaf(YType.uint32, "mark-session-set-nack-send-drop")

                                self.mark_session_set_rcv = YLeaf(YType.uint32, "mark-session-set-rcv")

                                self.mark_session_set_rcv_drop = YLeaf(YType.uint32, "mark-session-set-rcv-drop")

                                self.mark_session_set_send = YLeaf(YType.uint32, "mark-session-set-send")

                                self.mark_session_set_send_drop = YLeaf(YType.uint32, "mark-session-set-send-drop")

                                self.session_rcv = YLeaf(YType.uint32, "session-rcv")

                                self.session_rcv_drop = YLeaf(YType.uint32, "session-rcv-drop")

                                self.session_send = YLeaf(YType.uint32, "session-send")

                                self.session_send_drop = YLeaf(YType.uint32, "session-send-drop")

                                self.session_set_response_rcv = YLeaf(YType.uint32, "session-set-response-rcv")

                                self.session_set_response_rcv_drop = YLeaf(YType.uint32, "session-set-response-rcv-drop")

                                self.session_set_response_send = YLeaf(YType.uint32, "session-set-response-send")

                                self.session_set_response_send_drop = YLeaf(YType.uint32, "session-set-response-send-drop")

                                self.sweep_session_set_rcv = YLeaf(YType.uint32, "sweep-session-set-rcv")

                                self.sweep_session_set_rcv_drop = YLeaf(YType.uint32, "sweep-session-set-rcv-drop")

                                self.sweep_session_set_send = YLeaf(YType.uint32, "sweep-session-set-send")

                                self.sweep_session_set_send_drop = YLeaf(YType.uint32, "sweep-session-set-send-drop")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("abort",
                                                "mark_session_set_ack_rcv",
                                                "mark_session_set_ack_rcv_drop",
                                                "mark_session_set_ack_send",
                                                "mark_session_set_ack_send_drop",
                                                "mark_session_set_nack_rcv",
                                                "mark_session_set_nack_rcv_drop",
                                                "mark_session_set_nack_send",
                                                "mark_session_set_nack_send_drop",
                                                "mark_session_set_rcv",
                                                "mark_session_set_rcv_drop",
                                                "mark_session_set_send",
                                                "mark_session_set_send_drop",
                                                "session_rcv",
                                                "session_rcv_drop",
                                                "session_send",
                                                "session_send_drop",
                                                "session_set_response_rcv",
                                                "session_set_response_rcv_drop",
                                                "session_set_response_send",
                                                "session_set_response_send_drop",
                                                "sweep_session_set_rcv",
                                                "sweep_session_set_rcv_drop",
                                                "sweep_session_set_send",
                                                "sweep_session_set_send_drop") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.Common, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.Common, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.abort.is_set or
                                    self.mark_session_set_ack_rcv.is_set or
                                    self.mark_session_set_ack_rcv_drop.is_set or
                                    self.mark_session_set_ack_send.is_set or
                                    self.mark_session_set_ack_send_drop.is_set or
                                    self.mark_session_set_nack_rcv.is_set or
                                    self.mark_session_set_nack_rcv_drop.is_set or
                                    self.mark_session_set_nack_send.is_set or
                                    self.mark_session_set_nack_send_drop.is_set or
                                    self.mark_session_set_rcv.is_set or
                                    self.mark_session_set_rcv_drop.is_set or
                                    self.mark_session_set_send.is_set or
                                    self.mark_session_set_send_drop.is_set or
                                    self.session_rcv.is_set or
                                    self.session_rcv_drop.is_set or
                                    self.session_send.is_set or
                                    self.session_send_drop.is_set or
                                    self.session_set_response_rcv.is_set or
                                    self.session_set_response_rcv_drop.is_set or
                                    self.session_set_response_send.is_set or
                                    self.session_set_response_send_drop.is_set or
                                    self.sweep_session_set_rcv.is_set or
                                    self.sweep_session_set_rcv_drop.is_set or
                                    self.sweep_session_set_send.is_set or
                                    self.sweep_session_set_send_drop.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.abort.yfilter != YFilter.not_set or
                                    self.mark_session_set_ack_rcv.yfilter != YFilter.not_set or
                                    self.mark_session_set_ack_rcv_drop.yfilter != YFilter.not_set or
                                    self.mark_session_set_ack_send.yfilter != YFilter.not_set or
                                    self.mark_session_set_ack_send_drop.yfilter != YFilter.not_set or
                                    self.mark_session_set_nack_rcv.yfilter != YFilter.not_set or
                                    self.mark_session_set_nack_rcv_drop.yfilter != YFilter.not_set or
                                    self.mark_session_set_nack_send.yfilter != YFilter.not_set or
                                    self.mark_session_set_nack_send_drop.yfilter != YFilter.not_set or
                                    self.mark_session_set_rcv.yfilter != YFilter.not_set or
                                    self.mark_session_set_rcv_drop.yfilter != YFilter.not_set or
                                    self.mark_session_set_send.yfilter != YFilter.not_set or
                                    self.mark_session_set_send_drop.yfilter != YFilter.not_set or
                                    self.session_rcv.yfilter != YFilter.not_set or
                                    self.session_rcv_drop.yfilter != YFilter.not_set or
                                    self.session_send.yfilter != YFilter.not_set or
                                    self.session_send_drop.yfilter != YFilter.not_set or
                                    self.session_set_response_rcv.yfilter != YFilter.not_set or
                                    self.session_set_response_rcv_drop.yfilter != YFilter.not_set or
                                    self.session_set_response_send.yfilter != YFilter.not_set or
                                    self.session_set_response_send_drop.yfilter != YFilter.not_set or
                                    self.sweep_session_set_rcv.yfilter != YFilter.not_set or
                                    self.sweep_session_set_rcv_drop.yfilter != YFilter.not_set or
                                    self.sweep_session_set_send.yfilter != YFilter.not_set or
                                    self.sweep_session_set_send_drop.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "common" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.abort.is_set or self.abort.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.abort.get_name_leafdata())
                                if (self.mark_session_set_ack_rcv.is_set or self.mark_session_set_ack_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_ack_rcv.get_name_leafdata())
                                if (self.mark_session_set_ack_rcv_drop.is_set or self.mark_session_set_ack_rcv_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_ack_rcv_drop.get_name_leafdata())
                                if (self.mark_session_set_ack_send.is_set or self.mark_session_set_ack_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_ack_send.get_name_leafdata())
                                if (self.mark_session_set_ack_send_drop.is_set or self.mark_session_set_ack_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_ack_send_drop.get_name_leafdata())
                                if (self.mark_session_set_nack_rcv.is_set or self.mark_session_set_nack_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_nack_rcv.get_name_leafdata())
                                if (self.mark_session_set_nack_rcv_drop.is_set or self.mark_session_set_nack_rcv_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_nack_rcv_drop.get_name_leafdata())
                                if (self.mark_session_set_nack_send.is_set or self.mark_session_set_nack_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_nack_send.get_name_leafdata())
                                if (self.mark_session_set_nack_send_drop.is_set or self.mark_session_set_nack_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_nack_send_drop.get_name_leafdata())
                                if (self.mark_session_set_rcv.is_set or self.mark_session_set_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_rcv.get_name_leafdata())
                                if (self.mark_session_set_rcv_drop.is_set or self.mark_session_set_rcv_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_rcv_drop.get_name_leafdata())
                                if (self.mark_session_set_send.is_set or self.mark_session_set_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_send.get_name_leafdata())
                                if (self.mark_session_set_send_drop.is_set or self.mark_session_set_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_send_drop.get_name_leafdata())
                                if (self.session_rcv.is_set or self.session_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_rcv.get_name_leafdata())
                                if (self.session_rcv_drop.is_set or self.session_rcv_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_rcv_drop.get_name_leafdata())
                                if (self.session_send.is_set or self.session_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_send.get_name_leafdata())
                                if (self.session_send_drop.is_set or self.session_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_send_drop.get_name_leafdata())
                                if (self.session_set_response_rcv.is_set or self.session_set_response_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_set_response_rcv.get_name_leafdata())
                                if (self.session_set_response_rcv_drop.is_set or self.session_set_response_rcv_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_set_response_rcv_drop.get_name_leafdata())
                                if (self.session_set_response_send.is_set or self.session_set_response_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_set_response_send.get_name_leafdata())
                                if (self.session_set_response_send_drop.is_set or self.session_set_response_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_set_response_send_drop.get_name_leafdata())
                                if (self.sweep_session_set_rcv.is_set or self.sweep_session_set_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sweep_session_set_rcv.get_name_leafdata())
                                if (self.sweep_session_set_rcv_drop.is_set or self.sweep_session_set_rcv_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sweep_session_set_rcv_drop.get_name_leafdata())
                                if (self.sweep_session_set_send.is_set or self.sweep_session_set_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sweep_session_set_send.get_name_leafdata())
                                if (self.sweep_session_set_send_drop.is_set or self.sweep_session_set_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sweep_session_set_send_drop.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "abort" or name == "mark-session-set-ack-rcv" or name == "mark-session-set-ack-rcv-drop" or name == "mark-session-set-ack-send" or name == "mark-session-set-ack-send-drop" or name == "mark-session-set-nack-rcv" or name == "mark-session-set-nack-rcv-drop" or name == "mark-session-set-nack-send" or name == "mark-session-set-nack-send-drop" or name == "mark-session-set-rcv" or name == "mark-session-set-rcv-drop" or name == "mark-session-set-send" or name == "mark-session-set-send-drop" or name == "session-rcv" or name == "session-rcv-drop" or name == "session-send" or name == "session-send-drop" or name == "session-set-response-rcv" or name == "session-set-response-rcv-drop" or name == "session-set-response-send" or name == "session-set-response-send-drop" or name == "sweep-session-set-rcv" or name == "sweep-session-set-rcv-drop" or name == "sweep-session-set-send" or name == "sweep-session-set-send-drop"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "abort"):
                                    self.abort = value
                                    self.abort.value_namespace = name_space
                                    self.abort.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-ack-rcv"):
                                    self.mark_session_set_ack_rcv = value
                                    self.mark_session_set_ack_rcv.value_namespace = name_space
                                    self.mark_session_set_ack_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-ack-rcv-drop"):
                                    self.mark_session_set_ack_rcv_drop = value
                                    self.mark_session_set_ack_rcv_drop.value_namespace = name_space
                                    self.mark_session_set_ack_rcv_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-ack-send"):
                                    self.mark_session_set_ack_send = value
                                    self.mark_session_set_ack_send.value_namespace = name_space
                                    self.mark_session_set_ack_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-ack-send-drop"):
                                    self.mark_session_set_ack_send_drop = value
                                    self.mark_session_set_ack_send_drop.value_namespace = name_space
                                    self.mark_session_set_ack_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-nack-rcv"):
                                    self.mark_session_set_nack_rcv = value
                                    self.mark_session_set_nack_rcv.value_namespace = name_space
                                    self.mark_session_set_nack_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-nack-rcv-drop"):
                                    self.mark_session_set_nack_rcv_drop = value
                                    self.mark_session_set_nack_rcv_drop.value_namespace = name_space
                                    self.mark_session_set_nack_rcv_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-nack-send"):
                                    self.mark_session_set_nack_send = value
                                    self.mark_session_set_nack_send.value_namespace = name_space
                                    self.mark_session_set_nack_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-nack-send-drop"):
                                    self.mark_session_set_nack_send_drop = value
                                    self.mark_session_set_nack_send_drop.value_namespace = name_space
                                    self.mark_session_set_nack_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-rcv"):
                                    self.mark_session_set_rcv = value
                                    self.mark_session_set_rcv.value_namespace = name_space
                                    self.mark_session_set_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-rcv-drop"):
                                    self.mark_session_set_rcv_drop = value
                                    self.mark_session_set_rcv_drop.value_namespace = name_space
                                    self.mark_session_set_rcv_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-send"):
                                    self.mark_session_set_send = value
                                    self.mark_session_set_send.value_namespace = name_space
                                    self.mark_session_set_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-send-drop"):
                                    self.mark_session_set_send_drop = value
                                    self.mark_session_set_send_drop.value_namespace = name_space
                                    self.mark_session_set_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-rcv"):
                                    self.session_rcv = value
                                    self.session_rcv.value_namespace = name_space
                                    self.session_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-rcv-drop"):
                                    self.session_rcv_drop = value
                                    self.session_rcv_drop.value_namespace = name_space
                                    self.session_rcv_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-send"):
                                    self.session_send = value
                                    self.session_send.value_namespace = name_space
                                    self.session_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-send-drop"):
                                    self.session_send_drop = value
                                    self.session_send_drop.value_namespace = name_space
                                    self.session_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-set-response-rcv"):
                                    self.session_set_response_rcv = value
                                    self.session_set_response_rcv.value_namespace = name_space
                                    self.session_set_response_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-set-response-rcv-drop"):
                                    self.session_set_response_rcv_drop = value
                                    self.session_set_response_rcv_drop.value_namespace = name_space
                                    self.session_set_response_rcv_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-set-response-send"):
                                    self.session_set_response_send = value
                                    self.session_set_response_send.value_namespace = name_space
                                    self.session_set_response_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-set-response-send-drop"):
                                    self.session_set_response_send_drop = value
                                    self.session_set_response_send_drop.value_namespace = name_space
                                    self.session_set_response_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "sweep-session-set-rcv"):
                                    self.sweep_session_set_rcv = value
                                    self.sweep_session_set_rcv.value_namespace = name_space
                                    self.sweep_session_set_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "sweep-session-set-rcv-drop"):
                                    self.sweep_session_set_rcv_drop = value
                                    self.sweep_session_set_rcv_drop.value_namespace = name_space
                                    self.sweep_session_set_rcv_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "sweep-session-set-send"):
                                    self.sweep_session_set_send = value
                                    self.sweep_session_set_send.value_namespace = name_space
                                    self.sweep_session_set_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "sweep-session-set-send-drop"):
                                    self.sweep_session_set_send_drop = value
                                    self.sweep_session_set_send_drop.value_namespace = name_space
                                    self.sweep_session_set_send_drop.value_namespace_prefix = name_space_prefix


                        class AggrOnly(Entity):
                            """
                            Aggregate only audit counters
                            
                            .. attribute:: mark_session_set_ack_rcv_drop_aggr
                            
                            	Number of session\-set mark ack messages dropped by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_nack_rcv_drop_aggr
                            
                            	Number of session\-set mark nack messages dropped by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mark_session_set_rcv_drop_aggr
                            
                            	Number of session\-set Mark messages dropped by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_rcv_drop_aggr
                            
                            	Number of session audit messages dropped by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: session_set_response_rcv_drop_aggr
                            
                            	Number of session\-set response messages dropped by active
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sweep_session_set_rcv_drop_aggr
                            
                            	Number of session\-set Sweep messages dropped by standby
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.AggrOnly, self).__init__()

                                self.yang_name = "aggr-only"
                                self.yang_parent_name = "audit-counters"

                                self.mark_session_set_ack_rcv_drop_aggr = YLeaf(YType.uint32, "mark-session-set-ack-rcv-drop-aggr")

                                self.mark_session_set_nack_rcv_drop_aggr = YLeaf(YType.uint32, "mark-session-set-nack-rcv-drop-aggr")

                                self.mark_session_set_rcv_drop_aggr = YLeaf(YType.uint32, "mark-session-set-rcv-drop-aggr")

                                self.session_rcv_drop_aggr = YLeaf(YType.uint32, "session-rcv-drop-aggr")

                                self.session_set_response_rcv_drop_aggr = YLeaf(YType.uint32, "session-set-response-rcv-drop-aggr")

                                self.sweep_session_set_rcv_drop_aggr = YLeaf(YType.uint32, "sweep-session-set-rcv-drop-aggr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mark_session_set_ack_rcv_drop_aggr",
                                                "mark_session_set_nack_rcv_drop_aggr",
                                                "mark_session_set_rcv_drop_aggr",
                                                "session_rcv_drop_aggr",
                                                "session_set_response_rcv_drop_aggr",
                                                "sweep_session_set_rcv_drop_aggr") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.AggrOnly, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.AggrOnly, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mark_session_set_ack_rcv_drop_aggr.is_set or
                                    self.mark_session_set_nack_rcv_drop_aggr.is_set or
                                    self.mark_session_set_rcv_drop_aggr.is_set or
                                    self.session_rcv_drop_aggr.is_set or
                                    self.session_set_response_rcv_drop_aggr.is_set or
                                    self.sweep_session_set_rcv_drop_aggr.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mark_session_set_ack_rcv_drop_aggr.yfilter != YFilter.not_set or
                                    self.mark_session_set_nack_rcv_drop_aggr.yfilter != YFilter.not_set or
                                    self.mark_session_set_rcv_drop_aggr.yfilter != YFilter.not_set or
                                    self.session_rcv_drop_aggr.yfilter != YFilter.not_set or
                                    self.session_set_response_rcv_drop_aggr.yfilter != YFilter.not_set or
                                    self.sweep_session_set_rcv_drop_aggr.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "aggr-only" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mark_session_set_ack_rcv_drop_aggr.is_set or self.mark_session_set_ack_rcv_drop_aggr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_ack_rcv_drop_aggr.get_name_leafdata())
                                if (self.mark_session_set_nack_rcv_drop_aggr.is_set or self.mark_session_set_nack_rcv_drop_aggr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_nack_rcv_drop_aggr.get_name_leafdata())
                                if (self.mark_session_set_rcv_drop_aggr.is_set or self.mark_session_set_rcv_drop_aggr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mark_session_set_rcv_drop_aggr.get_name_leafdata())
                                if (self.session_rcv_drop_aggr.is_set or self.session_rcv_drop_aggr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_rcv_drop_aggr.get_name_leafdata())
                                if (self.session_set_response_rcv_drop_aggr.is_set or self.session_set_response_rcv_drop_aggr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.session_set_response_rcv_drop_aggr.get_name_leafdata())
                                if (self.sweep_session_set_rcv_drop_aggr.is_set or self.sweep_session_set_rcv_drop_aggr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sweep_session_set_rcv_drop_aggr.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mark-session-set-ack-rcv-drop-aggr" or name == "mark-session-set-nack-rcv-drop-aggr" or name == "mark-session-set-rcv-drop-aggr" or name == "session-rcv-drop-aggr" or name == "session-set-response-rcv-drop-aggr" or name == "sweep-session-set-rcv-drop-aggr"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mark-session-set-ack-rcv-drop-aggr"):
                                    self.mark_session_set_ack_rcv_drop_aggr = value
                                    self.mark_session_set_ack_rcv_drop_aggr.value_namespace = name_space
                                    self.mark_session_set_ack_rcv_drop_aggr.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-nack-rcv-drop-aggr"):
                                    self.mark_session_set_nack_rcv_drop_aggr = value
                                    self.mark_session_set_nack_rcv_drop_aggr.value_namespace = name_space
                                    self.mark_session_set_nack_rcv_drop_aggr.value_namespace_prefix = name_space_prefix
                                if(value_path == "mark-session-set-rcv-drop-aggr"):
                                    self.mark_session_set_rcv_drop_aggr = value
                                    self.mark_session_set_rcv_drop_aggr.value_namespace = name_space
                                    self.mark_session_set_rcv_drop_aggr.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-rcv-drop-aggr"):
                                    self.session_rcv_drop_aggr = value
                                    self.session_rcv_drop_aggr.value_namespace = name_space
                                    self.session_rcv_drop_aggr.value_namespace_prefix = name_space_prefix
                                if(value_path == "session-set-response-rcv-drop-aggr"):
                                    self.session_set_response_rcv_drop_aggr = value
                                    self.session_set_response_rcv_drop_aggr.value_namespace = name_space
                                    self.session_set_response_rcv_drop_aggr.value_namespace_prefix = name_space_prefix
                                if(value_path == "sweep-session-set-rcv-drop-aggr"):
                                    self.sweep_session_set_rcv_drop_aggr = value
                                    self.sweep_session_set_rcv_drop_aggr.value_namespace = name_space
                                    self.sweep_session_set_rcv_drop_aggr.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.aggr_only is not None and self.aggr_only.has_data()) or
                                (self.common is not None and self.common.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.aggr_only is not None and self.aggr_only.has_operation()) or
                                (self.common is not None and self.common.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "audit-counters" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "aggr-only"):
                                if (self.aggr_only is None):
                                    self.aggr_only = TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.AggrOnly()
                                    self.aggr_only.parent = self
                                    self._children_name_map["aggr_only"] = "aggr-only"
                                return self.aggr_only

                            if (child_yang_name == "common"):
                                if (self.common is None):
                                    self.common = TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters.Common()
                                    self.common.parent = self
                                    self._children_name_map["common"] = "common"
                                return self.common

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "aggr-only" or name == "common"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class NotificationStatistic(Entity):
                        """
                        Various types of notification stats
                        
                        .. attribute:: delivered_count
                        
                        	How many were picked up by app?
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: dropped_count
                        
                        	How many were dropped because of timeout
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed_count
                        
                        	Errors while queuing the notifs
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: queued_count
                        
                        	how many were queued
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Statistics.Summary.NotificationStatistic, self).__init__()

                            self.yang_name = "notification-statistic"
                            self.yang_parent_name = "summary"

                            self.delivered_count = YLeaf(YType.uint32, "delivered-count")

                            self.dropped_count = YLeaf(YType.uint32, "dropped-count")

                            self.failed_count = YLeaf(YType.uint32, "failed-count")

                            self.queued_count = YLeaf(YType.uint32, "queued-count")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("delivered_count",
                                            "dropped_count",
                                            "failed_count",
                                            "queued_count") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Statistics.Summary.NotificationStatistic, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Statistics.Summary.NotificationStatistic, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.delivered_count.is_set or
                                self.dropped_count.is_set or
                                self.failed_count.is_set or
                                self.queued_count.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.delivered_count.yfilter != YFilter.not_set or
                                self.dropped_count.yfilter != YFilter.not_set or
                                self.failed_count.yfilter != YFilter.not_set or
                                self.queued_count.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "notification-statistic" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.delivered_count.is_set or self.delivered_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.delivered_count.get_name_leafdata())
                            if (self.dropped_count.is_set or self.dropped_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dropped_count.get_name_leafdata())
                            if (self.failed_count.is_set or self.failed_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed_count.get_name_leafdata())
                            if (self.queued_count.is_set or self.queued_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.queued_count.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "delivered-count" or name == "dropped-count" or name == "failed-count" or name == "queued-count"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "delivered-count"):
                                self.delivered_count = value
                                self.delivered_count.value_namespace = name_space
                                self.delivered_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "dropped-count"):
                                self.dropped_count = value
                                self.dropped_count.value_namespace = name_space
                                self.dropped_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed-count"):
                                self.failed_count = value
                                self.failed_count.value_namespace = name_space
                                self.failed_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "queued-count"):
                                self.queued_count = value
                                self.queued_count.value_namespace = name_space
                                self.queued_count.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.notification_statistic:
                            if (c.has_data()):
                                return True
                        return (
                            self.held_packet_drops.is_set or
                            self.internal_ack_drops_immediate_match.is_set or
                            self.internal_ack_drops_initsync_first_phase.is_set or
                            self.internal_ack_drops_not_replicated.is_set or
                            self.internal_ack_drops_stale.is_set or
                            self.last_cleared_time.is_set or
                            self.number_of_added_sessions.is_set or
                            self.number_of_attempted_init_sync.is_set or
                            self.number_of_connected_clients.is_set or
                            self.number_of_created_session_sets.is_set or
                            self.number_of_current_clients.is_set or
                            self.number_of_current_session_sets.is_set or
                            self.number_of_current_sessions.is_set or
                            self.number_of_deleted_sessions.is_set or
                            self.number_of_destroyed_session_sets.is_set or
                            self.number_of_disconnected_clients.is_set or
                            self.number_of_failed_init_sync.is_set or
                            self.number_of_held_but_dropped_internal_acks.is_set or
                            self.number_of_held_but_dropped_packets.is_set or
                            self.number_of_held_internal_acks.is_set or
                            self.number_of_held_packets.is_set or
                            self.number_of_internal_ack_drops_no_pcb.is_set or
                            self.number_of_internal_ack_drops_no_scbdp.is_set or
                            self.number_of_partner_node.is_set or
                            self.number_of_qad_receive_messages_accepts.is_set or
                            self.number_of_qad_receive_messages_drops.is_set or
                            self.number_of_qad_receive_messages_unknowns.is_set or
                            self.number_of_qad_stale_receive_messages_drops.is_set or
                            self.number_of_qad_transfer_message_drops.is_set or
                            self.number_of_qad_transfer_message_sent.is_set or
                            self.number_of_received_internal_acks.is_set or
                            self.number_of_sent_internal_acks.is_set or
                            self.number_of_succeeded_init_sync.is_set or
                            (self.audit_counters is not None and self.audit_counters.has_data()) or
                            (self.snd_counters is not None and self.snd_counters.has_data()))

                    def has_operation(self):
                        for c in self.notification_statistic:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.held_packet_drops.yfilter != YFilter.not_set or
                            self.internal_ack_drops_immediate_match.yfilter != YFilter.not_set or
                            self.internal_ack_drops_initsync_first_phase.yfilter != YFilter.not_set or
                            self.internal_ack_drops_not_replicated.yfilter != YFilter.not_set or
                            self.internal_ack_drops_stale.yfilter != YFilter.not_set or
                            self.last_cleared_time.yfilter != YFilter.not_set or
                            self.number_of_added_sessions.yfilter != YFilter.not_set or
                            self.number_of_attempted_init_sync.yfilter != YFilter.not_set or
                            self.number_of_connected_clients.yfilter != YFilter.not_set or
                            self.number_of_created_session_sets.yfilter != YFilter.not_set or
                            self.number_of_current_clients.yfilter != YFilter.not_set or
                            self.number_of_current_session_sets.yfilter != YFilter.not_set or
                            self.number_of_current_sessions.yfilter != YFilter.not_set or
                            self.number_of_deleted_sessions.yfilter != YFilter.not_set or
                            self.number_of_destroyed_session_sets.yfilter != YFilter.not_set or
                            self.number_of_disconnected_clients.yfilter != YFilter.not_set or
                            self.number_of_failed_init_sync.yfilter != YFilter.not_set or
                            self.number_of_held_but_dropped_internal_acks.yfilter != YFilter.not_set or
                            self.number_of_held_but_dropped_packets.yfilter != YFilter.not_set or
                            self.number_of_held_internal_acks.yfilter != YFilter.not_set or
                            self.number_of_held_packets.yfilter != YFilter.not_set or
                            self.number_of_internal_ack_drops_no_pcb.yfilter != YFilter.not_set or
                            self.number_of_internal_ack_drops_no_scbdp.yfilter != YFilter.not_set or
                            self.number_of_partner_node.yfilter != YFilter.not_set or
                            self.number_of_qad_receive_messages_accepts.yfilter != YFilter.not_set or
                            self.number_of_qad_receive_messages_drops.yfilter != YFilter.not_set or
                            self.number_of_qad_receive_messages_unknowns.yfilter != YFilter.not_set or
                            self.number_of_qad_stale_receive_messages_drops.yfilter != YFilter.not_set or
                            self.number_of_qad_transfer_message_drops.yfilter != YFilter.not_set or
                            self.number_of_qad_transfer_message_sent.yfilter != YFilter.not_set or
                            self.number_of_received_internal_acks.yfilter != YFilter.not_set or
                            self.number_of_sent_internal_acks.yfilter != YFilter.not_set or
                            self.number_of_succeeded_init_sync.yfilter != YFilter.not_set or
                            (self.audit_counters is not None and self.audit_counters.has_operation()) or
                            (self.snd_counters is not None and self.snd_counters.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "summary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.held_packet_drops.is_set or self.held_packet_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.held_packet_drops.get_name_leafdata())
                        if (self.internal_ack_drops_immediate_match.is_set or self.internal_ack_drops_immediate_match.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.internal_ack_drops_immediate_match.get_name_leafdata())
                        if (self.internal_ack_drops_initsync_first_phase.is_set or self.internal_ack_drops_initsync_first_phase.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.internal_ack_drops_initsync_first_phase.get_name_leafdata())
                        if (self.internal_ack_drops_not_replicated.is_set or self.internal_ack_drops_not_replicated.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.internal_ack_drops_not_replicated.get_name_leafdata())
                        if (self.internal_ack_drops_stale.is_set or self.internal_ack_drops_stale.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.internal_ack_drops_stale.get_name_leafdata())
                        if (self.last_cleared_time.is_set or self.last_cleared_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_cleared_time.get_name_leafdata())
                        if (self.number_of_added_sessions.is_set or self.number_of_added_sessions.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_added_sessions.get_name_leafdata())
                        if (self.number_of_attempted_init_sync.is_set or self.number_of_attempted_init_sync.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_attempted_init_sync.get_name_leafdata())
                        if (self.number_of_connected_clients.is_set or self.number_of_connected_clients.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_connected_clients.get_name_leafdata())
                        if (self.number_of_created_session_sets.is_set or self.number_of_created_session_sets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_created_session_sets.get_name_leafdata())
                        if (self.number_of_current_clients.is_set or self.number_of_current_clients.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_current_clients.get_name_leafdata())
                        if (self.number_of_current_session_sets.is_set or self.number_of_current_session_sets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_current_session_sets.get_name_leafdata())
                        if (self.number_of_current_sessions.is_set or self.number_of_current_sessions.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_current_sessions.get_name_leafdata())
                        if (self.number_of_deleted_sessions.is_set or self.number_of_deleted_sessions.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_deleted_sessions.get_name_leafdata())
                        if (self.number_of_destroyed_session_sets.is_set or self.number_of_destroyed_session_sets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_destroyed_session_sets.get_name_leafdata())
                        if (self.number_of_disconnected_clients.is_set or self.number_of_disconnected_clients.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_disconnected_clients.get_name_leafdata())
                        if (self.number_of_failed_init_sync.is_set or self.number_of_failed_init_sync.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_failed_init_sync.get_name_leafdata())
                        if (self.number_of_held_but_dropped_internal_acks.is_set or self.number_of_held_but_dropped_internal_acks.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_held_but_dropped_internal_acks.get_name_leafdata())
                        if (self.number_of_held_but_dropped_packets.is_set or self.number_of_held_but_dropped_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_held_but_dropped_packets.get_name_leafdata())
                        if (self.number_of_held_internal_acks.is_set or self.number_of_held_internal_acks.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_held_internal_acks.get_name_leafdata())
                        if (self.number_of_held_packets.is_set or self.number_of_held_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_held_packets.get_name_leafdata())
                        if (self.number_of_internal_ack_drops_no_pcb.is_set or self.number_of_internal_ack_drops_no_pcb.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_internal_ack_drops_no_pcb.get_name_leafdata())
                        if (self.number_of_internal_ack_drops_no_scbdp.is_set or self.number_of_internal_ack_drops_no_scbdp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_internal_ack_drops_no_scbdp.get_name_leafdata())
                        if (self.number_of_partner_node.is_set or self.number_of_partner_node.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_partner_node.get_name_leafdata())
                        if (self.number_of_qad_receive_messages_accepts.is_set or self.number_of_qad_receive_messages_accepts.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_qad_receive_messages_accepts.get_name_leafdata())
                        if (self.number_of_qad_receive_messages_drops.is_set or self.number_of_qad_receive_messages_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_qad_receive_messages_drops.get_name_leafdata())
                        if (self.number_of_qad_receive_messages_unknowns.is_set or self.number_of_qad_receive_messages_unknowns.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_qad_receive_messages_unknowns.get_name_leafdata())
                        if (self.number_of_qad_stale_receive_messages_drops.is_set or self.number_of_qad_stale_receive_messages_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_qad_stale_receive_messages_drops.get_name_leafdata())
                        if (self.number_of_qad_transfer_message_drops.is_set or self.number_of_qad_transfer_message_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_qad_transfer_message_drops.get_name_leafdata())
                        if (self.number_of_qad_transfer_message_sent.is_set or self.number_of_qad_transfer_message_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_qad_transfer_message_sent.get_name_leafdata())
                        if (self.number_of_received_internal_acks.is_set or self.number_of_received_internal_acks.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_received_internal_acks.get_name_leafdata())
                        if (self.number_of_sent_internal_acks.is_set or self.number_of_sent_internal_acks.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_sent_internal_acks.get_name_leafdata())
                        if (self.number_of_succeeded_init_sync.is_set or self.number_of_succeeded_init_sync.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_succeeded_init_sync.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "audit-counters"):
                            if (self.audit_counters is None):
                                self.audit_counters = TcpNsr.Nodes.Node.Statistics.Summary.AuditCounters()
                                self.audit_counters.parent = self
                                self._children_name_map["audit_counters"] = "audit-counters"
                            return self.audit_counters

                        if (child_yang_name == "notification-statistic"):
                            for c in self.notification_statistic:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Statistics.Summary.NotificationStatistic()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.notification_statistic.append(c)
                            return c

                        if (child_yang_name == "snd-counters"):
                            if (self.snd_counters is None):
                                self.snd_counters = TcpNsr.Nodes.Node.Statistics.Summary.SndCounters()
                                self.snd_counters.parent = self
                                self._children_name_map["snd_counters"] = "snd-counters"
                            return self.snd_counters

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "audit-counters" or name == "notification-statistic" or name == "snd-counters" or name == "held-packet-drops" or name == "internal-ack-drops-immediate-match" or name == "internal-ack-drops-initsync-first-phase" or name == "internal-ack-drops-not-replicated" or name == "internal-ack-drops-stale" or name == "last-cleared-time" or name == "number-of-added-sessions" or name == "number-of-attempted-init-sync" or name == "number-of-connected-clients" or name == "number-of-created-session-sets" or name == "number-of-current-clients" or name == "number-of-current-session-sets" or name == "number-of-current-sessions" or name == "number-of-deleted-sessions" or name == "number-of-destroyed-session-sets" or name == "number-of-disconnected-clients" or name == "number-of-failed-init-sync" or name == "number-of-held-but-dropped-internal-acks" or name == "number-of-held-but-dropped-packets" or name == "number-of-held-internal-acks" or name == "number-of-held-packets" or name == "number-of-internal-ack-drops-no-pcb" or name == "number-of-internal-ack-drops-no-scbdp" or name == "number-of-partner-node" or name == "number-of-qad-receive-messages-accepts" or name == "number-of-qad-receive-messages-drops" or name == "number-of-qad-receive-messages-unknowns" or name == "number-of-qad-stale-receive-messages-drops" or name == "number-of-qad-transfer-message-drops" or name == "number-of-qad-transfer-message-sent" or name == "number-of-received-internal-acks" or name == "number-of-sent-internal-acks" or name == "number-of-succeeded-init-sync"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "held-packet-drops"):
                            self.held_packet_drops = value
                            self.held_packet_drops.value_namespace = name_space
                            self.held_packet_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "internal-ack-drops-immediate-match"):
                            self.internal_ack_drops_immediate_match = value
                            self.internal_ack_drops_immediate_match.value_namespace = name_space
                            self.internal_ack_drops_immediate_match.value_namespace_prefix = name_space_prefix
                        if(value_path == "internal-ack-drops-initsync-first-phase"):
                            self.internal_ack_drops_initsync_first_phase = value
                            self.internal_ack_drops_initsync_first_phase.value_namespace = name_space
                            self.internal_ack_drops_initsync_first_phase.value_namespace_prefix = name_space_prefix
                        if(value_path == "internal-ack-drops-not-replicated"):
                            self.internal_ack_drops_not_replicated = value
                            self.internal_ack_drops_not_replicated.value_namespace = name_space
                            self.internal_ack_drops_not_replicated.value_namespace_prefix = name_space_prefix
                        if(value_path == "internal-ack-drops-stale"):
                            self.internal_ack_drops_stale = value
                            self.internal_ack_drops_stale.value_namespace = name_space
                            self.internal_ack_drops_stale.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-cleared-time"):
                            self.last_cleared_time = value
                            self.last_cleared_time.value_namespace = name_space
                            self.last_cleared_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-added-sessions"):
                            self.number_of_added_sessions = value
                            self.number_of_added_sessions.value_namespace = name_space
                            self.number_of_added_sessions.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-attempted-init-sync"):
                            self.number_of_attempted_init_sync = value
                            self.number_of_attempted_init_sync.value_namespace = name_space
                            self.number_of_attempted_init_sync.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-connected-clients"):
                            self.number_of_connected_clients = value
                            self.number_of_connected_clients.value_namespace = name_space
                            self.number_of_connected_clients.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-created-session-sets"):
                            self.number_of_created_session_sets = value
                            self.number_of_created_session_sets.value_namespace = name_space
                            self.number_of_created_session_sets.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-current-clients"):
                            self.number_of_current_clients = value
                            self.number_of_current_clients.value_namespace = name_space
                            self.number_of_current_clients.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-current-session-sets"):
                            self.number_of_current_session_sets = value
                            self.number_of_current_session_sets.value_namespace = name_space
                            self.number_of_current_session_sets.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-current-sessions"):
                            self.number_of_current_sessions = value
                            self.number_of_current_sessions.value_namespace = name_space
                            self.number_of_current_sessions.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-deleted-sessions"):
                            self.number_of_deleted_sessions = value
                            self.number_of_deleted_sessions.value_namespace = name_space
                            self.number_of_deleted_sessions.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-destroyed-session-sets"):
                            self.number_of_destroyed_session_sets = value
                            self.number_of_destroyed_session_sets.value_namespace = name_space
                            self.number_of_destroyed_session_sets.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-disconnected-clients"):
                            self.number_of_disconnected_clients = value
                            self.number_of_disconnected_clients.value_namespace = name_space
                            self.number_of_disconnected_clients.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-failed-init-sync"):
                            self.number_of_failed_init_sync = value
                            self.number_of_failed_init_sync.value_namespace = name_space
                            self.number_of_failed_init_sync.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-held-but-dropped-internal-acks"):
                            self.number_of_held_but_dropped_internal_acks = value
                            self.number_of_held_but_dropped_internal_acks.value_namespace = name_space
                            self.number_of_held_but_dropped_internal_acks.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-held-but-dropped-packets"):
                            self.number_of_held_but_dropped_packets = value
                            self.number_of_held_but_dropped_packets.value_namespace = name_space
                            self.number_of_held_but_dropped_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-held-internal-acks"):
                            self.number_of_held_internal_acks = value
                            self.number_of_held_internal_acks.value_namespace = name_space
                            self.number_of_held_internal_acks.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-held-packets"):
                            self.number_of_held_packets = value
                            self.number_of_held_packets.value_namespace = name_space
                            self.number_of_held_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-internal-ack-drops-no-pcb"):
                            self.number_of_internal_ack_drops_no_pcb = value
                            self.number_of_internal_ack_drops_no_pcb.value_namespace = name_space
                            self.number_of_internal_ack_drops_no_pcb.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-internal-ack-drops-no-scbdp"):
                            self.number_of_internal_ack_drops_no_scbdp = value
                            self.number_of_internal_ack_drops_no_scbdp.value_namespace = name_space
                            self.number_of_internal_ack_drops_no_scbdp.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-partner-node"):
                            self.number_of_partner_node = value
                            self.number_of_partner_node.value_namespace = name_space
                            self.number_of_partner_node.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-qad-receive-messages-accepts"):
                            self.number_of_qad_receive_messages_accepts = value
                            self.number_of_qad_receive_messages_accepts.value_namespace = name_space
                            self.number_of_qad_receive_messages_accepts.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-qad-receive-messages-drops"):
                            self.number_of_qad_receive_messages_drops = value
                            self.number_of_qad_receive_messages_drops.value_namespace = name_space
                            self.number_of_qad_receive_messages_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-qad-receive-messages-unknowns"):
                            self.number_of_qad_receive_messages_unknowns = value
                            self.number_of_qad_receive_messages_unknowns.value_namespace = name_space
                            self.number_of_qad_receive_messages_unknowns.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-qad-stale-receive-messages-drops"):
                            self.number_of_qad_stale_receive_messages_drops = value
                            self.number_of_qad_stale_receive_messages_drops.value_namespace = name_space
                            self.number_of_qad_stale_receive_messages_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-qad-transfer-message-drops"):
                            self.number_of_qad_transfer_message_drops = value
                            self.number_of_qad_transfer_message_drops.value_namespace = name_space
                            self.number_of_qad_transfer_message_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-qad-transfer-message-sent"):
                            self.number_of_qad_transfer_message_sent = value
                            self.number_of_qad_transfer_message_sent.value_namespace = name_space
                            self.number_of_qad_transfer_message_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-received-internal-acks"):
                            self.number_of_received_internal_acks = value
                            self.number_of_received_internal_acks.value_namespace = name_space
                            self.number_of_received_internal_acks.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-sent-internal-acks"):
                            self.number_of_sent_internal_acks = value
                            self.number_of_sent_internal_acks.value_namespace = name_space
                            self.number_of_sent_internal_acks.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-succeeded-init-sync"):
                            self.number_of_succeeded_init_sync = value
                            self.number_of_succeeded_init_sync.value_namespace = name_space
                            self.number_of_succeeded_init_sync.value_namespace_prefix = name_space_prefix


                class StatisticClients(Entity):
                    """
                    Table listing NSR connections for which
                    statistic information is provided
                    
                    .. attribute:: statistic_client
                    
                    	showing statistic information of NSR Clients
                    	**type**\: list of    :py:class:`StatisticClient <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Statistics.StatisticClients, self).__init__()

                        self.yang_name = "statistic-clients"
                        self.yang_parent_name = "statistics"

                        self.statistic_client = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Statistics.StatisticClients, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Statistics.StatisticClients, self).__setattr__(name, value)


                    class StatisticClient(Entity):
                        """
                        showing statistic information of NSR Clients
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR Client
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: ccb
                        
                        	Address of the Client Control Block
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: connected_at
                        
                        	Time of connect (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: instance
                        
                        	Instance of the Client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: job_id
                        
                        	JOb ID of Client
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: last_cleared_time
                        
                        	Time of last clear (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: notification_statistic
                        
                        	Various types of notification stats
                        	**type**\: list of    :py:class:`NotificationStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient.NotificationStatistic>`
                        
                        .. attribute:: number_of_created_sscb
                        
                        	Num of created session sets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_deleted_sscb
                        
                        	Num of deleted session sets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: pid
                        
                        	PID of the Client
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: process_name
                        
                        	Proc name of Clinet
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient, self).__init__()

                            self.yang_name = "statistic-client"
                            self.yang_parent_name = "statistic-clients"

                            self.id = YLeaf(YType.str, "id")

                            self.ccb = YLeaf(YType.uint64, "ccb")

                            self.connected_at = YLeaf(YType.uint32, "connected-at")

                            self.instance = YLeaf(YType.uint32, "instance")

                            self.job_id = YLeaf(YType.int32, "job-id")

                            self.last_cleared_time = YLeaf(YType.uint32, "last-cleared-time")

                            self.number_of_created_sscb = YLeaf(YType.uint32, "number-of-created-sscb")

                            self.number_of_deleted_sscb = YLeaf(YType.uint32, "number-of-deleted-sscb")

                            self.pid = YLeaf(YType.uint32, "pid")

                            self.process_name = YLeaf(YType.str, "process-name")

                            self.notification_statistic = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "ccb",
                                            "connected_at",
                                            "instance",
                                            "job_id",
                                            "last_cleared_time",
                                            "number_of_created_sscb",
                                            "number_of_deleted_sscb",
                                            "pid",
                                            "process_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient, self).__setattr__(name, value)


                        class NotificationStatistic(Entity):
                            """
                            Various types of notification stats
                            
                            .. attribute:: delivered_count
                            
                            	How many were picked up by app?
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: dropped_count
                            
                            	How many were dropped because of timeout
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: failed_count
                            
                            	Errors while queuing the notifs
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: queued_count
                            
                            	how many were queued
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient.NotificationStatistic, self).__init__()

                                self.yang_name = "notification-statistic"
                                self.yang_parent_name = "statistic-client"

                                self.delivered_count = YLeaf(YType.uint32, "delivered-count")

                                self.dropped_count = YLeaf(YType.uint32, "dropped-count")

                                self.failed_count = YLeaf(YType.uint32, "failed-count")

                                self.queued_count = YLeaf(YType.uint32, "queued-count")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("delivered_count",
                                                "dropped_count",
                                                "failed_count",
                                                "queued_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient.NotificationStatistic, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient.NotificationStatistic, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.delivered_count.is_set or
                                    self.dropped_count.is_set or
                                    self.failed_count.is_set or
                                    self.queued_count.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.delivered_count.yfilter != YFilter.not_set or
                                    self.dropped_count.yfilter != YFilter.not_set or
                                    self.failed_count.yfilter != YFilter.not_set or
                                    self.queued_count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "notification-statistic" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.delivered_count.is_set or self.delivered_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delivered_count.get_name_leafdata())
                                if (self.dropped_count.is_set or self.dropped_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dropped_count.get_name_leafdata())
                                if (self.failed_count.is_set or self.failed_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.failed_count.get_name_leafdata())
                                if (self.queued_count.is_set or self.queued_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.queued_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "delivered-count" or name == "dropped-count" or name == "failed-count" or name == "queued-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "delivered-count"):
                                    self.delivered_count = value
                                    self.delivered_count.value_namespace = name_space
                                    self.delivered_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "dropped-count"):
                                    self.dropped_count = value
                                    self.dropped_count.value_namespace = name_space
                                    self.dropped_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "failed-count"):
                                    self.failed_count = value
                                    self.failed_count.value_namespace = name_space
                                    self.failed_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "queued-count"):
                                    self.queued_count = value
                                    self.queued_count.value_namespace = name_space
                                    self.queued_count.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.notification_statistic:
                                if (c.has_data()):
                                    return True
                            return (
                                self.id.is_set or
                                self.ccb.is_set or
                                self.connected_at.is_set or
                                self.instance.is_set or
                                self.job_id.is_set or
                                self.last_cleared_time.is_set or
                                self.number_of_created_sscb.is_set or
                                self.number_of_deleted_sscb.is_set or
                                self.pid.is_set or
                                self.process_name.is_set)

                        def has_operation(self):
                            for c in self.notification_statistic:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.ccb.yfilter != YFilter.not_set or
                                self.connected_at.yfilter != YFilter.not_set or
                                self.instance.yfilter != YFilter.not_set or
                                self.job_id.yfilter != YFilter.not_set or
                                self.last_cleared_time.yfilter != YFilter.not_set or
                                self.number_of_created_sscb.yfilter != YFilter.not_set or
                                self.number_of_deleted_sscb.yfilter != YFilter.not_set or
                                self.pid.yfilter != YFilter.not_set or
                                self.process_name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "statistic-client" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.ccb.is_set or self.ccb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccb.get_name_leafdata())
                            if (self.connected_at.is_set or self.connected_at.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connected_at.get_name_leafdata())
                            if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance.get_name_leafdata())
                            if (self.job_id.is_set or self.job_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.job_id.get_name_leafdata())
                            if (self.last_cleared_time.is_set or self.last_cleared_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_cleared_time.get_name_leafdata())
                            if (self.number_of_created_sscb.is_set or self.number_of_created_sscb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_created_sscb.get_name_leafdata())
                            if (self.number_of_deleted_sscb.is_set or self.number_of_deleted_sscb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_deleted_sscb.get_name_leafdata())
                            if (self.pid.is_set or self.pid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pid.get_name_leafdata())
                            if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.process_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "notification-statistic"):
                                for c in self.notification_statistic:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient.NotificationStatistic()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.notification_statistic.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "notification-statistic" or name == "id" or name == "ccb" or name == "connected-at" or name == "instance" or name == "job-id" or name == "last-cleared-time" or name == "number-of-created-sscb" or name == "number-of-deleted-sscb" or name == "pid" or name == "process-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccb"):
                                self.ccb = value
                                self.ccb.value_namespace = name_space
                                self.ccb.value_namespace_prefix = name_space_prefix
                            if(value_path == "connected-at"):
                                self.connected_at = value
                                self.connected_at.value_namespace = name_space
                                self.connected_at.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance"):
                                self.instance = value
                                self.instance.value_namespace = name_space
                                self.instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "job-id"):
                                self.job_id = value
                                self.job_id.value_namespace = name_space
                                self.job_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-cleared-time"):
                                self.last_cleared_time = value
                                self.last_cleared_time.value_namespace = name_space
                                self.last_cleared_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-created-sscb"):
                                self.number_of_created_sscb = value
                                self.number_of_created_sscb.value_namespace = name_space
                                self.number_of_created_sscb.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-deleted-sscb"):
                                self.number_of_deleted_sscb = value
                                self.number_of_deleted_sscb.value_namespace = name_space
                                self.number_of_deleted_sscb.value_namespace_prefix = name_space_prefix
                            if(value_path == "pid"):
                                self.pid = value
                                self.pid.value_namespace = name_space
                                self.pid.value_namespace_prefix = name_space_prefix
                            if(value_path == "process-name"):
                                self.process_name = value
                                self.process_name.value_namespace = name_space
                                self.process_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.statistic_client:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.statistic_client:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "statistic-clients" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "statistic-client"):
                            for c in self.statistic_client:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Statistics.StatisticClients.StatisticClient()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.statistic_client.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "statistic-client"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class StatisticSets(Entity):
                    """
                    Table listing NSR connections for which
                    statistic information is provided
                    
                    .. attribute:: statistic_set
                    
                    	showing statistic information of NSR Session Set
                    	**type**\: list of    :py:class:`StatisticSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticSets.StatisticSet>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Statistics.StatisticSets, self).__init__()

                        self.yang_name = "statistic-sets"
                        self.yang_parent_name = "statistics"

                        self.statistic_set = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Statistics.StatisticSets, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Statistics.StatisticSets, self).__setattr__(name, value)


                    class StatisticSet(Entity):
                        """
                        showing statistic information of NSR Session
                        Set
                        
                        .. attribute:: id  <key>
                        
                        	ID of NSR Session Set
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: last_cleared_time
                        
                        	Time of last clear (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: number_of_attempted_init_sync
                        
                        	no. of initial\-sync attempts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_failed_init_sync
                        
                        	no. of initial\-sync failures
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_failover
                        
                        	Number of Switch\-overs
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_nsr_resets
                        
                        	Number of times NSR was reset for the session
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_succeeded_init_sync
                        
                        	no. of initial\-sync successes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_id
                        
                        	ID of this Session\-set
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: sscb
                        
                        	SSCB Address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Statistics.StatisticSets.StatisticSet, self).__init__()

                            self.yang_name = "statistic-set"
                            self.yang_parent_name = "statistic-sets"

                            self.id = YLeaf(YType.str, "id")

                            self.last_cleared_time = YLeaf(YType.uint32, "last-cleared-time")

                            self.number_of_attempted_init_sync = YLeaf(YType.uint32, "number-of-attempted-init-sync")

                            self.number_of_failed_init_sync = YLeaf(YType.uint32, "number-of-failed-init-sync")

                            self.number_of_failover = YLeaf(YType.uint32, "number-of-failover")

                            self.number_of_nsr_resets = YLeaf(YType.uint32, "number-of-nsr-resets")

                            self.number_of_succeeded_init_sync = YLeaf(YType.uint32, "number-of-succeeded-init-sync")

                            self.set_id = YLeaf(YType.uint32, "set-id")

                            self.sscb = YLeaf(YType.uint64, "sscb")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "last_cleared_time",
                                            "number_of_attempted_init_sync",
                                            "number_of_failed_init_sync",
                                            "number_of_failover",
                                            "number_of_nsr_resets",
                                            "number_of_succeeded_init_sync",
                                            "set_id",
                                            "sscb") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Statistics.StatisticSets.StatisticSet, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Statistics.StatisticSets.StatisticSet, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.id.is_set or
                                self.last_cleared_time.is_set or
                                self.number_of_attempted_init_sync.is_set or
                                self.number_of_failed_init_sync.is_set or
                                self.number_of_failover.is_set or
                                self.number_of_nsr_resets.is_set or
                                self.number_of_succeeded_init_sync.is_set or
                                self.set_id.is_set or
                                self.sscb.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.last_cleared_time.yfilter != YFilter.not_set or
                                self.number_of_attempted_init_sync.yfilter != YFilter.not_set or
                                self.number_of_failed_init_sync.yfilter != YFilter.not_set or
                                self.number_of_failover.yfilter != YFilter.not_set or
                                self.number_of_nsr_resets.yfilter != YFilter.not_set or
                                self.number_of_succeeded_init_sync.yfilter != YFilter.not_set or
                                self.set_id.yfilter != YFilter.not_set or
                                self.sscb.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "statistic-set" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.last_cleared_time.is_set or self.last_cleared_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_cleared_time.get_name_leafdata())
                            if (self.number_of_attempted_init_sync.is_set or self.number_of_attempted_init_sync.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_attempted_init_sync.get_name_leafdata())
                            if (self.number_of_failed_init_sync.is_set or self.number_of_failed_init_sync.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_failed_init_sync.get_name_leafdata())
                            if (self.number_of_failover.is_set or self.number_of_failover.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_failover.get_name_leafdata())
                            if (self.number_of_nsr_resets.is_set or self.number_of_nsr_resets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_nsr_resets.get_name_leafdata())
                            if (self.number_of_succeeded_init_sync.is_set or self.number_of_succeeded_init_sync.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_succeeded_init_sync.get_name_leafdata())
                            if (self.set_id.is_set or self.set_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_id.get_name_leafdata())
                            if (self.sscb.is_set or self.sscb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sscb.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "id" or name == "last-cleared-time" or name == "number-of-attempted-init-sync" or name == "number-of-failed-init-sync" or name == "number-of-failover" or name == "number-of-nsr-resets" or name == "number-of-succeeded-init-sync" or name == "set-id" or name == "sscb"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-cleared-time"):
                                self.last_cleared_time = value
                                self.last_cleared_time.value_namespace = name_space
                                self.last_cleared_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-attempted-init-sync"):
                                self.number_of_attempted_init_sync = value
                                self.number_of_attempted_init_sync.value_namespace = name_space
                                self.number_of_attempted_init_sync.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-failed-init-sync"):
                                self.number_of_failed_init_sync = value
                                self.number_of_failed_init_sync.value_namespace = name_space
                                self.number_of_failed_init_sync.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-failover"):
                                self.number_of_failover = value
                                self.number_of_failover.value_namespace = name_space
                                self.number_of_failover.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-nsr-resets"):
                                self.number_of_nsr_resets = value
                                self.number_of_nsr_resets.value_namespace = name_space
                                self.number_of_nsr_resets.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-succeeded-init-sync"):
                                self.number_of_succeeded_init_sync = value
                                self.number_of_succeeded_init_sync.value_namespace = name_space
                                self.number_of_succeeded_init_sync.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-id"):
                                self.set_id = value
                                self.set_id.value_namespace = name_space
                                self.set_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "sscb"):
                                self.sscb = value
                                self.sscb.value_namespace = name_space
                                self.sscb.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.statistic_set:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.statistic_set:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "statistic-sets" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "statistic-set"):
                            for c in self.statistic_set:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Statistics.StatisticSets.StatisticSet()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.statistic_set.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "statistic-set"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class StatisticSessions(Entity):
                    """
                    Table listing NSR connections for which
                    statistic information is provided
                    
                    .. attribute:: statistic_session
                    
                    	showing statistic information of TCP connections
                    	**type**\: list of    :py:class:`StatisticSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession>`
                    
                    

                    """

                    _prefix = 'ip-tcp-oper'
                    _revision = '2016-02-26'

                    def __init__(self):
                        super(TcpNsr.Nodes.Node.Statistics.StatisticSessions, self).__init__()

                        self.yang_name = "statistic-sessions"
                        self.yang_parent_name = "statistics"

                        self.statistic_session = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(TcpNsr.Nodes.Node.Statistics.StatisticSessions, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(TcpNsr.Nodes.Node.Statistics.StatisticSessions, self).__setattr__(name, value)


                    class StatisticSession(Entity):
                        """
                        showing statistic information of TCP
                        connections
                        
                        .. attribute:: id  <key>
                        
                        	ID of TCP connection
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: internal_ack_drops_immediate_match
                        
                        	Number of iACKs not held because of an immediate match
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: internal_ack_drops_initsync_first_phase
                        
                        	Number of iACKs dropped because 1st phase of init\-sync is in progress
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: internal_ack_drops_not_replicated
                        
                        	Number of iACKs dropped because session is not replicated
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: internal_ack_drops_stale
                        
                        	Number of stale iACKs dropped
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: last_cleared_time
                        
                        	Time of last clear (in seconds since 1st Jan 1970 00\:00\:00)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: number_of_timers_nsr_down
                        
                        	no. of times nsr went down
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_times_nsr_disabled
                        
                        	no. of times nsr was disabled
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_times_nsr_fail_over
                        
                        	no. of times fail\-over occured
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: number_of_times_nsr_up
                        
                        	no. of times nsr went up
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: pcb
                        
                        	PCB Address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: snd_counters
                        
                        	Send path counters for the PCB
                        	**type**\:   :py:class:`SndCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_tcp_oper.TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession.SndCounters>`
                        
                        

                        """

                        _prefix = 'ip-tcp-oper'
                        _revision = '2016-02-26'

                        def __init__(self):
                            super(TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession, self).__init__()

                            self.yang_name = "statistic-session"
                            self.yang_parent_name = "statistic-sessions"

                            self.id = YLeaf(YType.str, "id")

                            self.internal_ack_drops_immediate_match = YLeaf(YType.uint64, "internal-ack-drops-immediate-match")

                            self.internal_ack_drops_initsync_first_phase = YLeaf(YType.uint64, "internal-ack-drops-initsync-first-phase")

                            self.internal_ack_drops_not_replicated = YLeaf(YType.uint64, "internal-ack-drops-not-replicated")

                            self.internal_ack_drops_stale = YLeaf(YType.uint64, "internal-ack-drops-stale")

                            self.last_cleared_time = YLeaf(YType.uint32, "last-cleared-time")

                            self.number_of_timers_nsr_down = YLeaf(YType.uint32, "number-of-timers-nsr-down")

                            self.number_of_times_nsr_disabled = YLeaf(YType.uint32, "number-of-times-nsr-disabled")

                            self.number_of_times_nsr_fail_over = YLeaf(YType.uint32, "number-of-times-nsr-fail-over")

                            self.number_of_times_nsr_up = YLeaf(YType.uint32, "number-of-times-nsr-up")

                            self.pcb = YLeaf(YType.uint64, "pcb")

                            self.snd_counters = TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession.SndCounters()
                            self.snd_counters.parent = self
                            self._children_name_map["snd_counters"] = "snd-counters"
                            self._children_yang_names.add("snd-counters")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("id",
                                            "internal_ack_drops_immediate_match",
                                            "internal_ack_drops_initsync_first_phase",
                                            "internal_ack_drops_not_replicated",
                                            "internal_ack_drops_stale",
                                            "last_cleared_time",
                                            "number_of_timers_nsr_down",
                                            "number_of_times_nsr_disabled",
                                            "number_of_times_nsr_fail_over",
                                            "number_of_times_nsr_up",
                                            "pcb") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession, self).__setattr__(name, value)


                        class SndCounters(Entity):
                            """
                            Send path counters for the PCB
                            
                            .. attribute:: cleanup_rcv
                            
                            	Number of received Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_rcv_fail_buffer_trim
                            
                            	Number of Cleanup messages that had trim failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_rcv_success
                            
                            	Number of successfully received Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_send
                            
                            	Number of successful Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cleanup_send_drop
                            
                            	Number of failed Cleanup messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv
                            
                            	Number of received DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_fail_buffer_trim
                            
                            	Number of received DATA transfers that had buffer trim failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_fail_snd_una_out_of_sync
                            
                            	Number of received DATA transfers that had failures because the send path was out of sync
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_rcv_success
                            
                            	Number of successfully received DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send
                            
                            	Number of successful DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send_drop
                            
                            	Number of failed DATA transfers
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send_iov_alloc
                            
                            	Number of data transfer msgs., that required new IOV's to be allocated
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: data_xfer_send_total
                            
                            	Amount of data transferred
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: nack_rcv
                            
                            	Number of received NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_rcv_fail_data_send
                            
                            	Number of received NACK messages that had failures when sending data in response to the NACK
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_rcv_success
                            
                            	Number of successfully received NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_send
                            
                            	Number of successful NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nack_send_drop
                            
                            	Number of failed NACK messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv
                            
                            	Number of received Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_fail_buffer_trim
                            
                            	Number of received Segmentation instructions that had buffer trim failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_fail_tcp_process
                            
                            	Number of received Segmentation instructions that had failures during TCP processing
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_rcv_success
                            
                            	Number of successfully received Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_send
                            
                            	Number of successful Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_send_drop
                            
                            	Number of failed Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: seg_instr_send_units
                            
                            	Number of segement units transferred via the successful Segmentation instruction messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ip-tcp-oper'
                            _revision = '2016-02-26'

                            def __init__(self):
                                super(TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession.SndCounters, self).__init__()

                                self.yang_name = "snd-counters"
                                self.yang_parent_name = "statistic-session"

                                self.cleanup_rcv = YLeaf(YType.uint32, "cleanup-rcv")

                                self.cleanup_rcv_fail_buffer_trim = YLeaf(YType.uint32, "cleanup-rcv-fail-buffer-trim")

                                self.cleanup_rcv_success = YLeaf(YType.uint32, "cleanup-rcv-success")

                                self.cleanup_send = YLeaf(YType.uint32, "cleanup-send")

                                self.cleanup_send_drop = YLeaf(YType.uint32, "cleanup-send-drop")

                                self.data_xfer_rcv = YLeaf(YType.uint32, "data-xfer-rcv")

                                self.data_xfer_rcv_fail_buffer_trim = YLeaf(YType.uint32, "data-xfer-rcv-fail-buffer-trim")

                                self.data_xfer_rcv_fail_snd_una_out_of_sync = YLeaf(YType.uint32, "data-xfer-rcv-fail-snd-una-out-of-sync")

                                self.data_xfer_rcv_success = YLeaf(YType.uint32, "data-xfer-rcv-success")

                                self.data_xfer_send = YLeaf(YType.uint32, "data-xfer-send")

                                self.data_xfer_send_drop = YLeaf(YType.uint32, "data-xfer-send-drop")

                                self.data_xfer_send_iov_alloc = YLeaf(YType.uint32, "data-xfer-send-iov-alloc")

                                self.data_xfer_send_total = YLeaf(YType.uint64, "data-xfer-send-total")

                                self.nack_rcv = YLeaf(YType.uint32, "nack-rcv")

                                self.nack_rcv_fail_data_send = YLeaf(YType.uint32, "nack-rcv-fail-data-send")

                                self.nack_rcv_success = YLeaf(YType.uint32, "nack-rcv-success")

                                self.nack_send = YLeaf(YType.uint32, "nack-send")

                                self.nack_send_drop = YLeaf(YType.uint32, "nack-send-drop")

                                self.seg_instr_rcv = YLeaf(YType.uint32, "seg-instr-rcv")

                                self.seg_instr_rcv_fail_buffer_trim = YLeaf(YType.uint32, "seg-instr-rcv-fail-buffer-trim")

                                self.seg_instr_rcv_fail_tcp_process = YLeaf(YType.uint32, "seg-instr-rcv-fail-tcp-process")

                                self.seg_instr_rcv_success = YLeaf(YType.uint32, "seg-instr-rcv-success")

                                self.seg_instr_send = YLeaf(YType.uint32, "seg-instr-send")

                                self.seg_instr_send_drop = YLeaf(YType.uint32, "seg-instr-send-drop")

                                self.seg_instr_send_units = YLeaf(YType.uint32, "seg-instr-send-units")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cleanup_rcv",
                                                "cleanup_rcv_fail_buffer_trim",
                                                "cleanup_rcv_success",
                                                "cleanup_send",
                                                "cleanup_send_drop",
                                                "data_xfer_rcv",
                                                "data_xfer_rcv_fail_buffer_trim",
                                                "data_xfer_rcv_fail_snd_una_out_of_sync",
                                                "data_xfer_rcv_success",
                                                "data_xfer_send",
                                                "data_xfer_send_drop",
                                                "data_xfer_send_iov_alloc",
                                                "data_xfer_send_total",
                                                "nack_rcv",
                                                "nack_rcv_fail_data_send",
                                                "nack_rcv_success",
                                                "nack_send",
                                                "nack_send_drop",
                                                "seg_instr_rcv",
                                                "seg_instr_rcv_fail_buffer_trim",
                                                "seg_instr_rcv_fail_tcp_process",
                                                "seg_instr_rcv_success",
                                                "seg_instr_send",
                                                "seg_instr_send_drop",
                                                "seg_instr_send_units") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession.SndCounters, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession.SndCounters, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.cleanup_rcv.is_set or
                                    self.cleanup_rcv_fail_buffer_trim.is_set or
                                    self.cleanup_rcv_success.is_set or
                                    self.cleanup_send.is_set or
                                    self.cleanup_send_drop.is_set or
                                    self.data_xfer_rcv.is_set or
                                    self.data_xfer_rcv_fail_buffer_trim.is_set or
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.is_set or
                                    self.data_xfer_rcv_success.is_set or
                                    self.data_xfer_send.is_set or
                                    self.data_xfer_send_drop.is_set or
                                    self.data_xfer_send_iov_alloc.is_set or
                                    self.data_xfer_send_total.is_set or
                                    self.nack_rcv.is_set or
                                    self.nack_rcv_fail_data_send.is_set or
                                    self.nack_rcv_success.is_set or
                                    self.nack_send.is_set or
                                    self.nack_send_drop.is_set or
                                    self.seg_instr_rcv.is_set or
                                    self.seg_instr_rcv_fail_buffer_trim.is_set or
                                    self.seg_instr_rcv_fail_tcp_process.is_set or
                                    self.seg_instr_rcv_success.is_set or
                                    self.seg_instr_send.is_set or
                                    self.seg_instr_send_drop.is_set or
                                    self.seg_instr_send_units.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cleanup_rcv.yfilter != YFilter.not_set or
                                    self.cleanup_rcv_fail_buffer_trim.yfilter != YFilter.not_set or
                                    self.cleanup_rcv_success.yfilter != YFilter.not_set or
                                    self.cleanup_send.yfilter != YFilter.not_set or
                                    self.cleanup_send_drop.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_fail_buffer_trim.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.yfilter != YFilter.not_set or
                                    self.data_xfer_rcv_success.yfilter != YFilter.not_set or
                                    self.data_xfer_send.yfilter != YFilter.not_set or
                                    self.data_xfer_send_drop.yfilter != YFilter.not_set or
                                    self.data_xfer_send_iov_alloc.yfilter != YFilter.not_set or
                                    self.data_xfer_send_total.yfilter != YFilter.not_set or
                                    self.nack_rcv.yfilter != YFilter.not_set or
                                    self.nack_rcv_fail_data_send.yfilter != YFilter.not_set or
                                    self.nack_rcv_success.yfilter != YFilter.not_set or
                                    self.nack_send.yfilter != YFilter.not_set or
                                    self.nack_send_drop.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_fail_buffer_trim.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_fail_tcp_process.yfilter != YFilter.not_set or
                                    self.seg_instr_rcv_success.yfilter != YFilter.not_set or
                                    self.seg_instr_send.yfilter != YFilter.not_set or
                                    self.seg_instr_send_drop.yfilter != YFilter.not_set or
                                    self.seg_instr_send_units.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "snd-counters" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cleanup_rcv.is_set or self.cleanup_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv.get_name_leafdata())
                                if (self.cleanup_rcv_fail_buffer_trim.is_set or self.cleanup_rcv_fail_buffer_trim.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv_fail_buffer_trim.get_name_leafdata())
                                if (self.cleanup_rcv_success.is_set or self.cleanup_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_rcv_success.get_name_leafdata())
                                if (self.cleanup_send.is_set or self.cleanup_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_send.get_name_leafdata())
                                if (self.cleanup_send_drop.is_set or self.cleanup_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cleanup_send_drop.get_name_leafdata())
                                if (self.data_xfer_rcv.is_set or self.data_xfer_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv.get_name_leafdata())
                                if (self.data_xfer_rcv_fail_buffer_trim.is_set or self.data_xfer_rcv_fail_buffer_trim.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_fail_buffer_trim.get_name_leafdata())
                                if (self.data_xfer_rcv_fail_snd_una_out_of_sync.is_set or self.data_xfer_rcv_fail_snd_una_out_of_sync.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_fail_snd_una_out_of_sync.get_name_leafdata())
                                if (self.data_xfer_rcv_success.is_set or self.data_xfer_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_rcv_success.get_name_leafdata())
                                if (self.data_xfer_send.is_set or self.data_xfer_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send.get_name_leafdata())
                                if (self.data_xfer_send_drop.is_set or self.data_xfer_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send_drop.get_name_leafdata())
                                if (self.data_xfer_send_iov_alloc.is_set or self.data_xfer_send_iov_alloc.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send_iov_alloc.get_name_leafdata())
                                if (self.data_xfer_send_total.is_set or self.data_xfer_send_total.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.data_xfer_send_total.get_name_leafdata())
                                if (self.nack_rcv.is_set or self.nack_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv.get_name_leafdata())
                                if (self.nack_rcv_fail_data_send.is_set or self.nack_rcv_fail_data_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv_fail_data_send.get_name_leafdata())
                                if (self.nack_rcv_success.is_set or self.nack_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_rcv_success.get_name_leafdata())
                                if (self.nack_send.is_set or self.nack_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_send.get_name_leafdata())
                                if (self.nack_send_drop.is_set or self.nack_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nack_send_drop.get_name_leafdata())
                                if (self.seg_instr_rcv.is_set or self.seg_instr_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv.get_name_leafdata())
                                if (self.seg_instr_rcv_fail_buffer_trim.is_set or self.seg_instr_rcv_fail_buffer_trim.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_fail_buffer_trim.get_name_leafdata())
                                if (self.seg_instr_rcv_fail_tcp_process.is_set or self.seg_instr_rcv_fail_tcp_process.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_fail_tcp_process.get_name_leafdata())
                                if (self.seg_instr_rcv_success.is_set or self.seg_instr_rcv_success.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_rcv_success.get_name_leafdata())
                                if (self.seg_instr_send.is_set or self.seg_instr_send.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_send.get_name_leafdata())
                                if (self.seg_instr_send_drop.is_set or self.seg_instr_send_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_send_drop.get_name_leafdata())
                                if (self.seg_instr_send_units.is_set or self.seg_instr_send_units.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seg_instr_send_units.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cleanup-rcv" or name == "cleanup-rcv-fail-buffer-trim" or name == "cleanup-rcv-success" or name == "cleanup-send" or name == "cleanup-send-drop" or name == "data-xfer-rcv" or name == "data-xfer-rcv-fail-buffer-trim" or name == "data-xfer-rcv-fail-snd-una-out-of-sync" or name == "data-xfer-rcv-success" or name == "data-xfer-send" or name == "data-xfer-send-drop" or name == "data-xfer-send-iov-alloc" or name == "data-xfer-send-total" or name == "nack-rcv" or name == "nack-rcv-fail-data-send" or name == "nack-rcv-success" or name == "nack-send" or name == "nack-send-drop" or name == "seg-instr-rcv" or name == "seg-instr-rcv-fail-buffer-trim" or name == "seg-instr-rcv-fail-tcp-process" or name == "seg-instr-rcv-success" or name == "seg-instr-send" or name == "seg-instr-send-drop" or name == "seg-instr-send-units"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cleanup-rcv"):
                                    self.cleanup_rcv = value
                                    self.cleanup_rcv.value_namespace = name_space
                                    self.cleanup_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-rcv-fail-buffer-trim"):
                                    self.cleanup_rcv_fail_buffer_trim = value
                                    self.cleanup_rcv_fail_buffer_trim.value_namespace = name_space
                                    self.cleanup_rcv_fail_buffer_trim.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-rcv-success"):
                                    self.cleanup_rcv_success = value
                                    self.cleanup_rcv_success.value_namespace = name_space
                                    self.cleanup_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-send"):
                                    self.cleanup_send = value
                                    self.cleanup_send.value_namespace = name_space
                                    self.cleanup_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "cleanup-send-drop"):
                                    self.cleanup_send_drop = value
                                    self.cleanup_send_drop.value_namespace = name_space
                                    self.cleanup_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv"):
                                    self.data_xfer_rcv = value
                                    self.data_xfer_rcv.value_namespace = name_space
                                    self.data_xfer_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-fail-buffer-trim"):
                                    self.data_xfer_rcv_fail_buffer_trim = value
                                    self.data_xfer_rcv_fail_buffer_trim.value_namespace = name_space
                                    self.data_xfer_rcv_fail_buffer_trim.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-fail-snd-una-out-of-sync"):
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync = value
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.value_namespace = name_space
                                    self.data_xfer_rcv_fail_snd_una_out_of_sync.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-rcv-success"):
                                    self.data_xfer_rcv_success = value
                                    self.data_xfer_rcv_success.value_namespace = name_space
                                    self.data_xfer_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send"):
                                    self.data_xfer_send = value
                                    self.data_xfer_send.value_namespace = name_space
                                    self.data_xfer_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send-drop"):
                                    self.data_xfer_send_drop = value
                                    self.data_xfer_send_drop.value_namespace = name_space
                                    self.data_xfer_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send-iov-alloc"):
                                    self.data_xfer_send_iov_alloc = value
                                    self.data_xfer_send_iov_alloc.value_namespace = name_space
                                    self.data_xfer_send_iov_alloc.value_namespace_prefix = name_space_prefix
                                if(value_path == "data-xfer-send-total"):
                                    self.data_xfer_send_total = value
                                    self.data_xfer_send_total.value_namespace = name_space
                                    self.data_xfer_send_total.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv"):
                                    self.nack_rcv = value
                                    self.nack_rcv.value_namespace = name_space
                                    self.nack_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv-fail-data-send"):
                                    self.nack_rcv_fail_data_send = value
                                    self.nack_rcv_fail_data_send.value_namespace = name_space
                                    self.nack_rcv_fail_data_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-rcv-success"):
                                    self.nack_rcv_success = value
                                    self.nack_rcv_success.value_namespace = name_space
                                    self.nack_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-send"):
                                    self.nack_send = value
                                    self.nack_send.value_namespace = name_space
                                    self.nack_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "nack-send-drop"):
                                    self.nack_send_drop = value
                                    self.nack_send_drop.value_namespace = name_space
                                    self.nack_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv"):
                                    self.seg_instr_rcv = value
                                    self.seg_instr_rcv.value_namespace = name_space
                                    self.seg_instr_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-fail-buffer-trim"):
                                    self.seg_instr_rcv_fail_buffer_trim = value
                                    self.seg_instr_rcv_fail_buffer_trim.value_namespace = name_space
                                    self.seg_instr_rcv_fail_buffer_trim.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-fail-tcp-process"):
                                    self.seg_instr_rcv_fail_tcp_process = value
                                    self.seg_instr_rcv_fail_tcp_process.value_namespace = name_space
                                    self.seg_instr_rcv_fail_tcp_process.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-rcv-success"):
                                    self.seg_instr_rcv_success = value
                                    self.seg_instr_rcv_success.value_namespace = name_space
                                    self.seg_instr_rcv_success.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-send"):
                                    self.seg_instr_send = value
                                    self.seg_instr_send.value_namespace = name_space
                                    self.seg_instr_send.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-send-drop"):
                                    self.seg_instr_send_drop = value
                                    self.seg_instr_send_drop.value_namespace = name_space
                                    self.seg_instr_send_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "seg-instr-send-units"):
                                    self.seg_instr_send_units = value
                                    self.seg_instr_send_units.value_namespace = name_space
                                    self.seg_instr_send_units.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.id.is_set or
                                self.internal_ack_drops_immediate_match.is_set or
                                self.internal_ack_drops_initsync_first_phase.is_set or
                                self.internal_ack_drops_not_replicated.is_set or
                                self.internal_ack_drops_stale.is_set or
                                self.last_cleared_time.is_set or
                                self.number_of_timers_nsr_down.is_set or
                                self.number_of_times_nsr_disabled.is_set or
                                self.number_of_times_nsr_fail_over.is_set or
                                self.number_of_times_nsr_up.is_set or
                                self.pcb.is_set or
                                (self.snd_counters is not None and self.snd_counters.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.id.yfilter != YFilter.not_set or
                                self.internal_ack_drops_immediate_match.yfilter != YFilter.not_set or
                                self.internal_ack_drops_initsync_first_phase.yfilter != YFilter.not_set or
                                self.internal_ack_drops_not_replicated.yfilter != YFilter.not_set or
                                self.internal_ack_drops_stale.yfilter != YFilter.not_set or
                                self.last_cleared_time.yfilter != YFilter.not_set or
                                self.number_of_timers_nsr_down.yfilter != YFilter.not_set or
                                self.number_of_times_nsr_disabled.yfilter != YFilter.not_set or
                                self.number_of_times_nsr_fail_over.yfilter != YFilter.not_set or
                                self.number_of_times_nsr_up.yfilter != YFilter.not_set or
                                self.pcb.yfilter != YFilter.not_set or
                                (self.snd_counters is not None and self.snd_counters.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "statistic-session" + "[id='" + self.id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.id.get_name_leafdata())
                            if (self.internal_ack_drops_immediate_match.is_set or self.internal_ack_drops_immediate_match.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.internal_ack_drops_immediate_match.get_name_leafdata())
                            if (self.internal_ack_drops_initsync_first_phase.is_set or self.internal_ack_drops_initsync_first_phase.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.internal_ack_drops_initsync_first_phase.get_name_leafdata())
                            if (self.internal_ack_drops_not_replicated.is_set or self.internal_ack_drops_not_replicated.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.internal_ack_drops_not_replicated.get_name_leafdata())
                            if (self.internal_ack_drops_stale.is_set or self.internal_ack_drops_stale.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.internal_ack_drops_stale.get_name_leafdata())
                            if (self.last_cleared_time.is_set or self.last_cleared_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_cleared_time.get_name_leafdata())
                            if (self.number_of_timers_nsr_down.is_set or self.number_of_timers_nsr_down.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_timers_nsr_down.get_name_leafdata())
                            if (self.number_of_times_nsr_disabled.is_set or self.number_of_times_nsr_disabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_times_nsr_disabled.get_name_leafdata())
                            if (self.number_of_times_nsr_fail_over.is_set or self.number_of_times_nsr_fail_over.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_times_nsr_fail_over.get_name_leafdata())
                            if (self.number_of_times_nsr_up.is_set or self.number_of_times_nsr_up.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.number_of_times_nsr_up.get_name_leafdata())
                            if (self.pcb.is_set or self.pcb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcb.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "snd-counters"):
                                if (self.snd_counters is None):
                                    self.snd_counters = TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession.SndCounters()
                                    self.snd_counters.parent = self
                                    self._children_name_map["snd_counters"] = "snd-counters"
                                return self.snd_counters

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "snd-counters" or name == "id" or name == "internal-ack-drops-immediate-match" or name == "internal-ack-drops-initsync-first-phase" or name == "internal-ack-drops-not-replicated" or name == "internal-ack-drops-stale" or name == "last-cleared-time" or name == "number-of-timers-nsr-down" or name == "number-of-times-nsr-disabled" or name == "number-of-times-nsr-fail-over" or name == "number-of-times-nsr-up" or name == "pcb"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "id"):
                                self.id = value
                                self.id.value_namespace = name_space
                                self.id.value_namespace_prefix = name_space_prefix
                            if(value_path == "internal-ack-drops-immediate-match"):
                                self.internal_ack_drops_immediate_match = value
                                self.internal_ack_drops_immediate_match.value_namespace = name_space
                                self.internal_ack_drops_immediate_match.value_namespace_prefix = name_space_prefix
                            if(value_path == "internal-ack-drops-initsync-first-phase"):
                                self.internal_ack_drops_initsync_first_phase = value
                                self.internal_ack_drops_initsync_first_phase.value_namespace = name_space
                                self.internal_ack_drops_initsync_first_phase.value_namespace_prefix = name_space_prefix
                            if(value_path == "internal-ack-drops-not-replicated"):
                                self.internal_ack_drops_not_replicated = value
                                self.internal_ack_drops_not_replicated.value_namespace = name_space
                                self.internal_ack_drops_not_replicated.value_namespace_prefix = name_space_prefix
                            if(value_path == "internal-ack-drops-stale"):
                                self.internal_ack_drops_stale = value
                                self.internal_ack_drops_stale.value_namespace = name_space
                                self.internal_ack_drops_stale.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-cleared-time"):
                                self.last_cleared_time = value
                                self.last_cleared_time.value_namespace = name_space
                                self.last_cleared_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-timers-nsr-down"):
                                self.number_of_timers_nsr_down = value
                                self.number_of_timers_nsr_down.value_namespace = name_space
                                self.number_of_timers_nsr_down.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-times-nsr-disabled"):
                                self.number_of_times_nsr_disabled = value
                                self.number_of_times_nsr_disabled.value_namespace = name_space
                                self.number_of_times_nsr_disabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-times-nsr-fail-over"):
                                self.number_of_times_nsr_fail_over = value
                                self.number_of_times_nsr_fail_over.value_namespace = name_space
                                self.number_of_times_nsr_fail_over.value_namespace_prefix = name_space_prefix
                            if(value_path == "number-of-times-nsr-up"):
                                self.number_of_times_nsr_up = value
                                self.number_of_times_nsr_up.value_namespace = name_space
                                self.number_of_times_nsr_up.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcb"):
                                self.pcb = value
                                self.pcb.value_namespace = name_space
                                self.pcb.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.statistic_session:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.statistic_session:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "statistic-sessions" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "statistic-session"):
                            for c in self.statistic_session:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = TcpNsr.Nodes.Node.Statistics.StatisticSessions.StatisticSession()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.statistic_session.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "statistic-session"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.statistic_clients is not None and self.statistic_clients.has_data()) or
                        (self.statistic_sessions is not None and self.statistic_sessions.has_data()) or
                        (self.statistic_sets is not None and self.statistic_sets.has_data()) or
                        (self.summary is not None and self.summary.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.statistic_clients is not None and self.statistic_clients.has_operation()) or
                        (self.statistic_sessions is not None and self.statistic_sessions.has_operation()) or
                        (self.statistic_sets is not None and self.statistic_sets.has_operation()) or
                        (self.summary is not None and self.summary.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "statistics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "statistic-clients"):
                        if (self.statistic_clients is None):
                            self.statistic_clients = TcpNsr.Nodes.Node.Statistics.StatisticClients()
                            self.statistic_clients.parent = self
                            self._children_name_map["statistic_clients"] = "statistic-clients"
                        return self.statistic_clients

                    if (child_yang_name == "statistic-sessions"):
                        if (self.statistic_sessions is None):
                            self.statistic_sessions = TcpNsr.Nodes.Node.Statistics.StatisticSessions()
                            self.statistic_sessions.parent = self
                            self._children_name_map["statistic_sessions"] = "statistic-sessions"
                        return self.statistic_sessions

                    if (child_yang_name == "statistic-sets"):
                        if (self.statistic_sets is None):
                            self.statistic_sets = TcpNsr.Nodes.Node.Statistics.StatisticSets()
                            self.statistic_sets.parent = self
                            self._children_name_map["statistic_sets"] = "statistic-sets"
                        return self.statistic_sets

                    if (child_yang_name == "summary"):
                        if (self.summary is None):
                            self.summary = TcpNsr.Nodes.Node.Statistics.Summary()
                            self.summary.parent = self
                            self._children_name_map["summary"] = "summary"
                        return self.summary

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "statistic-clients" or name == "statistic-sessions" or name == "statistic-sets" or name == "summary"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.id.is_set or
                    (self.client is not None and self.client.has_data()) or
                    (self.session is not None and self.session.has_data()) or
                    (self.session_set is not None and self.session_set.has_data()) or
                    (self.statistics is not None and self.statistics.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.id.yfilter != YFilter.not_set or
                    (self.client is not None and self.client.has_operation()) or
                    (self.session is not None and self.session.has_operation()) or
                    (self.session_set is not None and self.session_set.has_operation()) or
                    (self.statistics is not None and self.statistics.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[id='" + self.id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp-nsr/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "client"):
                    if (self.client is None):
                        self.client = TcpNsr.Nodes.Node.Client()
                        self.client.parent = self
                        self._children_name_map["client"] = "client"
                    return self.client

                if (child_yang_name == "session"):
                    if (self.session is None):
                        self.session = TcpNsr.Nodes.Node.Session()
                        self.session.parent = self
                        self._children_name_map["session"] = "session"
                    return self.session

                if (child_yang_name == "session-set"):
                    if (self.session_set is None):
                        self.session_set = TcpNsr.Nodes.Node.SessionSet()
                        self.session_set.parent = self
                        self._children_name_map["session_set"] = "session-set"
                    return self.session_set

                if (child_yang_name == "statistics"):
                    if (self.statistics is None):
                        self.statistics = TcpNsr.Nodes.Node.Statistics()
                        self.statistics.parent = self
                        self._children_name_map["statistics"] = "statistics"
                    return self.statistics

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "client" or name == "session" or name == "session-set" or name == "statistics" or name == "id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "id"):
                    self.id = value
                    self.id.value_namespace = name_space
                    self.id.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp-nsr/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = TcpNsr.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (self.nodes is not None and self.nodes.has_data())

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.nodes is not None and self.nodes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-ip-tcp-oper:tcp-nsr" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = TcpNsr.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "nodes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = TcpNsr()
        return self._top_entity

