""" CISCO_ENTITY_ALARM_MIB 

This MIB module defines the managed objects that support the
monitoring of alarms generated by physical entities contained
by the system, including chassis, slots, modules, ports, power
supplies, and fans.  In order to monitor alarms generated by a
physical entity, it must be represented by a row in the
entPhysicalTable (see ENTITY\-MIB).

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class Alarmseverity(Enum):
    """
    Alarmseverity

    Each alarm type defined by a vendor type employed by the

    system has an associated severity.  Bellcore TR\-NWT\-000474

    defines these severities as follows\:

    'critical'  An alarm used to indicate a severe, service\-

                affecting condition has occurred and that immediate

                corrective action is imperative, regardless of the

                time of day or day of the week.

    'major'     An alarm used for hardware or software conditions

                that indicate a serious disruption of service or the

                malfunctioning or failure of important hardware.

                These troubles require the immediate attention and

                response of a technician to restore or maintain

                system capability.  The urgency is less than in

                critical situations because of a lesser immediate

                or impending effect on service or system

                performance.

    'minor'     An alarm used for troubles that do not have a

                serious effect on service to customers or for

                troubles in hardware that are not essential to

                the operation of the system.

    'info'      An indication used to raise attention to a condition

                that could possibly be an impending problem or to 

                notify the customer of an event that improves

                operation.

    .. data:: critical = 1

    .. data:: major = 2

    .. data:: minor = 3

    .. data:: info = 4

    """

    critical = Enum.YLeaf(1, "critical")

    major = Enum.YLeaf(2, "major")

    minor = Enum.YLeaf(3, "minor")

    info = Enum.YLeaf(4, "info")



class CiscoEntityAlarmMib(Entity):
    """
    
    
    .. attribute:: cealarmdescrmaptable
    
    	For each type of entity (represented entPhysicalVendorType OID), this table contains a mapping between a unique  ceAlarmDescrIndex and entPhysicalvendorType OID
    	**type**\:   :py:class:`Cealarmdescrmaptable <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmdescrmaptable>`
    
    .. attribute:: cealarmdescrtable
    
    	This table contains a description for each alarm type defined by each vendor type employed by the system. Observe that this table is sparse in nature, as it is rarely the case that a physical entity type needs to  define every alarm in its alarm space
    	**type**\:   :py:class:`Cealarmdescrtable <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmdescrtable>`
    
    .. attribute:: cealarmfiltering
    
    	
    	**type**\:   :py:class:`Cealarmfiltering <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmfiltering>`
    
    .. attribute:: cealarmfilterprofiletable
    
    	This table contains a list of alarm filter profiles
    	**type**\:   :py:class:`Cealarmfilterprofiletable <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmfilterprofiletable>`
    
    .. attribute:: cealarmhistory
    
    	
    	**type**\:   :py:class:`Cealarmhistory <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmhistory>`
    
    .. attribute:: cealarmhisttable
    
    	This table contains a history of ceAlarmIndicate and ceAlarmClear traps generated by the agent
    	**type**\:   :py:class:`Cealarmhisttable <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmhisttable>`
    
    .. attribute:: cealarmmonitoring
    
    	
    	**type**\:   :py:class:`Cealarmmonitoring <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmmonitoring>`
    
    .. attribute:: cealarmtable
    
    	This table specifies alarm control and status information related to each physical entity contained by the system, including the alarms currently being asserted by each physical entity capable of generating alarms
    	**type**\:   :py:class:`Cealarmtable <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmtable>`
    
    

    """

    _prefix = 'CISCO-ENTITY-ALARM-MIB'
    _revision = '1999-07-06'

    def __init__(self):
        super(CiscoEntityAlarmMib, self).__init__()
        self._top_entity = None

        self.yang_name = "CISCO-ENTITY-ALARM-MIB"
        self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

        self.cealarmdescrmaptable = CiscoEntityAlarmMib.Cealarmdescrmaptable()
        self.cealarmdescrmaptable.parent = self
        self._children_name_map["cealarmdescrmaptable"] = "ceAlarmDescrMapTable"
        self._children_yang_names.add("ceAlarmDescrMapTable")

        self.cealarmdescrtable = CiscoEntityAlarmMib.Cealarmdescrtable()
        self.cealarmdescrtable.parent = self
        self._children_name_map["cealarmdescrtable"] = "ceAlarmDescrTable"
        self._children_yang_names.add("ceAlarmDescrTable")

        self.cealarmfiltering = CiscoEntityAlarmMib.Cealarmfiltering()
        self.cealarmfiltering.parent = self
        self._children_name_map["cealarmfiltering"] = "ceAlarmFiltering"
        self._children_yang_names.add("ceAlarmFiltering")

        self.cealarmfilterprofiletable = CiscoEntityAlarmMib.Cealarmfilterprofiletable()
        self.cealarmfilterprofiletable.parent = self
        self._children_name_map["cealarmfilterprofiletable"] = "ceAlarmFilterProfileTable"
        self._children_yang_names.add("ceAlarmFilterProfileTable")

        self.cealarmhistory = CiscoEntityAlarmMib.Cealarmhistory()
        self.cealarmhistory.parent = self
        self._children_name_map["cealarmhistory"] = "ceAlarmHistory"
        self._children_yang_names.add("ceAlarmHistory")

        self.cealarmhisttable = CiscoEntityAlarmMib.Cealarmhisttable()
        self.cealarmhisttable.parent = self
        self._children_name_map["cealarmhisttable"] = "ceAlarmHistTable"
        self._children_yang_names.add("ceAlarmHistTable")

        self.cealarmmonitoring = CiscoEntityAlarmMib.Cealarmmonitoring()
        self.cealarmmonitoring.parent = self
        self._children_name_map["cealarmmonitoring"] = "ceAlarmMonitoring"
        self._children_yang_names.add("ceAlarmMonitoring")

        self.cealarmtable = CiscoEntityAlarmMib.Cealarmtable()
        self.cealarmtable.parent = self
        self._children_name_map["cealarmtable"] = "ceAlarmTable"
        self._children_yang_names.add("ceAlarmTable")


    class Cealarmmonitoring(Entity):
        """
        
        
        .. attribute:: cealarmcriticalcount
        
        	The value of this object specifies the number of alarms currently asserted with a severity of 'critical'
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: cealarmcutoff
        
        	If the management client writes a value of 'true' to this object, the agent stops signalling all external audible alarms under the control of the agent.  Reading this object should always result in a value of 'false'.  Observe that alarm cutoff does not have an effect on monitoring, history logging, generation of notifications, or syslog message generation.  It also does not prevent the agent from signalling external audible alarms for alarms asserted after alarm\-cutoff.  This object emulates the 'alarm cut\-off' mechanism typically installed in a central office (e.g., a big red button).  Observe this object should neither affect external visual alarms under the control of the agent, nor should it affect the current state of alarms being asserted by the system
        	**type**\:  bool
        
        .. attribute:: cealarmmajorcount
        
        	The value of this object specifies the number of alarms currently asserted with a severity of 'major'
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: cealarmminorcount
        
        	The value of this object specifies the number of alarms currently asserted with a severity of 'minor'
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmmonitoring, self).__init__()

            self.yang_name = "ceAlarmMonitoring"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmcriticalcount = YLeaf(YType.uint32, "ceAlarmCriticalCount")

            self.cealarmcutoff = YLeaf(YType.boolean, "ceAlarmCutOff")

            self.cealarmmajorcount = YLeaf(YType.uint32, "ceAlarmMajorCount")

            self.cealarmminorcount = YLeaf(YType.uint32, "ceAlarmMinorCount")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cealarmcriticalcount",
                            "cealarmcutoff",
                            "cealarmmajorcount",
                            "cealarmminorcount") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmmonitoring, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmmonitoring, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.cealarmcriticalcount.is_set or
                self.cealarmcutoff.is_set or
                self.cealarmmajorcount.is_set or
                self.cealarmminorcount.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cealarmcriticalcount.yfilter != YFilter.not_set or
                self.cealarmcutoff.yfilter != YFilter.not_set or
                self.cealarmmajorcount.yfilter != YFilter.not_set or
                self.cealarmminorcount.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmMonitoring" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cealarmcriticalcount.is_set or self.cealarmcriticalcount.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmcriticalcount.get_name_leafdata())
            if (self.cealarmcutoff.is_set or self.cealarmcutoff.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmcutoff.get_name_leafdata())
            if (self.cealarmmajorcount.is_set or self.cealarmmajorcount.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmmajorcount.get_name_leafdata())
            if (self.cealarmminorcount.is_set or self.cealarmminorcount.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmminorcount.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmCriticalCount" or name == "ceAlarmCutOff" or name == "ceAlarmMajorCount" or name == "ceAlarmMinorCount"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "ceAlarmCriticalCount"):
                self.cealarmcriticalcount = value
                self.cealarmcriticalcount.value_namespace = name_space
                self.cealarmcriticalcount.value_namespace_prefix = name_space_prefix
            if(value_path == "ceAlarmCutOff"):
                self.cealarmcutoff = value
                self.cealarmcutoff.value_namespace = name_space
                self.cealarmcutoff.value_namespace_prefix = name_space_prefix
            if(value_path == "ceAlarmMajorCount"):
                self.cealarmmajorcount = value
                self.cealarmmajorcount.value_namespace = name_space
                self.cealarmmajorcount.value_namespace_prefix = name_space_prefix
            if(value_path == "ceAlarmMinorCount"):
                self.cealarmminorcount = value
                self.cealarmminorcount.value_namespace = name_space
                self.cealarmminorcount.value_namespace_prefix = name_space_prefix


    class Cealarmhistory(Entity):
        """
        
        
        .. attribute:: cealarmhistlastindex
        
        	This object specifies the value of the ceAlarmHistIndex object corresponding to the last entry added to the table by the agent.  If the management client uses the notifications defined by this module, then it can poll this object to determine whether it has missed a notification sent by the agent
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: cealarmhisttablesize
        
        	This object specifies the number of entries that the  ceAlarmHistTable can contain.  When a physical entity generates an unfiltered alarm, and the capacity of the ceAlarmHistTable has reached the value specified by this object, then the agent deletes the oldest entity in order to accommodate the new entry. A value of '0' prevents any history from being retained.  
        	**type**\:  int
        
        	**range:** 0..500
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmhistory, self).__init__()

            self.yang_name = "ceAlarmHistory"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmhistlastindex = YLeaf(YType.uint32, "ceAlarmHistLastIndex")

            self.cealarmhisttablesize = YLeaf(YType.int32, "ceAlarmHistTableSize")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cealarmhistlastindex",
                            "cealarmhisttablesize") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmhistory, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmhistory, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.cealarmhistlastindex.is_set or
                self.cealarmhisttablesize.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cealarmhistlastindex.yfilter != YFilter.not_set or
                self.cealarmhisttablesize.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmHistory" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cealarmhistlastindex.is_set or self.cealarmhistlastindex.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmhistlastindex.get_name_leafdata())
            if (self.cealarmhisttablesize.is_set or self.cealarmhisttablesize.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmhisttablesize.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmHistLastIndex" or name == "ceAlarmHistTableSize"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "ceAlarmHistLastIndex"):
                self.cealarmhistlastindex = value
                self.cealarmhistlastindex.value_namespace = name_space
                self.cealarmhistlastindex.value_namespace_prefix = name_space_prefix
            if(value_path == "ceAlarmHistTableSize"):
                self.cealarmhisttablesize = value
                self.cealarmhisttablesize.value_namespace = name_space
                self.cealarmhisttablesize.value_namespace_prefix = name_space_prefix


    class Cealarmfiltering(Entity):
        """
        
        
        .. attribute:: cealarmfilterprofileindexnext
        
        	This object contains an appropriate value to be used for ceAlarmFilterIndex when creating entries in the ceAlarmFilterProfileTable.  The value '0' indicates that no unassigned entries are available.  To obtain a ceAlarmFilterIndex, the management client issues a get request.  The agent has the responsibility of  modifying the value of this object following each  successful get request
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: cealarmnotifiesenable
        
        	This object specifies a severity threshold governing the generation of ceAlarmAsserted and ceAlarmCleared notifications.  For example, if the value of this object is set to 'major', then the agent generates these notifications if and only if the severity of the alarm being indicated is 'major' or 'critical'.  The value of '0' disables the  generation of notifications.  Observe that this setting overrides the value of the  ceAlarmFilterNotifiesEnabled object.  This object affects notification generation only; that is, it does not affect monitoring, history logging, and syslog message generation
        	**type**\:  int
        
        	**range:** 0..4
        
        .. attribute:: cealarmsyslogenable
        
        	This object specifies a severity threshold governing the generation of syslog messages corresponding to alarms.  For example, if the value of this object is set to 'major', then the agent generates these a syslog message if and only if the severity of the alarm being indicated is 'major' or 'critical'. The value of '0' disables the generation of syslog messages corresponding to alarms.  Observe that this setting overrides the value of the  ceAlarmFilterSyslogEnabled object.  This object affects syslog message generation only; that is, it does not have an effect on monitoring, history logging, and generation of notifications
        	**type**\:  int
        
        	**range:** 0..4
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmfiltering, self).__init__()

            self.yang_name = "ceAlarmFiltering"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmfilterprofileindexnext = YLeaf(YType.uint32, "ceAlarmFilterProfileIndexNext")

            self.cealarmnotifiesenable = YLeaf(YType.int32, "ceAlarmNotifiesEnable")

            self.cealarmsyslogenable = YLeaf(YType.int32, "ceAlarmSyslogEnable")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cealarmfilterprofileindexnext",
                            "cealarmnotifiesenable",
                            "cealarmsyslogenable") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmfiltering, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmfiltering, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.cealarmfilterprofileindexnext.is_set or
                self.cealarmnotifiesenable.is_set or
                self.cealarmsyslogenable.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cealarmfilterprofileindexnext.yfilter != YFilter.not_set or
                self.cealarmnotifiesenable.yfilter != YFilter.not_set or
                self.cealarmsyslogenable.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmFiltering" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cealarmfilterprofileindexnext.is_set or self.cealarmfilterprofileindexnext.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmfilterprofileindexnext.get_name_leafdata())
            if (self.cealarmnotifiesenable.is_set or self.cealarmnotifiesenable.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmnotifiesenable.get_name_leafdata())
            if (self.cealarmsyslogenable.is_set or self.cealarmsyslogenable.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cealarmsyslogenable.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmFilterProfileIndexNext" or name == "ceAlarmNotifiesEnable" or name == "ceAlarmSyslogEnable"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "ceAlarmFilterProfileIndexNext"):
                self.cealarmfilterprofileindexnext = value
                self.cealarmfilterprofileindexnext.value_namespace = name_space
                self.cealarmfilterprofileindexnext.value_namespace_prefix = name_space_prefix
            if(value_path == "ceAlarmNotifiesEnable"):
                self.cealarmnotifiesenable = value
                self.cealarmnotifiesenable.value_namespace = name_space
                self.cealarmnotifiesenable.value_namespace_prefix = name_space_prefix
            if(value_path == "ceAlarmSyslogEnable"):
                self.cealarmsyslogenable = value
                self.cealarmsyslogenable.value_namespace = name_space
                self.cealarmsyslogenable.value_namespace_prefix = name_space_prefix


    class Cealarmdescrmaptable(Entity):
        """
        For each type of entity (represented entPhysicalVendorType
        OID), this table contains a mapping between a unique 
        ceAlarmDescrIndex and entPhysicalvendorType OID.
        
        .. attribute:: cealarmdescrmapentry
        
        	A mapping between an alarm description and a vendor type
        	**type**\: list of    :py:class:`Cealarmdescrmapentry <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmdescrmaptable.Cealarmdescrmapentry>`
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmdescrmaptable, self).__init__()

            self.yang_name = "ceAlarmDescrMapTable"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmdescrmapentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmdescrmaptable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmdescrmaptable, self).__setattr__(name, value)


        class Cealarmdescrmapentry(Entity):
            """
            A mapping between an alarm description and a vendor type.
            
            .. attribute:: cealarmdescrindex  <key>
            
            	This object uniquely identifies an alarm description
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: cealarmdescrvendortype
            
            	This object specifies an object identifier (typically an enterprise\-specific OID) that uniquely identifies the vendor type of those physical entities that this alarm description applies to
            	**type**\:  str
            
            	**pattern:** (([0\-1](\\.[1\-3]?[0\-9]))\|(2\\.(0\|([1\-9]\\d\*))))(\\.(0\|([1\-9]\\d\*)))\*
            
            

            """

            _prefix = 'CISCO-ENTITY-ALARM-MIB'
            _revision = '1999-07-06'

            def __init__(self):
                super(CiscoEntityAlarmMib.Cealarmdescrmaptable.Cealarmdescrmapentry, self).__init__()

                self.yang_name = "ceAlarmDescrMapEntry"
                self.yang_parent_name = "ceAlarmDescrMapTable"

                self.cealarmdescrindex = YLeaf(YType.uint32, "ceAlarmDescrIndex")

                self.cealarmdescrvendortype = YLeaf(YType.str, "ceAlarmDescrVendorType")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cealarmdescrindex",
                                "cealarmdescrvendortype") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoEntityAlarmMib.Cealarmdescrmaptable.Cealarmdescrmapentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoEntityAlarmMib.Cealarmdescrmaptable.Cealarmdescrmapentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.cealarmdescrindex.is_set or
                    self.cealarmdescrvendortype.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cealarmdescrindex.yfilter != YFilter.not_set or
                    self.cealarmdescrvendortype.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ceAlarmDescrMapEntry" + "[ceAlarmDescrIndex='" + self.cealarmdescrindex.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/ceAlarmDescrMapTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cealarmdescrindex.is_set or self.cealarmdescrindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmdescrindex.get_name_leafdata())
                if (self.cealarmdescrvendortype.is_set or self.cealarmdescrvendortype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmdescrvendortype.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ceAlarmDescrIndex" or name == "ceAlarmDescrVendorType"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "ceAlarmDescrIndex"):
                    self.cealarmdescrindex = value
                    self.cealarmdescrindex.value_namespace = name_space
                    self.cealarmdescrindex.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmDescrVendorType"):
                    self.cealarmdescrvendortype = value
                    self.cealarmdescrvendortype.value_namespace = name_space
                    self.cealarmdescrvendortype.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.cealarmdescrmapentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.cealarmdescrmapentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmDescrMapTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ceAlarmDescrMapEntry"):
                for c in self.cealarmdescrmapentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoEntityAlarmMib.Cealarmdescrmaptable.Cealarmdescrmapentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.cealarmdescrmapentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmDescrMapEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Cealarmdescrtable(Entity):
        """
        This table contains a description for each alarm type
        defined by each vendor type employed by the system.
        Observe that this table is sparse in nature, as it is
        rarely the case that a physical entity type needs to 
        define every alarm in its alarm space.
        
        .. attribute:: cealarmdescrentry
        
        	A collection of attributes that describe an alarm type
        	**type**\: list of    :py:class:`Cealarmdescrentry <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmdescrtable.Cealarmdescrentry>`
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmdescrtable, self).__init__()

            self.yang_name = "ceAlarmDescrTable"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmdescrentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmdescrtable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmdescrtable, self).__setattr__(name, value)


        class Cealarmdescrentry(Entity):
            """
            A collection of attributes that describe an alarm type.
            
            .. attribute:: cealarmdescrindex  <key>
            
            	
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**refers to**\:  :py:class:`cealarmdescrindex <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmdescrmaptable.Cealarmdescrmapentry>`
            
            .. attribute:: cealarmdescralarmtype  <key>
            
            	This object specifies the alarm type being described
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: cealarmdescrseverity
            
            	This object specifies the severity associated with the alarm type.  An implementation may chose to not allow dynamic severity assignment, in which case it would restrict access to this object to be read\-only.  If an implementation allows dynamic severity assignment, then a management client can revert to the default severity by writing the value '0' to this object.  There exists a class of systems that should implement dynamic severity assignment.  For example, consider a DSLAM (Digital Subscriber Loop Access Multiplexor) designed for both the central office and pedestal environments.  A 'pedestal' is typically a dark\-green metal box mounted on a concrete or stone foundation in which carrier\-class companies house equipment. The central office typically controls the temperature and humidity of the environment, reducing reliance on a system's fans.  Thus, the customer probably has a desire to reduce the  severity of alarms indicating the failure of a fan.  However, a pedestal environment has a much greater reliance on a system's fans.  Thus, the customer probably has a desire to increase the severity of alarms indicating the failure of a fan
            	**type**\:  int
            
            	**range:** 0..4
            
            .. attribute:: cealarmdescrtext
            
            	This object specifies a human\-readable message describing the alarm
            	**type**\:  str
            
            

            """

            _prefix = 'CISCO-ENTITY-ALARM-MIB'
            _revision = '1999-07-06'

            def __init__(self):
                super(CiscoEntityAlarmMib.Cealarmdescrtable.Cealarmdescrentry, self).__init__()

                self.yang_name = "ceAlarmDescrEntry"
                self.yang_parent_name = "ceAlarmDescrTable"

                self.cealarmdescrindex = YLeaf(YType.str, "ceAlarmDescrIndex")

                self.cealarmdescralarmtype = YLeaf(YType.int32, "ceAlarmDescrAlarmType")

                self.cealarmdescrseverity = YLeaf(YType.int32, "ceAlarmDescrSeverity")

                self.cealarmdescrtext = YLeaf(YType.str, "ceAlarmDescrText")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cealarmdescrindex",
                                "cealarmdescralarmtype",
                                "cealarmdescrseverity",
                                "cealarmdescrtext") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoEntityAlarmMib.Cealarmdescrtable.Cealarmdescrentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoEntityAlarmMib.Cealarmdescrtable.Cealarmdescrentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.cealarmdescrindex.is_set or
                    self.cealarmdescralarmtype.is_set or
                    self.cealarmdescrseverity.is_set or
                    self.cealarmdescrtext.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cealarmdescrindex.yfilter != YFilter.not_set or
                    self.cealarmdescralarmtype.yfilter != YFilter.not_set or
                    self.cealarmdescrseverity.yfilter != YFilter.not_set or
                    self.cealarmdescrtext.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ceAlarmDescrEntry" + "[ceAlarmDescrIndex='" + self.cealarmdescrindex.get() + "']" + "[ceAlarmDescrAlarmType='" + self.cealarmdescralarmtype.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/ceAlarmDescrTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cealarmdescrindex.is_set or self.cealarmdescrindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmdescrindex.get_name_leafdata())
                if (self.cealarmdescralarmtype.is_set or self.cealarmdescralarmtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmdescralarmtype.get_name_leafdata())
                if (self.cealarmdescrseverity.is_set or self.cealarmdescrseverity.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmdescrseverity.get_name_leafdata())
                if (self.cealarmdescrtext.is_set or self.cealarmdescrtext.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmdescrtext.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ceAlarmDescrIndex" or name == "ceAlarmDescrAlarmType" or name == "ceAlarmDescrSeverity" or name == "ceAlarmDescrText"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "ceAlarmDescrIndex"):
                    self.cealarmdescrindex = value
                    self.cealarmdescrindex.value_namespace = name_space
                    self.cealarmdescrindex.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmDescrAlarmType"):
                    self.cealarmdescralarmtype = value
                    self.cealarmdescralarmtype.value_namespace = name_space
                    self.cealarmdescralarmtype.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmDescrSeverity"):
                    self.cealarmdescrseverity = value
                    self.cealarmdescrseverity.value_namespace = name_space
                    self.cealarmdescrseverity.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmDescrText"):
                    self.cealarmdescrtext = value
                    self.cealarmdescrtext.value_namespace = name_space
                    self.cealarmdescrtext.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.cealarmdescrentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.cealarmdescrentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmDescrTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ceAlarmDescrEntry"):
                for c in self.cealarmdescrentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoEntityAlarmMib.Cealarmdescrtable.Cealarmdescrentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.cealarmdescrentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmDescrEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Cealarmtable(Entity):
        """
        This table specifies alarm control and status information
        related to each physical entity contained by the system,
        including the alarms currently being asserted by each physical
        entity capable of generating alarms.
        
        .. attribute:: cealarmentry
        
        	Alarm control and status information related to the  corresponding physical entity, including a list of those alarms currently being asserted by that physical entity
        	**type**\: list of    :py:class:`Cealarmentry <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmtable.Cealarmentry>`
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmtable, self).__init__()

            self.yang_name = "ceAlarmTable"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmtable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmtable, self).__setattr__(name, value)


        class Cealarmentry(Entity):
            """
            Alarm control and status information related to the 
            corresponding physical entity, including a list of those
            alarms currently being asserted by that physical entity.
            
            .. attribute:: entphysicalindex  <key>
            
            	
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            	**refers to**\:  :py:class:`entphysicalindex <ydk.models.cisco_ios_xe.ENTITY_MIB.EntityMib.Entphysicaltable.Entphysicalentry>`
            
            .. attribute:: cealarmfilterprofile
            
            	This object specifies the alarm filter profile associated with the corresponding physical entity.  An alarm filter profile controls which alarm types the agent will monitor and signal for the corresponding physical entity.  If the value of this object is '0', then the agent monitors and signals all alarms associated with the corresponding physical entity
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: cealarmlist
            
            	This object specifies those alarms currently being asserted by the corresponding physical entity.  Note, an alarm indicates a condition, not an event.  An alarm has two states\:      'asserted'  Indicates that the condition described by the                 alarm exists.      'cleared'   Indicates that the condition described by the                 alarm does not exist.  For example, a slot in a chassis may define an alarm that specifies whether the slot contains a module.  At the time of module insertion, the physical entity corresponding to the slot asserts this alarm, and the alarm remains asserted until the  slot becomes empty.  If an alarm is being asserted by the physical entity, then the corresponding bit in the alarm list is set to a one. Observe that if the physical entity is not currently asserting any alarms, then the list will have a length of zero
            	**type**\:  str
            
            	**length:** 0..32
            
            .. attribute:: cealarmseverity
            
            	This object specifies the highest severity alarm currently being asserted by the corresponding physical entity.  A value of '0' indicates that there the corresponding physical entity currently is not asserting any alarms
            	**type**\:  int
            
            	**range:** 0..4
            
            

            """

            _prefix = 'CISCO-ENTITY-ALARM-MIB'
            _revision = '1999-07-06'

            def __init__(self):
                super(CiscoEntityAlarmMib.Cealarmtable.Cealarmentry, self).__init__()

                self.yang_name = "ceAlarmEntry"
                self.yang_parent_name = "ceAlarmTable"

                self.entphysicalindex = YLeaf(YType.str, "entPhysicalIndex")

                self.cealarmfilterprofile = YLeaf(YType.uint32, "ceAlarmFilterProfile")

                self.cealarmlist = YLeaf(YType.str, "ceAlarmList")

                self.cealarmseverity = YLeaf(YType.int32, "ceAlarmSeverity")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("entphysicalindex",
                                "cealarmfilterprofile",
                                "cealarmlist",
                                "cealarmseverity") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoEntityAlarmMib.Cealarmtable.Cealarmentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoEntityAlarmMib.Cealarmtable.Cealarmentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.entphysicalindex.is_set or
                    self.cealarmfilterprofile.is_set or
                    self.cealarmlist.is_set or
                    self.cealarmseverity.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.entphysicalindex.yfilter != YFilter.not_set or
                    self.cealarmfilterprofile.yfilter != YFilter.not_set or
                    self.cealarmlist.yfilter != YFilter.not_set or
                    self.cealarmseverity.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ceAlarmEntry" + "[entPhysicalIndex='" + self.entphysicalindex.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/ceAlarmTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.entphysicalindex.is_set or self.entphysicalindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.entphysicalindex.get_name_leafdata())
                if (self.cealarmfilterprofile.is_set or self.cealarmfilterprofile.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmfilterprofile.get_name_leafdata())
                if (self.cealarmlist.is_set or self.cealarmlist.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmlist.get_name_leafdata())
                if (self.cealarmseverity.is_set or self.cealarmseverity.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmseverity.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "entPhysicalIndex" or name == "ceAlarmFilterProfile" or name == "ceAlarmList" or name == "ceAlarmSeverity"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "entPhysicalIndex"):
                    self.entphysicalindex = value
                    self.entphysicalindex.value_namespace = name_space
                    self.entphysicalindex.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmFilterProfile"):
                    self.cealarmfilterprofile = value
                    self.cealarmfilterprofile.value_namespace = name_space
                    self.cealarmfilterprofile.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmList"):
                    self.cealarmlist = value
                    self.cealarmlist.value_namespace = name_space
                    self.cealarmlist.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmSeverity"):
                    self.cealarmseverity = value
                    self.cealarmseverity.value_namespace = name_space
                    self.cealarmseverity.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.cealarmentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.cealarmentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ceAlarmEntry"):
                for c in self.cealarmentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoEntityAlarmMib.Cealarmtable.Cealarmentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.cealarmentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Cealarmhisttable(Entity):
        """
        This table contains a history of ceAlarmIndicate and
        ceAlarmClear traps generated by the agent.
        
        .. attribute:: cealarmhistentry
        
        	The information conveyed by a ceAlarmIndicate or ceAlarmClear trap
        	**type**\: list of    :py:class:`Cealarmhistentry <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmhisttable.Cealarmhistentry>`
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmhisttable, self).__init__()

            self.yang_name = "ceAlarmHistTable"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmhistentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmhisttable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmhisttable, self).__setattr__(name, value)


        class Cealarmhistentry(Entity):
            """
            The information conveyed by a ceAlarmIndicate or
            ceAlarmClear trap.
            
            .. attribute:: cealarmhistindex  <key>
            
            	An integer value uniquely identifying the entry in the table. The value of this object starts at '1' and monotonically increases for each alarm condition transition monitored by the agent.  If the value of this object is '4294967295', the agent will reset it to '1' upon monitoring the next alarm condition transition
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: cealarmhistalarmtype
            
            	This object specifies the type of alarm generated
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: cealarmhistentphysicalindex
            
            	This object specifies the physical entity that generated the alarm
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            .. attribute:: cealarmhistseverity
            
            	This object specifies the severity of the alarm generated
            	**type**\:   :py:class:`Alarmseverity <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.Alarmseverity>`
            
            .. attribute:: cealarmhisttimestamp
            
            	This object specifies the value of the sysUpTime object at the time the alarm was generated
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: cealarmhisttype
            
            	This object specifies whether the agent created the entry as the result of an alarm being asserted or cleared
            	**type**\:   :py:class:`Cealarmhisttype <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmhisttable.Cealarmhistentry.Cealarmhisttype>`
            
            

            """

            _prefix = 'CISCO-ENTITY-ALARM-MIB'
            _revision = '1999-07-06'

            def __init__(self):
                super(CiscoEntityAlarmMib.Cealarmhisttable.Cealarmhistentry, self).__init__()

                self.yang_name = "ceAlarmHistEntry"
                self.yang_parent_name = "ceAlarmHistTable"

                self.cealarmhistindex = YLeaf(YType.uint32, "ceAlarmHistIndex")

                self.cealarmhistalarmtype = YLeaf(YType.int32, "ceAlarmHistAlarmType")

                self.cealarmhistentphysicalindex = YLeaf(YType.int32, "ceAlarmHistEntPhysicalIndex")

                self.cealarmhistseverity = YLeaf(YType.enumeration, "ceAlarmHistSeverity")

                self.cealarmhisttimestamp = YLeaf(YType.uint32, "ceAlarmHistTimeStamp")

                self.cealarmhisttype = YLeaf(YType.enumeration, "ceAlarmHistType")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cealarmhistindex",
                                "cealarmhistalarmtype",
                                "cealarmhistentphysicalindex",
                                "cealarmhistseverity",
                                "cealarmhisttimestamp",
                                "cealarmhisttype") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoEntityAlarmMib.Cealarmhisttable.Cealarmhistentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoEntityAlarmMib.Cealarmhisttable.Cealarmhistentry, self).__setattr__(name, value)

            class Cealarmhisttype(Enum):
                """
                Cealarmhisttype

                This object specifies whether the agent created the entry as

                the result of an alarm being asserted or cleared.

                .. data:: asserted = 1

                .. data:: cleared = 2

                """

                asserted = Enum.YLeaf(1, "asserted")

                cleared = Enum.YLeaf(2, "cleared")


            def has_data(self):
                return (
                    self.cealarmhistindex.is_set or
                    self.cealarmhistalarmtype.is_set or
                    self.cealarmhistentphysicalindex.is_set or
                    self.cealarmhistseverity.is_set or
                    self.cealarmhisttimestamp.is_set or
                    self.cealarmhisttype.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cealarmhistindex.yfilter != YFilter.not_set or
                    self.cealarmhistalarmtype.yfilter != YFilter.not_set or
                    self.cealarmhistentphysicalindex.yfilter != YFilter.not_set or
                    self.cealarmhistseverity.yfilter != YFilter.not_set or
                    self.cealarmhisttimestamp.yfilter != YFilter.not_set or
                    self.cealarmhisttype.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ceAlarmHistEntry" + "[ceAlarmHistIndex='" + self.cealarmhistindex.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/ceAlarmHistTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cealarmhistindex.is_set or self.cealarmhistindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmhistindex.get_name_leafdata())
                if (self.cealarmhistalarmtype.is_set or self.cealarmhistalarmtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmhistalarmtype.get_name_leafdata())
                if (self.cealarmhistentphysicalindex.is_set or self.cealarmhistentphysicalindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmhistentphysicalindex.get_name_leafdata())
                if (self.cealarmhistseverity.is_set or self.cealarmhistseverity.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmhistseverity.get_name_leafdata())
                if (self.cealarmhisttimestamp.is_set or self.cealarmhisttimestamp.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmhisttimestamp.get_name_leafdata())
                if (self.cealarmhisttype.is_set or self.cealarmhisttype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmhisttype.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ceAlarmHistIndex" or name == "ceAlarmHistAlarmType" or name == "ceAlarmHistEntPhysicalIndex" or name == "ceAlarmHistSeverity" or name == "ceAlarmHistTimeStamp" or name == "ceAlarmHistType"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "ceAlarmHistIndex"):
                    self.cealarmhistindex = value
                    self.cealarmhistindex.value_namespace = name_space
                    self.cealarmhistindex.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmHistAlarmType"):
                    self.cealarmhistalarmtype = value
                    self.cealarmhistalarmtype.value_namespace = name_space
                    self.cealarmhistalarmtype.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmHistEntPhysicalIndex"):
                    self.cealarmhistentphysicalindex = value
                    self.cealarmhistentphysicalindex.value_namespace = name_space
                    self.cealarmhistentphysicalindex.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmHistSeverity"):
                    self.cealarmhistseverity = value
                    self.cealarmhistseverity.value_namespace = name_space
                    self.cealarmhistseverity.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmHistTimeStamp"):
                    self.cealarmhisttimestamp = value
                    self.cealarmhisttimestamp.value_namespace = name_space
                    self.cealarmhisttimestamp.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmHistType"):
                    self.cealarmhisttype = value
                    self.cealarmhisttype.value_namespace = name_space
                    self.cealarmhisttype.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.cealarmhistentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.cealarmhistentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmHistTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ceAlarmHistEntry"):
                for c in self.cealarmhistentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoEntityAlarmMib.Cealarmhisttable.Cealarmhistentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.cealarmhistentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmHistEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Cealarmfilterprofiletable(Entity):
        """
        This table contains a list of alarm filter profiles.
        
        .. attribute:: cealarmfilterprofileentry
        
        	When a physical entity asserts/clears an alarm AND the ceAlarmFilterProfile object is not '0', the agent applies the specified alarm filter profile in processing the alarm. The agent uses the following procedure in processing the transition of an alarm condition of a given type\:  1)  If the alarm list specified by the alarm filter profile's     ceAlarmFilterAlarmsEnabled object specifies that the alarm     type is disabled, then the agent performs no further     processing.  2)  The agent creates an entry in the ceAlarmHistTable.  3)  If the alarm list specified by the alarm filter profile's      ceAlarmFilterNotifiesEnabled object specifies that the alarm     type is enabled, then the agent generates the appropriate     notification.  4)  If the alarm list specified by the alarm filter profile's     ceAlarmFilterSyslogEnabled object specifies that the alarm     type is enabled, then the agent generates the appropriate     syslog message
        	**type**\: list of    :py:class:`Cealarmfilterprofileentry <ydk.models.cisco_ios_xe.CISCO_ENTITY_ALARM_MIB.CiscoEntityAlarmMib.Cealarmfilterprofiletable.Cealarmfilterprofileentry>`
        
        

        """

        _prefix = 'CISCO-ENTITY-ALARM-MIB'
        _revision = '1999-07-06'

        def __init__(self):
            super(CiscoEntityAlarmMib.Cealarmfilterprofiletable, self).__init__()

            self.yang_name = "ceAlarmFilterProfileTable"
            self.yang_parent_name = "CISCO-ENTITY-ALARM-MIB"

            self.cealarmfilterprofileentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoEntityAlarmMib.Cealarmfilterprofiletable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoEntityAlarmMib.Cealarmfilterprofiletable, self).__setattr__(name, value)


        class Cealarmfilterprofileentry(Entity):
            """
            When a physical entity asserts/clears an alarm AND the
            ceAlarmFilterProfile object is not '0', the agent applies
            the specified alarm filter profile in processing the alarm.
            The agent uses the following procedure in processing the
            transition of an alarm condition of a given type\:
            
            1)  If the alarm list specified by the alarm filter profile's
                ceAlarmFilterAlarmsEnabled object specifies that the alarm
                type is disabled, then the agent performs no further
                processing.
            
            2)  The agent creates an entry in the ceAlarmHistTable.
            
            3)  If the alarm list specified by the alarm filter profile's 
                ceAlarmFilterNotifiesEnabled object specifies that the alarm
                type is enabled, then the agent generates the appropriate
                notification.
            
            4)  If the alarm list specified by the alarm filter profile's
                ceAlarmFilterSyslogEnabled object specifies that the alarm
                type is enabled, then the agent generates the appropriate
                syslog message.
            
            .. attribute:: cealarmfilterindex  <key>
            
            	This object uniquely identifies the alarm filter profile
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: cealarmfilteralarmsenabled
            
            	This object specifies a list of alarms that are enabled
            	**type**\:  str
            
            	**length:** 0..32
            
            .. attribute:: cealarmfilteralias
            
            	This object specifies an arbitrary name associated with the alarm filter profile by the management client, and provides a non\-volatile 'handle' for the alarm filter profile.  On the first instantiation of an alarm filter profile, the value of this object is a zero\-length string.  However, an agent may choose to set the value to a locally unique default value.  If an implementation supports write access to this object, then the agent is responsible for ensuring the retention of any value written to this object until a management client deletes it.  The level of retention must span reboots and  reinitializations of the network management system, including those that result in different assignments to the value of the entPhysicalIndex associated with the physical entity
            	**type**\:  str
            
            .. attribute:: cealarmfilternotifiesenabled
            
            	This object specifies a list of alarms for which notification generation is enabled
            	**type**\:  str
            
            	**length:** 0..32
            
            .. attribute:: cealarmfilterstatus
            
            	This object facilitates the creation, modification, or  deletion of a conceptual row in this table.  A management client can create a conceptual row in this table by setting this object to 'createAndWait' or  'createAndGo'.  If a request to create a conceptual row in this table fails, then the system is not capable of supporting any more alarm filters.  Before modifying a conceptual row in this table, the  management client must set this object to 'notInService'. After modifying a conceptual row in this table, the  management client must set this object to 'active'. This operation causes the modifications made to an alarm filter profile to take effect.  An implementation should not allow a conceptual row in this table to be deleted if one or more physical entities reference it
            	**type**\:   :py:class:`Rowstatus <ydk.models.cisco_ios_xe.SNMPv2_TC.Rowstatus>`
            
            .. attribute:: cealarmfiltersyslogenabled
            
            	This object specifies a list of alarms for which syslog message generation is enabled
            	**type**\:  str
            
            	**length:** 0..32
            
            

            """

            _prefix = 'CISCO-ENTITY-ALARM-MIB'
            _revision = '1999-07-06'

            def __init__(self):
                super(CiscoEntityAlarmMib.Cealarmfilterprofiletable.Cealarmfilterprofileentry, self).__init__()

                self.yang_name = "ceAlarmFilterProfileEntry"
                self.yang_parent_name = "ceAlarmFilterProfileTable"

                self.cealarmfilterindex = YLeaf(YType.uint32, "ceAlarmFilterIndex")

                self.cealarmfilteralarmsenabled = YLeaf(YType.str, "ceAlarmFilterAlarmsEnabled")

                self.cealarmfilteralias = YLeaf(YType.str, "ceAlarmFilterAlias")

                self.cealarmfilternotifiesenabled = YLeaf(YType.str, "ceAlarmFilterNotifiesEnabled")

                self.cealarmfilterstatus = YLeaf(YType.enumeration, "ceAlarmFilterStatus")

                self.cealarmfiltersyslogenabled = YLeaf(YType.str, "ceAlarmFilterSyslogEnabled")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cealarmfilterindex",
                                "cealarmfilteralarmsenabled",
                                "cealarmfilteralias",
                                "cealarmfilternotifiesenabled",
                                "cealarmfilterstatus",
                                "cealarmfiltersyslogenabled") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoEntityAlarmMib.Cealarmfilterprofiletable.Cealarmfilterprofileentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoEntityAlarmMib.Cealarmfilterprofiletable.Cealarmfilterprofileentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.cealarmfilterindex.is_set or
                    self.cealarmfilteralarmsenabled.is_set or
                    self.cealarmfilteralias.is_set or
                    self.cealarmfilternotifiesenabled.is_set or
                    self.cealarmfilterstatus.is_set or
                    self.cealarmfiltersyslogenabled.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cealarmfilterindex.yfilter != YFilter.not_set or
                    self.cealarmfilteralarmsenabled.yfilter != YFilter.not_set or
                    self.cealarmfilteralias.yfilter != YFilter.not_set or
                    self.cealarmfilternotifiesenabled.yfilter != YFilter.not_set or
                    self.cealarmfilterstatus.yfilter != YFilter.not_set or
                    self.cealarmfiltersyslogenabled.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ceAlarmFilterProfileEntry" + "[ceAlarmFilterIndex='" + self.cealarmfilterindex.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/ceAlarmFilterProfileTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cealarmfilterindex.is_set or self.cealarmfilterindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmfilterindex.get_name_leafdata())
                if (self.cealarmfilteralarmsenabled.is_set or self.cealarmfilteralarmsenabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmfilteralarmsenabled.get_name_leafdata())
                if (self.cealarmfilteralias.is_set or self.cealarmfilteralias.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmfilteralias.get_name_leafdata())
                if (self.cealarmfilternotifiesenabled.is_set or self.cealarmfilternotifiesenabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmfilternotifiesenabled.get_name_leafdata())
                if (self.cealarmfilterstatus.is_set or self.cealarmfilterstatus.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmfilterstatus.get_name_leafdata())
                if (self.cealarmfiltersyslogenabled.is_set or self.cealarmfiltersyslogenabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cealarmfiltersyslogenabled.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ceAlarmFilterIndex" or name == "ceAlarmFilterAlarmsEnabled" or name == "ceAlarmFilterAlias" or name == "ceAlarmFilterNotifiesEnabled" or name == "ceAlarmFilterStatus" or name == "ceAlarmFilterSyslogEnabled"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "ceAlarmFilterIndex"):
                    self.cealarmfilterindex = value
                    self.cealarmfilterindex.value_namespace = name_space
                    self.cealarmfilterindex.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmFilterAlarmsEnabled"):
                    self.cealarmfilteralarmsenabled = value
                    self.cealarmfilteralarmsenabled.value_namespace = name_space
                    self.cealarmfilteralarmsenabled.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmFilterAlias"):
                    self.cealarmfilteralias = value
                    self.cealarmfilteralias.value_namespace = name_space
                    self.cealarmfilteralias.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmFilterNotifiesEnabled"):
                    self.cealarmfilternotifiesenabled = value
                    self.cealarmfilternotifiesenabled.value_namespace = name_space
                    self.cealarmfilternotifiesenabled.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmFilterStatus"):
                    self.cealarmfilterstatus = value
                    self.cealarmfilterstatus.value_namespace = name_space
                    self.cealarmfilterstatus.value_namespace_prefix = name_space_prefix
                if(value_path == "ceAlarmFilterSyslogEnabled"):
                    self.cealarmfiltersyslogenabled = value
                    self.cealarmfiltersyslogenabled.value_namespace = name_space
                    self.cealarmfiltersyslogenabled.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.cealarmfilterprofileentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.cealarmfilterprofileentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ceAlarmFilterProfileTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ceAlarmFilterProfileEntry"):
                for c in self.cealarmfilterprofileentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoEntityAlarmMib.Cealarmfilterprofiletable.Cealarmfilterprofileentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.cealarmfilterprofileentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ceAlarmFilterProfileEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.cealarmdescrmaptable is not None and self.cealarmdescrmaptable.has_data()) or
            (self.cealarmdescrtable is not None and self.cealarmdescrtable.has_data()) or
            (self.cealarmfiltering is not None and self.cealarmfiltering.has_data()) or
            (self.cealarmfilterprofiletable is not None and self.cealarmfilterprofiletable.has_data()) or
            (self.cealarmhistory is not None and self.cealarmhistory.has_data()) or
            (self.cealarmhisttable is not None and self.cealarmhisttable.has_data()) or
            (self.cealarmmonitoring is not None and self.cealarmmonitoring.has_data()) or
            (self.cealarmtable is not None and self.cealarmtable.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.cealarmdescrmaptable is not None and self.cealarmdescrmaptable.has_operation()) or
            (self.cealarmdescrtable is not None and self.cealarmdescrtable.has_operation()) or
            (self.cealarmfiltering is not None and self.cealarmfiltering.has_operation()) or
            (self.cealarmfilterprofiletable is not None and self.cealarmfilterprofiletable.has_operation()) or
            (self.cealarmhistory is not None and self.cealarmhistory.has_operation()) or
            (self.cealarmhisttable is not None and self.cealarmhisttable.has_operation()) or
            (self.cealarmmonitoring is not None and self.cealarmmonitoring.has_operation()) or
            (self.cealarmtable is not None and self.cealarmtable.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "CISCO-ENTITY-ALARM-MIB:CISCO-ENTITY-ALARM-MIB" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "ceAlarmDescrMapTable"):
            if (self.cealarmdescrmaptable is None):
                self.cealarmdescrmaptable = CiscoEntityAlarmMib.Cealarmdescrmaptable()
                self.cealarmdescrmaptable.parent = self
                self._children_name_map["cealarmdescrmaptable"] = "ceAlarmDescrMapTable"
            return self.cealarmdescrmaptable

        if (child_yang_name == "ceAlarmDescrTable"):
            if (self.cealarmdescrtable is None):
                self.cealarmdescrtable = CiscoEntityAlarmMib.Cealarmdescrtable()
                self.cealarmdescrtable.parent = self
                self._children_name_map["cealarmdescrtable"] = "ceAlarmDescrTable"
            return self.cealarmdescrtable

        if (child_yang_name == "ceAlarmFiltering"):
            if (self.cealarmfiltering is None):
                self.cealarmfiltering = CiscoEntityAlarmMib.Cealarmfiltering()
                self.cealarmfiltering.parent = self
                self._children_name_map["cealarmfiltering"] = "ceAlarmFiltering"
            return self.cealarmfiltering

        if (child_yang_name == "ceAlarmFilterProfileTable"):
            if (self.cealarmfilterprofiletable is None):
                self.cealarmfilterprofiletable = CiscoEntityAlarmMib.Cealarmfilterprofiletable()
                self.cealarmfilterprofiletable.parent = self
                self._children_name_map["cealarmfilterprofiletable"] = "ceAlarmFilterProfileTable"
            return self.cealarmfilterprofiletable

        if (child_yang_name == "ceAlarmHistory"):
            if (self.cealarmhistory is None):
                self.cealarmhistory = CiscoEntityAlarmMib.Cealarmhistory()
                self.cealarmhistory.parent = self
                self._children_name_map["cealarmhistory"] = "ceAlarmHistory"
            return self.cealarmhistory

        if (child_yang_name == "ceAlarmHistTable"):
            if (self.cealarmhisttable is None):
                self.cealarmhisttable = CiscoEntityAlarmMib.Cealarmhisttable()
                self.cealarmhisttable.parent = self
                self._children_name_map["cealarmhisttable"] = "ceAlarmHistTable"
            return self.cealarmhisttable

        if (child_yang_name == "ceAlarmMonitoring"):
            if (self.cealarmmonitoring is None):
                self.cealarmmonitoring = CiscoEntityAlarmMib.Cealarmmonitoring()
                self.cealarmmonitoring.parent = self
                self._children_name_map["cealarmmonitoring"] = "ceAlarmMonitoring"
            return self.cealarmmonitoring

        if (child_yang_name == "ceAlarmTable"):
            if (self.cealarmtable is None):
                self.cealarmtable = CiscoEntityAlarmMib.Cealarmtable()
                self.cealarmtable.parent = self
                self._children_name_map["cealarmtable"] = "ceAlarmTable"
            return self.cealarmtable

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "ceAlarmDescrMapTable" or name == "ceAlarmDescrTable" or name == "ceAlarmFiltering" or name == "ceAlarmFilterProfileTable" or name == "ceAlarmHistory" or name == "ceAlarmHistTable" or name == "ceAlarmMonitoring" or name == "ceAlarmTable"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = CiscoEntityAlarmMib()
        return self._top_entity

