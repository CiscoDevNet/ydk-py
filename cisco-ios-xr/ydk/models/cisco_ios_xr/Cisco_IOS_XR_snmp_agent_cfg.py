""" Cisco_IOS_XR_snmp_agent_cfg 

This module contains a collection of YANG definitions
for Cisco IOS\-XR snmp\-agent package configuration.

This module contains definitions
for the following management objects\:
  snmp\: The heirarchy point for all the SNMP configurations
  mib\: mib

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class GroupSnmpVersion(Enum):
    """
    GroupSnmpVersion

    Group snmp version

    .. data:: v1 = 0

    	SNMP version 1

    .. data:: v2c = 1

    	SNMP version 2

    .. data:: v3 = 2

    	SNMP version 3

    """

    v1 = Enum.YLeaf(0, "v1")

    v2c = Enum.YLeaf(1, "v2c")

    v3 = Enum.YLeaf(2, "v3")


class SnmpAccessLevel(Enum):
    """
    SnmpAccessLevel

    Snmp access level

    .. data:: read_only = 0

    	Read Only Access for a community string

    .. data:: read_write = 1

    	Read Write Access for a community string

    """

    read_only = Enum.YLeaf(0, "read-only")

    read_write = Enum.YLeaf(1, "read-write")


class SnmpBulkstatFileFormat(Enum):
    """
    SnmpBulkstatFileFormat

    Snmp bulkstat file format

    .. data:: schema_ascii = 1

    	Tranfer file in schema Ascii format

    .. data:: bulk_ascii = 2

    	Tranfer file in Bulk Ascii format

    .. data:: bulk_binary = 3

    	Tranfer file in Bulk binary format

    """

    schema_ascii = Enum.YLeaf(1, "schema-ascii")

    bulk_ascii = Enum.YLeaf(2, "bulk-ascii")

    bulk_binary = Enum.YLeaf(3, "bulk-binary")


class SnmpBulkstatSchema(Enum):
    """
    SnmpBulkstatSchema

    Snmp bulkstat schema

    .. data:: exact_interface = 1

    	Exact Interface

    .. data:: exact_oid = 2

    	Exact OID

    .. data:: wild_interface = 3

    	Wild Interface

    .. data:: wild_oid = 4

    	Wild OID

    .. data:: range_oid = 5

    	Range of OID

    .. data:: repeat_oid = 6

    	Repeated the instance

    """

    exact_interface = Enum.YLeaf(1, "exact-interface")

    exact_oid = Enum.YLeaf(2, "exact-oid")

    wild_interface = Enum.YLeaf(3, "wild-interface")

    wild_oid = Enum.YLeaf(4, "wild-oid")

    range_oid = Enum.YLeaf(5, "range-oid")

    repeat_oid = Enum.YLeaf(6, "repeat-oid")


class SnmpContext(Enum):
    """
    SnmpContext

    Snmp context

    .. data:: vrf = 1

    	VRF feature

    .. data:: bridge = 4

    	BRIDGE feature

    .. data:: ospf = 5

    	OSPF feature

    .. data:: ospfv3 = 6

    	OSPFv3 feature

    """

    vrf = Enum.YLeaf(1, "vrf")

    bridge = Enum.YLeaf(4, "bridge")

    ospf = Enum.YLeaf(5, "ospf")

    ospfv3 = Enum.YLeaf(6, "ospfv3")


class SnmpDscpValue(Enum):
    """
    SnmpDscpValue

    Snmp dscp value

    .. data:: default = 0

    	Applicable to DSCP: bits 000000

    .. data:: af11 = 10

    	Applicable to DSCP: bits 001010

    .. data:: af12 = 12

    	Applicable to DSCP: bits 001100

    .. data:: af13 = 14

    	Applicable to DSCP: bits 001110

    .. data:: af21 = 18

    	Applicable to DSCP: bits 010010

    .. data:: af22 = 20

    	Applicable to DSCP: bits 010100

    .. data:: af23 = 22

    	Applicable to DSCP: bits 010110

    .. data:: af31 = 26

    	Applicable to DSCP: bits 011010

    .. data:: af32 = 28

    	Applicable to DSCP: bits 011100

    .. data:: af33 = 30

    	Applicable to DSCP: bits 011110

    .. data:: af41 = 34

    	Applicable to DSCP: bits 100010

    .. data:: af42 = 36

    	Applicable to DSCP: bits 100100

    .. data:: af43 = 38

    	Applicable to DSCP: bits 100110

    .. data:: ef = 46

    	Applicable to DSCP: bits 101110

    .. data:: cs1 = 8

    	Applicable to DSCP: bits 001000

    .. data:: cs2 = 16

    	Applicable to DSCP: bits 010000

    .. data:: cs3 = 24

    	Applicable to DSCP: bits 011000

    .. data:: cs4 = 32

    	Applicable to DSCP: bits 100000

    .. data:: cs5 = 40

    	Applicable to DSCP: bits 101000

    .. data:: cs6 = 48

    	Applicable to DSCP: bits 110000

    .. data:: cs7 = 56

    	Applicable to DSCP: bits 111000

    """

    default = Enum.YLeaf(0, "default")

    af11 = Enum.YLeaf(10, "af11")

    af12 = Enum.YLeaf(12, "af12")

    af13 = Enum.YLeaf(14, "af13")

    af21 = Enum.YLeaf(18, "af21")

    af22 = Enum.YLeaf(20, "af22")

    af23 = Enum.YLeaf(22, "af23")

    af31 = Enum.YLeaf(26, "af31")

    af32 = Enum.YLeaf(28, "af32")

    af33 = Enum.YLeaf(30, "af33")

    af41 = Enum.YLeaf(34, "af41")

    af42 = Enum.YLeaf(36, "af42")

    af43 = Enum.YLeaf(38, "af43")

    ef = Enum.YLeaf(46, "ef")

    cs1 = Enum.YLeaf(8, "cs1")

    cs2 = Enum.YLeaf(16, "cs2")

    cs3 = Enum.YLeaf(24, "cs3")

    cs4 = Enum.YLeaf(32, "cs4")

    cs5 = Enum.YLeaf(40, "cs5")

    cs6 = Enum.YLeaf(48, "cs6")

    cs7 = Enum.YLeaf(56, "cs7")


class SnmpHashAlgorithm(Enum):
    """
    SnmpHashAlgorithm

    Snmp hash algorithm

    .. data:: none = 0

    	No authentication required

    .. data:: md5 = 1

    	Standard Message Digest algorithm

    .. data:: sha = 2

    	SHA algorithm

    """

    none = Enum.YLeaf(0, "none")

    md5 = Enum.YLeaf(1, "md5")

    sha = Enum.YLeaf(2, "sha")


class SnmpMibViewInclusion(Enum):
    """
    SnmpMibViewInclusion

    Snmp mib view inclusion

    .. data:: included = 1

    	MIB View to be included

    .. data:: excluded = 2

    	MIB View to be excluded

    """

    included = Enum.YLeaf(1, "included")

    excluded = Enum.YLeaf(2, "excluded")


class SnmpOwnerAccess(Enum):
    """
    SnmpOwnerAccess

    Snmp owner access

    .. data:: sdr_owner = 0

    	Secure Domain Router Owner permissions

    .. data:: system_owner = 1

    	System owner permissions

    """

    sdr_owner = Enum.YLeaf(0, "sdr-owner")

    system_owner = Enum.YLeaf(1, "system-owner")


class SnmpPrecedenceValue1(Enum):
    """
    SnmpPrecedenceValue1

    Snmp precedence value1

    .. data:: routine = 0

    	Applicable to Precedence: value 0

    .. data:: priority = 1

    	Applicable to Precedence: value 1

    .. data:: immediate = 2

    	Applicable to Precedence: value 2

    .. data:: flash = 3

    	Applicable to Precedence: value 3

    .. data:: flash_override = 4

    	Applicable to Precedence: value 4

    .. data:: critical = 5

    	Applicable to Precedence: value 5

    .. data:: internet = 6

    	Applicable to Precedence: value 6

    .. data:: network = 7

    	Applicable to Precedence: value 7

    """

    routine = Enum.YLeaf(0, "routine")

    priority = Enum.YLeaf(1, "priority")

    immediate = Enum.YLeaf(2, "immediate")

    flash = Enum.YLeaf(3, "flash")

    flash_override = Enum.YLeaf(4, "flash-override")

    critical = Enum.YLeaf(5, "critical")

    internet = Enum.YLeaf(6, "internet")

    network = Enum.YLeaf(7, "network")


class SnmpPrivAlgorithm(Enum):
    """
    SnmpPrivAlgorithm

    Snmp priv algorithm

    .. data:: none = 0

    	No Privacy

    .. data:: des = 1

    	Des algorithm

    .. data:: Y_3des = 2

    	3des algorithm

    .. data:: aes128 = 3

    	aes128 algorithm

    .. data:: aes192 = 4

    	aes192 algorithm

    .. data:: aes256 = 5

    	aes256 algorithm

    """

    none = Enum.YLeaf(0, "none")

    des = Enum.YLeaf(1, "des")

    Y_3des = Enum.YLeaf(2, "3des")

    aes128 = Enum.YLeaf(3, "aes128")

    aes192 = Enum.YLeaf(4, "aes192")

    aes256 = Enum.YLeaf(5, "aes256")


class SnmpSecurityModel(Enum):
    """
    SnmpSecurityModel

    Snmp security model

    .. data:: no_authentication = 0

    	No Authentication required

    .. data:: authentication = 1

    	Authentication password alone required for

    	access

    .. data:: privacy = 2

    	Authentication and privacy password required

    	for access

    """

    no_authentication = Enum.YLeaf(0, "no-authentication")

    authentication = Enum.YLeaf(1, "authentication")

    privacy = Enum.YLeaf(2, "privacy")


class SnmpTos(Enum):
    """
    SnmpTos

    Snmp tos

    .. data:: precedence = 0

    	SNMP TOS type Precedence

    .. data:: dscp = 1

    	SNMP TOS type DSCP

    """

    precedence = Enum.YLeaf(0, "precedence")

    dscp = Enum.YLeaf(1, "dscp")


class Snmpacl(Enum):
    """
    Snmpacl

    Snmpacl

    .. data:: ipv4 = 1

    	Ipv4 Access-list

    .. data:: ipv6 = 2

    	Ipv6 Access-list

    """

    ipv4 = Enum.YLeaf(1, "ipv4")

    ipv6 = Enum.YLeaf(2, "ipv6")


class UserSnmpVersion(Enum):
    """
    UserSnmpVersion

    User snmp version

    .. data:: v1 = 1

    	SNMP version 1

    .. data:: v2c = 2

    	SNMP version 2

    .. data:: v3 = 3

    	SNMP version 3

    """

    v1 = Enum.YLeaf(1, "v1")

    v2c = Enum.YLeaf(2, "v2c")

    v3 = Enum.YLeaf(3, "v3")



class Snmp(Entity):
    """
    The heirarchy point for all the SNMP
    configurations
    
    .. attribute:: administration
    
    	Container class for SNMP administration
    	**type**\:   :py:class:`Administration <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Administration>`
    
    .. attribute:: agent
    
    	The heirarchy point for SNMP Agent configurations
    	**type**\:   :py:class:`Agent <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Agent>`
    
    .. attribute:: bulk_stats
    
    	SNMP bulk stats configuration commands
    	**type**\:   :py:class:`BulkStats <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats>`
    
    .. attribute:: context_mappings
    
    	List of context names
    	**type**\:   :py:class:`ContextMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.ContextMappings>`
    
    .. attribute:: contexts
    
    	List of Context Names
    	**type**\:   :py:class:`Contexts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Contexts>`
    
    .. attribute:: correlator
    
    	Configure properties of the trap correlator
    	**type**\:   :py:class:`Correlator <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator>`
    
    .. attribute:: default_community_maps
    
    	Container class to hold unencrpted community map
    	**type**\:   :py:class:`DefaultCommunityMaps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.DefaultCommunityMaps>`
    
    .. attribute:: encrypted_community_maps
    
    	Container class to hold clear/encrypted communitie maps
    	**type**\:   :py:class:`EncryptedCommunityMaps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.EncryptedCommunityMaps>`
    
    .. attribute:: groups
    
    	Define a User Security Model group
    	**type**\:   :py:class:`Groups <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Groups>`
    
    .. attribute:: inform_pending
    
    	Max nmber of informs to hold in queue, (default 25)
    	**type**\:  int
    
    	**range:** 0..4294967295
    
    .. attribute:: inform_retries
    
    	Number of times to retry an Inform request (default 3)
    	**type**\:  int
    
    	**range:** 0..100
    
    .. attribute:: inform_timeout
    
    	Timeout value in seconds for Inform request (default 15 sec)
    	**type**\:  int
    
    	**range:** 1..42949671
    
    	**units**\: second
    
    .. attribute:: ipv4
    
    	SNMP TOS bit for outgoing packets
    	**type**\:   :py:class:`Ipv4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Ipv4>`
    
    .. attribute:: ipv6
    
    	SNMP TOS bit for outgoing packets
    	**type**\:   :py:class:`Ipv6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Ipv6>`
    
    .. attribute:: logging
    
    	SNMP logging
    	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Logging>`
    
    .. attribute:: notification
    
    	Enable SNMP notifications
    	**type**\:   :py:class:`Notification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification>`
    
    .. attribute:: oid_poll_stats
    
    	Enable Poll OID statistics
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: overload_control
    
    	Set overload control params for handling incoming messages
    	**type**\:   :py:class:`OverloadControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.OverloadControl>`
    
    	**presence node**\: True
    
    .. attribute:: packet_size
    
    	Largest SNMP packet size
    	**type**\:  int
    
    	**range:** 484..65500
    
    .. attribute:: system
    
    	container to hold system information
    	**type**\:   :py:class:`System <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.System>`
    
    .. attribute:: target
    
    	SNMP target configurations
    	**type**\:   :py:class:`Target <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Target>`
    
    .. attribute:: throttle_time
    
    	Throttle time for incoming queue (default 0 msec)
    	**type**\:  int
    
    	**range:** 50..1000
    
    .. attribute:: timeouts
    
    	SNMP timeouts
    	**type**\:   :py:class:`Timeouts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Timeouts>`
    
    .. attribute:: trap
    
    	Class to hold trap configurations
    	**type**\:   :py:class:`Trap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Trap>`
    
    .. attribute:: trap_hosts
    
    	Specify hosts to receive SNMP notifications
    	**type**\:   :py:class:`TrapHosts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts>`
    
    .. attribute:: trap_port
    
    	Change the source port of all traps
    	**type**\:  int
    
    	**range:** 1024..65535
    
    .. attribute:: trap_source
    
    	Assign an interface for the source address of all traps
    	**type**\:  str
    
    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
    
    .. attribute:: trap_source_ipv4
    
    	Assign an interface for the source address of all traps
    	**type**\:  str
    
    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
    
    .. attribute:: trap_source_ipv6
    
    	Assign an interface for the source IPV6 address of all traps
    	**type**\:  str
    
    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
    
    .. attribute:: users
    
    	Define a user who can access the SNMP engine
    	**type**\:   :py:class:`Users <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Users>`
    
    .. attribute:: views
    
    	Class to configure a SNMPv2 MIB view
    	**type**\:   :py:class:`Views <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Views>`
    
    .. attribute:: vrf_authentication_trap_disable
    
    	Disable authentication traps for packets on a vrf
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: vrfs
    
    	SNMP VRF configuration commands
    	**type**\:   :py:class:`Vrfs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs>`
    
    

    """

    _prefix = 'snmp-agent-cfg'
    _revision = '2015-10-27'

    def __init__(self):
        super(Snmp, self).__init__()
        self._top_entity = None

        self.yang_name = "snmp"
        self.yang_parent_name = "Cisco-IOS-XR-snmp-agent-cfg"

        self.inform_pending = YLeaf(YType.uint32, "inform-pending")

        self.inform_retries = YLeaf(YType.uint32, "inform-retries")

        self.inform_timeout = YLeaf(YType.uint32, "inform-timeout")

        self.oid_poll_stats = YLeaf(YType.empty, "oid-poll-stats")

        self.packet_size = YLeaf(YType.uint32, "packet-size")

        self.throttle_time = YLeaf(YType.uint32, "throttle-time")

        self.trap_port = YLeaf(YType.uint32, "trap-port")

        self.trap_source = YLeaf(YType.str, "trap-source")

        self.trap_source_ipv4 = YLeaf(YType.str, "trap-source-ipv4")

        self.trap_source_ipv6 = YLeaf(YType.str, "trap-source-ipv6")

        self.vrf_authentication_trap_disable = YLeaf(YType.empty, "vrf-authentication-trap-disable")

        self.administration = Snmp.Administration()
        self.administration.parent = self
        self._children_name_map["administration"] = "administration"
        self._children_yang_names.add("administration")

        self.agent = Snmp.Agent()
        self.agent.parent = self
        self._children_name_map["agent"] = "agent"
        self._children_yang_names.add("agent")

        self.bulk_stats = Snmp.BulkStats()
        self.bulk_stats.parent = self
        self._children_name_map["bulk_stats"] = "bulk-stats"
        self._children_yang_names.add("bulk-stats")

        self.context_mappings = Snmp.ContextMappings()
        self.context_mappings.parent = self
        self._children_name_map["context_mappings"] = "context-mappings"
        self._children_yang_names.add("context-mappings")

        self.contexts = Snmp.Contexts()
        self.contexts.parent = self
        self._children_name_map["contexts"] = "contexts"
        self._children_yang_names.add("contexts")

        self.correlator = Snmp.Correlator()
        self.correlator.parent = self
        self._children_name_map["correlator"] = "correlator"
        self._children_yang_names.add("correlator")

        self.default_community_maps = Snmp.DefaultCommunityMaps()
        self.default_community_maps.parent = self
        self._children_name_map["default_community_maps"] = "default-community-maps"
        self._children_yang_names.add("default-community-maps")

        self.encrypted_community_maps = Snmp.EncryptedCommunityMaps()
        self.encrypted_community_maps.parent = self
        self._children_name_map["encrypted_community_maps"] = "encrypted-community-maps"
        self._children_yang_names.add("encrypted-community-maps")

        self.groups = Snmp.Groups()
        self.groups.parent = self
        self._children_name_map["groups"] = "groups"
        self._children_yang_names.add("groups")

        self.ipv4 = Snmp.Ipv4()
        self.ipv4.parent = self
        self._children_name_map["ipv4"] = "ipv4"
        self._children_yang_names.add("ipv4")

        self.ipv6 = Snmp.Ipv6()
        self.ipv6.parent = self
        self._children_name_map["ipv6"] = "ipv6"
        self._children_yang_names.add("ipv6")

        self.logging = Snmp.Logging()
        self.logging.parent = self
        self._children_name_map["logging"] = "logging"
        self._children_yang_names.add("logging")

        self.notification = Snmp.Notification()
        self.notification.parent = self
        self._children_name_map["notification"] = "notification"
        self._children_yang_names.add("notification")

        self.overload_control = None
        self._children_name_map["overload_control"] = "overload-control"
        self._children_yang_names.add("overload-control")

        self.system = Snmp.System()
        self.system.parent = self
        self._children_name_map["system"] = "system"
        self._children_yang_names.add("system")

        self.target = Snmp.Target()
        self.target.parent = self
        self._children_name_map["target"] = "target"
        self._children_yang_names.add("target")

        self.timeouts = Snmp.Timeouts()
        self.timeouts.parent = self
        self._children_name_map["timeouts"] = "timeouts"
        self._children_yang_names.add("timeouts")

        self.trap = Snmp.Trap()
        self.trap.parent = self
        self._children_name_map["trap"] = "trap"
        self._children_yang_names.add("trap")

        self.trap_hosts = Snmp.TrapHosts()
        self.trap_hosts.parent = self
        self._children_name_map["trap_hosts"] = "trap-hosts"
        self._children_yang_names.add("trap-hosts")

        self.users = Snmp.Users()
        self.users.parent = self
        self._children_name_map["users"] = "users"
        self._children_yang_names.add("users")

        self.views = Snmp.Views()
        self.views.parent = self
        self._children_name_map["views"] = "views"
        self._children_yang_names.add("views")

        self.vrfs = Snmp.Vrfs()
        self.vrfs.parent = self
        self._children_name_map["vrfs"] = "vrfs"
        self._children_yang_names.add("vrfs")

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in ("inform_pending",
                        "inform_retries",
                        "inform_timeout",
                        "oid_poll_stats",
                        "packet_size",
                        "throttle_time",
                        "trap_port",
                        "trap_source",
                        "trap_source_ipv4",
                        "trap_source_ipv6",
                        "vrf_authentication_trap_disable") and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(Snmp, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(Snmp, self).__setattr__(name, value)


    class EncryptedCommunityMaps(Entity):
        """
        Container class to hold clear/encrypted
        communitie maps
        
        .. attribute:: encrypted_community_map
        
        	Clear/encrypted SNMP community map
        	**type**\: list of    :py:class:`EncryptedCommunityMap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.EncryptedCommunityMaps.EncryptedCommunityMap>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.EncryptedCommunityMaps, self).__init__()

            self.yang_name = "encrypted-community-maps"
            self.yang_parent_name = "snmp"

            self.encrypted_community_map = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.EncryptedCommunityMaps, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.EncryptedCommunityMaps, self).__setattr__(name, value)


        class EncryptedCommunityMap(Entity):
            """
            Clear/encrypted SNMP community map
            
            .. attribute:: community_name  <key>
            
            	SNMP community map
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: context
            
            	SNMP Context Name 
            	**type**\:  str
            
            .. attribute:: security
            
            	SNMP Security Name 
            	**type**\:  str
            
            .. attribute:: target_list
            
            	target list name 
            	**type**\:  str
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.EncryptedCommunityMaps.EncryptedCommunityMap, self).__init__()

                self.yang_name = "encrypted-community-map"
                self.yang_parent_name = "encrypted-community-maps"

                self.community_name = YLeaf(YType.str, "community-name")

                self.context = YLeaf(YType.str, "context")

                self.security = YLeaf(YType.str, "security")

                self.target_list = YLeaf(YType.str, "target-list")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("community_name",
                                "context",
                                "security",
                                "target_list") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.EncryptedCommunityMaps.EncryptedCommunityMap, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.EncryptedCommunityMaps.EncryptedCommunityMap, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.community_name.is_set or
                    self.context.is_set or
                    self.security.is_set or
                    self.target_list.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.community_name.yfilter != YFilter.not_set or
                    self.context.yfilter != YFilter.not_set or
                    self.security.yfilter != YFilter.not_set or
                    self.target_list.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "encrypted-community-map" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/encrypted-community-maps/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.community_name.get_name_leafdata())
                if (self.context.is_set or self.context.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.context.get_name_leafdata())
                if (self.security.is_set or self.security.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.security.get_name_leafdata())
                if (self.target_list.is_set or self.target_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.target_list.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "community-name" or name == "context" or name == "security" or name == "target-list"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "community-name"):
                    self.community_name = value
                    self.community_name.value_namespace = name_space
                    self.community_name.value_namespace_prefix = name_space_prefix
                if(value_path == "context"):
                    self.context = value
                    self.context.value_namespace = name_space
                    self.context.value_namespace_prefix = name_space_prefix
                if(value_path == "security"):
                    self.security = value
                    self.security.value_namespace = name_space
                    self.security.value_namespace_prefix = name_space_prefix
                if(value_path == "target-list"):
                    self.target_list = value
                    self.target_list.value_namespace = name_space
                    self.target_list.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.encrypted_community_map:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.encrypted_community_map:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "encrypted-community-maps" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "encrypted-community-map"):
                for c in self.encrypted_community_map:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.EncryptedCommunityMaps.EncryptedCommunityMap()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.encrypted_community_map.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "encrypted-community-map"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Views(Entity):
        """
        Class to configure a SNMPv2 MIB view
        
        .. attribute:: view
        
        	Name of the view
        	**type**\: list of    :py:class:`View <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Views.View>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Views, self).__init__()

            self.yang_name = "views"
            self.yang_parent_name = "snmp"

            self.view = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Views, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Views, self).__setattr__(name, value)


        class View(Entity):
            """
            Name of the view
            
            .. attribute:: view_name  <key>
            
            	Name of the view
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: family  <key>
            
            	MIB view family name
            	**type**\:  str
            
            .. attribute:: view_inclusion
            
            	MIB view to be included or excluded
            	**type**\:   :py:class:`SnmpMibViewInclusion <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpMibViewInclusion>`
            
            	**mandatory**\: True
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Views.View, self).__init__()

                self.yang_name = "view"
                self.yang_parent_name = "views"

                self.view_name = YLeaf(YType.str, "view-name")

                self.family = YLeaf(YType.str, "family")

                self.view_inclusion = YLeaf(YType.enumeration, "view-inclusion")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("view_name",
                                "family",
                                "view_inclusion") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Views.View, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Views.View, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.view_name.is_set or
                    self.family.is_set or
                    self.view_inclusion.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.view_name.yfilter != YFilter.not_set or
                    self.family.yfilter != YFilter.not_set or
                    self.view_inclusion.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "view" + "[view-name='" + self.view_name.get() + "']" + "[family='" + self.family.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/views/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.view_name.is_set or self.view_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.view_name.get_name_leafdata())
                if (self.family.is_set or self.family.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.family.get_name_leafdata())
                if (self.view_inclusion.is_set or self.view_inclusion.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.view_inclusion.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "view-name" or name == "family" or name == "view-inclusion"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "view-name"):
                    self.view_name = value
                    self.view_name.value_namespace = name_space
                    self.view_name.value_namespace_prefix = name_space_prefix
                if(value_path == "family"):
                    self.family = value
                    self.family.value_namespace = name_space
                    self.family.value_namespace_prefix = name_space_prefix
                if(value_path == "view-inclusion"):
                    self.view_inclusion = value
                    self.view_inclusion.value_namespace = name_space
                    self.view_inclusion.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.view:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.view:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "views" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "view"):
                for c in self.view:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.Views.View()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.view.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "view"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Logging(Entity):
        """
        SNMP logging
        
        .. attribute:: threshold
        
        	SNMP logging threshold
        	**type**\:   :py:class:`Threshold <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Logging.Threshold>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Logging, self).__init__()

            self.yang_name = "logging"
            self.yang_parent_name = "snmp"

            self.threshold = Snmp.Logging.Threshold()
            self.threshold.parent = self
            self._children_name_map["threshold"] = "threshold"
            self._children_yang_names.add("threshold")


        class Threshold(Entity):
            """
            SNMP logging threshold
            
            .. attribute:: oid_processing
            
            	SNMP logging threshold for OID processing
            	**type**\:  int
            
            	**range:** 0..20000
            
            	**default value**\: 500
            
            .. attribute:: pdu_processing
            
            	SNMP logging threshold for PDU processing
            	**type**\:  int
            
            	**range:** 0..20000
            
            	**default value**\: 20000
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Logging.Threshold, self).__init__()

                self.yang_name = "threshold"
                self.yang_parent_name = "logging"

                self.oid_processing = YLeaf(YType.uint32, "oid-processing")

                self.pdu_processing = YLeaf(YType.uint32, "pdu-processing")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("oid_processing",
                                "pdu_processing") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Logging.Threshold, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Logging.Threshold, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.oid_processing.is_set or
                    self.pdu_processing.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.oid_processing.yfilter != YFilter.not_set or
                    self.pdu_processing.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "threshold" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/logging/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.oid_processing.is_set or self.oid_processing.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.oid_processing.get_name_leafdata())
                if (self.pdu_processing.is_set or self.pdu_processing.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pdu_processing.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "oid-processing" or name == "pdu-processing"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "oid-processing"):
                    self.oid_processing = value
                    self.oid_processing.value_namespace = name_space
                    self.oid_processing.value_namespace_prefix = name_space_prefix
                if(value_path == "pdu-processing"):
                    self.pdu_processing = value
                    self.pdu_processing.value_namespace = name_space
                    self.pdu_processing.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.threshold is not None and self.threshold.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.threshold is not None and self.threshold.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "logging" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "threshold"):
                if (self.threshold is None):
                    self.threshold = Snmp.Logging.Threshold()
                    self.threshold.parent = self
                    self._children_name_map["threshold"] = "threshold"
                return self.threshold

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "threshold"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Administration(Entity):
        """
        Container class for SNMP administration
        
        .. attribute:: default_communities
        
        	Container class to hold unencrpted communities
        	**type**\:   :py:class:`DefaultCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Administration.DefaultCommunities>`
        
        .. attribute:: encrypted_communities
        
        	Container class to hold clear/encrypted communities
        	**type**\:   :py:class:`EncryptedCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Administration.EncryptedCommunities>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Administration, self).__init__()

            self.yang_name = "administration"
            self.yang_parent_name = "snmp"

            self.default_communities = Snmp.Administration.DefaultCommunities()
            self.default_communities.parent = self
            self._children_name_map["default_communities"] = "default-communities"
            self._children_yang_names.add("default-communities")

            self.encrypted_communities = Snmp.Administration.EncryptedCommunities()
            self.encrypted_communities.parent = self
            self._children_name_map["encrypted_communities"] = "encrypted-communities"
            self._children_yang_names.add("encrypted-communities")


        class DefaultCommunities(Entity):
            """
            Container class to hold unencrpted communities
            
            .. attribute:: default_community
            
            	Unencrpted SNMP community string and access priviledges
            	**type**\: list of    :py:class:`DefaultCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Administration.DefaultCommunities.DefaultCommunity>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Administration.DefaultCommunities, self).__init__()

                self.yang_name = "default-communities"
                self.yang_parent_name = "administration"

                self.default_community = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Administration.DefaultCommunities, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Administration.DefaultCommunities, self).__setattr__(name, value)


            class DefaultCommunity(Entity):
                """
                Unencrpted SNMP community string and access
                priviledges
                
                .. attribute:: community_name  <key>
                
                	SNMP community string
                	**type**\:  str
                
                	**length:** 1..128
                
                .. attribute:: owner
                
                	Logical Router or System owner access
                	**type**\:   :py:class:`SnmpOwnerAccess <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpOwnerAccess>`
                
                .. attribute:: priviledge
                
                	Read/Write Access
                	**type**\:   :py:class:`SnmpAccessLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpAccessLevel>`
                
                .. attribute:: v4_access_list
                
                	Ipv4 Access\-list name
                	**type**\:  str
                
                .. attribute:: v4acl_type
                
                	Access\-list type
                	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
                
                .. attribute:: v6_access_list
                
                	Ipv6 Access\-list name
                	**type**\:  str
                
                .. attribute:: v6acl_type
                
                	Access\-list type
                	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
                
                .. attribute:: view_name
                
                	MIB view to which the community has access
                	**type**\:  str
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Administration.DefaultCommunities.DefaultCommunity, self).__init__()

                    self.yang_name = "default-community"
                    self.yang_parent_name = "default-communities"

                    self.community_name = YLeaf(YType.str, "community-name")

                    self.owner = YLeaf(YType.enumeration, "owner")

                    self.priviledge = YLeaf(YType.enumeration, "priviledge")

                    self.v4_access_list = YLeaf(YType.str, "v4-access-list")

                    self.v4acl_type = YLeaf(YType.enumeration, "v4acl-type")

                    self.v6_access_list = YLeaf(YType.str, "v6-access-list")

                    self.v6acl_type = YLeaf(YType.enumeration, "v6acl-type")

                    self.view_name = YLeaf(YType.str, "view-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("community_name",
                                    "owner",
                                    "priviledge",
                                    "v4_access_list",
                                    "v4acl_type",
                                    "v6_access_list",
                                    "v6acl_type",
                                    "view_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Administration.DefaultCommunities.DefaultCommunity, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Administration.DefaultCommunities.DefaultCommunity, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.community_name.is_set or
                        self.owner.is_set or
                        self.priviledge.is_set or
                        self.v4_access_list.is_set or
                        self.v4acl_type.is_set or
                        self.v6_access_list.is_set or
                        self.v6acl_type.is_set or
                        self.view_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.community_name.yfilter != YFilter.not_set or
                        self.owner.yfilter != YFilter.not_set or
                        self.priviledge.yfilter != YFilter.not_set or
                        self.v4_access_list.yfilter != YFilter.not_set or
                        self.v4acl_type.yfilter != YFilter.not_set or
                        self.v6_access_list.yfilter != YFilter.not_set or
                        self.v6acl_type.yfilter != YFilter.not_set or
                        self.view_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "default-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/administration/default-communities/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.community_name.get_name_leafdata())
                    if (self.owner.is_set or self.owner.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.owner.get_name_leafdata())
                    if (self.priviledge.is_set or self.priviledge.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.priviledge.get_name_leafdata())
                    if (self.v4_access_list.is_set or self.v4_access_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v4_access_list.get_name_leafdata())
                    if (self.v4acl_type.is_set or self.v4acl_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v4acl_type.get_name_leafdata())
                    if (self.v6_access_list.is_set or self.v6_access_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v6_access_list.get_name_leafdata())
                    if (self.v6acl_type.is_set or self.v6acl_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v6acl_type.get_name_leafdata())
                    if (self.view_name.is_set or self.view_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.view_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "community-name" or name == "owner" or name == "priviledge" or name == "v4-access-list" or name == "v4acl-type" or name == "v6-access-list" or name == "v6acl-type" or name == "view-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "community-name"):
                        self.community_name = value
                        self.community_name.value_namespace = name_space
                        self.community_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "owner"):
                        self.owner = value
                        self.owner.value_namespace = name_space
                        self.owner.value_namespace_prefix = name_space_prefix
                    if(value_path == "priviledge"):
                        self.priviledge = value
                        self.priviledge.value_namespace = name_space
                        self.priviledge.value_namespace_prefix = name_space_prefix
                    if(value_path == "v4-access-list"):
                        self.v4_access_list = value
                        self.v4_access_list.value_namespace = name_space
                        self.v4_access_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "v4acl-type"):
                        self.v4acl_type = value
                        self.v4acl_type.value_namespace = name_space
                        self.v4acl_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "v6-access-list"):
                        self.v6_access_list = value
                        self.v6_access_list.value_namespace = name_space
                        self.v6_access_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "v6acl-type"):
                        self.v6acl_type = value
                        self.v6acl_type.value_namespace = name_space
                        self.v6acl_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "view-name"):
                        self.view_name = value
                        self.view_name.value_namespace = name_space
                        self.view_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.default_community:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.default_community:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "default-communities" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/administration/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "default-community"):
                    for c in self.default_community:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.Administration.DefaultCommunities.DefaultCommunity()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.default_community.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "default-community"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EncryptedCommunities(Entity):
            """
            Container class to hold clear/encrypted
            communities
            
            .. attribute:: encrypted_community
            
            	Clear/encrypted SNMP community string and access priviledges
            	**type**\: list of    :py:class:`EncryptedCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Administration.EncryptedCommunities.EncryptedCommunity>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Administration.EncryptedCommunities, self).__init__()

                self.yang_name = "encrypted-communities"
                self.yang_parent_name = "administration"

                self.encrypted_community = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Administration.EncryptedCommunities, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Administration.EncryptedCommunities, self).__setattr__(name, value)


            class EncryptedCommunity(Entity):
                """
                Clear/encrypted SNMP community string and
                access priviledges
                
                .. attribute:: community_name  <key>
                
                	SNMP community string
                	**type**\:  str
                
                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                
                .. attribute:: owner
                
                	Logical Router or System owner access
                	**type**\:   :py:class:`SnmpOwnerAccess <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpOwnerAccess>`
                
                .. attribute:: priviledge
                
                	Read/Write Access
                	**type**\:   :py:class:`SnmpAccessLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpAccessLevel>`
                
                .. attribute:: v4_access_list
                
                	Ipv4 Access\-list name
                	**type**\:  str
                
                .. attribute:: v4acl_type
                
                	Access\-list type
                	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
                
                .. attribute:: v6_access_list
                
                	Ipv6 Access\-list name
                	**type**\:  str
                
                .. attribute:: v6acl_type
                
                	Access\-list type
                	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
                
                .. attribute:: view_name
                
                	MIB view to which the community has access
                	**type**\:  str
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Administration.EncryptedCommunities.EncryptedCommunity, self).__init__()

                    self.yang_name = "encrypted-community"
                    self.yang_parent_name = "encrypted-communities"

                    self.community_name = YLeaf(YType.str, "community-name")

                    self.owner = YLeaf(YType.enumeration, "owner")

                    self.priviledge = YLeaf(YType.enumeration, "priviledge")

                    self.v4_access_list = YLeaf(YType.str, "v4-access-list")

                    self.v4acl_type = YLeaf(YType.enumeration, "v4acl-type")

                    self.v6_access_list = YLeaf(YType.str, "v6-access-list")

                    self.v6acl_type = YLeaf(YType.enumeration, "v6acl-type")

                    self.view_name = YLeaf(YType.str, "view-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("community_name",
                                    "owner",
                                    "priviledge",
                                    "v4_access_list",
                                    "v4acl_type",
                                    "v6_access_list",
                                    "v6acl_type",
                                    "view_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Administration.EncryptedCommunities.EncryptedCommunity, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Administration.EncryptedCommunities.EncryptedCommunity, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.community_name.is_set or
                        self.owner.is_set or
                        self.priviledge.is_set or
                        self.v4_access_list.is_set or
                        self.v4acl_type.is_set or
                        self.v6_access_list.is_set or
                        self.v6acl_type.is_set or
                        self.view_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.community_name.yfilter != YFilter.not_set or
                        self.owner.yfilter != YFilter.not_set or
                        self.priviledge.yfilter != YFilter.not_set or
                        self.v4_access_list.yfilter != YFilter.not_set or
                        self.v4acl_type.yfilter != YFilter.not_set or
                        self.v6_access_list.yfilter != YFilter.not_set or
                        self.v6acl_type.yfilter != YFilter.not_set or
                        self.view_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "encrypted-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/administration/encrypted-communities/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.community_name.get_name_leafdata())
                    if (self.owner.is_set or self.owner.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.owner.get_name_leafdata())
                    if (self.priviledge.is_set or self.priviledge.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.priviledge.get_name_leafdata())
                    if (self.v4_access_list.is_set or self.v4_access_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v4_access_list.get_name_leafdata())
                    if (self.v4acl_type.is_set or self.v4acl_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v4acl_type.get_name_leafdata())
                    if (self.v6_access_list.is_set or self.v6_access_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v6_access_list.get_name_leafdata())
                    if (self.v6acl_type.is_set or self.v6acl_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.v6acl_type.get_name_leafdata())
                    if (self.view_name.is_set or self.view_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.view_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "community-name" or name == "owner" or name == "priviledge" or name == "v4-access-list" or name == "v4acl-type" or name == "v6-access-list" or name == "v6acl-type" or name == "view-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "community-name"):
                        self.community_name = value
                        self.community_name.value_namespace = name_space
                        self.community_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "owner"):
                        self.owner = value
                        self.owner.value_namespace = name_space
                        self.owner.value_namespace_prefix = name_space_prefix
                    if(value_path == "priviledge"):
                        self.priviledge = value
                        self.priviledge.value_namespace = name_space
                        self.priviledge.value_namespace_prefix = name_space_prefix
                    if(value_path == "v4-access-list"):
                        self.v4_access_list = value
                        self.v4_access_list.value_namespace = name_space
                        self.v4_access_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "v4acl-type"):
                        self.v4acl_type = value
                        self.v4acl_type.value_namespace = name_space
                        self.v4acl_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "v6-access-list"):
                        self.v6_access_list = value
                        self.v6_access_list.value_namespace = name_space
                        self.v6_access_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "v6acl-type"):
                        self.v6acl_type = value
                        self.v6acl_type.value_namespace = name_space
                        self.v6acl_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "view-name"):
                        self.view_name = value
                        self.view_name.value_namespace = name_space
                        self.view_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.encrypted_community:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.encrypted_community:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "encrypted-communities" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/administration/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "encrypted-community"):
                    for c in self.encrypted_community:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.Administration.EncryptedCommunities.EncryptedCommunity()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.encrypted_community.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "encrypted-community"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.default_communities is not None and self.default_communities.has_data()) or
                (self.encrypted_communities is not None and self.encrypted_communities.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.default_communities is not None and self.default_communities.has_operation()) or
                (self.encrypted_communities is not None and self.encrypted_communities.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "administration" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "default-communities"):
                if (self.default_communities is None):
                    self.default_communities = Snmp.Administration.DefaultCommunities()
                    self.default_communities.parent = self
                    self._children_name_map["default_communities"] = "default-communities"
                return self.default_communities

            if (child_yang_name == "encrypted-communities"):
                if (self.encrypted_communities is None):
                    self.encrypted_communities = Snmp.Administration.EncryptedCommunities()
                    self.encrypted_communities.parent = self
                    self._children_name_map["encrypted_communities"] = "encrypted-communities"
                return self.encrypted_communities

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "default-communities" or name == "encrypted-communities"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Agent(Entity):
        """
        The heirarchy point for SNMP Agent
        configurations
        
        .. attribute:: engine_id
        
        	SNMPv3 engineID
        	**type**\:   :py:class:`EngineId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Agent.EngineId>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Agent, self).__init__()

            self.yang_name = "agent"
            self.yang_parent_name = "snmp"

            self.engine_id = Snmp.Agent.EngineId()
            self.engine_id.parent = self
            self._children_name_map["engine_id"] = "engine-id"
            self._children_yang_names.add("engine-id")


        class EngineId(Entity):
            """
            SNMPv3 engineID
            
            .. attribute:: local
            
            	engineID of the local agent
            	**type**\:  str
            
            .. attribute:: remotes
            
            	SNMPv3 remote SNMP Entity
            	**type**\:   :py:class:`Remotes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Agent.EngineId.Remotes>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Agent.EngineId, self).__init__()

                self.yang_name = "engine-id"
                self.yang_parent_name = "agent"

                self.local = YLeaf(YType.str, "local")

                self.remotes = Snmp.Agent.EngineId.Remotes()
                self.remotes.parent = self
                self._children_name_map["remotes"] = "remotes"
                self._children_yang_names.add("remotes")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("local") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Agent.EngineId, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Agent.EngineId, self).__setattr__(name, value)


            class Remotes(Entity):
                """
                SNMPv3 remote SNMP Entity
                
                .. attribute:: remote
                
                	engineID of the remote agent
                	**type**\: list of    :py:class:`Remote <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Agent.EngineId.Remotes.Remote>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Agent.EngineId.Remotes, self).__init__()

                    self.yang_name = "remotes"
                    self.yang_parent_name = "engine-id"

                    self.remote = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Agent.EngineId.Remotes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Agent.EngineId.Remotes, self).__setattr__(name, value)


                class Remote(Entity):
                    """
                    engineID of the remote agent
                    
                    .. attribute:: remote_address  <key>
                    
                    	IP address of remote SNMP entity
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: port
                    
                    	UDP port number
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    .. attribute:: remote_engine_id
                    
                    	engine ID octet string
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Agent.EngineId.Remotes.Remote, self).__init__()

                        self.yang_name = "remote"
                        self.yang_parent_name = "remotes"

                        self.remote_address = YLeaf(YType.str, "remote-address")

                        self.port = YLeaf(YType.uint16, "port")

                        self.remote_engine_id = YLeaf(YType.str, "remote-engine-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("remote_address",
                                        "port",
                                        "remote_engine_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Agent.EngineId.Remotes.Remote, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Agent.EngineId.Remotes.Remote, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.remote_address.is_set or
                            self.port.is_set or
                            self.remote_engine_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.remote_address.yfilter != YFilter.not_set or
                            self.port.yfilter != YFilter.not_set or
                            self.remote_engine_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote" + "[remote-address='" + self.remote_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/agent/engine-id/remotes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.remote_address.is_set or self.remote_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_address.get_name_leafdata())
                        if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.port.get_name_leafdata())
                        if (self.remote_engine_id.is_set or self.remote_engine_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_engine_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "remote-address" or name == "port" or name == "remote-engine-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "remote-address"):
                            self.remote_address = value
                            self.remote_address.value_namespace = name_space
                            self.remote_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "port"):
                            self.port = value
                            self.port.value_namespace = name_space
                            self.port.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-engine-id"):
                            self.remote_engine_id = value
                            self.remote_engine_id.value_namespace = name_space
                            self.remote_engine_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.remote:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.remote:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "remotes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/agent/engine-id/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "remote"):
                        for c in self.remote:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Snmp.Agent.EngineId.Remotes.Remote()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.remote.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "remote"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.local.is_set or
                    (self.remotes is not None and self.remotes.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.local.yfilter != YFilter.not_set or
                    (self.remotes is not None and self.remotes.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "engine-id" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/agent/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.local.is_set or self.local.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "remotes"):
                    if (self.remotes is None):
                        self.remotes = Snmp.Agent.EngineId.Remotes()
                        self.remotes.parent = self
                        self._children_name_map["remotes"] = "remotes"
                    return self.remotes

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "remotes" or name == "local"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "local"):
                    self.local = value
                    self.local.value_namespace = name_space
                    self.local.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.engine_id is not None and self.engine_id.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.engine_id is not None and self.engine_id.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "agent" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "engine-id"):
                if (self.engine_id is None):
                    self.engine_id = Snmp.Agent.EngineId()
                    self.engine_id.parent = self
                    self._children_name_map["engine_id"] = "engine-id"
                return self.engine_id

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "engine-id"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Trap(Entity):
        """
        Class to hold trap configurations
        
        .. attribute:: queue_length
        
        	Message queue length for each TRAP host
        	**type**\:  int
        
        	**range:** 1..5000
        
        .. attribute:: throttle_time
        
        	Set throttle time for handling traps
        	**type**\:  int
        
        	**range:** 10..500
        
        	**units**\: millisecond
        
        .. attribute:: timeout
        
        	Timeout for TRAP message retransmissions
        	**type**\:  int
        
        	**range:** 1..1000
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Trap, self).__init__()

            self.yang_name = "trap"
            self.yang_parent_name = "snmp"

            self.queue_length = YLeaf(YType.uint32, "queue-length")

            self.throttle_time = YLeaf(YType.uint32, "throttle-time")

            self.timeout = YLeaf(YType.uint32, "timeout")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("queue_length",
                            "throttle_time",
                            "timeout") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Trap, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Trap, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.queue_length.is_set or
                self.throttle_time.is_set or
                self.timeout.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.queue_length.yfilter != YFilter.not_set or
                self.throttle_time.yfilter != YFilter.not_set or
                self.timeout.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "trap" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.queue_length.is_set or self.queue_length.yfilter != YFilter.not_set):
                leaf_name_data.append(self.queue_length.get_name_leafdata())
            if (self.throttle_time.is_set or self.throttle_time.yfilter != YFilter.not_set):
                leaf_name_data.append(self.throttle_time.get_name_leafdata())
            if (self.timeout.is_set or self.timeout.yfilter != YFilter.not_set):
                leaf_name_data.append(self.timeout.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "queue-length" or name == "throttle-time" or name == "timeout"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "queue-length"):
                self.queue_length = value
                self.queue_length.value_namespace = name_space
                self.queue_length.value_namespace_prefix = name_space_prefix
            if(value_path == "throttle-time"):
                self.throttle_time = value
                self.throttle_time.value_namespace = name_space
                self.throttle_time.value_namespace_prefix = name_space_prefix
            if(value_path == "timeout"):
                self.timeout = value
                self.timeout.value_namespace = name_space
                self.timeout.value_namespace_prefix = name_space_prefix


    class Ipv6(Entity):
        """
        SNMP TOS bit for outgoing packets
        
        .. attribute:: tos
        
        	Type of TOS
        	**type**\:   :py:class:`Tos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Ipv6.Tos>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Ipv6, self).__init__()

            self.yang_name = "ipv6"
            self.yang_parent_name = "snmp"

            self.tos = Snmp.Ipv6.Tos()
            self.tos.parent = self
            self._children_name_map["tos"] = "tos"
            self._children_yang_names.add("tos")


        class Tos(Entity):
            """
            Type of TOS
            
            .. attribute:: dscp
            
            	SNMP DSCP value
            	**type**\: one of the below types:
            
            	**type**\:   :py:class:`SnmpDscpValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpDscpValue>`
            
            
            ----
            	**type**\:  int
            
            	**range:** 0..63
            
            
            ----
            .. attribute:: precedence
            
            	SNMP Precedence value
            	**type**\: one of the below types:
            
            	**type**\:   :py:class:`SnmpPrecedenceValue1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpPrecedenceValue1>`
            
            
            ----
            	**type**\:  int
            
            	**range:** 0..7
            
            
            ----
            .. attribute:: type
            
            	SNMP TOS type DSCP or Precedence
            	**type**\:   :py:class:`SnmpTos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpTos>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Ipv6.Tos, self).__init__()

                self.yang_name = "tos"
                self.yang_parent_name = "ipv6"

                self.dscp = YLeaf(YType.str, "dscp")

                self.precedence = YLeaf(YType.str, "precedence")

                self.type = YLeaf(YType.enumeration, "type")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("dscp",
                                "precedence",
                                "type") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Ipv6.Tos, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Ipv6.Tos, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.dscp.is_set or
                    self.precedence.is_set or
                    self.type.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.dscp.yfilter != YFilter.not_set or
                    self.precedence.yfilter != YFilter.not_set or
                    self.type.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tos" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/ipv6/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.dscp.is_set or self.dscp.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.dscp.get_name_leafdata())
                if (self.precedence.is_set or self.precedence.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.precedence.get_name_leafdata())
                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.type.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "dscp" or name == "precedence" or name == "type"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "dscp"):
                    self.dscp = value
                    self.dscp.value_namespace = name_space
                    self.dscp.value_namespace_prefix = name_space_prefix
                if(value_path == "precedence"):
                    self.precedence = value
                    self.precedence.value_namespace = name_space
                    self.precedence.value_namespace_prefix = name_space_prefix
                if(value_path == "type"):
                    self.type = value
                    self.type.value_namespace = name_space
                    self.type.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.tos is not None and self.tos.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.tos is not None and self.tos.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tos"):
                if (self.tos is None):
                    self.tos = Snmp.Ipv6.Tos()
                    self.tos.parent = self
                    self._children_name_map["tos"] = "tos"
                return self.tos

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tos"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4(Entity):
        """
        SNMP TOS bit for outgoing packets
        
        .. attribute:: tos
        
        	Type of TOS
        	**type**\:   :py:class:`Tos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Ipv4.Tos>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Ipv4, self).__init__()

            self.yang_name = "ipv4"
            self.yang_parent_name = "snmp"

            self.tos = Snmp.Ipv4.Tos()
            self.tos.parent = self
            self._children_name_map["tos"] = "tos"
            self._children_yang_names.add("tos")


        class Tos(Entity):
            """
            Type of TOS
            
            .. attribute:: dscp
            
            	SNMP DSCP value
            	**type**\: one of the below types:
            
            	**type**\:   :py:class:`SnmpDscpValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpDscpValue>`
            
            
            ----
            	**type**\:  int
            
            	**range:** 0..63
            
            
            ----
            .. attribute:: precedence
            
            	SNMP Precedence value
            	**type**\: one of the below types:
            
            	**type**\:   :py:class:`SnmpPrecedenceValue1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpPrecedenceValue1>`
            
            
            ----
            	**type**\:  int
            
            	**range:** 0..7
            
            
            ----
            .. attribute:: type
            
            	SNMP TOS type DSCP or Precedence
            	**type**\:   :py:class:`SnmpTos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpTos>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Ipv4.Tos, self).__init__()

                self.yang_name = "tos"
                self.yang_parent_name = "ipv4"

                self.dscp = YLeaf(YType.str, "dscp")

                self.precedence = YLeaf(YType.str, "precedence")

                self.type = YLeaf(YType.enumeration, "type")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("dscp",
                                "precedence",
                                "type") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Ipv4.Tos, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Ipv4.Tos, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.dscp.is_set or
                    self.precedence.is_set or
                    self.type.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.dscp.yfilter != YFilter.not_set or
                    self.precedence.yfilter != YFilter.not_set or
                    self.type.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tos" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/ipv4/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.dscp.is_set or self.dscp.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.dscp.get_name_leafdata())
                if (self.precedence.is_set or self.precedence.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.precedence.get_name_leafdata())
                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.type.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "dscp" or name == "precedence" or name == "type"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "dscp"):
                    self.dscp = value
                    self.dscp.value_namespace = name_space
                    self.dscp.value_namespace_prefix = name_space_prefix
                if(value_path == "precedence"):
                    self.precedence = value
                    self.precedence.value_namespace = name_space
                    self.precedence.value_namespace_prefix = name_space_prefix
                if(value_path == "type"):
                    self.type = value
                    self.type.value_namespace = name_space
                    self.type.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.tos is not None and self.tos.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.tos is not None and self.tos.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tos"):
                if (self.tos is None):
                    self.tos = Snmp.Ipv4.Tos()
                    self.tos.parent = self
                    self._children_name_map["tos"] = "tos"
                return self.tos

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tos"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class System(Entity):
        """
        container to hold system information
        
        .. attribute:: chassis_id
        
        	String to uniquely identify this chassis
        	**type**\:  str
        
        	**length:** 1..255
        
        .. attribute:: contact
        
        	identification of the contact person for this managed node
        	**type**\:  str
        
        	**length:** 1..255
        
        .. attribute:: location
        
        	The physical location of this node
        	**type**\:  str
        
        	**length:** 1..255
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.System, self).__init__()

            self.yang_name = "system"
            self.yang_parent_name = "snmp"

            self.chassis_id = YLeaf(YType.str, "chassis-id")

            self.contact = YLeaf(YType.str, "contact")

            self.location = YLeaf(YType.str, "location")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("chassis_id",
                            "contact",
                            "location") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.System, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.System, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.chassis_id.is_set or
                self.contact.is_set or
                self.location.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.chassis_id.yfilter != YFilter.not_set or
                self.contact.yfilter != YFilter.not_set or
                self.location.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "system" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.chassis_id.is_set or self.chassis_id.yfilter != YFilter.not_set):
                leaf_name_data.append(self.chassis_id.get_name_leafdata())
            if (self.contact.is_set or self.contact.yfilter != YFilter.not_set):
                leaf_name_data.append(self.contact.get_name_leafdata())
            if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                leaf_name_data.append(self.location.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "chassis-id" or name == "contact" or name == "location"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "chassis-id"):
                self.chassis_id = value
                self.chassis_id.value_namespace = name_space
                self.chassis_id.value_namespace_prefix = name_space_prefix
            if(value_path == "contact"):
                self.contact = value
                self.contact.value_namespace = name_space
                self.contact.value_namespace_prefix = name_space_prefix
            if(value_path == "location"):
                self.location = value
                self.location.value_namespace = name_space
                self.location.value_namespace_prefix = name_space_prefix


    class Target(Entity):
        """
        SNMP target configurations
        
        .. attribute:: targets
        
        	List of targets
        	**type**\:   :py:class:`Targets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Target.Targets>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Target, self).__init__()

            self.yang_name = "target"
            self.yang_parent_name = "snmp"

            self.targets = Snmp.Target.Targets()
            self.targets.parent = self
            self._children_name_map["targets"] = "targets"
            self._children_yang_names.add("targets")


        class Targets(Entity):
            """
            List of targets
            
            .. attribute:: target
            
            	Name of the target list
            	**type**\: list of    :py:class:`Target <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Target.Targets.Target>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Target.Targets, self).__init__()

                self.yang_name = "targets"
                self.yang_parent_name = "target"

                self.target = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Target.Targets, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Target.Targets, self).__setattr__(name, value)


            class Target(Entity):
                """
                Name of the target list
                
                .. attribute:: target_list_name  <key>
                
                	Name of the target list
                	**type**\:  str
                
                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                
                .. attribute:: target_addresses
                
                	SNMP Target address configurations
                	**type**\:   :py:class:`TargetAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Target.Targets.Target.TargetAddresses>`
                
                .. attribute:: vrf_names
                
                	List of VRF Name for a target list
                	**type**\:   :py:class:`VrfNames <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Target.Targets.Target.VrfNames>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Target.Targets.Target, self).__init__()

                    self.yang_name = "target"
                    self.yang_parent_name = "targets"

                    self.target_list_name = YLeaf(YType.str, "target-list-name")

                    self.target_addresses = Snmp.Target.Targets.Target.TargetAddresses()
                    self.target_addresses.parent = self
                    self._children_name_map["target_addresses"] = "target-addresses"
                    self._children_yang_names.add("target-addresses")

                    self.vrf_names = Snmp.Target.Targets.Target.VrfNames()
                    self.vrf_names.parent = self
                    self._children_name_map["vrf_names"] = "vrf-names"
                    self._children_yang_names.add("vrf-names")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("target_list_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Target.Targets.Target, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Target.Targets.Target, self).__setattr__(name, value)


                class VrfNames(Entity):
                    """
                    List of VRF Name for a target list
                    
                    .. attribute:: vrf_name
                    
                    	VRF name of the target
                    	**type**\: list of    :py:class:`VrfName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Target.Targets.Target.VrfNames.VrfName>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Target.Targets.Target.VrfNames, self).__init__()

                        self.yang_name = "vrf-names"
                        self.yang_parent_name = "target"

                        self.vrf_name = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Target.Targets.Target.VrfNames, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Target.Targets.Target.VrfNames, self).__setattr__(name, value)


                    class VrfName(Entity):
                        """
                        VRF name of the target
                        
                        .. attribute:: name  <key>
                        
                        	VRF Name
                        	**type**\:  str
                        
                        	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Target.Targets.Target.VrfNames.VrfName, self).__init__()

                            self.yang_name = "vrf-name"
                            self.yang_parent_name = "vrf-names"

                            self.name = YLeaf(YType.str, "name")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Target.Targets.Target.VrfNames.VrfName, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Target.Targets.Target.VrfNames.VrfName, self).__setattr__(name, value)

                        def has_data(self):
                            return self.name.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "vrf-name" + "[name='" + self.name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "name"):
                                self.name = value
                                self.name.value_namespace = name_space
                                self.name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.vrf_name:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.vrf_name:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "vrf-names" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "vrf-name"):
                            for c in self.vrf_name:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Snmp.Target.Targets.Target.VrfNames.VrfName()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.vrf_name.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class TargetAddresses(Entity):
                    """
                    SNMP Target address configurations
                    
                    .. attribute:: target_address
                    
                    	IP Address to be configured for the Target
                    	**type**\: list of    :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Target.Targets.Target.TargetAddresses.TargetAddress>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Target.Targets.Target.TargetAddresses, self).__init__()

                        self.yang_name = "target-addresses"
                        self.yang_parent_name = "target"

                        self.target_address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Target.Targets.Target.TargetAddresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Target.Targets.Target.TargetAddresses, self).__setattr__(name, value)


                    class TargetAddress(Entity):
                        """
                        IP Address to be configured for the Target
                        
                        .. attribute:: ip_address  <key>
                        
                        	IPv4/Ipv6 address
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Target.Targets.Target.TargetAddresses.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "target-addresses"

                            self.ip_address = YLeaf(YType.str, "ip-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ip_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Target.Targets.Target.TargetAddresses.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Target.Targets.Target.TargetAddresses.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return self.ip_address.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ip_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + "[ip-address='" + self.ip_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ip-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ip-address"):
                                self.ip_address = value
                                self.ip_address.value_namespace = name_space
                                self.ip_address.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.target_address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.target_address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "target-addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "target-address"):
                            for c in self.target_address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Snmp.Target.Targets.Target.TargetAddresses.TargetAddress()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.target_address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "target-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.target_list_name.is_set or
                        (self.target_addresses is not None and self.target_addresses.has_data()) or
                        (self.vrf_names is not None and self.vrf_names.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.target_list_name.yfilter != YFilter.not_set or
                        (self.target_addresses is not None and self.target_addresses.has_operation()) or
                        (self.vrf_names is not None and self.vrf_names.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "target" + "[target-list-name='" + self.target_list_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/target/targets/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.target_list_name.is_set or self.target_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.target_list_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "target-addresses"):
                        if (self.target_addresses is None):
                            self.target_addresses = Snmp.Target.Targets.Target.TargetAddresses()
                            self.target_addresses.parent = self
                            self._children_name_map["target_addresses"] = "target-addresses"
                        return self.target_addresses

                    if (child_yang_name == "vrf-names"):
                        if (self.vrf_names is None):
                            self.vrf_names = Snmp.Target.Targets.Target.VrfNames()
                            self.vrf_names.parent = self
                            self._children_name_map["vrf_names"] = "vrf-names"
                        return self.vrf_names

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "target-addresses" or name == "vrf-names" or name == "target-list-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "target-list-name"):
                        self.target_list_name = value
                        self.target_list_name.value_namespace = name_space
                        self.target_list_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.target:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.target:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "targets" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/target/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "target"):
                    for c in self.target:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.Target.Targets.Target()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.target.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "target"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.targets is not None and self.targets.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.targets is not None and self.targets.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "target" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "targets"):
                if (self.targets is None):
                    self.targets = Snmp.Target.Targets()
                    self.targets.parent = self
                    self._children_name_map["targets"] = "targets"
                return self.targets

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "targets"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Notification(Entity):
        """
        Enable SNMP notifications
        
        .. attribute:: bfd
        
        	CISCO\-IETF\-BFD\-MIB notification configuration
        	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Bfd>`
        
        .. attribute:: bgp
        
        	BGP4\-MIB and CISCO\-BGP4\-MIB notification configuration
        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Bgp>`
        
        .. attribute:: bridge
        
        	BRIDGE\-MIB notification configuration
        	**type**\:   :py:class:`Bridge <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Bridge>`
        
        .. attribute:: cfm
        
        	802.1ag Connectivity Fault Management MIB notification configuration
        	**type**\:   :py:class:`Cfm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Cfm>`
        
        .. attribute:: config_copy
        
        	CISCO\-CONFIG\-COPY\-MIB notification configuration
        	**type**\:   :py:class:`ConfigCopy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.ConfigCopy>`
        
        .. attribute:: config_man
        
        	CISCO\-CONFIG\-MAN\-MIB notification configurations
        	**type**\:   :py:class:`ConfigMan <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.ConfigMan>`
        
        .. attribute:: entity_
        
        	Enable ENTITY\-MIB notifications
        	**type**\:   :py:class:`Entity_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Entity_>`
        
        .. attribute:: entity_redundancy
        
        	CISCO\-ENTITY\-REDUNDANCY\-MIB notification configuration
        	**type**\:   :py:class:`EntityRedundancy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.EntityRedundancy>`
        
        .. attribute:: entity_state
        
        	ENTITY\-STATE\-MIB notification configuration
        	**type**\:   :py:class:`EntityState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.EntityState>`
        
        .. attribute:: flash
        
        	CISCO\-FLASH\-MIB notification configuration
        	**type**\:   :py:class:`Flash <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Flash>`
        
        .. attribute:: fru_control
        
        	CISCO\-ENTITY\-FRU\-CONTROL\-MIB notification configuration
        	**type**\:   :py:class:`FruControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.FruControl>`
        
        .. attribute:: hsrp
        
        	CISCO\-HSRP\-MIB notification configuration
        	**type**\:   :py:class:`Hsrp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Hsrp>`
        
        .. attribute:: isis
        
        	Enable ISIS\-MIB notifications
        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Isis>`
        
        .. attribute:: l2vpn
        
        	CISCO\-IETF\-PW\-MIB notification configuration
        	**type**\:   :py:class:`L2Vpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.L2Vpn>`
        
        .. attribute:: mpls_frr
        
        	CISCO\-IETF\-FRR\-MIB notification configuration
        	**type**\:   :py:class:`MplsFrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.MplsFrr>`
        
        .. attribute:: mpls_l3vpn
        
        	MPLS\-L3VPN\-STD\-MIB notification configuration
        	**type**\:   :py:class:`MplsL3Vpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.MplsL3Vpn>`
        
        .. attribute:: mpls_ldp
        
        	MPLS\-LDP\-STD\-MIB notification configuration
        	**type**\:   :py:class:`MplsLdp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.MplsLdp>`
        
        .. attribute:: mpls_te
        
        	MPLS\-TE\-STD\-MIB notification configuration
        	**type**\:   :py:class:`MplsTe <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.MplsTe>`
        
        .. attribute:: mpls_te_p2mp
        
        	CISCO\-MPLS\-TE\-P2MP\-STD\-MIB notification configuration
        	**type**\:   :py:class:`MplsTeP2Mp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.MplsTeP2Mp>`
        
        .. attribute:: ntp
        
        	CISCO\-NTP\-MIB notification configuration
        	**type**\:   :py:class:`Ntp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ntp>`
        
        .. attribute:: oam
        
        	802.3 OAM MIB notification configuration
        	**type**\:   :py:class:`Oam <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Oam>`
        
        .. attribute:: optical
        
        	CISCO\-OPTICAL\-MIB notification configuration
        	**type**\:   :py:class:`Optical <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Optical>`
        
        .. attribute:: ospf
        
        	OSPF\-MIB notification configuration
        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospf>`
        
        .. attribute:: ospfv3
        
        	OSPFv3\-MIB notification configuration
        	**type**\:   :py:class:`Ospfv3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospfv3>`
        
        .. attribute:: otn
        
        	CISCO\-OTN\-IF\-MIB notification configuration
        	**type**\:   :py:class:`Otn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Otn>`
        
        .. attribute:: rf
        
        	CISCO\-RF\-MIB notification configuration
        	**type**\:   :py:class:`Rf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Rf>`
        
        .. attribute:: rsvp
        
        	Enable RSVP\-MIB notifications
        	**type**\:   :py:class:`Rsvp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Rsvp>`
        
        .. attribute:: selective_vrf_download
        
        	CISCO\-SELECTIVE\-VRF\-DOWNLOAD\-MIB notification configuration
        	**type**\:   :py:class:`SelectiveVrfDownload <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.SelectiveVrfDownload>`
        
        .. attribute:: sensor
        
        	CISCO\-ENTITY\-SENSOR\-MIB notification configuration
        	**type**\:   :py:class:`Sensor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Sensor>`
        
        .. attribute:: snmp
        
        	SNMP notification configuration
        	**type**\:   :py:class:`Snmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Snmp>`
        
        .. attribute:: syslog
        
        	CISCO\-SYSLOG\-MIB notification configuration
        	**type**\:   :py:class:`Syslog <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Syslog>`
        
        .. attribute:: system
        
        	CISCO\-SYSTEM\-MIB notification configuration
        	**type**\:   :py:class:`System <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.System>`
        
        .. attribute:: vpls
        
        	CISCO\-IETF\-VPLS\-GENERIC\-MIB notification configuration
        	**type**\:   :py:class:`Vpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Vpls>`
        
        .. attribute:: vrrp
        
        	VRRP\-MIB notification configuration
        	**type**\:   :py:class:`Vrrp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Vrrp>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Notification, self).__init__()

            self.yang_name = "notification"
            self.yang_parent_name = "snmp"

            self.bfd = Snmp.Notification.Bfd()
            self.bfd.parent = self
            self._children_name_map["bfd"] = "bfd"
            self._children_yang_names.add("bfd")

            self.bgp = Snmp.Notification.Bgp()
            self.bgp.parent = self
            self._children_name_map["bgp"] = "bgp"
            self._children_yang_names.add("bgp")

            self.bridge = Snmp.Notification.Bridge()
            self.bridge.parent = self
            self._children_name_map["bridge"] = "bridge"
            self._children_yang_names.add("bridge")

            self.cfm = Snmp.Notification.Cfm()
            self.cfm.parent = self
            self._children_name_map["cfm"] = "cfm"
            self._children_yang_names.add("cfm")

            self.config_copy = Snmp.Notification.ConfigCopy()
            self.config_copy.parent = self
            self._children_name_map["config_copy"] = "config-copy"
            self._children_yang_names.add("config-copy")

            self.config_man = Snmp.Notification.ConfigMan()
            self.config_man.parent = self
            self._children_name_map["config_man"] = "config-man"
            self._children_yang_names.add("config-man")

            self.entity_ = Snmp.Notification.Entity_()
            self.entity_.parent = self
            self._children_name_map["entity_"] = "entity"
            self._children_yang_names.add("entity")

            self.entity_redundancy = Snmp.Notification.EntityRedundancy()
            self.entity_redundancy.parent = self
            self._children_name_map["entity_redundancy"] = "entity-redundancy"
            self._children_yang_names.add("entity-redundancy")

            self.entity_state = Snmp.Notification.EntityState()
            self.entity_state.parent = self
            self._children_name_map["entity_state"] = "entity-state"
            self._children_yang_names.add("entity-state")

            self.flash = Snmp.Notification.Flash()
            self.flash.parent = self
            self._children_name_map["flash"] = "flash"
            self._children_yang_names.add("flash")

            self.fru_control = Snmp.Notification.FruControl()
            self.fru_control.parent = self
            self._children_name_map["fru_control"] = "fru-control"
            self._children_yang_names.add("fru-control")

            self.hsrp = Snmp.Notification.Hsrp()
            self.hsrp.parent = self
            self._children_name_map["hsrp"] = "hsrp"
            self._children_yang_names.add("hsrp")

            self.isis = Snmp.Notification.Isis()
            self.isis.parent = self
            self._children_name_map["isis"] = "isis"
            self._children_yang_names.add("isis")

            self.l2vpn = Snmp.Notification.L2Vpn()
            self.l2vpn.parent = self
            self._children_name_map["l2vpn"] = "l2vpn"
            self._children_yang_names.add("l2vpn")

            self.mpls_frr = Snmp.Notification.MplsFrr()
            self.mpls_frr.parent = self
            self._children_name_map["mpls_frr"] = "mpls-frr"
            self._children_yang_names.add("mpls-frr")

            self.mpls_l3vpn = Snmp.Notification.MplsL3Vpn()
            self.mpls_l3vpn.parent = self
            self._children_name_map["mpls_l3vpn"] = "mpls-l3vpn"
            self._children_yang_names.add("mpls-l3vpn")

            self.mpls_ldp = Snmp.Notification.MplsLdp()
            self.mpls_ldp.parent = self
            self._children_name_map["mpls_ldp"] = "mpls-ldp"
            self._children_yang_names.add("mpls-ldp")

            self.mpls_te = Snmp.Notification.MplsTe()
            self.mpls_te.parent = self
            self._children_name_map["mpls_te"] = "mpls-te"
            self._children_yang_names.add("mpls-te")

            self.mpls_te_p2mp = Snmp.Notification.MplsTeP2Mp()
            self.mpls_te_p2mp.parent = self
            self._children_name_map["mpls_te_p2mp"] = "mpls-te-p2mp"
            self._children_yang_names.add("mpls-te-p2mp")

            self.ntp = Snmp.Notification.Ntp()
            self.ntp.parent = self
            self._children_name_map["ntp"] = "ntp"
            self._children_yang_names.add("ntp")

            self.oam = Snmp.Notification.Oam()
            self.oam.parent = self
            self._children_name_map["oam"] = "oam"
            self._children_yang_names.add("oam")

            self.optical = Snmp.Notification.Optical()
            self.optical.parent = self
            self._children_name_map["optical"] = "optical"
            self._children_yang_names.add("optical")

            self.ospf = Snmp.Notification.Ospf()
            self.ospf.parent = self
            self._children_name_map["ospf"] = "ospf"
            self._children_yang_names.add("ospf")

            self.ospfv3 = Snmp.Notification.Ospfv3()
            self.ospfv3.parent = self
            self._children_name_map["ospfv3"] = "ospfv3"
            self._children_yang_names.add("ospfv3")

            self.otn = Snmp.Notification.Otn()
            self.otn.parent = self
            self._children_name_map["otn"] = "otn"
            self._children_yang_names.add("otn")

            self.rf = Snmp.Notification.Rf()
            self.rf.parent = self
            self._children_name_map["rf"] = "rf"
            self._children_yang_names.add("rf")

            self.rsvp = Snmp.Notification.Rsvp()
            self.rsvp.parent = self
            self._children_name_map["rsvp"] = "rsvp"
            self._children_yang_names.add("rsvp")

            self.selective_vrf_download = Snmp.Notification.SelectiveVrfDownload()
            self.selective_vrf_download.parent = self
            self._children_name_map["selective_vrf_download"] = "selective-vrf-download"
            self._children_yang_names.add("selective-vrf-download")

            self.sensor = Snmp.Notification.Sensor()
            self.sensor.parent = self
            self._children_name_map["sensor"] = "sensor"
            self._children_yang_names.add("sensor")

            self.snmp = Snmp.Notification.Snmp()
            self.snmp.parent = self
            self._children_name_map["snmp"] = "snmp"
            self._children_yang_names.add("snmp")

            self.syslog = Snmp.Notification.Syslog()
            self.syslog.parent = self
            self._children_name_map["syslog"] = "syslog"
            self._children_yang_names.add("syslog")

            self.system = Snmp.Notification.System()
            self.system.parent = self
            self._children_name_map["system"] = "system"
            self._children_yang_names.add("system")

            self.vpls = Snmp.Notification.Vpls()
            self.vpls.parent = self
            self._children_name_map["vpls"] = "vpls"
            self._children_yang_names.add("vpls")

            self.vrrp = Snmp.Notification.Vrrp()
            self.vrrp.parent = self
            self._children_name_map["vrrp"] = "vrrp"
            self._children_yang_names.add("vrrp")


        class Snmp(Entity):
            """
            SNMP notification configuration
            
            .. attribute:: authentication
            
            	Enable authentication notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: cold_start
            
            	Enable cold start notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: enable
            
            	Enable SNMP notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: link_down
            
            	Enable link down notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: link_up
            
            	Enable link up notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: warm_start
            
            	Enable warm start notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Notification.Snmp, self).__init__()

                self.yang_name = "snmp"
                self.yang_parent_name = "notification"

                self.authentication = YLeaf(YType.empty, "authentication")

                self.cold_start = YLeaf(YType.empty, "cold-start")

                self.enable = YLeaf(YType.empty, "enable")

                self.link_down = YLeaf(YType.empty, "Cisco-IOS-XR-snmp-ifmib-cfg:link-down")

                self.link_up = YLeaf(YType.empty, "Cisco-IOS-XR-snmp-ifmib-cfg:link-up")

                self.warm_start = YLeaf(YType.empty, "warm-start")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("authentication",
                                "cold_start",
                                "enable",
                                "link_down",
                                "link_up",
                                "warm_start") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Snmp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Snmp, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.authentication.is_set or
                    self.cold_start.is_set or
                    self.enable.is_set or
                    self.link_down.is_set or
                    self.link_up.is_set or
                    self.warm_start.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.authentication.yfilter != YFilter.not_set or
                    self.cold_start.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.link_down.yfilter != YFilter.not_set or
                    self.link_up.yfilter != YFilter.not_set or
                    self.warm_start.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "snmp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.authentication.is_set or self.authentication.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.authentication.get_name_leafdata())
                if (self.cold_start.is_set or self.cold_start.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cold_start.get_name_leafdata())
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.link_down.is_set or self.link_down.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.link_down.get_name_leafdata())
                if (self.link_up.is_set or self.link_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.link_up.get_name_leafdata())
                if (self.warm_start.is_set or self.warm_start.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.warm_start.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "authentication" or name == "cold-start" or name == "enable" or name == "link-down" or name == "link-up" or name == "warm-start"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "authentication"):
                    self.authentication = value
                    self.authentication.value_namespace = name_space
                    self.authentication.value_namespace_prefix = name_space_prefix
                if(value_path == "cold-start"):
                    self.cold_start = value
                    self.cold_start.value_namespace = name_space
                    self.cold_start.value_namespace_prefix = name_space_prefix
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "link-down"):
                    self.link_down = value
                    self.link_down.value_namespace = name_space
                    self.link_down.value_namespace_prefix = name_space_prefix
                if(value_path == "link-up"):
                    self.link_up = value
                    self.link_up.value_namespace = name_space
                    self.link_up.value_namespace_prefix = name_space_prefix
                if(value_path == "warm-start"):
                    self.warm_start = value
                    self.warm_start.value_namespace = name_space
                    self.warm_start.value_namespace_prefix = name_space_prefix


        class Vpls(Entity):
            """
            CISCO\-IETF\-VPLS\-GENERIC\-MIB notification
            configuration
            
            .. attribute:: enable
            
            	Enable CISCO\-IETF\-VPLS\-GENERIC\-MIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: full_clear
            
            	Enable cvplsFwdFullAlarmCleared notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: full_raise
            
            	Enable cvplsFwdFullAlarmRaised notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: status
            
            	Enable cvplsStatusChanged notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Vpls, self).__init__()

                self.yang_name = "vpls"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

                self.full_clear = YLeaf(YType.empty, "full-clear")

                self.full_raise = YLeaf(YType.empty, "full-raise")

                self.status = YLeaf(YType.empty, "status")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "full_clear",
                                "full_raise",
                                "status") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Vpls, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Vpls, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.full_clear.is_set or
                    self.full_raise.is_set or
                    self.status.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.full_clear.yfilter != YFilter.not_set or
                    self.full_raise.yfilter != YFilter.not_set or
                    self.status.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:vpls" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.full_clear.is_set or self.full_clear.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.full_clear.get_name_leafdata())
                if (self.full_raise.is_set or self.full_raise.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.full_raise.get_name_leafdata())
                if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.status.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "full-clear" or name == "full-raise" or name == "status"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "full-clear"):
                    self.full_clear = value
                    self.full_clear.value_namespace = name_space
                    self.full_clear.value_namespace_prefix = name_space_prefix
                if(value_path == "full-raise"):
                    self.full_raise = value
                    self.full_raise.value_namespace = name_space
                    self.full_raise.value_namespace_prefix = name_space_prefix
                if(value_path == "status"):
                    self.status = value
                    self.status.value_namespace = name_space
                    self.status.value_namespace_prefix = name_space_prefix


        class L2Vpn(Entity):
            """
            CISCO\-IETF\-PW\-MIB notification configuration
            
            .. attribute:: cisco
            
            	Enable Cisco format including extra varbinds
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: enable
            
            	Enable CISCO\-IETF\-PW\-MIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: vc_down
            
            	Enable cpwVcDown notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: vc_up
            
            	Enable cpwVcUp notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.L2Vpn, self).__init__()

                self.yang_name = "l2vpn"
                self.yang_parent_name = "notification"

                self.cisco = YLeaf(YType.empty, "cisco")

                self.enable = YLeaf(YType.empty, "enable")

                self.vc_down = YLeaf(YType.empty, "vc-down")

                self.vc_up = YLeaf(YType.empty, "vc-up")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cisco",
                                "enable",
                                "vc_down",
                                "vc_up") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.L2Vpn, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.L2Vpn, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.cisco.is_set or
                    self.enable.is_set or
                    self.vc_down.is_set or
                    self.vc_up.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cisco.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.vc_down.yfilter != YFilter.not_set or
                    self.vc_up.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cisco.is_set or self.cisco.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cisco.get_name_leafdata())
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.vc_down.is_set or self.vc_down.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vc_down.get_name_leafdata())
                if (self.vc_up.is_set or self.vc_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vc_up.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "cisco" or name == "enable" or name == "vc-down" or name == "vc-up"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "cisco"):
                    self.cisco = value
                    self.cisco.value_namespace = name_space
                    self.cisco.value_namespace_prefix = name_space_prefix
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "vc-down"):
                    self.vc_down = value
                    self.vc_down.value_namespace = name_space
                    self.vc_down.value_namespace_prefix = name_space_prefix
                if(value_path == "vc-up"):
                    self.vc_up = value
                    self.vc_up.value_namespace = name_space
                    self.vc_up.value_namespace_prefix = name_space_prefix


        class Isis(Entity):
            """
            Enable ISIS\-MIB notifications
            
            .. attribute:: adjacency_change
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibAdjacencyChangeBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibAdjacencyChangeBoolean>`
            
            	**default value**\: false
            
            .. attribute:: all
            
            	Enable all isisMIB notifications
            	**type**\:   :py:class:`IsisMibAllBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibAllBoolean>`
            
            	**default value**\: false
            
            .. attribute:: area_mismatch
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibAreaMismatchBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibAreaMismatchBoolean>`
            
            	**default value**\: false
            
            .. attribute:: attempt_to_exceed_max_sequence
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibAttemptToExceedMaxSequenceBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibAttemptToExceedMaxSequenceBoolean>`
            
            	**default value**\: false
            
            .. attribute:: authentication_failure
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibAuthenticationFailureBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibAuthenticationFailureBoolean>`
            
            	**default value**\: false
            
            .. attribute:: authentication_type_failure
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibAuthenticationTypeFailureBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibAuthenticationTypeFailureBoolean>`
            
            	**default value**\: false
            
            .. attribute:: corrupted_lsp_detected
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibCorruptedLspDetectedBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibCorruptedLspDetectedBoolean>`
            
            	**default value**\: false
            
            .. attribute:: database_overflow
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibDatabaseOverFlowBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibDatabaseOverFlowBoolean>`
            
            	**default value**\: false
            
            .. attribute:: id_length_mismatch
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibIdLengthMismatchBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibIdLengthMismatchBoolean>`
            
            	**default value**\: false
            
            .. attribute:: lsp_error_detected
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibLspErrorDetectedBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibLspErrorDetectedBoolean>`
            
            	**default value**\: false
            
            .. attribute:: lsp_too_large_to_propagate
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibLspTooLargeToPropagateBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibLspTooLargeToPropagateBoolean>`
            
            	**default value**\: false
            
            .. attribute:: manual_address_drops
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibManualAddressDropsBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibManualAddressDropsBoolean>`
            
            	**default value**\: false
            
            .. attribute:: max_area_address_mismatch
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibMaxAreaAddressMismatchBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibMaxAreaAddressMismatchBoolean>`
            
            	**default value**\: false
            
            .. attribute:: originated_lsp_buffer_size_mismatch
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibOriginatedLspBufferSizeMismatchBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibOriginatedLspBufferSizeMismatchBoolean>`
            
            	**default value**\: false
            
            .. attribute:: own_lsp_purge
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibOwnLspPurgeBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibOwnLspPurgeBoolean>`
            
            	**default value**\: false
            
            .. attribute:: protocols_supported_mismatch
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibProtocolsSupportedMismatchBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibProtocolsSupportedMismatchBoolean>`
            
            	**default value**\: false
            
            .. attribute:: rejected_adjacency
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibRejectedAdjacencyBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibRejectedAdjacencyBoolean>`
            
            	**default value**\: false
            
            .. attribute:: sequence_number_skip
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibSequenceNumberSkipBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibSequenceNumberSkipBoolean>`
            
            	**default value**\: false
            
            .. attribute:: version_skew
            
            	Enable or disable
            	**type**\:   :py:class:`IsisMibVersionSkewBoolean <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMibVersionSkewBoolean>`
            
            	**default value**\: false
            
            

            """

            _prefix = 'clns-isis-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Isis, self).__init__()

                self.yang_name = "isis"
                self.yang_parent_name = "notification"

                self.adjacency_change = YLeaf(YType.enumeration, "adjacency-change")

                self.all = YLeaf(YType.enumeration, "all")

                self.area_mismatch = YLeaf(YType.enumeration, "area-mismatch")

                self.attempt_to_exceed_max_sequence = YLeaf(YType.enumeration, "attempt-to-exceed-max-sequence")

                self.authentication_failure = YLeaf(YType.enumeration, "authentication-failure")

                self.authentication_type_failure = YLeaf(YType.enumeration, "authentication-type-failure")

                self.corrupted_lsp_detected = YLeaf(YType.enumeration, "corrupted-lsp-detected")

                self.database_overflow = YLeaf(YType.enumeration, "database-overflow")

                self.id_length_mismatch = YLeaf(YType.enumeration, "id-length-mismatch")

                self.lsp_error_detected = YLeaf(YType.enumeration, "lsp-error-detected")

                self.lsp_too_large_to_propagate = YLeaf(YType.enumeration, "lsp-too-large-to-propagate")

                self.manual_address_drops = YLeaf(YType.enumeration, "manual-address-drops")

                self.max_area_address_mismatch = YLeaf(YType.enumeration, "max-area-address-mismatch")

                self.originated_lsp_buffer_size_mismatch = YLeaf(YType.enumeration, "originated-lsp-buffer-size-mismatch")

                self.own_lsp_purge = YLeaf(YType.enumeration, "own-lsp-purge")

                self.protocols_supported_mismatch = YLeaf(YType.enumeration, "protocols-supported-mismatch")

                self.rejected_adjacency = YLeaf(YType.enumeration, "rejected-adjacency")

                self.sequence_number_skip = YLeaf(YType.enumeration, "sequence-number-skip")

                self.version_skew = YLeaf(YType.enumeration, "version-skew")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("adjacency_change",
                                "all",
                                "area_mismatch",
                                "attempt_to_exceed_max_sequence",
                                "authentication_failure",
                                "authentication_type_failure",
                                "corrupted_lsp_detected",
                                "database_overflow",
                                "id_length_mismatch",
                                "lsp_error_detected",
                                "lsp_too_large_to_propagate",
                                "manual_address_drops",
                                "max_area_address_mismatch",
                                "originated_lsp_buffer_size_mismatch",
                                "own_lsp_purge",
                                "protocols_supported_mismatch",
                                "rejected_adjacency",
                                "sequence_number_skip",
                                "version_skew") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Isis, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Isis, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.adjacency_change.is_set or
                    self.all.is_set or
                    self.area_mismatch.is_set or
                    self.attempt_to_exceed_max_sequence.is_set or
                    self.authentication_failure.is_set or
                    self.authentication_type_failure.is_set or
                    self.corrupted_lsp_detected.is_set or
                    self.database_overflow.is_set or
                    self.id_length_mismatch.is_set or
                    self.lsp_error_detected.is_set or
                    self.lsp_too_large_to_propagate.is_set or
                    self.manual_address_drops.is_set or
                    self.max_area_address_mismatch.is_set or
                    self.originated_lsp_buffer_size_mismatch.is_set or
                    self.own_lsp_purge.is_set or
                    self.protocols_supported_mismatch.is_set or
                    self.rejected_adjacency.is_set or
                    self.sequence_number_skip.is_set or
                    self.version_skew.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.adjacency_change.yfilter != YFilter.not_set or
                    self.all.yfilter != YFilter.not_set or
                    self.area_mismatch.yfilter != YFilter.not_set or
                    self.attempt_to_exceed_max_sequence.yfilter != YFilter.not_set or
                    self.authentication_failure.yfilter != YFilter.not_set or
                    self.authentication_type_failure.yfilter != YFilter.not_set or
                    self.corrupted_lsp_detected.yfilter != YFilter.not_set or
                    self.database_overflow.yfilter != YFilter.not_set or
                    self.id_length_mismatch.yfilter != YFilter.not_set or
                    self.lsp_error_detected.yfilter != YFilter.not_set or
                    self.lsp_too_large_to_propagate.yfilter != YFilter.not_set or
                    self.manual_address_drops.yfilter != YFilter.not_set or
                    self.max_area_address_mismatch.yfilter != YFilter.not_set or
                    self.originated_lsp_buffer_size_mismatch.yfilter != YFilter.not_set or
                    self.own_lsp_purge.yfilter != YFilter.not_set or
                    self.protocols_supported_mismatch.yfilter != YFilter.not_set or
                    self.rejected_adjacency.yfilter != YFilter.not_set or
                    self.sequence_number_skip.yfilter != YFilter.not_set or
                    self.version_skew.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-clns-isis-cfg:isis" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.adjacency_change.is_set or self.adjacency_change.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.adjacency_change.get_name_leafdata())
                if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.all.get_name_leafdata())
                if (self.area_mismatch.is_set or self.area_mismatch.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.area_mismatch.get_name_leafdata())
                if (self.attempt_to_exceed_max_sequence.is_set or self.attempt_to_exceed_max_sequence.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.attempt_to_exceed_max_sequence.get_name_leafdata())
                if (self.authentication_failure.is_set or self.authentication_failure.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.authentication_failure.get_name_leafdata())
                if (self.authentication_type_failure.is_set or self.authentication_type_failure.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.authentication_type_failure.get_name_leafdata())
                if (self.corrupted_lsp_detected.is_set or self.corrupted_lsp_detected.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.corrupted_lsp_detected.get_name_leafdata())
                if (self.database_overflow.is_set or self.database_overflow.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.database_overflow.get_name_leafdata())
                if (self.id_length_mismatch.is_set or self.id_length_mismatch.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.id_length_mismatch.get_name_leafdata())
                if (self.lsp_error_detected.is_set or self.lsp_error_detected.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.lsp_error_detected.get_name_leafdata())
                if (self.lsp_too_large_to_propagate.is_set or self.lsp_too_large_to_propagate.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.lsp_too_large_to_propagate.get_name_leafdata())
                if (self.manual_address_drops.is_set or self.manual_address_drops.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.manual_address_drops.get_name_leafdata())
                if (self.max_area_address_mismatch.is_set or self.max_area_address_mismatch.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_area_address_mismatch.get_name_leafdata())
                if (self.originated_lsp_buffer_size_mismatch.is_set or self.originated_lsp_buffer_size_mismatch.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.originated_lsp_buffer_size_mismatch.get_name_leafdata())
                if (self.own_lsp_purge.is_set or self.own_lsp_purge.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.own_lsp_purge.get_name_leafdata())
                if (self.protocols_supported_mismatch.is_set or self.protocols_supported_mismatch.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocols_supported_mismatch.get_name_leafdata())
                if (self.rejected_adjacency.is_set or self.rejected_adjacency.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.rejected_adjacency.get_name_leafdata())
                if (self.sequence_number_skip.is_set or self.sequence_number_skip.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sequence_number_skip.get_name_leafdata())
                if (self.version_skew.is_set or self.version_skew.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.version_skew.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "adjacency-change" or name == "all" or name == "area-mismatch" or name == "attempt-to-exceed-max-sequence" or name == "authentication-failure" or name == "authentication-type-failure" or name == "corrupted-lsp-detected" or name == "database-overflow" or name == "id-length-mismatch" or name == "lsp-error-detected" or name == "lsp-too-large-to-propagate" or name == "manual-address-drops" or name == "max-area-address-mismatch" or name == "originated-lsp-buffer-size-mismatch" or name == "own-lsp-purge" or name == "protocols-supported-mismatch" or name == "rejected-adjacency" or name == "sequence-number-skip" or name == "version-skew"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "adjacency-change"):
                    self.adjacency_change = value
                    self.adjacency_change.value_namespace = name_space
                    self.adjacency_change.value_namespace_prefix = name_space_prefix
                if(value_path == "all"):
                    self.all = value
                    self.all.value_namespace = name_space
                    self.all.value_namespace_prefix = name_space_prefix
                if(value_path == "area-mismatch"):
                    self.area_mismatch = value
                    self.area_mismatch.value_namespace = name_space
                    self.area_mismatch.value_namespace_prefix = name_space_prefix
                if(value_path == "attempt-to-exceed-max-sequence"):
                    self.attempt_to_exceed_max_sequence = value
                    self.attempt_to_exceed_max_sequence.value_namespace = name_space
                    self.attempt_to_exceed_max_sequence.value_namespace_prefix = name_space_prefix
                if(value_path == "authentication-failure"):
                    self.authentication_failure = value
                    self.authentication_failure.value_namespace = name_space
                    self.authentication_failure.value_namespace_prefix = name_space_prefix
                if(value_path == "authentication-type-failure"):
                    self.authentication_type_failure = value
                    self.authentication_type_failure.value_namespace = name_space
                    self.authentication_type_failure.value_namespace_prefix = name_space_prefix
                if(value_path == "corrupted-lsp-detected"):
                    self.corrupted_lsp_detected = value
                    self.corrupted_lsp_detected.value_namespace = name_space
                    self.corrupted_lsp_detected.value_namespace_prefix = name_space_prefix
                if(value_path == "database-overflow"):
                    self.database_overflow = value
                    self.database_overflow.value_namespace = name_space
                    self.database_overflow.value_namespace_prefix = name_space_prefix
                if(value_path == "id-length-mismatch"):
                    self.id_length_mismatch = value
                    self.id_length_mismatch.value_namespace = name_space
                    self.id_length_mismatch.value_namespace_prefix = name_space_prefix
                if(value_path == "lsp-error-detected"):
                    self.lsp_error_detected = value
                    self.lsp_error_detected.value_namespace = name_space
                    self.lsp_error_detected.value_namespace_prefix = name_space_prefix
                if(value_path == "lsp-too-large-to-propagate"):
                    self.lsp_too_large_to_propagate = value
                    self.lsp_too_large_to_propagate.value_namespace = name_space
                    self.lsp_too_large_to_propagate.value_namespace_prefix = name_space_prefix
                if(value_path == "manual-address-drops"):
                    self.manual_address_drops = value
                    self.manual_address_drops.value_namespace = name_space
                    self.manual_address_drops.value_namespace_prefix = name_space_prefix
                if(value_path == "max-area-address-mismatch"):
                    self.max_area_address_mismatch = value
                    self.max_area_address_mismatch.value_namespace = name_space
                    self.max_area_address_mismatch.value_namespace_prefix = name_space_prefix
                if(value_path == "originated-lsp-buffer-size-mismatch"):
                    self.originated_lsp_buffer_size_mismatch = value
                    self.originated_lsp_buffer_size_mismatch.value_namespace = name_space
                    self.originated_lsp_buffer_size_mismatch.value_namespace_prefix = name_space_prefix
                if(value_path == "own-lsp-purge"):
                    self.own_lsp_purge = value
                    self.own_lsp_purge.value_namespace = name_space
                    self.own_lsp_purge.value_namespace_prefix = name_space_prefix
                if(value_path == "protocols-supported-mismatch"):
                    self.protocols_supported_mismatch = value
                    self.protocols_supported_mismatch.value_namespace = name_space
                    self.protocols_supported_mismatch.value_namespace_prefix = name_space_prefix
                if(value_path == "rejected-adjacency"):
                    self.rejected_adjacency = value
                    self.rejected_adjacency.value_namespace = name_space
                    self.rejected_adjacency.value_namespace_prefix = name_space_prefix
                if(value_path == "sequence-number-skip"):
                    self.sequence_number_skip = value
                    self.sequence_number_skip.value_namespace = name_space
                    self.sequence_number_skip.value_namespace_prefix = name_space_prefix
                if(value_path == "version-skew"):
                    self.version_skew = value
                    self.version_skew.value_namespace = name_space
                    self.version_skew.value_namespace_prefix = name_space_prefix


        class ConfigMan(Entity):
            """
            CISCO\-CONFIG\-MAN\-MIB notification configurations
            
            .. attribute:: enable
            
            	Enable ciscoConfigManMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'config-mibs-cfg'
            _revision = '2015-09-29'

            def __init__(self):
                super(Snmp.Notification.ConfigMan, self).__init__()

                self.yang_name = "config-man"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.ConfigMan, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.ConfigMan, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-config-mibs-cfg:config-man" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Cfm(Entity):
            """
            802.1ag Connectivity Fault Management MIB
            notification configuration
            
            .. attribute:: enable
            
            	Enable 802.1ag Connectivity Fault Management MIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ethernet-cfm-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Cfm, self).__init__()

                self.yang_name = "cfm"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Cfm, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Cfm, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ethernet-cfm-cfg:cfm" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Oam(Entity):
            """
            802.3 OAM MIB notification configuration
            
            .. attribute:: enable
            
            	Enable 802.3 OAM MIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ethernet-link-oam-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Oam, self).__init__()

                self.yang_name = "oam"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Oam, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Oam, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ethernet-link-oam-cfg:oam" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Flash(Entity):
            """
            CISCO\-FLASH\-MIB notification configuration
            
            .. attribute:: insertion
            
            	Enable ciscoFlashDeviceInsertedNotif notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: removal
            
            	Enable ciscoFlashDeviceRemovedNotif notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'flashmib-cfg'
            _revision = '2015-12-15'

            def __init__(self):
                super(Snmp.Notification.Flash, self).__init__()

                self.yang_name = "flash"
                self.yang_parent_name = "notification"

                self.insertion = YLeaf(YType.empty, "insertion")

                self.removal = YLeaf(YType.empty, "removal")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("insertion",
                                "removal") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Flash, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Flash, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.insertion.is_set or
                    self.removal.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.insertion.yfilter != YFilter.not_set or
                    self.removal.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-flashmib-cfg:flash" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.insertion.is_set or self.insertion.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.insertion.get_name_leafdata())
                if (self.removal.is_set or self.removal.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.removal.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "insertion" or name == "removal"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "insertion"):
                    self.insertion = value
                    self.insertion.value_namespace = name_space
                    self.insertion.value_namespace_prefix = name_space_prefix
                if(value_path == "removal"):
                    self.removal = value
                    self.removal.value_namespace = name_space
                    self.removal.value_namespace_prefix = name_space_prefix


        class EntityRedundancy(Entity):
            """
            CISCO\-ENTITY\-REDUNDANCY\-MIB notification
            configuration
            
            .. attribute:: enable
            
            	Enable CISCO\-ENTITY\-REDUNDANCY\-MIB notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: status
            
            	Enable status change notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: switchover
            
            	Enable switchover notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'infra-ceredundancymib-cfg'
            _revision = '2015-01-07'

            def __init__(self):
                super(Snmp.Notification.EntityRedundancy, self).__init__()

                self.yang_name = "entity-redundancy"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

                self.status = YLeaf(YType.empty, "status")

                self.switchover = YLeaf(YType.empty, "switchover")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "status",
                                "switchover") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.EntityRedundancy, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.EntityRedundancy, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.status.is_set or
                    self.switchover.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.status.yfilter != YFilter.not_set or
                    self.switchover.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-infra-ceredundancymib-cfg:entity-redundancy" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.status.get_name_leafdata())
                if (self.switchover.is_set or self.switchover.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.switchover.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "status" or name == "switchover"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "status"):
                    self.status = value
                    self.status.value_namespace = name_space
                    self.status.value_namespace_prefix = name_space_prefix
                if(value_path == "switchover"):
                    self.switchover = value
                    self.switchover.value_namespace = name_space
                    self.switchover.value_namespace_prefix = name_space_prefix


        class ConfigCopy(Entity):
            """
            CISCO\-CONFIG\-COPY\-MIB notification configuration
            
            .. attribute:: completion
            
            	Enable ccCopyCompletion notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'infra-confcopymib-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.ConfigCopy, self).__init__()

                self.yang_name = "config-copy"
                self.yang_parent_name = "notification"

                self.completion = YLeaf(YType.empty, "completion")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("completion") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.ConfigCopy, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.ConfigCopy, self).__setattr__(name, value)

            def has_data(self):
                return self.completion.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.completion.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-infra-confcopymib-cfg:config-copy" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.completion.is_set or self.completion.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.completion.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "completion"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "completion"):
                    self.completion = value
                    self.completion.value_namespace = name_space
                    self.completion.value_namespace_prefix = name_space_prefix


        class SelectiveVrfDownload(Entity):
            """
            CISCO\-SELECTIVE\-VRF\-DOWNLOAD\-MIB notification
            configuration
            
            .. attribute:: role_change
            
            	Enable csvdEntityRoleChangeNotification notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'infra-rsi-cfg'
            _revision = '2016-12-19'

            def __init__(self):
                super(Snmp.Notification.SelectiveVrfDownload, self).__init__()

                self.yang_name = "selective-vrf-download"
                self.yang_parent_name = "notification"

                self.role_change = YLeaf(YType.empty, "role-change")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("role_change") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.SelectiveVrfDownload, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.SelectiveVrfDownload, self).__setattr__(name, value)

            def has_data(self):
                return self.role_change.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.role_change.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-infra-rsi-cfg:selective-vrf-download" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.role_change.is_set or self.role_change.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.role_change.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "role-change"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "role-change"):
                    self.role_change = value
                    self.role_change.value_namespace = name_space
                    self.role_change.value_namespace_prefix = name_space_prefix


        class System(Entity):
            """
            CISCO\-SYSTEM\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable ciscoSystemMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'infra-systemmib-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.System, self).__init__()

                self.yang_name = "system"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.System, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.System, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-infra-systemmib-cfg:system" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Bfd(Entity):
            """
            CISCO\-IETF\-BFD\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable CISCO\-IETF\-BFD\-MIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ip-bfd-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Bfd, self).__init__()

                self.yang_name = "bfd"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Bfd, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Bfd, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ip-bfd-cfg:bfd" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Ntp(Entity):
            """
            CISCO\-NTP\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable ciscoNtpMIB notification configuration
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ip-ntp-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Ntp, self).__init__()

                self.yang_name = "ntp"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Ntp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Ntp, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ip-ntp-cfg:ntp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Rsvp(Entity):
            """
            Enable RSVP\-MIB notifications
            
            .. attribute:: enable
            
            	Enable all RSVP notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: lost_flow
            
            	Enable lostFlow notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: new_flow
            
            	Enable newFlow notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ip-rsvp-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Rsvp, self).__init__()

                self.yang_name = "rsvp"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

                self.lost_flow = YLeaf(YType.empty, "lost-flow")

                self.new_flow = YLeaf(YType.empty, "new-flow")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "lost_flow",
                                "new_flow") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Rsvp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Rsvp, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.lost_flow.is_set or
                    self.new_flow.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.lost_flow.yfilter != YFilter.not_set or
                    self.new_flow.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ip-rsvp-cfg:rsvp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.lost_flow.is_set or self.lost_flow.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.lost_flow.get_name_leafdata())
                if (self.new_flow.is_set or self.new_flow.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.new_flow.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "lost-flow" or name == "new-flow"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "lost-flow"):
                    self.lost_flow = value
                    self.lost_flow.value_namespace = name_space
                    self.lost_flow.value_namespace_prefix = name_space_prefix
                if(value_path == "new-flow"):
                    self.new_flow = value
                    self.new_flow.value_namespace = name_space
                    self.new_flow.value_namespace_prefix = name_space_prefix


        class Bgp(Entity):
            """
            BGP4\-MIB and CISCO\-BGP4\-MIB notification
            configuration
            
            .. attribute:: bgp4mib
            
            	Enable BGP4\-MIB and CISCO\-BGP4\-MIB IPv4\-only notifications\: bgpEstablishedNotification, bgpBackwardTransNotification, cbgpFsmStateChange, cbgpBackwardTransition, cbgpPrefixThresholdExceeded, cbgpPrefixThresholdClear
            	**type**\:   :py:class:`Bgp4Mib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Bgp.Bgp4Mib>`
            
            .. attribute:: cisco_bgp4mib
            
            	Enable CISCO\-BGP4\-MIB v2 notifications\: cbgpPeer2EstablishedNotification, cbgpPeer2BackwardTransNotification, cbgpPeer2FsmStateChange, cbgpPeer2BackwardTransition, cbgpPeer2PrefixThresholdExceeded, cbgpPeer2PrefixThresholdClear
            	**type**\:   :py:class:`CiscoBgp4Mib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Bgp.CiscoBgp4Mib>`
            
            

            """

            _prefix = 'ipv4-bgp-cfg'
            _revision = '2015-08-27'

            def __init__(self):
                super(Snmp.Notification.Bgp, self).__init__()

                self.yang_name = "bgp"
                self.yang_parent_name = "notification"

                self.bgp4mib = Snmp.Notification.Bgp.Bgp4Mib()
                self.bgp4mib.parent = self
                self._children_name_map["bgp4mib"] = "bgp4mib"
                self._children_yang_names.add("bgp4mib")

                self.cisco_bgp4mib = Snmp.Notification.Bgp.CiscoBgp4Mib()
                self.cisco_bgp4mib.parent = self
                self._children_name_map["cisco_bgp4mib"] = "cisco-bgp4mib"
                self._children_yang_names.add("cisco-bgp4mib")


            class Bgp4Mib(Entity):
                """
                Enable BGP4\-MIB and CISCO\-BGP4\-MIB IPv4\-only
                notifications\: bgpEstablishedNotification,
                bgpBackwardTransNotification,
                cbgpFsmStateChange, cbgpBackwardTransition,
                cbgpPrefixThresholdExceeded,
                cbgpPrefixThresholdClear.
                
                .. attribute:: enable
                
                	Enable BGP4\-MIB and CISCO\-BGP4\-MIB IPv4\-only notifications
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: up_down
                
                	Enable BGP4\-MIB and CISCO\-BGP4\-MIB IPv4\-only up/down notifications
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-bgp-cfg'
                _revision = '2015-08-27'

                def __init__(self):
                    super(Snmp.Notification.Bgp.Bgp4Mib, self).__init__()

                    self.yang_name = "bgp4mib"
                    self.yang_parent_name = "bgp"

                    self.enable = YLeaf(YType.empty, "enable")

                    self.up_down = YLeaf(YType.empty, "up-down")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enable",
                                    "up_down") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Bgp.Bgp4Mib, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Bgp.Bgp4Mib, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.enable.is_set or
                        self.up_down.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.up_down.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "bgp4mib" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv4-bgp-cfg:bgp/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.up_down.is_set or self.up_down.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_down.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enable" or name == "up-down"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-down"):
                        self.up_down = value
                        self.up_down.value_namespace = name_space
                        self.up_down.value_namespace_prefix = name_space_prefix


            class CiscoBgp4Mib(Entity):
                """
                Enable CISCO\-BGP4\-MIB v2 notifications\:
                cbgpPeer2EstablishedNotification,
                cbgpPeer2BackwardTransNotification,
                cbgpPeer2FsmStateChange,
                cbgpPeer2BackwardTransition,
                cbgpPeer2PrefixThresholdExceeded,
                cbgpPeer2PrefixThresholdClear.
                
                .. attribute:: enable
                
                	Enable CISCO\-BGP4\-MIB v2 notifications
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: up_down
                
                	Enable CISCO\-BGP4\-MIB v2 up/down notifications
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-bgp-cfg'
                _revision = '2015-08-27'

                def __init__(self):
                    super(Snmp.Notification.Bgp.CiscoBgp4Mib, self).__init__()

                    self.yang_name = "cisco-bgp4mib"
                    self.yang_parent_name = "bgp"

                    self.enable = YLeaf(YType.empty, "enable")

                    self.up_down = YLeaf(YType.empty, "up-down")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enable",
                                    "up_down") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Bgp.CiscoBgp4Mib, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Bgp.CiscoBgp4Mib, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.enable.is_set or
                        self.up_down.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.up_down.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "cisco-bgp4mib" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv4-bgp-cfg:bgp/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.up_down.is_set or self.up_down.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_down.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enable" or name == "up-down"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-down"):
                        self.up_down = value
                        self.up_down.value_namespace = name_space
                        self.up_down.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.bgp4mib is not None and self.bgp4mib.has_data()) or
                    (self.cisco_bgp4mib is not None and self.cisco_bgp4mib.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.bgp4mib is not None and self.bgp4mib.has_operation()) or
                    (self.cisco_bgp4mib is not None and self.cisco_bgp4mib.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ipv4-bgp-cfg:bgp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "bgp4mib"):
                    if (self.bgp4mib is None):
                        self.bgp4mib = Snmp.Notification.Bgp.Bgp4Mib()
                        self.bgp4mib.parent = self
                        self._children_name_map["bgp4mib"] = "bgp4mib"
                    return self.bgp4mib

                if (child_yang_name == "cisco-bgp4mib"):
                    if (self.cisco_bgp4mib is None):
                        self.cisco_bgp4mib = Snmp.Notification.Bgp.CiscoBgp4Mib()
                        self.cisco_bgp4mib.parent = self
                        self._children_name_map["cisco_bgp4mib"] = "cisco-bgp4mib"
                    return self.cisco_bgp4mib

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "bgp4mib" or name == "cisco-bgp4mib"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Hsrp(Entity):
            """
            CISCO\-HSRP\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable CISCO\-HSRP\-MIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ipv4-hsrp-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Hsrp, self).__init__()

                self.yang_name = "hsrp"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Hsrp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Hsrp, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ipv4-hsrp-cfg:hsrp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Ospf(Entity):
            """
            OSPF\-MIB notification configuration
            
            .. attribute:: error
            
            	SNMP notifications for OSPF errors
            	**type**\:   :py:class:`Error <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospf.Error>`
            
            .. attribute:: lsa
            
            	SNMP notifications related to LSAs
            	**type**\:   :py:class:`Lsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospf.Lsa>`
            
            .. attribute:: retransmit
            
            	SNMP notifications for packet retransmissions
            	**type**\:   :py:class:`Retransmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospf.Retransmit>`
            
            .. attribute:: state_change
            
            	SNMP notifications for OSPF state change
            	**type**\:   :py:class:`StateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospf.StateChange>`
            
            

            """

            _prefix = 'ipv4-ospf-cfg'
            _revision = '2017-01-02'

            def __init__(self):
                super(Snmp.Notification.Ospf, self).__init__()

                self.yang_name = "ospf"
                self.yang_parent_name = "notification"

                self.error = Snmp.Notification.Ospf.Error()
                self.error.parent = self
                self._children_name_map["error"] = "error"
                self._children_yang_names.add("error")

                self.lsa = Snmp.Notification.Ospf.Lsa()
                self.lsa.parent = self
                self._children_name_map["lsa"] = "lsa"
                self._children_yang_names.add("lsa")

                self.retransmit = Snmp.Notification.Ospf.Retransmit()
                self.retransmit.parent = self
                self._children_name_map["retransmit"] = "retransmit"
                self._children_yang_names.add("retransmit")

                self.state_change = Snmp.Notification.Ospf.StateChange()
                self.state_change.parent = self
                self._children_name_map["state_change"] = "state-change"
                self._children_yang_names.add("state-change")


            class Lsa(Entity):
                """
                SNMP notifications related to LSAs
                
                .. attribute:: max_age_lsa
                
                	Enable ospfMaxAgeLsa notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: originate_lsa
                
                	Enable ospfOriginateLsa notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-ospf-cfg'
                _revision = '2017-01-02'

                def __init__(self):
                    super(Snmp.Notification.Ospf.Lsa, self).__init__()

                    self.yang_name = "lsa"
                    self.yang_parent_name = "ospf"

                    self.max_age_lsa = YLeaf(YType.empty, "max-age-lsa")

                    self.originate_lsa = YLeaf(YType.empty, "originate-lsa")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("max_age_lsa",
                                    "originate_lsa") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Ospf.Lsa, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Ospf.Lsa, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.max_age_lsa.is_set or
                        self.originate_lsa.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.max_age_lsa.yfilter != YFilter.not_set or
                        self.originate_lsa.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsa" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv4-ospf-cfg:ospf/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.max_age_lsa.is_set or self.max_age_lsa.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.max_age_lsa.get_name_leafdata())
                    if (self.originate_lsa.is_set or self.originate_lsa.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.originate_lsa.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "max-age-lsa" or name == "originate-lsa"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "max-age-lsa"):
                        self.max_age_lsa = value
                        self.max_age_lsa.value_namespace = name_space
                        self.max_age_lsa.value_namespace_prefix = name_space_prefix
                    if(value_path == "originate-lsa"):
                        self.originate_lsa = value
                        self.originate_lsa.value_namespace = name_space
                        self.originate_lsa.value_namespace_prefix = name_space_prefix


            class StateChange(Entity):
                """
                SNMP notifications for OSPF state change
                
                .. attribute:: interface
                
                	Enable ospfIfStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: neighbor
                
                	Enable ospfNbrStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_interface
                
                	Enable ospfVirtIfStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_neighbor
                
                	Enable ospfVirtNbrStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-ospf-cfg'
                _revision = '2017-01-02'

                def __init__(self):
                    super(Snmp.Notification.Ospf.StateChange, self).__init__()

                    self.yang_name = "state-change"
                    self.yang_parent_name = "ospf"

                    self.interface = YLeaf(YType.empty, "interface")

                    self.neighbor = YLeaf(YType.empty, "neighbor")

                    self.virtual_interface = YLeaf(YType.empty, "virtual-interface")

                    self.virtual_neighbor = YLeaf(YType.empty, "virtual-neighbor")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface",
                                    "neighbor",
                                    "virtual_interface",
                                    "virtual_neighbor") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Ospf.StateChange, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Ospf.StateChange, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface.is_set or
                        self.neighbor.is_set or
                        self.virtual_interface.is_set or
                        self.virtual_neighbor.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.neighbor.yfilter != YFilter.not_set or
                        self.virtual_interface.yfilter != YFilter.not_set or
                        self.virtual_neighbor.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state-change" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv4-ospf-cfg:ospf/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor.get_name_leafdata())
                    if (self.virtual_interface.is_set or self.virtual_interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_interface.get_name_leafdata())
                    if (self.virtual_neighbor.is_set or self.virtual_neighbor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_neighbor.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface" or name == "neighbor" or name == "virtual-interface" or name == "virtual-neighbor"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor"):
                        self.neighbor = value
                        self.neighbor.value_namespace = name_space
                        self.neighbor.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-interface"):
                        self.virtual_interface = value
                        self.virtual_interface.value_namespace = name_space
                        self.virtual_interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-neighbor"):
                        self.virtual_neighbor = value
                        self.virtual_neighbor.value_namespace = name_space
                        self.virtual_neighbor.value_namespace_prefix = name_space_prefix


            class Retransmit(Entity):
                """
                SNMP notifications for packet retransmissions
                
                .. attribute:: packet
                
                	Enable ospfTxRetransmit notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_packet
                
                	Enable ospfVirtIfTxRetransmit notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-ospf-cfg'
                _revision = '2017-01-02'

                def __init__(self):
                    super(Snmp.Notification.Ospf.Retransmit, self).__init__()

                    self.yang_name = "retransmit"
                    self.yang_parent_name = "ospf"

                    self.packet = YLeaf(YType.empty, "packet")

                    self.virtual_packet = YLeaf(YType.empty, "virtual-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("packet",
                                    "virtual_packet") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Ospf.Retransmit, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Ospf.Retransmit, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.packet.is_set or
                        self.virtual_packet.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.packet.yfilter != YFilter.not_set or
                        self.virtual_packet.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "retransmit" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv4-ospf-cfg:ospf/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.packet.is_set or self.packet.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.packet.get_name_leafdata())
                    if (self.virtual_packet.is_set or self.virtual_packet.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_packet.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "packet" or name == "virtual-packet"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "packet"):
                        self.packet = value
                        self.packet.value_namespace = name_space
                        self.packet.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-packet"):
                        self.virtual_packet = value
                        self.virtual_packet.value_namespace = name_space
                        self.virtual_packet.value_namespace_prefix = name_space_prefix


            class Error(Entity):
                """
                SNMP notifications for OSPF errors
                
                .. attribute:: authentication_failure
                
                	Enable ospfIfAuthFailure notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: bad_packet
                
                	Enable ospfIfRxBadPacket notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: config_error
                
                	Enable ospfIfConfigError notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_authentication_failure
                
                	Enable ospfVirtIfAuthFailure notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_bad_packet
                
                	Enable ospfVirtIfRxBadPacket notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_config_error
                
                	Enable ospfVirtIfConfigError notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-ospf-cfg'
                _revision = '2017-01-02'

                def __init__(self):
                    super(Snmp.Notification.Ospf.Error, self).__init__()

                    self.yang_name = "error"
                    self.yang_parent_name = "ospf"

                    self.authentication_failure = YLeaf(YType.empty, "authentication-failure")

                    self.bad_packet = YLeaf(YType.empty, "bad-packet")

                    self.config_error = YLeaf(YType.empty, "config-error")

                    self.virtual_authentication_failure = YLeaf(YType.empty, "virtual-authentication-failure")

                    self.virtual_bad_packet = YLeaf(YType.empty, "virtual-bad-packet")

                    self.virtual_config_error = YLeaf(YType.empty, "virtual-config-error")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("authentication_failure",
                                    "bad_packet",
                                    "config_error",
                                    "virtual_authentication_failure",
                                    "virtual_bad_packet",
                                    "virtual_config_error") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Ospf.Error, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Ospf.Error, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.authentication_failure.is_set or
                        self.bad_packet.is_set or
                        self.config_error.is_set or
                        self.virtual_authentication_failure.is_set or
                        self.virtual_bad_packet.is_set or
                        self.virtual_config_error.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.authentication_failure.yfilter != YFilter.not_set or
                        self.bad_packet.yfilter != YFilter.not_set or
                        self.config_error.yfilter != YFilter.not_set or
                        self.virtual_authentication_failure.yfilter != YFilter.not_set or
                        self.virtual_bad_packet.yfilter != YFilter.not_set or
                        self.virtual_config_error.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "error" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv4-ospf-cfg:ospf/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.authentication_failure.is_set or self.authentication_failure.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.authentication_failure.get_name_leafdata())
                    if (self.bad_packet.is_set or self.bad_packet.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bad_packet.get_name_leafdata())
                    if (self.config_error.is_set or self.config_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.config_error.get_name_leafdata())
                    if (self.virtual_authentication_failure.is_set or self.virtual_authentication_failure.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_authentication_failure.get_name_leafdata())
                    if (self.virtual_bad_packet.is_set or self.virtual_bad_packet.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_bad_packet.get_name_leafdata())
                    if (self.virtual_config_error.is_set or self.virtual_config_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_config_error.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "authentication-failure" or name == "bad-packet" or name == "config-error" or name == "virtual-authentication-failure" or name == "virtual-bad-packet" or name == "virtual-config-error"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "authentication-failure"):
                        self.authentication_failure = value
                        self.authentication_failure.value_namespace = name_space
                        self.authentication_failure.value_namespace_prefix = name_space_prefix
                    if(value_path == "bad-packet"):
                        self.bad_packet = value
                        self.bad_packet.value_namespace = name_space
                        self.bad_packet.value_namespace_prefix = name_space_prefix
                    if(value_path == "config-error"):
                        self.config_error = value
                        self.config_error.value_namespace = name_space
                        self.config_error.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-authentication-failure"):
                        self.virtual_authentication_failure = value
                        self.virtual_authentication_failure.value_namespace = name_space
                        self.virtual_authentication_failure.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-bad-packet"):
                        self.virtual_bad_packet = value
                        self.virtual_bad_packet.value_namespace = name_space
                        self.virtual_bad_packet.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-config-error"):
                        self.virtual_config_error = value
                        self.virtual_config_error.value_namespace = name_space
                        self.virtual_config_error.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.error is not None and self.error.has_data()) or
                    (self.lsa is not None and self.lsa.has_data()) or
                    (self.retransmit is not None and self.retransmit.has_data()) or
                    (self.state_change is not None and self.state_change.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.error is not None and self.error.has_operation()) or
                    (self.lsa is not None and self.lsa.has_operation()) or
                    (self.retransmit is not None and self.retransmit.has_operation()) or
                    (self.state_change is not None and self.state_change.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ipv4-ospf-cfg:ospf" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "error"):
                    if (self.error is None):
                        self.error = Snmp.Notification.Ospf.Error()
                        self.error.parent = self
                        self._children_name_map["error"] = "error"
                    return self.error

                if (child_yang_name == "lsa"):
                    if (self.lsa is None):
                        self.lsa = Snmp.Notification.Ospf.Lsa()
                        self.lsa.parent = self
                        self._children_name_map["lsa"] = "lsa"
                    return self.lsa

                if (child_yang_name == "retransmit"):
                    if (self.retransmit is None):
                        self.retransmit = Snmp.Notification.Ospf.Retransmit()
                        self.retransmit.parent = self
                        self._children_name_map["retransmit"] = "retransmit"
                    return self.retransmit

                if (child_yang_name == "state-change"):
                    if (self.state_change is None):
                        self.state_change = Snmp.Notification.Ospf.StateChange()
                        self.state_change.parent = self
                        self._children_name_map["state_change"] = "state-change"
                    return self.state_change

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "error" or name == "lsa" or name == "retransmit" or name == "state-change"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Vrrp(Entity):
            """
            VRRP\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable VRRP\-MIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ipv4-vrrp-cfg'
            _revision = '2016-12-16'

            def __init__(self):
                super(Snmp.Notification.Vrrp, self).__init__()

                self.yang_name = "vrrp"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Vrrp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Vrrp, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ipv4-vrrp-cfg:vrrp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Ospfv3(Entity):
            """
            OSPFv3\-MIB notification configuration
            
            .. attribute:: error
            
            	SNMP notifications for OSPF errors
            	**type**\:   :py:class:`Error <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospfv3.Error>`
            
            .. attribute:: state_change
            
            	SNMP notifications for OSPF state change
            	**type**\:   :py:class:`StateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.Ospfv3.StateChange>`
            
            

            """

            _prefix = 'ipv6-ospfv3-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Ospfv3, self).__init__()

                self.yang_name = "ospfv3"
                self.yang_parent_name = "notification"

                self.error = Snmp.Notification.Ospfv3.Error()
                self.error.parent = self
                self._children_name_map["error"] = "error"
                self._children_yang_names.add("error")

                self.state_change = Snmp.Notification.Ospfv3.StateChange()
                self.state_change.parent = self
                self._children_name_map["state_change"] = "state-change"
                self._children_yang_names.add("state-change")


            class Error(Entity):
                """
                SNMP notifications for OSPF errors
                
                .. attribute:: bad_packet
                
                	Enable ospfv3IfRxBadPacket notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: config_error
                
                	Enable ospfv3IfConfigError notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_bad_packet
                
                	Enable ospfv3VirtIfRxBadPacket notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_config_error
                
                	Enable ospfv3VirtIfConfigError notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv6-ospfv3-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Snmp.Notification.Ospfv3.Error, self).__init__()

                    self.yang_name = "error"
                    self.yang_parent_name = "ospfv3"

                    self.bad_packet = YLeaf(YType.empty, "bad-packet")

                    self.config_error = YLeaf(YType.empty, "config-error")

                    self.virtual_bad_packet = YLeaf(YType.empty, "virtual-bad-packet")

                    self.virtual_config_error = YLeaf(YType.empty, "virtual-config-error")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("bad_packet",
                                    "config_error",
                                    "virtual_bad_packet",
                                    "virtual_config_error") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Ospfv3.Error, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Ospfv3.Error, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.bad_packet.is_set or
                        self.config_error.is_set or
                        self.virtual_bad_packet.is_set or
                        self.virtual_config_error.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.bad_packet.yfilter != YFilter.not_set or
                        self.config_error.yfilter != YFilter.not_set or
                        self.virtual_bad_packet.yfilter != YFilter.not_set or
                        self.virtual_config_error.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "error" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.bad_packet.is_set or self.bad_packet.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bad_packet.get_name_leafdata())
                    if (self.config_error.is_set or self.config_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.config_error.get_name_leafdata())
                    if (self.virtual_bad_packet.is_set or self.virtual_bad_packet.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_bad_packet.get_name_leafdata())
                    if (self.virtual_config_error.is_set or self.virtual_config_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_config_error.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bad-packet" or name == "config-error" or name == "virtual-bad-packet" or name == "virtual-config-error"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "bad-packet"):
                        self.bad_packet = value
                        self.bad_packet.value_namespace = name_space
                        self.bad_packet.value_namespace_prefix = name_space_prefix
                    if(value_path == "config-error"):
                        self.config_error = value
                        self.config_error.value_namespace = name_space
                        self.config_error.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-bad-packet"):
                        self.virtual_bad_packet = value
                        self.virtual_bad_packet.value_namespace = name_space
                        self.virtual_bad_packet.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-config-error"):
                        self.virtual_config_error = value
                        self.virtual_config_error.value_namespace = name_space
                        self.virtual_config_error.value_namespace_prefix = name_space_prefix


            class StateChange(Entity):
                """
                SNMP notifications for OSPF state change
                
                .. attribute:: interface
                
                	Enable ospfv3IfStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: neighbor
                
                	Enable ospfv3NbrStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: nssa_translator
                
                	Enable ospfv3NssaTranslatorStatusChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: restart
                
                	Enable ospfv3RestartStatusChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: restart_helper
                
                	Enable ospfv3NbrRestartHelperStatusChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: restart_virtual_helper
                
                	Enable ospfv3VirtNbrRestartHelperStatusChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_interface
                
                	Enable ospfv3VirtIfStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: virtual_neighbor
                
                	Enable ospfv3VirtNbrStateChange notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv6-ospfv3-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Snmp.Notification.Ospfv3.StateChange, self).__init__()

                    self.yang_name = "state-change"
                    self.yang_parent_name = "ospfv3"

                    self.interface = YLeaf(YType.empty, "interface")

                    self.neighbor = YLeaf(YType.empty, "neighbor")

                    self.nssa_translator = YLeaf(YType.empty, "nssa-translator")

                    self.restart = YLeaf(YType.empty, "restart")

                    self.restart_helper = YLeaf(YType.empty, "restart-helper")

                    self.restart_virtual_helper = YLeaf(YType.empty, "restart-virtual-helper")

                    self.virtual_interface = YLeaf(YType.empty, "virtual-interface")

                    self.virtual_neighbor = YLeaf(YType.empty, "virtual-neighbor")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface",
                                    "neighbor",
                                    "nssa_translator",
                                    "restart",
                                    "restart_helper",
                                    "restart_virtual_helper",
                                    "virtual_interface",
                                    "virtual_neighbor") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.Ospfv3.StateChange, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.Ospfv3.StateChange, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface.is_set or
                        self.neighbor.is_set or
                        self.nssa_translator.is_set or
                        self.restart.is_set or
                        self.restart_helper.is_set or
                        self.restart_virtual_helper.is_set or
                        self.virtual_interface.is_set or
                        self.virtual_neighbor.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.neighbor.yfilter != YFilter.not_set or
                        self.nssa_translator.yfilter != YFilter.not_set or
                        self.restart.yfilter != YFilter.not_set or
                        self.restart_helper.yfilter != YFilter.not_set or
                        self.restart_virtual_helper.yfilter != YFilter.not_set or
                        self.virtual_interface.yfilter != YFilter.not_set or
                        self.virtual_neighbor.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state-change" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor.get_name_leafdata())
                    if (self.nssa_translator.is_set or self.nssa_translator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nssa_translator.get_name_leafdata())
                    if (self.restart.is_set or self.restart.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.restart.get_name_leafdata())
                    if (self.restart_helper.is_set or self.restart_helper.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.restart_helper.get_name_leafdata())
                    if (self.restart_virtual_helper.is_set or self.restart_virtual_helper.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.restart_virtual_helper.get_name_leafdata())
                    if (self.virtual_interface.is_set or self.virtual_interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_interface.get_name_leafdata())
                    if (self.virtual_neighbor.is_set or self.virtual_neighbor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.virtual_neighbor.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface" or name == "neighbor" or name == "nssa-translator" or name == "restart" or name == "restart-helper" or name == "restart-virtual-helper" or name == "virtual-interface" or name == "virtual-neighbor"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor"):
                        self.neighbor = value
                        self.neighbor.value_namespace = name_space
                        self.neighbor.value_namespace_prefix = name_space_prefix
                    if(value_path == "nssa-translator"):
                        self.nssa_translator = value
                        self.nssa_translator.value_namespace = name_space
                        self.nssa_translator.value_namespace_prefix = name_space_prefix
                    if(value_path == "restart"):
                        self.restart = value
                        self.restart.value_namespace = name_space
                        self.restart.value_namespace_prefix = name_space_prefix
                    if(value_path == "restart-helper"):
                        self.restart_helper = value
                        self.restart_helper.value_namespace = name_space
                        self.restart_helper.value_namespace_prefix = name_space_prefix
                    if(value_path == "restart-virtual-helper"):
                        self.restart_virtual_helper = value
                        self.restart_virtual_helper.value_namespace = name_space
                        self.restart_virtual_helper.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-interface"):
                        self.virtual_interface = value
                        self.virtual_interface.value_namespace = name_space
                        self.virtual_interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "virtual-neighbor"):
                        self.virtual_neighbor = value
                        self.virtual_neighbor.value_namespace = name_space
                        self.virtual_neighbor.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.error is not None and self.error.has_data()) or
                    (self.state_change is not None and self.state_change.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.error is not None and self.error.has_operation()) or
                    (self.state_change is not None and self.state_change.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "error"):
                    if (self.error is None):
                        self.error = Snmp.Notification.Ospfv3.Error()
                        self.error.parent = self
                        self._children_name_map["error"] = "error"
                    return self.error

                if (child_yang_name == "state-change"):
                    if (self.state_change is None):
                        self.state_change = Snmp.Notification.Ospfv3.StateChange()
                        self.state_change.parent = self
                        self._children_name_map["state_change"] = "state-change"
                    return self.state_change

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "error" or name == "state-change"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class MplsLdp(Entity):
            """
            MPLS\-LDP\-STD\-MIB notification configuration
            
            .. attribute:: init_session_threshold_exceeded
            
            	Enable mplsLdpInitSessionThresholdExceeded notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: session_down
            
            	Enable mplsLdpSessionDown notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: session_up
            
            	Enable mplsLdpSessionUp notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'mpls-ldp-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.MplsLdp, self).__init__()

                self.yang_name = "mpls-ldp"
                self.yang_parent_name = "notification"

                self.init_session_threshold_exceeded = YLeaf(YType.empty, "init-session-threshold-exceeded")

                self.session_down = YLeaf(YType.empty, "session-down")

                self.session_up = YLeaf(YType.empty, "session-up")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("init_session_threshold_exceeded",
                                "session_down",
                                "session_up") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.MplsLdp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.MplsLdp, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.init_session_threshold_exceeded.is_set or
                    self.session_down.is_set or
                    self.session_up.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.init_session_threshold_exceeded.yfilter != YFilter.not_set or
                    self.session_down.yfilter != YFilter.not_set or
                    self.session_up.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-mpls-ldp-cfg:mpls-ldp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.init_session_threshold_exceeded.is_set or self.init_session_threshold_exceeded.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.init_session_threshold_exceeded.get_name_leafdata())
                if (self.session_down.is_set or self.session_down.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_down.get_name_leafdata())
                if (self.session_up.is_set or self.session_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_up.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "init-session-threshold-exceeded" or name == "session-down" or name == "session-up"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "init-session-threshold-exceeded"):
                    self.init_session_threshold_exceeded = value
                    self.init_session_threshold_exceeded.value_namespace = name_space
                    self.init_session_threshold_exceeded.value_namespace_prefix = name_space_prefix
                if(value_path == "session-down"):
                    self.session_down = value
                    self.session_down.value_namespace = name_space
                    self.session_down.value_namespace_prefix = name_space_prefix
                if(value_path == "session-up"):
                    self.session_up = value
                    self.session_up.value_namespace = name_space
                    self.session_up.value_namespace_prefix = name_space_prefix


        class MplsTeP2Mp(Entity):
            """
            CISCO\-MPLS\-TE\-P2MP\-STD\-MIB notification
            configuration
            
            .. attribute:: down
            
            	Enable cmplsTeP2mpTunnelDestDown notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: up
            
            	Enable cmplsTeP2mpTunnelDestUp notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.MplsTeP2Mp, self).__init__()

                self.yang_name = "mpls-te-p2mp"
                self.yang_parent_name = "notification"

                self.down = YLeaf(YType.empty, "down")

                self.up = YLeaf(YType.empty, "up")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down",
                                "up") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.MplsTeP2Mp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.MplsTeP2Mp, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down.is_set or
                    self.up.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down.yfilter != YFilter.not_set or
                    self.up.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te-p2mp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down.is_set or self.down.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down.get_name_leafdata())
                if (self.up.is_set or self.up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down" or name == "up"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down"):
                    self.down = value
                    self.down.value_namespace = name_space
                    self.down.value_namespace_prefix = name_space_prefix
                if(value_path == "up"):
                    self.up = value
                    self.up.value_namespace = name_space
                    self.up.value_namespace_prefix = name_space_prefix


        class MplsTe(Entity):
            """
            MPLS\-TE\-STD\-MIB notification configuration
            
            .. attribute:: cisco
            
            	Enable MPLS TE tunnel Cisco format (default IETF) notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: cisco_extension
            
            	CISCO\-MPLS\-TE\-STD\-EXT\-MIB notification configuration
            	**type**\:   :py:class:`CiscoExtension <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Notification.MplsTe.CiscoExtension>`
            
            .. attribute:: down
            
            	Enable mplsTunnelDown notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: reoptimize
            
            	Enable mplsTunnelReoptimized notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: reroute
            
            	Enable mplsTunnelRerouted notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: up
            
            	Enable mplsTunnelUp notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.MplsTe, self).__init__()

                self.yang_name = "mpls-te"
                self.yang_parent_name = "notification"

                self.cisco = YLeaf(YType.empty, "cisco")

                self.down = YLeaf(YType.empty, "down")

                self.reoptimize = YLeaf(YType.empty, "reoptimize")

                self.reroute = YLeaf(YType.empty, "reroute")

                self.up = YLeaf(YType.empty, "up")

                self.cisco_extension = Snmp.Notification.MplsTe.CiscoExtension()
                self.cisco_extension.parent = self
                self._children_name_map["cisco_extension"] = "cisco-extension"
                self._children_yang_names.add("cisco-extension")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cisco",
                                "down",
                                "reoptimize",
                                "reroute",
                                "up") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.MplsTe, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.MplsTe, self).__setattr__(name, value)


            class CiscoExtension(Entity):
                """
                CISCO\-MPLS\-TE\-STD\-EXT\-MIB notification
                configuration
                
                .. attribute:: bringup_fail
                
                	Enable cmplsTunnelBringupFail notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: insufficient_bandwidth
                
                	Enable cmplsTunnelInsuffBW notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: preempt
                
                	Enable cmplsTunnelPreempt notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: re_route_pending
                
                	Enable cmplsTunnelReRoutePending notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: re_route_pending_clear
                
                	Enable cmplsTunnelReRoutePendingClear notification
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Snmp.Notification.MplsTe.CiscoExtension, self).__init__()

                    self.yang_name = "cisco-extension"
                    self.yang_parent_name = "mpls-te"

                    self.bringup_fail = YLeaf(YType.empty, "bringup-fail")

                    self.insufficient_bandwidth = YLeaf(YType.empty, "insufficient-bandwidth")

                    self.preempt = YLeaf(YType.empty, "preempt")

                    self.re_route_pending = YLeaf(YType.empty, "re-route-pending")

                    self.re_route_pending_clear = YLeaf(YType.empty, "re-route-pending-clear")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("bringup_fail",
                                    "insufficient_bandwidth",
                                    "preempt",
                                    "re_route_pending",
                                    "re_route_pending_clear") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Notification.MplsTe.CiscoExtension, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Notification.MplsTe.CiscoExtension, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.bringup_fail.is_set or
                        self.insufficient_bandwidth.is_set or
                        self.preempt.is_set or
                        self.re_route_pending.is_set or
                        self.re_route_pending_clear.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.bringup_fail.yfilter != YFilter.not_set or
                        self.insufficient_bandwidth.yfilter != YFilter.not_set or
                        self.preempt.yfilter != YFilter.not_set or
                        self.re_route_pending.yfilter != YFilter.not_set or
                        self.re_route_pending_clear.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "cisco-extension" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.bringup_fail.is_set or self.bringup_fail.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bringup_fail.get_name_leafdata())
                    if (self.insufficient_bandwidth.is_set or self.insufficient_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.insufficient_bandwidth.get_name_leafdata())
                    if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.preempt.get_name_leafdata())
                    if (self.re_route_pending.is_set or self.re_route_pending.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.re_route_pending.get_name_leafdata())
                    if (self.re_route_pending_clear.is_set or self.re_route_pending_clear.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.re_route_pending_clear.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bringup-fail" or name == "insufficient-bandwidth" or name == "preempt" or name == "re-route-pending" or name == "re-route-pending-clear"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "bringup-fail"):
                        self.bringup_fail = value
                        self.bringup_fail.value_namespace = name_space
                        self.bringup_fail.value_namespace_prefix = name_space_prefix
                    if(value_path == "insufficient-bandwidth"):
                        self.insufficient_bandwidth = value
                        self.insufficient_bandwidth.value_namespace = name_space
                        self.insufficient_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "preempt"):
                        self.preempt = value
                        self.preempt.value_namespace = name_space
                        self.preempt.value_namespace_prefix = name_space_prefix
                    if(value_path == "re-route-pending"):
                        self.re_route_pending = value
                        self.re_route_pending.value_namespace = name_space
                        self.re_route_pending.value_namespace_prefix = name_space_prefix
                    if(value_path == "re-route-pending-clear"):
                        self.re_route_pending_clear = value
                        self.re_route_pending_clear.value_namespace = name_space
                        self.re_route_pending_clear.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.cisco.is_set or
                    self.down.is_set or
                    self.reoptimize.is_set or
                    self.reroute.is_set or
                    self.up.is_set or
                    (self.cisco_extension is not None and self.cisco_extension.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cisco.yfilter != YFilter.not_set or
                    self.down.yfilter != YFilter.not_set or
                    self.reoptimize.yfilter != YFilter.not_set or
                    self.reroute.yfilter != YFilter.not_set or
                    self.up.yfilter != YFilter.not_set or
                    (self.cisco_extension is not None and self.cisco_extension.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cisco.is_set or self.cisco.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cisco.get_name_leafdata())
                if (self.down.is_set or self.down.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down.get_name_leafdata())
                if (self.reoptimize.is_set or self.reoptimize.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.reoptimize.get_name_leafdata())
                if (self.reroute.is_set or self.reroute.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.reroute.get_name_leafdata())
                if (self.up.is_set or self.up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "cisco-extension"):
                    if (self.cisco_extension is None):
                        self.cisco_extension = Snmp.Notification.MplsTe.CiscoExtension()
                        self.cisco_extension.parent = self
                        self._children_name_map["cisco_extension"] = "cisco-extension"
                    return self.cisco_extension

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "cisco-extension" or name == "cisco" or name == "down" or name == "reoptimize" or name == "reroute" or name == "up"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "cisco"):
                    self.cisco = value
                    self.cisco.value_namespace = name_space
                    self.cisco.value_namespace_prefix = name_space_prefix
                if(value_path == "down"):
                    self.down = value
                    self.down.value_namespace = name_space
                    self.down.value_namespace_prefix = name_space_prefix
                if(value_path == "reoptimize"):
                    self.reoptimize = value
                    self.reoptimize.value_namespace = name_space
                    self.reoptimize.value_namespace_prefix = name_space_prefix
                if(value_path == "reroute"):
                    self.reroute = value
                    self.reroute.value_namespace = name_space
                    self.reroute.value_namespace_prefix = name_space_prefix
                if(value_path == "up"):
                    self.up = value
                    self.up.value_namespace = name_space
                    self.up.value_namespace_prefix = name_space_prefix


        class MplsFrr(Entity):
            """
            CISCO\-IETF\-FRR\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable cmplsFrrMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: protected
            
            	Enable cmplsFrrProtected notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: unprotected
            
            	Enable cmplsFrrUnProtected notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.MplsFrr, self).__init__()

                self.yang_name = "mpls-frr"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

                self.protected = YLeaf(YType.empty, "protected")

                self.unprotected = YLeaf(YType.empty, "unprotected")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "protected",
                                "unprotected") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.MplsFrr, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.MplsFrr, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.protected.is_set or
                    self.unprotected.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.protected.yfilter != YFilter.not_set or
                    self.unprotected.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-frr" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.protected.is_set or self.protected.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protected.get_name_leafdata())
                if (self.unprotected.is_set or self.unprotected.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unprotected.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "protected" or name == "unprotected"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "protected"):
                    self.protected = value
                    self.protected.value_namespace = name_space
                    self.protected.value_namespace_prefix = name_space_prefix
                if(value_path == "unprotected"):
                    self.unprotected = value
                    self.unprotected.value_namespace = name_space
                    self.unprotected.value_namespace_prefix = name_space_prefix


        class MplsL3Vpn(Entity):
            """
            MPLS\-L3VPN\-STD\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable mplsL3VpnMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: max_threshold_cleared
            
            	Enable mplsL3VpnNumVrfRouteMaxThreshCleared notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: max_threshold_exceeded
            
            	Enable mplsL3VpnVrfNumVrfRouteMaxThreshExceeded notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: max_threshold_reissue_notification_time
            
            	Time interval (secs) for re\-issuing max\-threshold notification
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            	**units**\: second
            
            .. attribute:: mid_threshold_exceeded
            
            	Enable mplsL3VpnVrfRouteMidThreshExceeded notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: vrf_down
            
            	Enable mplsL3VpnVrfDown notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: vrf_up
            
            	Enable mplsL3VpnVrfUp notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'mpls-vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.MplsL3Vpn, self).__init__()

                self.yang_name = "mpls-l3vpn"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

                self.max_threshold_cleared = YLeaf(YType.empty, "max-threshold-cleared")

                self.max_threshold_exceeded = YLeaf(YType.empty, "max-threshold-exceeded")

                self.max_threshold_reissue_notification_time = YLeaf(YType.int32, "max-threshold-reissue-notification-time")

                self.mid_threshold_exceeded = YLeaf(YType.empty, "mid-threshold-exceeded")

                self.vrf_down = YLeaf(YType.empty, "vrf-down")

                self.vrf_up = YLeaf(YType.empty, "vrf-up")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "max_threshold_cleared",
                                "max_threshold_exceeded",
                                "max_threshold_reissue_notification_time",
                                "mid_threshold_exceeded",
                                "vrf_down",
                                "vrf_up") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.MplsL3Vpn, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.MplsL3Vpn, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.max_threshold_cleared.is_set or
                    self.max_threshold_exceeded.is_set or
                    self.max_threshold_reissue_notification_time.is_set or
                    self.mid_threshold_exceeded.is_set or
                    self.vrf_down.is_set or
                    self.vrf_up.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.max_threshold_cleared.yfilter != YFilter.not_set or
                    self.max_threshold_exceeded.yfilter != YFilter.not_set or
                    self.max_threshold_reissue_notification_time.yfilter != YFilter.not_set or
                    self.mid_threshold_exceeded.yfilter != YFilter.not_set or
                    self.vrf_down.yfilter != YFilter.not_set or
                    self.vrf_up.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-mpls-vpn-cfg:mpls-l3vpn" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.max_threshold_cleared.is_set or self.max_threshold_cleared.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_threshold_cleared.get_name_leafdata())
                if (self.max_threshold_exceeded.is_set or self.max_threshold_exceeded.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_threshold_exceeded.get_name_leafdata())
                if (self.max_threshold_reissue_notification_time.is_set or self.max_threshold_reissue_notification_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_threshold_reissue_notification_time.get_name_leafdata())
                if (self.mid_threshold_exceeded.is_set or self.mid_threshold_exceeded.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.mid_threshold_exceeded.get_name_leafdata())
                if (self.vrf_down.is_set or self.vrf_down.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_down.get_name_leafdata())
                if (self.vrf_up.is_set or self.vrf_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_up.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "max-threshold-cleared" or name == "max-threshold-exceeded" or name == "max-threshold-reissue-notification-time" or name == "mid-threshold-exceeded" or name == "vrf-down" or name == "vrf-up"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "max-threshold-cleared"):
                    self.max_threshold_cleared = value
                    self.max_threshold_cleared.value_namespace = name_space
                    self.max_threshold_cleared.value_namespace_prefix = name_space_prefix
                if(value_path == "max-threshold-exceeded"):
                    self.max_threshold_exceeded = value
                    self.max_threshold_exceeded.value_namespace = name_space
                    self.max_threshold_exceeded.value_namespace_prefix = name_space_prefix
                if(value_path == "max-threshold-reissue-notification-time"):
                    self.max_threshold_reissue_notification_time = value
                    self.max_threshold_reissue_notification_time.value_namespace = name_space
                    self.max_threshold_reissue_notification_time.value_namespace_prefix = name_space_prefix
                if(value_path == "mid-threshold-exceeded"):
                    self.mid_threshold_exceeded = value
                    self.mid_threshold_exceeded.value_namespace = name_space
                    self.mid_threshold_exceeded.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-down"):
                    self.vrf_down = value
                    self.vrf_down.value_namespace = name_space
                    self.vrf_down.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-up"):
                    self.vrf_up = value
                    self.vrf_up.value_namespace = name_space
                    self.vrf_up.value_namespace_prefix = name_space_prefix


        class Optical(Entity):
            """
            CISCO\-OPTICAL\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable Opticalmib notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'opticalmib-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Optical, self).__init__()

                self.yang_name = "optical"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Optical, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Optical, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-opticalmib-cfg:optical" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Otn(Entity):
            """
            CISCO\-OTN\-IF\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable ciscoOtnIfMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'otnifmib-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Otn, self).__init__()

                self.yang_name = "otn"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Otn, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Otn, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-otnifmib-cfg:otn" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Bridge(Entity):
            """
            BRIDGE\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable dot1dBridge notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-bridgemib-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Bridge, self).__init__()

                self.yang_name = "bridge"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Bridge, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Bridge, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-snmp-bridgemib-cfg:bridge" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Sensor(Entity):
            """
            CISCO\-ENTITY\-SENSOR\-MIB notification
            configuration
            
            .. attribute:: enable
            
            	Enable entitySensorMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-ciscosensormib-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Snmp.Notification.Sensor, self).__init__()

                self.yang_name = "sensor"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Sensor, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Sensor, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-snmp-ciscosensormib-cfg:sensor" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Entity_(Entity):
            """
            Enable ENTITY\-MIB notifications
            
            .. attribute:: enable
            
            	Enable entityMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-entitymib-cfg'
            _revision = '2015-01-07'

            def __init__(self):
                super(Snmp.Notification.Entity_, self).__init__()

                self.yang_name = "entity"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Entity_, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Entity_, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-snmp-entitymib-cfg:entity" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class EntityState(Entity):
            """
            ENTITY\-STATE\-MIB notification configuration
            
            .. attribute:: oper_status
            
            	Enable entStateOperEnable and entStateOperDisable notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: switchover
            
            	Enable ceStateExtStandbySwitchover notification
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-entstatemib-cfg'
            _revision = '2015-07-27'

            def __init__(self):
                super(Snmp.Notification.EntityState, self).__init__()

                self.yang_name = "entity-state"
                self.yang_parent_name = "notification"

                self.oper_status = YLeaf(YType.empty, "oper-status")

                self.switchover = YLeaf(YType.empty, "switchover")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("oper_status",
                                "switchover") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.EntityState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.EntityState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.oper_status.is_set or
                    self.switchover.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.oper_status.yfilter != YFilter.not_set or
                    self.switchover.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-snmp-entstatemib-cfg:entity-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.oper_status.is_set or self.oper_status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.oper_status.get_name_leafdata())
                if (self.switchover.is_set or self.switchover.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.switchover.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "oper-status" or name == "switchover"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "oper-status"):
                    self.oper_status = value
                    self.oper_status.value_namespace = name_space
                    self.oper_status.value_namespace_prefix = name_space_prefix
                if(value_path == "switchover"):
                    self.switchover = value
                    self.switchover.value_namespace = name_space
                    self.switchover.value_namespace_prefix = name_space_prefix


        class FruControl(Entity):
            """
            CISCO\-ENTITY\-FRU\-CONTROL\-MIB notification
            configuration
            
            .. attribute:: enable
            
            	Enable ciscoEntityFRUControlMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-frucontrolmib-cfg'
            _revision = '2015-01-07'

            def __init__(self):
                super(Snmp.Notification.FruControl, self).__init__()

                self.yang_name = "fru-control"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.FruControl, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.FruControl, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-snmp-frucontrolmib-cfg:fru-control" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Rf(Entity):
            """
            CISCO\-RF\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable ciscoRFMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-mib-rfmib-cfg'
            _revision = '2016-05-13'

            def __init__(self):
                super(Snmp.Notification.Rf, self).__init__()

                self.yang_name = "rf"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Rf, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Rf, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-snmp-mib-rfmib-cfg:rf" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Syslog(Entity):
            """
            CISCO\-SYSLOG\-MIB notification configuration
            
            .. attribute:: enable
            
            	Enable ciscoSyslogMIB notifications
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-syslogmib-cfg'
            _revision = '2015-12-01'

            def __init__(self):
                super(Snmp.Notification.Syslog, self).__init__()

                self.yang_name = "syslog"
                self.yang_parent_name = "notification"

                self.enable = YLeaf(YType.empty, "enable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Notification.Syslog, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Notification.Syslog, self).__setattr__(name, value)

            def has_data(self):
                return self.enable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "Cisco-IOS-XR-snmp-syslogmib-cfg:syslog" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/notification/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                (self.bfd is not None and self.bfd.has_data()) or
                (self.bgp is not None and self.bgp.has_data()) or
                (self.bridge is not None and self.bridge.has_data()) or
                (self.cfm is not None and self.cfm.has_data()) or
                (self.config_copy is not None and self.config_copy.has_data()) or
                (self.config_man is not None and self.config_man.has_data()) or
                (self.entity_ is not None and self.entity_.has_data()) or
                (self.entity_redundancy is not None and self.entity_redundancy.has_data()) or
                (self.entity_state is not None and self.entity_state.has_data()) or
                (self.flash is not None and self.flash.has_data()) or
                (self.fru_control is not None and self.fru_control.has_data()) or
                (self.hsrp is not None and self.hsrp.has_data()) or
                (self.isis is not None and self.isis.has_data()) or
                (self.l2vpn is not None and self.l2vpn.has_data()) or
                (self.mpls_frr is not None and self.mpls_frr.has_data()) or
                (self.mpls_l3vpn is not None and self.mpls_l3vpn.has_data()) or
                (self.mpls_ldp is not None and self.mpls_ldp.has_data()) or
                (self.mpls_te is not None and self.mpls_te.has_data()) or
                (self.mpls_te_p2mp is not None and self.mpls_te_p2mp.has_data()) or
                (self.ntp is not None and self.ntp.has_data()) or
                (self.oam is not None and self.oam.has_data()) or
                (self.optical is not None and self.optical.has_data()) or
                (self.ospf is not None and self.ospf.has_data()) or
                (self.ospfv3 is not None and self.ospfv3.has_data()) or
                (self.otn is not None and self.otn.has_data()) or
                (self.rf is not None and self.rf.has_data()) or
                (self.rsvp is not None and self.rsvp.has_data()) or
                (self.selective_vrf_download is not None and self.selective_vrf_download.has_data()) or
                (self.sensor is not None and self.sensor.has_data()) or
                (self.snmp is not None and self.snmp.has_data()) or
                (self.syslog is not None and self.syslog.has_data()) or
                (self.system is not None and self.system.has_data()) or
                (self.vpls is not None and self.vpls.has_data()) or
                (self.vrrp is not None and self.vrrp.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.bfd is not None and self.bfd.has_operation()) or
                (self.bgp is not None and self.bgp.has_operation()) or
                (self.bridge is not None and self.bridge.has_operation()) or
                (self.cfm is not None and self.cfm.has_operation()) or
                (self.config_copy is not None and self.config_copy.has_operation()) or
                (self.config_man is not None and self.config_man.has_operation()) or
                (self.entity_ is not None and self.entity_.has_operation()) or
                (self.entity_redundancy is not None and self.entity_redundancy.has_operation()) or
                (self.entity_state is not None and self.entity_state.has_operation()) or
                (self.flash is not None and self.flash.has_operation()) or
                (self.fru_control is not None and self.fru_control.has_operation()) or
                (self.hsrp is not None and self.hsrp.has_operation()) or
                (self.isis is not None and self.isis.has_operation()) or
                (self.l2vpn is not None and self.l2vpn.has_operation()) or
                (self.mpls_frr is not None and self.mpls_frr.has_operation()) or
                (self.mpls_l3vpn is not None and self.mpls_l3vpn.has_operation()) or
                (self.mpls_ldp is not None and self.mpls_ldp.has_operation()) or
                (self.mpls_te is not None and self.mpls_te.has_operation()) or
                (self.mpls_te_p2mp is not None and self.mpls_te_p2mp.has_operation()) or
                (self.ntp is not None and self.ntp.has_operation()) or
                (self.oam is not None and self.oam.has_operation()) or
                (self.optical is not None and self.optical.has_operation()) or
                (self.ospf is not None and self.ospf.has_operation()) or
                (self.ospfv3 is not None and self.ospfv3.has_operation()) or
                (self.otn is not None and self.otn.has_operation()) or
                (self.rf is not None and self.rf.has_operation()) or
                (self.rsvp is not None and self.rsvp.has_operation()) or
                (self.selective_vrf_download is not None and self.selective_vrf_download.has_operation()) or
                (self.sensor is not None and self.sensor.has_operation()) or
                (self.snmp is not None and self.snmp.has_operation()) or
                (self.syslog is not None and self.syslog.has_operation()) or
                (self.system is not None and self.system.has_operation()) or
                (self.vpls is not None and self.vpls.has_operation()) or
                (self.vrrp is not None and self.vrrp.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "notification" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "bfd"):
                if (self.bfd is None):
                    self.bfd = Snmp.Notification.Bfd()
                    self.bfd.parent = self
                    self._children_name_map["bfd"] = "bfd"
                return self.bfd

            if (child_yang_name == "bgp"):
                if (self.bgp is None):
                    self.bgp = Snmp.Notification.Bgp()
                    self.bgp.parent = self
                    self._children_name_map["bgp"] = "bgp"
                return self.bgp

            if (child_yang_name == "bridge"):
                if (self.bridge is None):
                    self.bridge = Snmp.Notification.Bridge()
                    self.bridge.parent = self
                    self._children_name_map["bridge"] = "bridge"
                return self.bridge

            if (child_yang_name == "cfm"):
                if (self.cfm is None):
                    self.cfm = Snmp.Notification.Cfm()
                    self.cfm.parent = self
                    self._children_name_map["cfm"] = "cfm"
                return self.cfm

            if (child_yang_name == "config-copy"):
                if (self.config_copy is None):
                    self.config_copy = Snmp.Notification.ConfigCopy()
                    self.config_copy.parent = self
                    self._children_name_map["config_copy"] = "config-copy"
                return self.config_copy

            if (child_yang_name == "config-man"):
                if (self.config_man is None):
                    self.config_man = Snmp.Notification.ConfigMan()
                    self.config_man.parent = self
                    self._children_name_map["config_man"] = "config-man"
                return self.config_man

            if (child_yang_name == "entity"):
                if (self.entity_ is None):
                    self.entity_ = Snmp.Notification.Entity_()
                    self.entity_.parent = self
                    self._children_name_map["entity_"] = "entity"
                return self.entity_

            if (child_yang_name == "entity-redundancy"):
                if (self.entity_redundancy is None):
                    self.entity_redundancy = Snmp.Notification.EntityRedundancy()
                    self.entity_redundancy.parent = self
                    self._children_name_map["entity_redundancy"] = "entity-redundancy"
                return self.entity_redundancy

            if (child_yang_name == "entity-state"):
                if (self.entity_state is None):
                    self.entity_state = Snmp.Notification.EntityState()
                    self.entity_state.parent = self
                    self._children_name_map["entity_state"] = "entity-state"
                return self.entity_state

            if (child_yang_name == "flash"):
                if (self.flash is None):
                    self.flash = Snmp.Notification.Flash()
                    self.flash.parent = self
                    self._children_name_map["flash"] = "flash"
                return self.flash

            if (child_yang_name == "fru-control"):
                if (self.fru_control is None):
                    self.fru_control = Snmp.Notification.FruControl()
                    self.fru_control.parent = self
                    self._children_name_map["fru_control"] = "fru-control"
                return self.fru_control

            if (child_yang_name == "hsrp"):
                if (self.hsrp is None):
                    self.hsrp = Snmp.Notification.Hsrp()
                    self.hsrp.parent = self
                    self._children_name_map["hsrp"] = "hsrp"
                return self.hsrp

            if (child_yang_name == "isis"):
                if (self.isis is None):
                    self.isis = Snmp.Notification.Isis()
                    self.isis.parent = self
                    self._children_name_map["isis"] = "isis"
                return self.isis

            if (child_yang_name == "l2vpn"):
                if (self.l2vpn is None):
                    self.l2vpn = Snmp.Notification.L2Vpn()
                    self.l2vpn.parent = self
                    self._children_name_map["l2vpn"] = "l2vpn"
                return self.l2vpn

            if (child_yang_name == "mpls-frr"):
                if (self.mpls_frr is None):
                    self.mpls_frr = Snmp.Notification.MplsFrr()
                    self.mpls_frr.parent = self
                    self._children_name_map["mpls_frr"] = "mpls-frr"
                return self.mpls_frr

            if (child_yang_name == "mpls-l3vpn"):
                if (self.mpls_l3vpn is None):
                    self.mpls_l3vpn = Snmp.Notification.MplsL3Vpn()
                    self.mpls_l3vpn.parent = self
                    self._children_name_map["mpls_l3vpn"] = "mpls-l3vpn"
                return self.mpls_l3vpn

            if (child_yang_name == "mpls-ldp"):
                if (self.mpls_ldp is None):
                    self.mpls_ldp = Snmp.Notification.MplsLdp()
                    self.mpls_ldp.parent = self
                    self._children_name_map["mpls_ldp"] = "mpls-ldp"
                return self.mpls_ldp

            if (child_yang_name == "mpls-te"):
                if (self.mpls_te is None):
                    self.mpls_te = Snmp.Notification.MplsTe()
                    self.mpls_te.parent = self
                    self._children_name_map["mpls_te"] = "mpls-te"
                return self.mpls_te

            if (child_yang_name == "mpls-te-p2mp"):
                if (self.mpls_te_p2mp is None):
                    self.mpls_te_p2mp = Snmp.Notification.MplsTeP2Mp()
                    self.mpls_te_p2mp.parent = self
                    self._children_name_map["mpls_te_p2mp"] = "mpls-te-p2mp"
                return self.mpls_te_p2mp

            if (child_yang_name == "ntp"):
                if (self.ntp is None):
                    self.ntp = Snmp.Notification.Ntp()
                    self.ntp.parent = self
                    self._children_name_map["ntp"] = "ntp"
                return self.ntp

            if (child_yang_name == "oam"):
                if (self.oam is None):
                    self.oam = Snmp.Notification.Oam()
                    self.oam.parent = self
                    self._children_name_map["oam"] = "oam"
                return self.oam

            if (child_yang_name == "optical"):
                if (self.optical is None):
                    self.optical = Snmp.Notification.Optical()
                    self.optical.parent = self
                    self._children_name_map["optical"] = "optical"
                return self.optical

            if (child_yang_name == "ospf"):
                if (self.ospf is None):
                    self.ospf = Snmp.Notification.Ospf()
                    self.ospf.parent = self
                    self._children_name_map["ospf"] = "ospf"
                return self.ospf

            if (child_yang_name == "ospfv3"):
                if (self.ospfv3 is None):
                    self.ospfv3 = Snmp.Notification.Ospfv3()
                    self.ospfv3.parent = self
                    self._children_name_map["ospfv3"] = "ospfv3"
                return self.ospfv3

            if (child_yang_name == "otn"):
                if (self.otn is None):
                    self.otn = Snmp.Notification.Otn()
                    self.otn.parent = self
                    self._children_name_map["otn"] = "otn"
                return self.otn

            if (child_yang_name == "rf"):
                if (self.rf is None):
                    self.rf = Snmp.Notification.Rf()
                    self.rf.parent = self
                    self._children_name_map["rf"] = "rf"
                return self.rf

            if (child_yang_name == "rsvp"):
                if (self.rsvp is None):
                    self.rsvp = Snmp.Notification.Rsvp()
                    self.rsvp.parent = self
                    self._children_name_map["rsvp"] = "rsvp"
                return self.rsvp

            if (child_yang_name == "selective-vrf-download"):
                if (self.selective_vrf_download is None):
                    self.selective_vrf_download = Snmp.Notification.SelectiveVrfDownload()
                    self.selective_vrf_download.parent = self
                    self._children_name_map["selective_vrf_download"] = "selective-vrf-download"
                return self.selective_vrf_download

            if (child_yang_name == "sensor"):
                if (self.sensor is None):
                    self.sensor = Snmp.Notification.Sensor()
                    self.sensor.parent = self
                    self._children_name_map["sensor"] = "sensor"
                return self.sensor

            if (child_yang_name == "snmp"):
                if (self.snmp is None):
                    self.snmp = Snmp.Notification.Snmp()
                    self.snmp.parent = self
                    self._children_name_map["snmp"] = "snmp"
                return self.snmp

            if (child_yang_name == "syslog"):
                if (self.syslog is None):
                    self.syslog = Snmp.Notification.Syslog()
                    self.syslog.parent = self
                    self._children_name_map["syslog"] = "syslog"
                return self.syslog

            if (child_yang_name == "system"):
                if (self.system is None):
                    self.system = Snmp.Notification.System()
                    self.system.parent = self
                    self._children_name_map["system"] = "system"
                return self.system

            if (child_yang_name == "vpls"):
                if (self.vpls is None):
                    self.vpls = Snmp.Notification.Vpls()
                    self.vpls.parent = self
                    self._children_name_map["vpls"] = "vpls"
                return self.vpls

            if (child_yang_name == "vrrp"):
                if (self.vrrp is None):
                    self.vrrp = Snmp.Notification.Vrrp()
                    self.vrrp.parent = self
                    self._children_name_map["vrrp"] = "vrrp"
                return self.vrrp

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "bfd" or name == "bgp" or name == "bridge" or name == "cfm" or name == "config-copy" or name == "config-man" or name == "entity" or name == "entity-redundancy" or name == "entity-state" or name == "flash" or name == "fru-control" or name == "hsrp" or name == "isis" or name == "l2vpn" or name == "mpls-frr" or name == "mpls-l3vpn" or name == "mpls-ldp" or name == "mpls-te" or name == "mpls-te-p2mp" or name == "ntp" or name == "oam" or name == "optical" or name == "ospf" or name == "ospfv3" or name == "otn" or name == "rf" or name == "rsvp" or name == "selective-vrf-download" or name == "sensor" or name == "snmp" or name == "syslog" or name == "system" or name == "vpls" or name == "vrrp"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Correlator(Entity):
        """
        Configure properties of the trap correlator
        
        .. attribute:: buffer_size
        
        	Configure size of the correlator buffer
        	**type**\:  int
        
        	**range:** 1024..52428800
        
        .. attribute:: rule_sets
        
        	Table of configured rulesets
        	**type**\:   :py:class:`RuleSets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.RuleSets>`
        
        .. attribute:: rules
        
        	Table of configured rules
        	**type**\:   :py:class:`Rules <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Correlator, self).__init__()

            self.yang_name = "correlator"
            self.yang_parent_name = "snmp"

            self.buffer_size = YLeaf(YType.uint32, "buffer-size")

            self.rule_sets = Snmp.Correlator.RuleSets()
            self.rule_sets.parent = self
            self._children_name_map["rule_sets"] = "rule-sets"
            self._children_yang_names.add("rule-sets")

            self.rules = Snmp.Correlator.Rules()
            self.rules.parent = self
            self._children_name_map["rules"] = "rules"
            self._children_yang_names.add("rules")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("buffer_size") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Correlator, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Correlator, self).__setattr__(name, value)


        class Rules(Entity):
            """
            Table of configured rules
            
            .. attribute:: rule
            
            	Rule name
            	**type**\: list of    :py:class:`Rule <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Correlator.Rules, self).__init__()

                self.yang_name = "rules"
                self.yang_parent_name = "correlator"

                self.rule = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Correlator.Rules, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Correlator.Rules, self).__setattr__(name, value)


            class Rule(Entity):
                """
                Rule name
                
                .. attribute:: name  <key>
                
                	Rule name
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: applied_to
                
                	Applied to the Rule or Ruleset
                	**type**\:   :py:class:`AppliedTo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.AppliedTo>`
                
                .. attribute:: non_stateful
                
                	The Non\-Stateful Rule Type
                	**type**\:   :py:class:`NonStateful <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful>`
                
                	**presence node**\: True
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Correlator.Rules.Rule, self).__init__()

                    self.yang_name = "rule"
                    self.yang_parent_name = "rules"

                    self.name = YLeaf(YType.str, "name")

                    self.applied_to = Snmp.Correlator.Rules.Rule.AppliedTo()
                    self.applied_to.parent = self
                    self._children_name_map["applied_to"] = "applied-to"
                    self._children_yang_names.add("applied-to")

                    self.non_stateful = None
                    self._children_name_map["non_stateful"] = "non-stateful"
                    self._children_yang_names.add("non-stateful")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Correlator.Rules.Rule, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Correlator.Rules.Rule, self).__setattr__(name, value)


                class NonStateful(Entity):
                    """
                    The Non\-Stateful Rule Type
                    
                    .. attribute:: non_root_causes
                    
                    	Table of configured non\-rootcause
                    	**type**\:   :py:class:`NonRootCauses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses>`
                    
                    .. attribute:: root_causes
                    
                    	Table of configured rootcause (only one entry allowed)
                    	**type**\:   :py:class:`RootCauses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.RootCauses>`
                    
                    .. attribute:: timeout
                    
                    	Timeout (time to wait for active correlation) in milliseconds
                    	**type**\:  int
                    
                    	**range:** 1..600000
                    
                    	**units**\: millisecond
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Correlator.Rules.Rule.NonStateful, self).__init__()

                        self.yang_name = "non-stateful"
                        self.yang_parent_name = "rule"
                        self.is_presence_container = True

                        self.timeout = YLeaf(YType.uint32, "timeout")

                        self.non_root_causes = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses()
                        self.non_root_causes.parent = self
                        self._children_name_map["non_root_causes"] = "non-root-causes"
                        self._children_yang_names.add("non-root-causes")

                        self.root_causes = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses()
                        self.root_causes.parent = self
                        self._children_name_map["root_causes"] = "root-causes"
                        self._children_yang_names.add("root-causes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("timeout") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Correlator.Rules.Rule.NonStateful, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Correlator.Rules.Rule.NonStateful, self).__setattr__(name, value)


                    class RootCauses(Entity):
                        """
                        Table of configured rootcause (only one
                        entry allowed)
                        
                        .. attribute:: root_cause
                        
                        	The rootcause \- maximum of one can be configured per rule
                        	**type**\: list of    :py:class:`RootCause <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause>`
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses, self).__init__()

                            self.yang_name = "root-causes"
                            self.yang_parent_name = "non-stateful"

                            self.root_cause = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses, self).__setattr__(name, value)


                        class RootCause(Entity):
                            """
                            The rootcause \- maximum of one can be
                            configured per rule
                            
                            .. attribute:: oid  <key>
                            
                            	OID of rootcause trap (dotted decimal)
                            	**type**\:  str
                            
                            .. attribute:: created
                            
                            	Create rootcause
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: var_binds
                            
                            	Varbinds to match
                            	**type**\:   :py:class:`VarBinds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds>`
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause, self).__init__()

                                self.yang_name = "root-cause"
                                self.yang_parent_name = "root-causes"

                                self.oid = YLeaf(YType.str, "oid")

                                self.created = YLeaf(YType.empty, "created")

                                self.var_binds = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds()
                                self.var_binds.parent = self
                                self._children_name_map["var_binds"] = "var-binds"
                                self._children_yang_names.add("var-binds")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("oid",
                                                "created") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause, self).__setattr__(name, value)


                            class VarBinds(Entity):
                                """
                                Varbinds to match
                                
                                .. attribute:: var_bind
                                
                                	Varbind match conditions
                                	**type**\: list of    :py:class:`VarBind <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind>`
                                
                                

                                """

                                _prefix = 'snmp-agent-cfg'
                                _revision = '2015-10-27'

                                def __init__(self):
                                    super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds, self).__init__()

                                    self.yang_name = "var-binds"
                                    self.yang_parent_name = "root-cause"

                                    self.var_bind = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds, self).__setattr__(name, value)


                                class VarBind(Entity):
                                    """
                                    Varbind match conditions
                                    
                                    .. attribute:: oid  <key>
                                    
                                    	OID of varbind (dotted decimal)
                                    	**type**\:  str
                                    
                                    .. attribute:: match
                                    
                                    	VarBind match conditions
                                    	**type**\:   :py:class:`Match <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind.Match>`
                                    
                                    

                                    """

                                    _prefix = 'snmp-agent-cfg'
                                    _revision = '2015-10-27'

                                    def __init__(self):
                                        super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind, self).__init__()

                                        self.yang_name = "var-bind"
                                        self.yang_parent_name = "var-binds"

                                        self.oid = YLeaf(YType.str, "oid")

                                        self.match = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind.Match()
                                        self.match.parent = self
                                        self._children_name_map["match"] = "match"
                                        self._children_yang_names.add("match")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("oid") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind, self).__setattr__(name, value)


                                    class Match(Entity):
                                        """
                                        VarBind match conditions
                                        
                                        .. attribute:: index
                                        
                                        	Regular Expression to match index
                                        	**type**\:  str
                                        
                                        .. attribute:: value
                                        
                                        	Regular Expression to match value
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'snmp-agent-cfg'
                                        _revision = '2015-10-27'

                                        def __init__(self):
                                            super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind.Match, self).__init__()

                                            self.yang_name = "match"
                                            self.yang_parent_name = "var-bind"

                                            self.index = YLeaf(YType.str, "index")

                                            self.value = YLeaf(YType.str, "value")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("index",
                                                            "value") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind.Match, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind.Match, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.index.is_set or
                                                self.value.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.index.yfilter != YFilter.not_set or
                                                self.value.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "match" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.index.get_name_leafdata())
                                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.value.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "index" or name == "value"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "index"):
                                                self.index = value
                                                self.index.value_namespace = name_space
                                                self.index.value_namespace_prefix = name_space_prefix
                                            if(value_path == "value"):
                                                self.value = value
                                                self.value.value_namespace = name_space
                                                self.value.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.oid.is_set or
                                            (self.match is not None and self.match.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.oid.yfilter != YFilter.not_set or
                                            (self.match is not None and self.match.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "var-bind" + "[oid='" + self.oid.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.oid.is_set or self.oid.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.oid.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "match"):
                                            if (self.match is None):
                                                self.match = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind.Match()
                                                self.match.parent = self
                                                self._children_name_map["match"] = "match"
                                            return self.match

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "match" or name == "oid"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "oid"):
                                            self.oid = value
                                            self.oid.value_namespace = name_space
                                            self.oid.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.var_bind:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.var_bind:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "var-binds" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "var-bind"):
                                        for c in self.var_bind:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds.VarBind()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.var_bind.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "var-bind"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.oid.is_set or
                                    self.created.is_set or
                                    (self.var_binds is not None and self.var_binds.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.oid.yfilter != YFilter.not_set or
                                    self.created.yfilter != YFilter.not_set or
                                    (self.var_binds is not None and self.var_binds.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "root-cause" + "[oid='" + self.oid.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.oid.is_set or self.oid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.oid.get_name_leafdata())
                                if (self.created.is_set or self.created.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.created.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "var-binds"):
                                    if (self.var_binds is None):
                                        self.var_binds = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause.VarBinds()
                                        self.var_binds.parent = self
                                        self._children_name_map["var_binds"] = "var-binds"
                                    return self.var_binds

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "var-binds" or name == "oid" or name == "created"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "oid"):
                                    self.oid = value
                                    self.oid.value_namespace = name_space
                                    self.oid.value_namespace_prefix = name_space_prefix
                                if(value_path == "created"):
                                    self.created = value
                                    self.created.value_namespace = name_space
                                    self.created.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.root_cause:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.root_cause:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "root-causes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "root-cause"):
                                for c in self.root_cause:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses.RootCause()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.root_cause.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "root-cause"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class NonRootCauses(Entity):
                        """
                        Table of configured non\-rootcause
                        
                        .. attribute:: non_root_cause
                        
                        	A non\-rootcause
                        	**type**\: list of    :py:class:`NonRootCause <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause>`
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses, self).__init__()

                            self.yang_name = "non-root-causes"
                            self.yang_parent_name = "non-stateful"

                            self.non_root_cause = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses, self).__setattr__(name, value)


                        class NonRootCause(Entity):
                            """
                            A non\-rootcause
                            
                            .. attribute:: oid  <key>
                            
                            	OID of nonrootcause trap (dotted decimal)
                            	**type**\:  str
                            
                            .. attribute:: created
                            
                            	Create nonrootcause
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: var_binds
                            
                            	Varbinds to match
                            	**type**\:   :py:class:`VarBinds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds>`
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause, self).__init__()

                                self.yang_name = "non-root-cause"
                                self.yang_parent_name = "non-root-causes"

                                self.oid = YLeaf(YType.str, "oid")

                                self.created = YLeaf(YType.empty, "created")

                                self.var_binds = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds()
                                self.var_binds.parent = self
                                self._children_name_map["var_binds"] = "var-binds"
                                self._children_yang_names.add("var-binds")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("oid",
                                                "created") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause, self).__setattr__(name, value)


                            class VarBinds(Entity):
                                """
                                Varbinds to match
                                
                                .. attribute:: var_bind
                                
                                	Varbind match conditions
                                	**type**\: list of    :py:class:`VarBind <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind>`
                                
                                

                                """

                                _prefix = 'snmp-agent-cfg'
                                _revision = '2015-10-27'

                                def __init__(self):
                                    super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds, self).__init__()

                                    self.yang_name = "var-binds"
                                    self.yang_parent_name = "non-root-cause"

                                    self.var_bind = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds, self).__setattr__(name, value)


                                class VarBind(Entity):
                                    """
                                    Varbind match conditions
                                    
                                    .. attribute:: oid  <key>
                                    
                                    	OID of varbind (dotted decimal)
                                    	**type**\:  str
                                    
                                    .. attribute:: match
                                    
                                    	VarBind match conditions
                                    	**type**\:   :py:class:`Match <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind.Match>`
                                    
                                    

                                    """

                                    _prefix = 'snmp-agent-cfg'
                                    _revision = '2015-10-27'

                                    def __init__(self):
                                        super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind, self).__init__()

                                        self.yang_name = "var-bind"
                                        self.yang_parent_name = "var-binds"

                                        self.oid = YLeaf(YType.str, "oid")

                                        self.match = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind.Match()
                                        self.match.parent = self
                                        self._children_name_map["match"] = "match"
                                        self._children_yang_names.add("match")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("oid") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind, self).__setattr__(name, value)


                                    class Match(Entity):
                                        """
                                        VarBind match conditions
                                        
                                        .. attribute:: index
                                        
                                        	Regular Expression to match index
                                        	**type**\:  str
                                        
                                        .. attribute:: value
                                        
                                        	Regular Expression to match value
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'snmp-agent-cfg'
                                        _revision = '2015-10-27'

                                        def __init__(self):
                                            super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind.Match, self).__init__()

                                            self.yang_name = "match"
                                            self.yang_parent_name = "var-bind"

                                            self.index = YLeaf(YType.str, "index")

                                            self.value = YLeaf(YType.str, "value")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("index",
                                                            "value") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind.Match, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind.Match, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.index.is_set or
                                                self.value.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.index.yfilter != YFilter.not_set or
                                                self.value.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "match" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.index.get_name_leafdata())
                                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.value.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "index" or name == "value"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "index"):
                                                self.index = value
                                                self.index.value_namespace = name_space
                                                self.index.value_namespace_prefix = name_space_prefix
                                            if(value_path == "value"):
                                                self.value = value
                                                self.value.value_namespace = name_space
                                                self.value.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.oid.is_set or
                                            (self.match is not None and self.match.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.oid.yfilter != YFilter.not_set or
                                            (self.match is not None and self.match.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "var-bind" + "[oid='" + self.oid.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.oid.is_set or self.oid.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.oid.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "match"):
                                            if (self.match is None):
                                                self.match = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind.Match()
                                                self.match.parent = self
                                                self._children_name_map["match"] = "match"
                                            return self.match

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "match" or name == "oid"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "oid"):
                                            self.oid = value
                                            self.oid.value_namespace = name_space
                                            self.oid.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.var_bind:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.var_bind:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "var-binds" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "var-bind"):
                                        for c in self.var_bind:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds.VarBind()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.var_bind.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "var-bind"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.oid.is_set or
                                    self.created.is_set or
                                    (self.var_binds is not None and self.var_binds.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.oid.yfilter != YFilter.not_set or
                                    self.created.yfilter != YFilter.not_set or
                                    (self.var_binds is not None and self.var_binds.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "non-root-cause" + "[oid='" + self.oid.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.oid.is_set or self.oid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.oid.get_name_leafdata())
                                if (self.created.is_set or self.created.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.created.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "var-binds"):
                                    if (self.var_binds is None):
                                        self.var_binds = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause.VarBinds()
                                        self.var_binds.parent = self
                                        self._children_name_map["var_binds"] = "var-binds"
                                    return self.var_binds

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "var-binds" or name == "oid" or name == "created"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "oid"):
                                    self.oid = value
                                    self.oid.value_namespace = name_space
                                    self.oid.value_namespace_prefix = name_space_prefix
                                if(value_path == "created"):
                                    self.created = value
                                    self.created.value_namespace = name_space
                                    self.created.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.non_root_cause:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.non_root_cause:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "non-root-causes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "non-root-cause"):
                                for c in self.non_root_cause:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses.NonRootCause()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.non_root_cause.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "non-root-cause"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.timeout.is_set or
                            (self.non_root_causes is not None and self.non_root_causes.has_data()) or
                            (self.root_causes is not None and self.root_causes.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.timeout.yfilter != YFilter.not_set or
                            (self.non_root_causes is not None and self.non_root_causes.has_operation()) or
                            (self.root_causes is not None and self.root_causes.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "non-stateful" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.timeout.is_set or self.timeout.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.timeout.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "non-root-causes"):
                            if (self.non_root_causes is None):
                                self.non_root_causes = Snmp.Correlator.Rules.Rule.NonStateful.NonRootCauses()
                                self.non_root_causes.parent = self
                                self._children_name_map["non_root_causes"] = "non-root-causes"
                            return self.non_root_causes

                        if (child_yang_name == "root-causes"):
                            if (self.root_causes is None):
                                self.root_causes = Snmp.Correlator.Rules.Rule.NonStateful.RootCauses()
                                self.root_causes.parent = self
                                self._children_name_map["root_causes"] = "root-causes"
                            return self.root_causes

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "non-root-causes" or name == "root-causes" or name == "timeout"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "timeout"):
                            self.timeout = value
                            self.timeout.value_namespace = name_space
                            self.timeout.value_namespace_prefix = name_space_prefix


                class AppliedTo(Entity):
                    """
                    Applied to the Rule or Ruleset
                    
                    .. attribute:: all
                    
                    	Apply to all of the device
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: hosts
                    
                    	Table of configured hosts to apply rules to
                    	**type**\:   :py:class:`Hosts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.AppliedTo.Hosts>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Correlator.Rules.Rule.AppliedTo, self).__init__()

                        self.yang_name = "applied-to"
                        self.yang_parent_name = "rule"

                        self.all = YLeaf(YType.empty, "all")

                        self.hosts = Snmp.Correlator.Rules.Rule.AppliedTo.Hosts()
                        self.hosts.parent = self
                        self._children_name_map["hosts"] = "hosts"
                        self._children_yang_names.add("hosts")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("all") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Correlator.Rules.Rule.AppliedTo, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Correlator.Rules.Rule.AppliedTo, self).__setattr__(name, value)


                    class Hosts(Entity):
                        """
                        Table of configured hosts to apply rules to
                        
                        .. attribute:: host
                        
                        	A destination host
                        	**type**\: list of    :py:class:`Host <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.Rules.Rule.AppliedTo.Hosts.Host>`
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Correlator.Rules.Rule.AppliedTo.Hosts, self).__init__()

                            self.yang_name = "hosts"
                            self.yang_parent_name = "applied-to"

                            self.host = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Correlator.Rules.Rule.AppliedTo.Hosts, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Correlator.Rules.Rule.AppliedTo.Hosts, self).__setattr__(name, value)


                        class Host(Entity):
                            """
                            A destination host
                            
                            .. attribute:: ip_address  <key>
                            
                            	IP address
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: port  <key>
                            
                            	Port (specify 162 for default)
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Correlator.Rules.Rule.AppliedTo.Hosts.Host, self).__init__()

                                self.yang_name = "host"
                                self.yang_parent_name = "hosts"

                                self.ip_address = YLeaf(YType.str, "ip-address")

                                self.port = YLeaf(YType.uint16, "port")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip_address",
                                                "port") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Correlator.Rules.Rule.AppliedTo.Hosts.Host, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Correlator.Rules.Rule.AppliedTo.Hosts.Host, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip_address.is_set or
                                    self.port.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip_address.yfilter != YFilter.not_set or
                                    self.port.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "host" + "[ip-address='" + self.ip_address.get() + "']" + "[port='" + self.port.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip_address.get_name_leafdata())
                                if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip-address" or name == "port"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip-address"):
                                    self.ip_address = value
                                    self.ip_address.value_namespace = name_space
                                    self.ip_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "port"):
                                    self.port = value
                                    self.port.value_namespace = name_space
                                    self.port.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.host:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.host:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hosts" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "host"):
                                for c in self.host:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Snmp.Correlator.Rules.Rule.AppliedTo.Hosts.Host()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.host.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "host"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.all.is_set or
                            (self.hosts is not None and self.hosts.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.all.yfilter != YFilter.not_set or
                            (self.hosts is not None and self.hosts.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "applied-to" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.all.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "hosts"):
                            if (self.hosts is None):
                                self.hosts = Snmp.Correlator.Rules.Rule.AppliedTo.Hosts()
                                self.hosts.parent = self
                                self._children_name_map["hosts"] = "hosts"
                            return self.hosts

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "hosts" or name == "all"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "all"):
                            self.all = value
                            self.all.value_namespace = name_space
                            self.all.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.applied_to is not None and self.applied_to.has_data()) or
                        (self.non_stateful is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.applied_to is not None and self.applied_to.has_operation()) or
                        (self.non_stateful is not None and self.non_stateful.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rule" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/correlator/rules/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "applied-to"):
                        if (self.applied_to is None):
                            self.applied_to = Snmp.Correlator.Rules.Rule.AppliedTo()
                            self.applied_to.parent = self
                            self._children_name_map["applied_to"] = "applied-to"
                        return self.applied_to

                    if (child_yang_name == "non-stateful"):
                        if (self.non_stateful is None):
                            self.non_stateful = Snmp.Correlator.Rules.Rule.NonStateful()
                            self.non_stateful.parent = self
                            self._children_name_map["non_stateful"] = "non-stateful"
                        return self.non_stateful

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "applied-to" or name == "non-stateful" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.rule:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.rule:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "rules" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/correlator/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "rule"):
                    for c in self.rule:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.Correlator.Rules.Rule()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.rule.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "rule"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class RuleSets(Entity):
            """
            Table of configured rulesets
            
            .. attribute:: rule_set
            
            	Ruleset name
            	**type**\: list of    :py:class:`RuleSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.RuleSets.RuleSet>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Correlator.RuleSets, self).__init__()

                self.yang_name = "rule-sets"
                self.yang_parent_name = "correlator"

                self.rule_set = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Correlator.RuleSets, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Correlator.RuleSets, self).__setattr__(name, value)


            class RuleSet(Entity):
                """
                Ruleset name
                
                .. attribute:: name  <key>
                
                	Ruleset name
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: applied_to
                
                	Applied to the Rule or Ruleset
                	**type**\:   :py:class:`AppliedTo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.RuleSets.RuleSet.AppliedTo>`
                
                .. attribute:: rulenames
                
                	Table of configured rulenames
                	**type**\:   :py:class:`Rulenames <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.RuleSets.RuleSet.Rulenames>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Correlator.RuleSets.RuleSet, self).__init__()

                    self.yang_name = "rule-set"
                    self.yang_parent_name = "rule-sets"

                    self.name = YLeaf(YType.str, "name")

                    self.applied_to = Snmp.Correlator.RuleSets.RuleSet.AppliedTo()
                    self.applied_to.parent = self
                    self._children_name_map["applied_to"] = "applied-to"
                    self._children_yang_names.add("applied-to")

                    self.rulenames = Snmp.Correlator.RuleSets.RuleSet.Rulenames()
                    self.rulenames.parent = self
                    self._children_name_map["rulenames"] = "rulenames"
                    self._children_yang_names.add("rulenames")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Correlator.RuleSets.RuleSet, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Correlator.RuleSets.RuleSet, self).__setattr__(name, value)


                class Rulenames(Entity):
                    """
                    Table of configured rulenames
                    
                    .. attribute:: rulename
                    
                    	A rulename
                    	**type**\: list of    :py:class:`Rulename <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.RuleSets.RuleSet.Rulenames.Rulename>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Correlator.RuleSets.RuleSet.Rulenames, self).__init__()

                        self.yang_name = "rulenames"
                        self.yang_parent_name = "rule-set"

                        self.rulename = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Correlator.RuleSets.RuleSet.Rulenames, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Correlator.RuleSets.RuleSet.Rulenames, self).__setattr__(name, value)


                    class Rulename(Entity):
                        """
                        A rulename
                        
                        .. attribute:: rulename  <key>
                        
                        	Rule name
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Correlator.RuleSets.RuleSet.Rulenames.Rulename, self).__init__()

                            self.yang_name = "rulename"
                            self.yang_parent_name = "rulenames"

                            self.rulename = YLeaf(YType.str, "rulename")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rulename") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Correlator.RuleSets.RuleSet.Rulenames.Rulename, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Correlator.RuleSets.RuleSet.Rulenames.Rulename, self).__setattr__(name, value)

                        def has_data(self):
                            return self.rulename.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rulename.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rulename" + "[rulename='" + self.rulename.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rulename.is_set or self.rulename.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rulename.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "rulename"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rulename"):
                                self.rulename = value
                                self.rulename.value_namespace = name_space
                                self.rulename.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.rulename:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.rulename:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rulenames" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "rulename"):
                            for c in self.rulename:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Snmp.Correlator.RuleSets.RuleSet.Rulenames.Rulename()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.rulename.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rulename"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AppliedTo(Entity):
                    """
                    Applied to the Rule or Ruleset
                    
                    .. attribute:: all
                    
                    	Apply to all of the device
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: hosts
                    
                    	Table of configured hosts to apply rules to
                    	**type**\:   :py:class:`Hosts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo, self).__init__()

                        self.yang_name = "applied-to"
                        self.yang_parent_name = "rule-set"

                        self.all = YLeaf(YType.empty, "all")

                        self.hosts = Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts()
                        self.hosts.parent = self
                        self._children_name_map["hosts"] = "hosts"
                        self._children_yang_names.add("hosts")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("all") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo, self).__setattr__(name, value)


                    class Hosts(Entity):
                        """
                        Table of configured hosts to apply rules to
                        
                        .. attribute:: host
                        
                        	A destination host
                        	**type**\: list of    :py:class:`Host <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts.Host>`
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts, self).__init__()

                            self.yang_name = "hosts"
                            self.yang_parent_name = "applied-to"

                            self.host = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts, self).__setattr__(name, value)


                        class Host(Entity):
                            """
                            A destination host
                            
                            .. attribute:: ip_address  <key>
                            
                            	IP address
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: port  <key>
                            
                            	Port (specify 162 for default)
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts.Host, self).__init__()

                                self.yang_name = "host"
                                self.yang_parent_name = "hosts"

                                self.ip_address = YLeaf(YType.str, "ip-address")

                                self.port = YLeaf(YType.uint16, "port")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip_address",
                                                "port") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts.Host, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts.Host, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip_address.is_set or
                                    self.port.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip_address.yfilter != YFilter.not_set or
                                    self.port.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "host" + "[ip-address='" + self.ip_address.get() + "']" + "[port='" + self.port.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip_address.get_name_leafdata())
                                if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip-address" or name == "port"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip-address"):
                                    self.ip_address = value
                                    self.ip_address.value_namespace = name_space
                                    self.ip_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "port"):
                                    self.port = value
                                    self.port.value_namespace = name_space
                                    self.port.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.host:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.host:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hosts" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "host"):
                                for c in self.host:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts.Host()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.host.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "host"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.all.is_set or
                            (self.hosts is not None and self.hosts.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.all.yfilter != YFilter.not_set or
                            (self.hosts is not None and self.hosts.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "applied-to" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.all.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "hosts"):
                            if (self.hosts is None):
                                self.hosts = Snmp.Correlator.RuleSets.RuleSet.AppliedTo.Hosts()
                                self.hosts.parent = self
                                self._children_name_map["hosts"] = "hosts"
                            return self.hosts

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "hosts" or name == "all"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "all"):
                            self.all = value
                            self.all.value_namespace = name_space
                            self.all.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.applied_to is not None and self.applied_to.has_data()) or
                        (self.rulenames is not None and self.rulenames.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.applied_to is not None and self.applied_to.has_operation()) or
                        (self.rulenames is not None and self.rulenames.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rule-set" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/correlator/rule-sets/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "applied-to"):
                        if (self.applied_to is None):
                            self.applied_to = Snmp.Correlator.RuleSets.RuleSet.AppliedTo()
                            self.applied_to.parent = self
                            self._children_name_map["applied_to"] = "applied-to"
                        return self.applied_to

                    if (child_yang_name == "rulenames"):
                        if (self.rulenames is None):
                            self.rulenames = Snmp.Correlator.RuleSets.RuleSet.Rulenames()
                            self.rulenames.parent = self
                            self._children_name_map["rulenames"] = "rulenames"
                        return self.rulenames

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "applied-to" or name == "rulenames" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.rule_set:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.rule_set:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "rule-sets" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/correlator/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "rule-set"):
                    for c in self.rule_set:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.Correlator.RuleSets.RuleSet()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.rule_set.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "rule-set"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.buffer_size.is_set or
                (self.rule_sets is not None and self.rule_sets.has_data()) or
                (self.rules is not None and self.rules.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.buffer_size.yfilter != YFilter.not_set or
                (self.rule_sets is not None and self.rule_sets.has_operation()) or
                (self.rules is not None and self.rules.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "correlator" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.buffer_size.is_set or self.buffer_size.yfilter != YFilter.not_set):
                leaf_name_data.append(self.buffer_size.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "rule-sets"):
                if (self.rule_sets is None):
                    self.rule_sets = Snmp.Correlator.RuleSets()
                    self.rule_sets.parent = self
                    self._children_name_map["rule_sets"] = "rule-sets"
                return self.rule_sets

            if (child_yang_name == "rules"):
                if (self.rules is None):
                    self.rules = Snmp.Correlator.Rules()
                    self.rules.parent = self
                    self._children_name_map["rules"] = "rules"
                return self.rules

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "rule-sets" or name == "rules" or name == "buffer-size"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "buffer-size"):
                self.buffer_size = value
                self.buffer_size.value_namespace = name_space
                self.buffer_size.value_namespace_prefix = name_space_prefix


    class BulkStats(Entity):
        """
        SNMP bulk stats configuration commands
        
        .. attribute:: memory
        
        	per process memory limit in kilo bytes
        	**type**\:  int
        
        	**range:** 100..200000
        
        	**units**\: kilobyte
        
        .. attribute:: objects
        
        	Configure an Object List 
        	**type**\:   :py:class:`Objects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Objects>`
        
        .. attribute:: schemas
        
        	Configure schema definition
        	**type**\:   :py:class:`Schemas <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Schemas>`
        
        .. attribute:: transfers
        
        	Periodicity for the transfer of bulk data in minutes
        	**type**\:   :py:class:`Transfers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Transfers>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.BulkStats, self).__init__()

            self.yang_name = "bulk-stats"
            self.yang_parent_name = "snmp"

            self.memory = YLeaf(YType.uint32, "memory")

            self.objects = Snmp.BulkStats.Objects()
            self.objects.parent = self
            self._children_name_map["objects"] = "objects"
            self._children_yang_names.add("objects")

            self.schemas = Snmp.BulkStats.Schemas()
            self.schemas.parent = self
            self._children_name_map["schemas"] = "schemas"
            self._children_yang_names.add("schemas")

            self.transfers = Snmp.BulkStats.Transfers()
            self.transfers.parent = self
            self._children_name_map["transfers"] = "transfers"
            self._children_yang_names.add("transfers")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("memory") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.BulkStats, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.BulkStats, self).__setattr__(name, value)


        class Schemas(Entity):
            """
            Configure schema definition
            
            .. attribute:: schema
            
            	The name of the Schema
            	**type**\: list of    :py:class:`Schema <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Schemas.Schema>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.BulkStats.Schemas, self).__init__()

                self.yang_name = "schemas"
                self.yang_parent_name = "bulk-stats"

                self.schema = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.BulkStats.Schemas, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.BulkStats.Schemas, self).__setattr__(name, value)


            class Schema(Entity):
                """
                The name of the Schema
                
                .. attribute:: schema_name  <key>
                
                	The name of the schema
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: instance
                
                	Object instance information
                	**type**\:   :py:class:`Instance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Schemas.Schema.Instance>`
                
                	**presence node**\: True
                
                .. attribute:: poll_interval
                
                	Periodicity for polling of objects in this schema in minutes
                	**type**\:  int
                
                	**range:** 1..20000
                
                	**units**\: minute
                
                .. attribute:: schema_object_list
                
                	Name of an object List
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: type
                
                	Configure schema name
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.BulkStats.Schemas.Schema, self).__init__()

                    self.yang_name = "schema"
                    self.yang_parent_name = "schemas"

                    self.schema_name = YLeaf(YType.str, "schema-name")

                    self.poll_interval = YLeaf(YType.uint32, "poll-interval")

                    self.schema_object_list = YLeaf(YType.str, "schema-object-list")

                    self.type = YLeaf(YType.empty, "type")

                    self.instance = None
                    self._children_name_map["instance"] = "instance"
                    self._children_yang_names.add("instance")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("schema_name",
                                    "poll_interval",
                                    "schema_object_list",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.BulkStats.Schemas.Schema, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.BulkStats.Schemas.Schema, self).__setattr__(name, value)


                class Instance(Entity):
                    """
                    Object instance information
                    
                    .. attribute:: end
                    
                    	End Instance OID for repetition
                    	**type**\:  str
                    
                    	**mandatory**\: True
                    
                    .. attribute:: instance
                    
                    	Instance of the schema
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: max
                    
                    	Max value of Instance repetition
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**mandatory**\: True
                    
                    .. attribute:: start
                    
                    	Start Instance OID for repetition
                    	**type**\:  str
                    
                    	**mandatory**\: True
                    
                    .. attribute:: sub_interface
                    
                    	Include all the subinterface
                    	**type**\:  bool
                    
                    	**mandatory**\: True
                    
                    .. attribute:: type
                    
                    	Type of the instance
                    	**type**\:   :py:class:`SnmpBulkstatSchema <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpBulkstatSchema>`
                    
                    	**mandatory**\: True
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.BulkStats.Schemas.Schema.Instance, self).__init__()

                        self.yang_name = "instance"
                        self.yang_parent_name = "schema"
                        self.is_presence_container = True

                        self.end = YLeaf(YType.str, "end")

                        self.instance = YLeaf(YType.str, "instance")

                        self.max = YLeaf(YType.int32, "max")

                        self.start = YLeaf(YType.str, "start")

                        self.sub_interface = YLeaf(YType.boolean, "sub-interface")

                        self.type = YLeaf(YType.enumeration, "type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("end",
                                        "instance",
                                        "max",
                                        "start",
                                        "sub_interface",
                                        "type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.BulkStats.Schemas.Schema.Instance, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.BulkStats.Schemas.Schema.Instance, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.end.is_set or
                            self.instance.is_set or
                            self.max.is_set or
                            self.start.is_set or
                            self.sub_interface.is_set or
                            self.type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.end.yfilter != YFilter.not_set or
                            self.instance.yfilter != YFilter.not_set or
                            self.max.yfilter != YFilter.not_set or
                            self.start.yfilter != YFilter.not_set or
                            self.sub_interface.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "instance" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.end.is_set or self.end.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.end.get_name_leafdata())
                        if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.instance.get_name_leafdata())
                        if (self.max.is_set or self.max.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max.get_name_leafdata())
                        if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.start.get_name_leafdata())
                        if (self.sub_interface.is_set or self.sub_interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sub_interface.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "end" or name == "instance" or name == "max" or name == "start" or name == "sub-interface" or name == "type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "end"):
                            self.end = value
                            self.end.value_namespace = name_space
                            self.end.value_namespace_prefix = name_space_prefix
                        if(value_path == "instance"):
                            self.instance = value
                            self.instance.value_namespace = name_space
                            self.instance.value_namespace_prefix = name_space_prefix
                        if(value_path == "max"):
                            self.max = value
                            self.max.value_namespace = name_space
                            self.max.value_namespace_prefix = name_space_prefix
                        if(value_path == "start"):
                            self.start = value
                            self.start.value_namespace = name_space
                            self.start.value_namespace_prefix = name_space_prefix
                        if(value_path == "sub-interface"):
                            self.sub_interface = value
                            self.sub_interface.value_namespace = name_space
                            self.sub_interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.schema_name.is_set or
                        self.poll_interval.is_set or
                        self.schema_object_list.is_set or
                        self.type.is_set or
                        (self.instance is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.schema_name.yfilter != YFilter.not_set or
                        self.poll_interval.yfilter != YFilter.not_set or
                        self.schema_object_list.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set or
                        (self.instance is not None and self.instance.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "schema" + "[schema-name='" + self.schema_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/bulk-stats/schemas/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.schema_name.is_set or self.schema_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.schema_name.get_name_leafdata())
                    if (self.poll_interval.is_set or self.poll_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.poll_interval.get_name_leafdata())
                    if (self.schema_object_list.is_set or self.schema_object_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.schema_object_list.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "instance"):
                        if (self.instance is None):
                            self.instance = Snmp.BulkStats.Schemas.Schema.Instance()
                            self.instance.parent = self
                            self._children_name_map["instance"] = "instance"
                        return self.instance

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "instance" or name == "schema-name" or name == "poll-interval" or name == "schema-object-list" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "schema-name"):
                        self.schema_name = value
                        self.schema_name.value_namespace = name_space
                        self.schema_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "poll-interval"):
                        self.poll_interval = value
                        self.poll_interval.value_namespace = name_space
                        self.poll_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "schema-object-list"):
                        self.schema_object_list = value
                        self.schema_object_list.value_namespace = name_space
                        self.schema_object_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.schema:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.schema:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "schemas" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/bulk-stats/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "schema"):
                    for c in self.schema:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.BulkStats.Schemas.Schema()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.schema.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "schema"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Objects(Entity):
            """
            Configure an Object List 
            
            .. attribute:: object
            
            	Name of the object List
            	**type**\: list of    :py:class:`Object <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Objects.Object>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.BulkStats.Objects, self).__init__()

                self.yang_name = "objects"
                self.yang_parent_name = "bulk-stats"

                self.object = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.BulkStats.Objects, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.BulkStats.Objects, self).__setattr__(name, value)


            class Object(Entity):
                """
                Name of the object List
                
                .. attribute:: object_list_name  <key>
                
                	Name of the object List
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: objects
                
                	Configure an object List
                	**type**\:   :py:class:`Objects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Objects.Object.Objects>`
                
                .. attribute:: type
                
                	Configure object list name
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.BulkStats.Objects.Object, self).__init__()

                    self.yang_name = "object"
                    self.yang_parent_name = "objects"

                    self.object_list_name = YLeaf(YType.str, "object-list-name")

                    self.type = YLeaf(YType.empty, "type")

                    self.objects = Snmp.BulkStats.Objects.Object.Objects()
                    self.objects.parent = self
                    self._children_name_map["objects"] = "objects"
                    self._children_yang_names.add("objects")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("object_list_name",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.BulkStats.Objects.Object, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.BulkStats.Objects.Object, self).__setattr__(name, value)


                class Objects(Entity):
                    """
                    Configure an object List
                    
                    .. attribute:: object
                    
                    	Object name or OID
                    	**type**\: list of    :py:class:`Object <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Objects.Object.Objects.Object>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.BulkStats.Objects.Object.Objects, self).__init__()

                        self.yang_name = "objects"
                        self.yang_parent_name = "object"

                        self.object = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.BulkStats.Objects.Object.Objects, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.BulkStats.Objects.Object.Objects, self).__setattr__(name, value)


                    class Object(Entity):
                        """
                        Object name or OID
                        
                        .. attribute:: oid  <key>
                        
                        	Object name or OID 
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.BulkStats.Objects.Object.Objects.Object, self).__init__()

                            self.yang_name = "object"
                            self.yang_parent_name = "objects"

                            self.oid = YLeaf(YType.str, "oid")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("oid") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.BulkStats.Objects.Object.Objects.Object, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.BulkStats.Objects.Object.Objects.Object, self).__setattr__(name, value)

                        def has_data(self):
                            return self.oid.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.oid.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "object" + "[oid='" + self.oid.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.oid.is_set or self.oid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.oid.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "oid"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "oid"):
                                self.oid = value
                                self.oid.value_namespace = name_space
                                self.oid.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.object:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.object:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "objects" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "object"):
                            for c in self.object:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Snmp.BulkStats.Objects.Object.Objects.Object()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.object.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "object"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.object_list_name.is_set or
                        self.type.is_set or
                        (self.objects is not None and self.objects.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.object_list_name.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set or
                        (self.objects is not None and self.objects.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "object" + "[object-list-name='" + self.object_list_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/bulk-stats/objects/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.object_list_name.is_set or self.object_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.object_list_name.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "objects"):
                        if (self.objects is None):
                            self.objects = Snmp.BulkStats.Objects.Object.Objects()
                            self.objects.parent = self
                            self._children_name_map["objects"] = "objects"
                        return self.objects

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "objects" or name == "object-list-name" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "object-list-name"):
                        self.object_list_name = value
                        self.object_list_name.value_namespace = name_space
                        self.object_list_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.object:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.object:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "objects" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/bulk-stats/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "object"):
                    for c in self.object:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.BulkStats.Objects.Object()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.object.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "object"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Transfers(Entity):
            """
            Periodicity for the transfer of bulk data in
            minutes
            
            .. attribute:: transfer
            
            	Name of bulk transfer
            	**type**\: list of    :py:class:`Transfer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Transfers.Transfer>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.BulkStats.Transfers, self).__init__()

                self.yang_name = "transfers"
                self.yang_parent_name = "bulk-stats"

                self.transfer = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.BulkStats.Transfers, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.BulkStats.Transfers, self).__setattr__(name, value)


            class Transfer(Entity):
                """
                Name of bulk transfer
                
                .. attribute:: transfer_name  <key>
                
                	Name of bulk transfer
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: buffer_size
                
                	Bulkstat data file maximum size in bytes
                	**type**\:  int
                
                	**range:** 1024..2147483647
                
                	**units**\: byte
                
                .. attribute:: enable
                
                	Start Data Collection for this Configuration
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: format
                
                	Format of the bulk data file
                	**type**\:   :py:class:`SnmpBulkstatFileFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpBulkstatFileFormat>`
                
                .. attribute:: interval
                
                	Periodicity for the transfer of bulk data in minutes
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                	**units**\: minute
                
                .. attribute:: primary
                
                	FTP or rcp or TFTP can be used for file transfer
                	**type**\:  str
                
                .. attribute:: retain
                
                	Retention period in minutes
                	**type**\:  int
                
                	**range:** 0..20000
                
                	**units**\: minute
                
                .. attribute:: retry
                
                	Number of transmission retries
                	**type**\:  int
                
                	**range:** 0..100
                
                .. attribute:: secondary
                
                	FTP or rcp or TFTP can be used for file transfer
                	**type**\:  str
                
                .. attribute:: transfer_schemas
                
                	Schema that contains objects to be collected
                	**type**\:   :py:class:`TransferSchemas <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Transfers.Transfer.TransferSchemas>`
                
                .. attribute:: type
                
                	Configure transfer list name
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.BulkStats.Transfers.Transfer, self).__init__()

                    self.yang_name = "transfer"
                    self.yang_parent_name = "transfers"

                    self.transfer_name = YLeaf(YType.str, "transfer-name")

                    self.buffer_size = YLeaf(YType.uint32, "buffer-size")

                    self.enable = YLeaf(YType.empty, "enable")

                    self.format = YLeaf(YType.enumeration, "format")

                    self.interval = YLeaf(YType.int32, "interval")

                    self.primary = YLeaf(YType.str, "primary")

                    self.retain = YLeaf(YType.uint32, "retain")

                    self.retry = YLeaf(YType.uint32, "retry")

                    self.secondary = YLeaf(YType.str, "secondary")

                    self.type = YLeaf(YType.empty, "type")

                    self.transfer_schemas = Snmp.BulkStats.Transfers.Transfer.TransferSchemas()
                    self.transfer_schemas.parent = self
                    self._children_name_map["transfer_schemas"] = "transfer-schemas"
                    self._children_yang_names.add("transfer-schemas")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("transfer_name",
                                    "buffer_size",
                                    "enable",
                                    "format",
                                    "interval",
                                    "primary",
                                    "retain",
                                    "retry",
                                    "secondary",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.BulkStats.Transfers.Transfer, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.BulkStats.Transfers.Transfer, self).__setattr__(name, value)


                class TransferSchemas(Entity):
                    """
                    Schema that contains objects to be collected
                    
                    .. attribute:: transfer_schema
                    
                    	Schema that contains objects to be collected
                    	**type**\: list of    :py:class:`TransferSchema <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.BulkStats.Transfers.Transfer.TransferSchemas.TransferSchema>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.BulkStats.Transfers.Transfer.TransferSchemas, self).__init__()

                        self.yang_name = "transfer-schemas"
                        self.yang_parent_name = "transfer"

                        self.transfer_schema = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.BulkStats.Transfers.Transfer.TransferSchemas, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.BulkStats.Transfers.Transfer.TransferSchemas, self).__setattr__(name, value)


                    class TransferSchema(Entity):
                        """
                        Schema that contains objects to be collected
                        
                        .. attribute:: schema_name  <key>
                        
                        	Schema that contains objects to be collected
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.BulkStats.Transfers.Transfer.TransferSchemas.TransferSchema, self).__init__()

                            self.yang_name = "transfer-schema"
                            self.yang_parent_name = "transfer-schemas"

                            self.schema_name = YLeaf(YType.str, "schema-name")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("schema_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.BulkStats.Transfers.Transfer.TransferSchemas.TransferSchema, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.BulkStats.Transfers.Transfer.TransferSchemas.TransferSchema, self).__setattr__(name, value)

                        def has_data(self):
                            return self.schema_name.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.schema_name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "transfer-schema" + "[schema-name='" + self.schema_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.schema_name.is_set or self.schema_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.schema_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "schema-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "schema-name"):
                                self.schema_name = value
                                self.schema_name.value_namespace = name_space
                                self.schema_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.transfer_schema:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.transfer_schema:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transfer-schemas" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "transfer-schema"):
                            for c in self.transfer_schema:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Snmp.BulkStats.Transfers.Transfer.TransferSchemas.TransferSchema()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.transfer_schema.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "transfer-schema"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.transfer_name.is_set or
                        self.buffer_size.is_set or
                        self.enable.is_set or
                        self.format.is_set or
                        self.interval.is_set or
                        self.primary.is_set or
                        self.retain.is_set or
                        self.retry.is_set or
                        self.secondary.is_set or
                        self.type.is_set or
                        (self.transfer_schemas is not None and self.transfer_schemas.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.transfer_name.yfilter != YFilter.not_set or
                        self.buffer_size.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.format.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.primary.yfilter != YFilter.not_set or
                        self.retain.yfilter != YFilter.not_set or
                        self.retry.yfilter != YFilter.not_set or
                        self.secondary.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set or
                        (self.transfer_schemas is not None and self.transfer_schemas.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "transfer" + "[transfer-name='" + self.transfer_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/bulk-stats/transfers/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.transfer_name.is_set or self.transfer_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.transfer_name.get_name_leafdata())
                    if (self.buffer_size.is_set or self.buffer_size.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.buffer_size.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.format.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.primary.is_set or self.primary.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.primary.get_name_leafdata())
                    if (self.retain.is_set or self.retain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retain.get_name_leafdata())
                    if (self.retry.is_set or self.retry.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry.get_name_leafdata())
                    if (self.secondary.is_set or self.secondary.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.secondary.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "transfer-schemas"):
                        if (self.transfer_schemas is None):
                            self.transfer_schemas = Snmp.BulkStats.Transfers.Transfer.TransferSchemas()
                            self.transfer_schemas.parent = self
                            self._children_name_map["transfer_schemas"] = "transfer-schemas"
                        return self.transfer_schemas

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "transfer-schemas" or name == "transfer-name" or name == "buffer-size" or name == "enable" or name == "format" or name == "interval" or name == "primary" or name == "retain" or name == "retry" or name == "secondary" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "transfer-name"):
                        self.transfer_name = value
                        self.transfer_name.value_namespace = name_space
                        self.transfer_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "buffer-size"):
                        self.buffer_size = value
                        self.buffer_size.value_namespace = name_space
                        self.buffer_size.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "format"):
                        self.format = value
                        self.format.value_namespace = name_space
                        self.format.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "primary"):
                        self.primary = value
                        self.primary.value_namespace = name_space
                        self.primary.value_namespace_prefix = name_space_prefix
                    if(value_path == "retain"):
                        self.retain = value
                        self.retain.value_namespace = name_space
                        self.retain.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry"):
                        self.retry = value
                        self.retry.value_namespace = name_space
                        self.retry.value_namespace_prefix = name_space_prefix
                    if(value_path == "secondary"):
                        self.secondary = value
                        self.secondary.value_namespace = name_space
                        self.secondary.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.transfer:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.transfer:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "transfers" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/bulk-stats/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "transfer"):
                    for c in self.transfer:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Snmp.BulkStats.Transfers.Transfer()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.transfer.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "transfer"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.memory.is_set or
                (self.objects is not None and self.objects.has_data()) or
                (self.schemas is not None and self.schemas.has_data()) or
                (self.transfers is not None and self.transfers.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.memory.yfilter != YFilter.not_set or
                (self.objects is not None and self.objects.has_operation()) or
                (self.schemas is not None and self.schemas.has_operation()) or
                (self.transfers is not None and self.transfers.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "bulk-stats" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.memory.is_set or self.memory.yfilter != YFilter.not_set):
                leaf_name_data.append(self.memory.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "objects"):
                if (self.objects is None):
                    self.objects = Snmp.BulkStats.Objects()
                    self.objects.parent = self
                    self._children_name_map["objects"] = "objects"
                return self.objects

            if (child_yang_name == "schemas"):
                if (self.schemas is None):
                    self.schemas = Snmp.BulkStats.Schemas()
                    self.schemas.parent = self
                    self._children_name_map["schemas"] = "schemas"
                return self.schemas

            if (child_yang_name == "transfers"):
                if (self.transfers is None):
                    self.transfers = Snmp.BulkStats.Transfers()
                    self.transfers.parent = self
                    self._children_name_map["transfers"] = "transfers"
                return self.transfers

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "objects" or name == "schemas" or name == "transfers" or name == "memory"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "memory"):
                self.memory = value
                self.memory.value_namespace = name_space
                self.memory.value_namespace_prefix = name_space_prefix


    class DefaultCommunityMaps(Entity):
        """
        Container class to hold unencrpted community map
        
        .. attribute:: default_community_map
        
        	Unencrpted SNMP community map name 
        	**type**\: list of    :py:class:`DefaultCommunityMap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.DefaultCommunityMaps.DefaultCommunityMap>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.DefaultCommunityMaps, self).__init__()

            self.yang_name = "default-community-maps"
            self.yang_parent_name = "snmp"

            self.default_community_map = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.DefaultCommunityMaps, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.DefaultCommunityMaps, self).__setattr__(name, value)


        class DefaultCommunityMap(Entity):
            """
            Unencrpted SNMP community map name 
            
            .. attribute:: community_name  <key>
            
            	SNMP community map
            	**type**\:  str
            
            	**length:** 1..128
            
            .. attribute:: context
            
            	SNMP Context Name 
            	**type**\:  str
            
            .. attribute:: security
            
            	SNMP Security Name 
            	**type**\:  str
            
            .. attribute:: target_list
            
            	target list name 
            	**type**\:  str
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.DefaultCommunityMaps.DefaultCommunityMap, self).__init__()

                self.yang_name = "default-community-map"
                self.yang_parent_name = "default-community-maps"

                self.community_name = YLeaf(YType.str, "community-name")

                self.context = YLeaf(YType.str, "context")

                self.security = YLeaf(YType.str, "security")

                self.target_list = YLeaf(YType.str, "target-list")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("community_name",
                                "context",
                                "security",
                                "target_list") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.DefaultCommunityMaps.DefaultCommunityMap, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.DefaultCommunityMaps.DefaultCommunityMap, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.community_name.is_set or
                    self.context.is_set or
                    self.security.is_set or
                    self.target_list.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.community_name.yfilter != YFilter.not_set or
                    self.context.yfilter != YFilter.not_set or
                    self.security.yfilter != YFilter.not_set or
                    self.target_list.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "default-community-map" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/default-community-maps/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.community_name.get_name_leafdata())
                if (self.context.is_set or self.context.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.context.get_name_leafdata())
                if (self.security.is_set or self.security.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.security.get_name_leafdata())
                if (self.target_list.is_set or self.target_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.target_list.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "community-name" or name == "context" or name == "security" or name == "target-list"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "community-name"):
                    self.community_name = value
                    self.community_name.value_namespace = name_space
                    self.community_name.value_namespace_prefix = name_space_prefix
                if(value_path == "context"):
                    self.context = value
                    self.context.value_namespace = name_space
                    self.context.value_namespace_prefix = name_space_prefix
                if(value_path == "security"):
                    self.security = value
                    self.security.value_namespace = name_space
                    self.security.value_namespace_prefix = name_space_prefix
                if(value_path == "target-list"):
                    self.target_list = value
                    self.target_list.value_namespace = name_space
                    self.target_list.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.default_community_map:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.default_community_map:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "default-community-maps" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "default-community-map"):
                for c in self.default_community_map:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.DefaultCommunityMaps.DefaultCommunityMap()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.default_community_map.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "default-community-map"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class OverloadControl(Entity):
        """
        Set overload control params for handling
        incoming messages
        
        .. attribute:: drop_time
        
        	Drop time in seconds for incoming queue (default 1 sec)
        	**type**\:  int
        
        	**range:** 0..300
        
        	**mandatory**\: True
        
        	**units**\: second
        
        .. attribute:: throttle_rate
        
        	Throttle time in milliseconds for incoming queue (default 500 msec)
        	**type**\:  int
        
        	**range:** 0..1000
        
        	**mandatory**\: True
        
        	**units**\: millisecond
        
        

        This class is a :ref:`presence class<presence-class>`

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.OverloadControl, self).__init__()

            self.yang_name = "overload-control"
            self.yang_parent_name = "snmp"
            self.is_presence_container = True

            self.drop_time = YLeaf(YType.uint32, "drop-time")

            self.throttle_rate = YLeaf(YType.uint32, "throttle-rate")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("drop_time",
                            "throttle_rate") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.OverloadControl, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.OverloadControl, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.drop_time.is_set or
                self.throttle_rate.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.drop_time.yfilter != YFilter.not_set or
                self.throttle_rate.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "overload-control" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.drop_time.is_set or self.drop_time.yfilter != YFilter.not_set):
                leaf_name_data.append(self.drop_time.get_name_leafdata())
            if (self.throttle_rate.is_set or self.throttle_rate.yfilter != YFilter.not_set):
                leaf_name_data.append(self.throttle_rate.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "drop-time" or name == "throttle-rate"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "drop-time"):
                self.drop_time = value
                self.drop_time.value_namespace = name_space
                self.drop_time.value_namespace_prefix = name_space_prefix
            if(value_path == "throttle-rate"):
                self.throttle_rate = value
                self.throttle_rate.value_namespace = name_space
                self.throttle_rate.value_namespace_prefix = name_space_prefix


    class Timeouts(Entity):
        """
        SNMP timeouts
        
        .. attribute:: duplicates
        
        	Duplicate request feature timeout
        	**type**\:  int
        
        	**range:** 0..20
        
        	**units**\: second
        
        	**default value**\: 1
        
        .. attribute:: in_qdrop
        
        	incoming queue drop feature timeout
        	**type**\:  int
        
        	**range:** 0..20
        
        	**units**\: second
        
        	**default value**\: 10
        
        .. attribute:: pdu_stats
        
        	SNMP pdu statistics timeout
        	**type**\:  int
        
        	**range:** 1..10
        
        	**units**\: second
        
        	**default value**\: 2
        
        .. attribute:: subagent
        
        	Sub\-Agent Request timeout
        	**type**\:  int
        
        	**range:** 1..20
        
        	**units**\: second
        
        	**default value**\: 10
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Timeouts, self).__init__()

            self.yang_name = "timeouts"
            self.yang_parent_name = "snmp"

            self.duplicates = YLeaf(YType.uint32, "duplicates")

            self.in_qdrop = YLeaf(YType.uint32, "in-qdrop")

            self.pdu_stats = YLeaf(YType.uint32, "pdu-stats")

            self.subagent = YLeaf(YType.uint32, "subagent")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("duplicates",
                            "in_qdrop",
                            "pdu_stats",
                            "subagent") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Timeouts, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Timeouts, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.duplicates.is_set or
                self.in_qdrop.is_set or
                self.pdu_stats.is_set or
                self.subagent.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.duplicates.yfilter != YFilter.not_set or
                self.in_qdrop.yfilter != YFilter.not_set or
                self.pdu_stats.yfilter != YFilter.not_set or
                self.subagent.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "timeouts" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.duplicates.is_set or self.duplicates.yfilter != YFilter.not_set):
                leaf_name_data.append(self.duplicates.get_name_leafdata())
            if (self.in_qdrop.is_set or self.in_qdrop.yfilter != YFilter.not_set):
                leaf_name_data.append(self.in_qdrop.get_name_leafdata())
            if (self.pdu_stats.is_set or self.pdu_stats.yfilter != YFilter.not_set):
                leaf_name_data.append(self.pdu_stats.get_name_leafdata())
            if (self.subagent.is_set or self.subagent.yfilter != YFilter.not_set):
                leaf_name_data.append(self.subagent.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "duplicates" or name == "in-qdrop" or name == "pdu-stats" or name == "subagent"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "duplicates"):
                self.duplicates = value
                self.duplicates.value_namespace = name_space
                self.duplicates.value_namespace_prefix = name_space_prefix
            if(value_path == "in-qdrop"):
                self.in_qdrop = value
                self.in_qdrop.value_namespace = name_space
                self.in_qdrop.value_namespace_prefix = name_space_prefix
            if(value_path == "pdu-stats"):
                self.pdu_stats = value
                self.pdu_stats.value_namespace = name_space
                self.pdu_stats.value_namespace_prefix = name_space_prefix
            if(value_path == "subagent"):
                self.subagent = value
                self.subagent.value_namespace = name_space
                self.subagent.value_namespace_prefix = name_space_prefix


    class Users(Entity):
        """
        Define a user who can access the SNMP engine
        
        .. attribute:: user
        
        	Name of the user
        	**type**\: list of    :py:class:`User <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Users.User>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Users, self).__init__()

            self.yang_name = "users"
            self.yang_parent_name = "snmp"

            self.user = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Users, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Users, self).__setattr__(name, value)


        class User(Entity):
            """
            Name of the user
            
            .. attribute:: user_name  <key>
            
            	Name of the user
            	**type**\:  str
            
            .. attribute:: algorithm
            
            	The algorithm used md5 or sha
            	**type**\:   :py:class:`SnmpHashAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpHashAlgorithm>`
            
            .. attribute:: authentication_password
            
            	The authentication password
            	**type**\:  str
            
            	**pattern:** (!.+)\|([^!].+)
            
            .. attribute:: authentication_password_configured
            
            	Flag to indicate that authentication password is configred for version 3
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: group_name
            
            	Group to which the user belongs
            	**type**\:  str
            
            	**mandatory**\: True
            
            .. attribute:: owner
            
            	The system access either SDROwner or SystemOwner
            	**type**\:   :py:class:`SnmpOwnerAccess <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpOwnerAccess>`
            
            .. attribute:: port
            
            	UDP port number
            	**type**\:  int
            
            	**range:** 1..65535
            
            .. attribute:: priv_algorithm
            
            	The algorithm used des56 or aes128 or aes192or aes256 or 3des
            	**type**\:   :py:class:`SnmpPrivAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpPrivAlgorithm>`
            
            .. attribute:: privacy_password
            
            	The privacy password
            	**type**\:  str
            
            	**pattern:** (!.+)\|([^!].+)
            
            .. attribute:: privacy_password_configured
            
            	Flag to indicate that the privacy password is configured for version 3
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: remote_address
            
            	IP address of remote SNMP entity
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: v4_access_list
            
            	Ipv4 Access\-list name
            	**type**\:  str
            
            .. attribute:: v4acl_type
            
            	Access\-list type
            	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
            
            .. attribute:: v6_access_list
            
            	Ipv6 Access\-list name
            	**type**\:  str
            
            .. attribute:: v6acl_type
            
            	Access\-list type
            	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
            
            .. attribute:: version
            
            	SNMP version to be used. v1,v2c or v3
            	**type**\:   :py:class:`UserSnmpVersion <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.UserSnmpVersion>`
            
            	**mandatory**\: True
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Users.User, self).__init__()

                self.yang_name = "user"
                self.yang_parent_name = "users"

                self.user_name = YLeaf(YType.str, "user-name")

                self.algorithm = YLeaf(YType.enumeration, "algorithm")

                self.authentication_password = YLeaf(YType.str, "authentication-password")

                self.authentication_password_configured = YLeaf(YType.empty, "authentication-password-configured")

                self.group_name = YLeaf(YType.str, "group-name")

                self.owner = YLeaf(YType.enumeration, "owner")

                self.port = YLeaf(YType.uint16, "port")

                self.priv_algorithm = YLeaf(YType.enumeration, "priv-algorithm")

                self.privacy_password = YLeaf(YType.str, "privacy-password")

                self.privacy_password_configured = YLeaf(YType.empty, "privacy-password-configured")

                self.remote_address = YLeaf(YType.str, "remote-address")

                self.v4_access_list = YLeaf(YType.str, "v4-access-list")

                self.v4acl_type = YLeaf(YType.enumeration, "v4acl-type")

                self.v6_access_list = YLeaf(YType.str, "v6-access-list")

                self.v6acl_type = YLeaf(YType.enumeration, "v6acl-type")

                self.version = YLeaf(YType.enumeration, "version")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("user_name",
                                "algorithm",
                                "authentication_password",
                                "authentication_password_configured",
                                "group_name",
                                "owner",
                                "port",
                                "priv_algorithm",
                                "privacy_password",
                                "privacy_password_configured",
                                "remote_address",
                                "v4_access_list",
                                "v4acl_type",
                                "v6_access_list",
                                "v6acl_type",
                                "version") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Users.User, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Users.User, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.user_name.is_set or
                    self.algorithm.is_set or
                    self.authentication_password.is_set or
                    self.authentication_password_configured.is_set or
                    self.group_name.is_set or
                    self.owner.is_set or
                    self.port.is_set or
                    self.priv_algorithm.is_set or
                    self.privacy_password.is_set or
                    self.privacy_password_configured.is_set or
                    self.remote_address.is_set or
                    self.v4_access_list.is_set or
                    self.v4acl_type.is_set or
                    self.v6_access_list.is_set or
                    self.v6acl_type.is_set or
                    self.version.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.user_name.yfilter != YFilter.not_set or
                    self.algorithm.yfilter != YFilter.not_set or
                    self.authentication_password.yfilter != YFilter.not_set or
                    self.authentication_password_configured.yfilter != YFilter.not_set or
                    self.group_name.yfilter != YFilter.not_set or
                    self.owner.yfilter != YFilter.not_set or
                    self.port.yfilter != YFilter.not_set or
                    self.priv_algorithm.yfilter != YFilter.not_set or
                    self.privacy_password.yfilter != YFilter.not_set or
                    self.privacy_password_configured.yfilter != YFilter.not_set or
                    self.remote_address.yfilter != YFilter.not_set or
                    self.v4_access_list.yfilter != YFilter.not_set or
                    self.v4acl_type.yfilter != YFilter.not_set or
                    self.v6_access_list.yfilter != YFilter.not_set or
                    self.v6acl_type.yfilter != YFilter.not_set or
                    self.version.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "user" + "[user-name='" + self.user_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/users/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.user_name.is_set or self.user_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.user_name.get_name_leafdata())
                if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.algorithm.get_name_leafdata())
                if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.authentication_password.get_name_leafdata())
                if (self.authentication_password_configured.is_set or self.authentication_password_configured.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.authentication_password_configured.get_name_leafdata())
                if (self.group_name.is_set or self.group_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.group_name.get_name_leafdata())
                if (self.owner.is_set or self.owner.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.owner.get_name_leafdata())
                if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.port.get_name_leafdata())
                if (self.priv_algorithm.is_set or self.priv_algorithm.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.priv_algorithm.get_name_leafdata())
                if (self.privacy_password.is_set or self.privacy_password.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.privacy_password.get_name_leafdata())
                if (self.privacy_password_configured.is_set or self.privacy_password_configured.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.privacy_password_configured.get_name_leafdata())
                if (self.remote_address.is_set or self.remote_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_address.get_name_leafdata())
                if (self.v4_access_list.is_set or self.v4_access_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v4_access_list.get_name_leafdata())
                if (self.v4acl_type.is_set or self.v4acl_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v4acl_type.get_name_leafdata())
                if (self.v6_access_list.is_set or self.v6_access_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v6_access_list.get_name_leafdata())
                if (self.v6acl_type.is_set or self.v6acl_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v6acl_type.get_name_leafdata())
                if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.version.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "user-name" or name == "algorithm" or name == "authentication-password" or name == "authentication-password-configured" or name == "group-name" or name == "owner" or name == "port" or name == "priv-algorithm" or name == "privacy-password" or name == "privacy-password-configured" or name == "remote-address" or name == "v4-access-list" or name == "v4acl-type" or name == "v6-access-list" or name == "v6acl-type" or name == "version"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "user-name"):
                    self.user_name = value
                    self.user_name.value_namespace = name_space
                    self.user_name.value_namespace_prefix = name_space_prefix
                if(value_path == "algorithm"):
                    self.algorithm = value
                    self.algorithm.value_namespace = name_space
                    self.algorithm.value_namespace_prefix = name_space_prefix
                if(value_path == "authentication-password"):
                    self.authentication_password = value
                    self.authentication_password.value_namespace = name_space
                    self.authentication_password.value_namespace_prefix = name_space_prefix
                if(value_path == "authentication-password-configured"):
                    self.authentication_password_configured = value
                    self.authentication_password_configured.value_namespace = name_space
                    self.authentication_password_configured.value_namespace_prefix = name_space_prefix
                if(value_path == "group-name"):
                    self.group_name = value
                    self.group_name.value_namespace = name_space
                    self.group_name.value_namespace_prefix = name_space_prefix
                if(value_path == "owner"):
                    self.owner = value
                    self.owner.value_namespace = name_space
                    self.owner.value_namespace_prefix = name_space_prefix
                if(value_path == "port"):
                    self.port = value
                    self.port.value_namespace = name_space
                    self.port.value_namespace_prefix = name_space_prefix
                if(value_path == "priv-algorithm"):
                    self.priv_algorithm = value
                    self.priv_algorithm.value_namespace = name_space
                    self.priv_algorithm.value_namespace_prefix = name_space_prefix
                if(value_path == "privacy-password"):
                    self.privacy_password = value
                    self.privacy_password.value_namespace = name_space
                    self.privacy_password.value_namespace_prefix = name_space_prefix
                if(value_path == "privacy-password-configured"):
                    self.privacy_password_configured = value
                    self.privacy_password_configured.value_namespace = name_space
                    self.privacy_password_configured.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-address"):
                    self.remote_address = value
                    self.remote_address.value_namespace = name_space
                    self.remote_address.value_namespace_prefix = name_space_prefix
                if(value_path == "v4-access-list"):
                    self.v4_access_list = value
                    self.v4_access_list.value_namespace = name_space
                    self.v4_access_list.value_namespace_prefix = name_space_prefix
                if(value_path == "v4acl-type"):
                    self.v4acl_type = value
                    self.v4acl_type.value_namespace = name_space
                    self.v4acl_type.value_namespace_prefix = name_space_prefix
                if(value_path == "v6-access-list"):
                    self.v6_access_list = value
                    self.v6_access_list.value_namespace = name_space
                    self.v6_access_list.value_namespace_prefix = name_space_prefix
                if(value_path == "v6acl-type"):
                    self.v6acl_type = value
                    self.v6acl_type.value_namespace = name_space
                    self.v6acl_type.value_namespace_prefix = name_space_prefix
                if(value_path == "version"):
                    self.version = value
                    self.version.value_namespace = name_space
                    self.version.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.user:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.user:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "users" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "user"):
                for c in self.user:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.Users.User()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.user.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "user"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Vrfs(Entity):
        """
        SNMP VRF configuration commands
        
        .. attribute:: vrf
        
        	VRF name
        	**type**\: list of    :py:class:`Vrf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Vrfs, self).__init__()

            self.yang_name = "vrfs"
            self.yang_parent_name = "snmp"

            self.vrf = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Vrfs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Vrfs, self).__setattr__(name, value)


        class Vrf(Entity):
            """
            VRF name
            
            .. attribute:: name  <key>
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: context_mappings
            
            	List of context names
            	**type**\:   :py:class:`ContextMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.ContextMappings>`
            
            .. attribute:: contexts
            
            	List of Context Names
            	**type**\:   :py:class:`Contexts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.Contexts>`
            
            .. attribute:: trap_hosts
            
            	Specify hosts to receive SNMP notifications
            	**type**\:   :py:class:`TrapHosts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Vrfs.Vrf, self).__init__()

                self.yang_name = "vrf"
                self.yang_parent_name = "vrfs"

                self.name = YLeaf(YType.str, "name")

                self.context_mappings = Snmp.Vrfs.Vrf.ContextMappings()
                self.context_mappings.parent = self
                self._children_name_map["context_mappings"] = "context-mappings"
                self._children_yang_names.add("context-mappings")

                self.contexts = Snmp.Vrfs.Vrf.Contexts()
                self.contexts.parent = self
                self._children_name_map["contexts"] = "contexts"
                self._children_yang_names.add("contexts")

                self.trap_hosts = Snmp.Vrfs.Vrf.TrapHosts()
                self.trap_hosts.parent = self
                self._children_name_map["trap_hosts"] = "trap-hosts"
                self._children_yang_names.add("trap-hosts")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Vrfs.Vrf, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Vrfs.Vrf, self).__setattr__(name, value)


            class TrapHosts(Entity):
                """
                Specify hosts to receive SNMP notifications
                
                .. attribute:: trap_host
                
                	Specify hosts to receive SNMP notifications
                	**type**\: list of    :py:class:`TrapHost <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Vrfs.Vrf.TrapHosts, self).__init__()

                    self.yang_name = "trap-hosts"
                    self.yang_parent_name = "vrf"

                    self.trap_host = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Vrfs.Vrf.TrapHosts, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Vrfs.Vrf.TrapHosts, self).__setattr__(name, value)


                class TrapHost(Entity):
                    """
                    Specify hosts to receive SNMP notifications
                    
                    .. attribute:: ip_address  <key>
                    
                    	IP address of SNMP notification host
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: default_user_communities
                    
                    	Container class for defining communities for a trap host
                    	**type**\:   :py:class:`DefaultUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities>`
                    
                    .. attribute:: encrypted_user_communities
                    
                    	Container class for defining Clear/encrypt communities for a trap host
                    	**type**\:   :py:class:`EncryptedUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities>`
                    
                    .. attribute:: inform_host
                    
                    	Container class for defining notification type for a Inform host
                    	**type**\:   :py:class:`InformHost <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost, self).__init__()

                        self.yang_name = "trap-host"
                        self.yang_parent_name = "trap-hosts"

                        self.ip_address = YLeaf(YType.str, "ip-address")

                        self.default_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities()
                        self.default_user_communities.parent = self
                        self._children_name_map["default_user_communities"] = "default-user-communities"
                        self._children_yang_names.add("default-user-communities")

                        self.encrypted_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities()
                        self.encrypted_user_communities.parent = self
                        self._children_name_map["encrypted_user_communities"] = "encrypted-user-communities"
                        self._children_yang_names.add("encrypted-user-communities")

                        self.inform_host = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost()
                        self.inform_host.parent = self
                        self._children_name_map["inform_host"] = "inform-host"
                        self._children_yang_names.add("inform-host")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ip_address") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost, self).__setattr__(name, value)


                    class EncryptedUserCommunities(Entity):
                        """
                        Container class for defining Clear/encrypt
                        communities for a trap host
                        
                        .. attribute:: encrypted_user_community
                        
                        	Clear/Encrypt Community name associated with a trap host
                        	**type**\: list of    :py:class:`EncryptedUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity>`
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities, self).__init__()

                            self.yang_name = "encrypted-user-communities"
                            self.yang_parent_name = "trap-host"

                            self.encrypted_user_community = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities, self).__setattr__(name, value)


                        class EncryptedUserCommunity(Entity):
                            """
                            Clear/Encrypt Community name associated with
                            a trap host
                            
                            .. attribute:: community_name  <key>
                            
                            	SNMPv1/v2c community string or SNMPv3 user
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: advanced_trap_types1
                            
                            	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            	**mandatory**\: True
                            
                            .. attribute:: advanced_trap_types2
                            
                            	Number to signify the feature traps that needs to be setvalue should always to set as 0
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            	**mandatory**\: True
                            
                            .. attribute:: basic_trap_types
                            
                            	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            	**mandatory**\: True
                            
                            .. attribute:: port
                            
                            	UDP port number
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            .. attribute:: security_level
                            
                            	Security level to be used noauth/auth/priv
                            	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                            
                            .. attribute:: version
                            
                            	SNMP Version to be used v1/v2c/v3
                            	**type**\:  str
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity, self).__init__()

                                self.yang_name = "encrypted-user-community"
                                self.yang_parent_name = "encrypted-user-communities"

                                self.community_name = YLeaf(YType.str, "community-name")

                                self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                                self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                                self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                                self.port = YLeaf(YType.uint16, "port")

                                self.security_level = YLeaf(YType.enumeration, "security-level")

                                self.version = YLeaf(YType.str, "version")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("community_name",
                                                "advanced_trap_types1",
                                                "advanced_trap_types2",
                                                "basic_trap_types",
                                                "port",
                                                "security_level",
                                                "version") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.community_name.is_set or
                                    self.advanced_trap_types1.is_set or
                                    self.advanced_trap_types2.is_set or
                                    self.basic_trap_types.is_set or
                                    self.port.is_set or
                                    self.security_level.is_set or
                                    self.version.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.community_name.yfilter != YFilter.not_set or
                                    self.advanced_trap_types1.yfilter != YFilter.not_set or
                                    self.advanced_trap_types2.yfilter != YFilter.not_set or
                                    self.basic_trap_types.yfilter != YFilter.not_set or
                                    self.port.yfilter != YFilter.not_set or
                                    self.security_level.yfilter != YFilter.not_set or
                                    self.version.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "encrypted-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.community_name.get_name_leafdata())
                                if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                                if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                                if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                                if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port.get_name_leafdata())
                                if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.security_level.get_name_leafdata())
                                if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.version.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "community-name"):
                                    self.community_name = value
                                    self.community_name.value_namespace = name_space
                                    self.community_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "advanced-trap-types1"):
                                    self.advanced_trap_types1 = value
                                    self.advanced_trap_types1.value_namespace = name_space
                                    self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                                if(value_path == "advanced-trap-types2"):
                                    self.advanced_trap_types2 = value
                                    self.advanced_trap_types2.value_namespace = name_space
                                    self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                                if(value_path == "basic-trap-types"):
                                    self.basic_trap_types = value
                                    self.basic_trap_types.value_namespace = name_space
                                    self.basic_trap_types.value_namespace_prefix = name_space_prefix
                                if(value_path == "port"):
                                    self.port = value
                                    self.port.value_namespace = name_space
                                    self.port.value_namespace_prefix = name_space_prefix
                                if(value_path == "security-level"):
                                    self.security_level = value
                                    self.security_level.value_namespace = name_space
                                    self.security_level.value_namespace_prefix = name_space_prefix
                                if(value_path == "version"):
                                    self.version = value
                                    self.version.value_namespace = name_space
                                    self.version.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.encrypted_user_community:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.encrypted_user_community:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "encrypted-user-communities" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "encrypted-user-community"):
                                for c in self.encrypted_user_community:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.encrypted_user_community.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "encrypted-user-community"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class InformHost(Entity):
                        """
                        Container class for defining notification type
                        for a Inform host
                        
                        .. attribute:: inform_encrypted_user_communities
                        
                        	Container class for defining Clear/encrypt communities for a inform host
                        	**type**\:   :py:class:`InformEncryptedUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities>`
                        
                        .. attribute:: inform_user_communities
                        
                        	Container class for defining communities for a inform host
                        	**type**\:   :py:class:`InformUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities>`
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost, self).__init__()

                            self.yang_name = "inform-host"
                            self.yang_parent_name = "trap-host"

                            self.inform_encrypted_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities()
                            self.inform_encrypted_user_communities.parent = self
                            self._children_name_map["inform_encrypted_user_communities"] = "inform-encrypted-user-communities"
                            self._children_yang_names.add("inform-encrypted-user-communities")

                            self.inform_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities()
                            self.inform_user_communities.parent = self
                            self._children_name_map["inform_user_communities"] = "inform-user-communities"
                            self._children_yang_names.add("inform-user-communities")


                        class InformUserCommunities(Entity):
                            """
                            Container class for defining communities for
                            a inform host
                            
                            .. attribute:: inform_user_community
                            
                            	Unencrpted Community name associated with a inform host
                            	**type**\: list of    :py:class:`InformUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity>`
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities, self).__init__()

                                self.yang_name = "inform-user-communities"
                                self.yang_parent_name = "inform-host"

                                self.inform_user_community = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities, self).__setattr__(name, value)


                            class InformUserCommunity(Entity):
                                """
                                Unencrpted Community name associated with a
                                inform host
                                
                                .. attribute:: community_name  <key>
                                
                                	SNMPv2c community string or SNMPv3 user
                                	**type**\:  str
                                
                                	**length:** 1..128
                                
                                .. attribute:: advanced_trap_types1
                                
                                	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                	**mandatory**\: True
                                
                                .. attribute:: advanced_trap_types2
                                
                                	Number to signify the feature traps that needs to be setvalue should always to set as 0
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                	**mandatory**\: True
                                
                                .. attribute:: basic_trap_types
                                
                                	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072 ,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                	**mandatory**\: True
                                
                                .. attribute:: port
                                
                                	UDP port number
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: security_level
                                
                                	Security level to be used noauth/auth/priv
                                	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                                
                                .. attribute:: version
                                
                                	SNMP Version to be used v2c/v3
                                	**type**\:  str
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'snmp-agent-cfg'
                                _revision = '2015-10-27'

                                def __init__(self):
                                    super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity, self).__init__()

                                    self.yang_name = "inform-user-community"
                                    self.yang_parent_name = "inform-user-communities"

                                    self.community_name = YLeaf(YType.str, "community-name")

                                    self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                                    self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                                    self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                                    self.port = YLeaf(YType.uint16, "port")

                                    self.security_level = YLeaf(YType.enumeration, "security-level")

                                    self.version = YLeaf(YType.str, "version")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("community_name",
                                                    "advanced_trap_types1",
                                                    "advanced_trap_types2",
                                                    "basic_trap_types",
                                                    "port",
                                                    "security_level",
                                                    "version") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.community_name.is_set or
                                        self.advanced_trap_types1.is_set or
                                        self.advanced_trap_types2.is_set or
                                        self.basic_trap_types.is_set or
                                        self.port.is_set or
                                        self.security_level.is_set or
                                        self.version.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.community_name.yfilter != YFilter.not_set or
                                        self.advanced_trap_types1.yfilter != YFilter.not_set or
                                        self.advanced_trap_types2.yfilter != YFilter.not_set or
                                        self.basic_trap_types.yfilter != YFilter.not_set or
                                        self.port.yfilter != YFilter.not_set or
                                        self.security_level.yfilter != YFilter.not_set or
                                        self.version.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "inform-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.community_name.get_name_leafdata())
                                    if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                                    if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                                    if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                                    if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port.get_name_leafdata())
                                    if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.security_level.get_name_leafdata())
                                    if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.version.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "community-name"):
                                        self.community_name = value
                                        self.community_name.value_namespace = name_space
                                        self.community_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "advanced-trap-types1"):
                                        self.advanced_trap_types1 = value
                                        self.advanced_trap_types1.value_namespace = name_space
                                        self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                                    if(value_path == "advanced-trap-types2"):
                                        self.advanced_trap_types2 = value
                                        self.advanced_trap_types2.value_namespace = name_space
                                        self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                                    if(value_path == "basic-trap-types"):
                                        self.basic_trap_types = value
                                        self.basic_trap_types.value_namespace = name_space
                                        self.basic_trap_types.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port"):
                                        self.port = value
                                        self.port.value_namespace = name_space
                                        self.port.value_namespace_prefix = name_space_prefix
                                    if(value_path == "security-level"):
                                        self.security_level = value
                                        self.security_level.value_namespace = name_space
                                        self.security_level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "version"):
                                        self.version = value
                                        self.version.value_namespace = name_space
                                        self.version.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.inform_user_community:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.inform_user_community:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "inform-user-communities" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "inform-user-community"):
                                    for c in self.inform_user_community:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.inform_user_community.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "inform-user-community"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class InformEncryptedUserCommunities(Entity):
                            """
                            Container class for defining Clear/encrypt
                            communities for a inform host
                            
                            .. attribute:: inform_encrypted_user_community
                            
                            	Clear/Encrypt Community name associated with a inform host
                            	**type**\: list of    :py:class:`InformEncryptedUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity>`
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities, self).__init__()

                                self.yang_name = "inform-encrypted-user-communities"
                                self.yang_parent_name = "inform-host"

                                self.inform_encrypted_user_community = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities, self).__setattr__(name, value)


                            class InformEncryptedUserCommunity(Entity):
                                """
                                Clear/Encrypt Community name associated with
                                a inform host
                                
                                .. attribute:: community_name  <key>
                                
                                	SNMPv2c community string or SNMPv3 user
                                	**type**\:  str
                                
                                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                
                                .. attribute:: advanced_trap_types1
                                
                                	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                	**mandatory**\: True
                                
                                .. attribute:: advanced_trap_types2
                                
                                	Number to signify the feature traps that needs to be setvalue should always to set as 0
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                	**mandatory**\: True
                                
                                .. attribute:: basic_trap_types
                                
                                	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072 ,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                	**mandatory**\: True
                                
                                .. attribute:: port
                                
                                	UDP port number
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: security_level
                                
                                	Security level to be used noauth/auth/priv
                                	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                                
                                .. attribute:: version
                                
                                	SNMP Version to be used v2c/v3
                                	**type**\:  str
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'snmp-agent-cfg'
                                _revision = '2015-10-27'

                                def __init__(self):
                                    super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity, self).__init__()

                                    self.yang_name = "inform-encrypted-user-community"
                                    self.yang_parent_name = "inform-encrypted-user-communities"

                                    self.community_name = YLeaf(YType.str, "community-name")

                                    self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                                    self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                                    self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                                    self.port = YLeaf(YType.uint16, "port")

                                    self.security_level = YLeaf(YType.enumeration, "security-level")

                                    self.version = YLeaf(YType.str, "version")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("community_name",
                                                    "advanced_trap_types1",
                                                    "advanced_trap_types2",
                                                    "basic_trap_types",
                                                    "port",
                                                    "security_level",
                                                    "version") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.community_name.is_set or
                                        self.advanced_trap_types1.is_set or
                                        self.advanced_trap_types2.is_set or
                                        self.basic_trap_types.is_set or
                                        self.port.is_set or
                                        self.security_level.is_set or
                                        self.version.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.community_name.yfilter != YFilter.not_set or
                                        self.advanced_trap_types1.yfilter != YFilter.not_set or
                                        self.advanced_trap_types2.yfilter != YFilter.not_set or
                                        self.basic_trap_types.yfilter != YFilter.not_set or
                                        self.port.yfilter != YFilter.not_set or
                                        self.security_level.yfilter != YFilter.not_set or
                                        self.version.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "inform-encrypted-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.community_name.get_name_leafdata())
                                    if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                                    if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                                    if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                                    if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port.get_name_leafdata())
                                    if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.security_level.get_name_leafdata())
                                    if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.version.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "community-name"):
                                        self.community_name = value
                                        self.community_name.value_namespace = name_space
                                        self.community_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "advanced-trap-types1"):
                                        self.advanced_trap_types1 = value
                                        self.advanced_trap_types1.value_namespace = name_space
                                        self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                                    if(value_path == "advanced-trap-types2"):
                                        self.advanced_trap_types2 = value
                                        self.advanced_trap_types2.value_namespace = name_space
                                        self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                                    if(value_path == "basic-trap-types"):
                                        self.basic_trap_types = value
                                        self.basic_trap_types.value_namespace = name_space
                                        self.basic_trap_types.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port"):
                                        self.port = value
                                        self.port.value_namespace = name_space
                                        self.port.value_namespace_prefix = name_space_prefix
                                    if(value_path == "security-level"):
                                        self.security_level = value
                                        self.security_level.value_namespace = name_space
                                        self.security_level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "version"):
                                        self.version = value
                                        self.version.value_namespace = name_space
                                        self.version.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.inform_encrypted_user_community:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.inform_encrypted_user_community:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "inform-encrypted-user-communities" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "inform-encrypted-user-community"):
                                    for c in self.inform_encrypted_user_community:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.inform_encrypted_user_community.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "inform-encrypted-user-community"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.inform_encrypted_user_communities is not None and self.inform_encrypted_user_communities.has_data()) or
                                (self.inform_user_communities is not None and self.inform_user_communities.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.inform_encrypted_user_communities is not None and self.inform_encrypted_user_communities.has_operation()) or
                                (self.inform_user_communities is not None and self.inform_user_communities.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "inform-host" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "inform-encrypted-user-communities"):
                                if (self.inform_encrypted_user_communities is None):
                                    self.inform_encrypted_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities()
                                    self.inform_encrypted_user_communities.parent = self
                                    self._children_name_map["inform_encrypted_user_communities"] = "inform-encrypted-user-communities"
                                return self.inform_encrypted_user_communities

                            if (child_yang_name == "inform-user-communities"):
                                if (self.inform_user_communities is None):
                                    self.inform_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost.InformUserCommunities()
                                    self.inform_user_communities.parent = self
                                    self._children_name_map["inform_user_communities"] = "inform-user-communities"
                                return self.inform_user_communities

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "inform-encrypted-user-communities" or name == "inform-user-communities"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class DefaultUserCommunities(Entity):
                        """
                        Container class for defining communities for a
                        trap host
                        
                        .. attribute:: default_user_community
                        
                        	Unencrpted Community name associated with a trap host
                        	**type**\: list of    :py:class:`DefaultUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity>`
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities, self).__init__()

                            self.yang_name = "default-user-communities"
                            self.yang_parent_name = "trap-host"

                            self.default_user_community = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities, self).__setattr__(name, value)


                        class DefaultUserCommunity(Entity):
                            """
                            Unencrpted Community name associated with a
                            trap host
                            
                            .. attribute:: community_name  <key>
                            
                            	SNMPv1/v2c community string or SNMPv3 user
                            	**type**\:  str
                            
                            	**length:** 1..128
                            
                            .. attribute:: advanced_trap_types1
                            
                            	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            	**mandatory**\: True
                            
                            .. attribute:: advanced_trap_types2
                            
                            	Number to signify the feature traps that needs to be setvalue should always to set as 0
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            	**mandatory**\: True
                            
                            .. attribute:: basic_trap_types
                            
                            	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            	**mandatory**\: True
                            
                            .. attribute:: port
                            
                            	UDP port number
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            .. attribute:: security_level
                            
                            	Security level to be used noauth/auth/priv
                            	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                            
                            .. attribute:: version
                            
                            	SNMP Version to be used v1/v2c/v3
                            	**type**\:  str
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'snmp-agent-cfg'
                            _revision = '2015-10-27'

                            def __init__(self):
                                super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity, self).__init__()

                                self.yang_name = "default-user-community"
                                self.yang_parent_name = "default-user-communities"

                                self.community_name = YLeaf(YType.str, "community-name")

                                self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                                self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                                self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                                self.port = YLeaf(YType.uint16, "port")

                                self.security_level = YLeaf(YType.enumeration, "security-level")

                                self.version = YLeaf(YType.str, "version")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("community_name",
                                                "advanced_trap_types1",
                                                "advanced_trap_types2",
                                                "basic_trap_types",
                                                "port",
                                                "security_level",
                                                "version") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.community_name.is_set or
                                    self.advanced_trap_types1.is_set or
                                    self.advanced_trap_types2.is_set or
                                    self.basic_trap_types.is_set or
                                    self.port.is_set or
                                    self.security_level.is_set or
                                    self.version.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.community_name.yfilter != YFilter.not_set or
                                    self.advanced_trap_types1.yfilter != YFilter.not_set or
                                    self.advanced_trap_types2.yfilter != YFilter.not_set or
                                    self.basic_trap_types.yfilter != YFilter.not_set or
                                    self.port.yfilter != YFilter.not_set or
                                    self.security_level.yfilter != YFilter.not_set or
                                    self.version.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "default-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.community_name.get_name_leafdata())
                                if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                                if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                                if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                                if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port.get_name_leafdata())
                                if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.security_level.get_name_leafdata())
                                if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.version.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "community-name"):
                                    self.community_name = value
                                    self.community_name.value_namespace = name_space
                                    self.community_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "advanced-trap-types1"):
                                    self.advanced_trap_types1 = value
                                    self.advanced_trap_types1.value_namespace = name_space
                                    self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                                if(value_path == "advanced-trap-types2"):
                                    self.advanced_trap_types2 = value
                                    self.advanced_trap_types2.value_namespace = name_space
                                    self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                                if(value_path == "basic-trap-types"):
                                    self.basic_trap_types = value
                                    self.basic_trap_types.value_namespace = name_space
                                    self.basic_trap_types.value_namespace_prefix = name_space_prefix
                                if(value_path == "port"):
                                    self.port = value
                                    self.port.value_namespace = name_space
                                    self.port.value_namespace_prefix = name_space_prefix
                                if(value_path == "security-level"):
                                    self.security_level = value
                                    self.security_level.value_namespace = name_space
                                    self.security_level.value_namespace_prefix = name_space_prefix
                                if(value_path == "version"):
                                    self.version = value
                                    self.version.value_namespace = name_space
                                    self.version.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.default_user_community:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.default_user_community:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "default-user-communities" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "default-user-community"):
                                for c in self.default_user_community:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.default_user_community.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "default-user-community"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.ip_address.is_set or
                            (self.default_user_communities is not None and self.default_user_communities.has_data()) or
                            (self.encrypted_user_communities is not None and self.encrypted_user_communities.has_data()) or
                            (self.inform_host is not None and self.inform_host.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ip_address.yfilter != YFilter.not_set or
                            (self.default_user_communities is not None and self.default_user_communities.has_operation()) or
                            (self.encrypted_user_communities is not None and self.encrypted_user_communities.has_operation()) or
                            (self.inform_host is not None and self.inform_host.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "trap-host" + "[ip-address='" + self.ip_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ip_address.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "default-user-communities"):
                            if (self.default_user_communities is None):
                                self.default_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.DefaultUserCommunities()
                                self.default_user_communities.parent = self
                                self._children_name_map["default_user_communities"] = "default-user-communities"
                            return self.default_user_communities

                        if (child_yang_name == "encrypted-user-communities"):
                            if (self.encrypted_user_communities is None):
                                self.encrypted_user_communities = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.EncryptedUserCommunities()
                                self.encrypted_user_communities.parent = self
                                self._children_name_map["encrypted_user_communities"] = "encrypted-user-communities"
                            return self.encrypted_user_communities

                        if (child_yang_name == "inform-host"):
                            if (self.inform_host is None):
                                self.inform_host = Snmp.Vrfs.Vrf.TrapHosts.TrapHost.InformHost()
                                self.inform_host.parent = self
                                self._children_name_map["inform_host"] = "inform-host"
                            return self.inform_host

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "default-user-communities" or name == "encrypted-user-communities" or name == "inform-host" or name == "ip-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ip-address"):
                            self.ip_address = value
                            self.ip_address.value_namespace = name_space
                            self.ip_address.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.trap_host:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.trap_host:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "trap-hosts" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "trap-host"):
                        for c in self.trap_host:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Snmp.Vrfs.Vrf.TrapHosts.TrapHost()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.trap_host.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "trap-host"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Contexts(Entity):
                """
                List of Context Names
                
                .. attribute:: context
                
                	Context Name
                	**type**\: list of    :py:class:`Context <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.Contexts.Context>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Vrfs.Vrf.Contexts, self).__init__()

                    self.yang_name = "contexts"
                    self.yang_parent_name = "vrf"

                    self.context = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Vrfs.Vrf.Contexts, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Vrfs.Vrf.Contexts, self).__setattr__(name, value)


                class Context(Entity):
                    """
                    Context Name
                    
                    .. attribute:: context_name  <key>
                    
                    	Context Name
                    	**type**\:  str
                    
                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Vrfs.Vrf.Contexts.Context, self).__init__()

                        self.yang_name = "context"
                        self.yang_parent_name = "contexts"

                        self.context_name = YLeaf(YType.str, "context-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("context_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Vrfs.Vrf.Contexts.Context, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Vrfs.Vrf.Contexts.Context, self).__setattr__(name, value)

                    def has_data(self):
                        return self.context_name.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.context_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "context" + "[context-name='" + self.context_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.context_name.is_set or self.context_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.context_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "context-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "context-name"):
                            self.context_name = value
                            self.context_name.value_namespace = name_space
                            self.context_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.context:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.context:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "contexts" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "context"):
                        for c in self.context:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Snmp.Vrfs.Vrf.Contexts.Context()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.context.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "context"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class ContextMappings(Entity):
                """
                List of context names
                
                .. attribute:: context_mapping
                
                	Context mapping name
                	**type**\: list of    :py:class:`ContextMapping <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Vrfs.Vrf.ContextMappings.ContextMapping>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.Vrfs.Vrf.ContextMappings, self).__init__()

                    self.yang_name = "context-mappings"
                    self.yang_parent_name = "vrf"

                    self.context_mapping = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.Vrfs.Vrf.ContextMappings, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.Vrfs.Vrf.ContextMappings, self).__setattr__(name, value)


                class ContextMapping(Entity):
                    """
                    Context mapping name
                    
                    .. attribute:: context_mapping_name  <key>
                    
                    	Context mapping name
                    	**type**\:  str
                    
                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                    
                    .. attribute:: context
                    
                    	SNMP context feature type
                    	**type**\:   :py:class:`SnmpContext <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpContext>`
                    
                    .. attribute:: instance_name
                    
                    	OSPF protocol instance
                    	**type**\:  str
                    
                    .. attribute:: topology_name
                    
                    	Topology name associated with the context
                    	**type**\:  str
                    
                    .. attribute:: vrf_name
                    
                    	VRF name associated with the context
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.Vrfs.Vrf.ContextMappings.ContextMapping, self).__init__()

                        self.yang_name = "context-mapping"
                        self.yang_parent_name = "context-mappings"

                        self.context_mapping_name = YLeaf(YType.str, "context-mapping-name")

                        self.context = YLeaf(YType.enumeration, "context")

                        self.instance_name = YLeaf(YType.str, "instance-name")

                        self.topology_name = YLeaf(YType.str, "topology-name")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("context_mapping_name",
                                        "context",
                                        "instance_name",
                                        "topology_name",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.Vrfs.Vrf.ContextMappings.ContextMapping, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.Vrfs.Vrf.ContextMappings.ContextMapping, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.context_mapping_name.is_set or
                            self.context.is_set or
                            self.instance_name.is_set or
                            self.topology_name.is_set or
                            self.vrf_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.context_mapping_name.yfilter != YFilter.not_set or
                            self.context.yfilter != YFilter.not_set or
                            self.instance_name.yfilter != YFilter.not_set or
                            self.topology_name.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "context-mapping" + "[context-mapping-name='" + self.context_mapping_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.context_mapping_name.is_set or self.context_mapping_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.context_mapping_name.get_name_leafdata())
                        if (self.context.is_set or self.context.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.context.get_name_leafdata())
                        if (self.instance_name.is_set or self.instance_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.instance_name.get_name_leafdata())
                        if (self.topology_name.is_set or self.topology_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.topology_name.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "context-mapping-name" or name == "context" or name == "instance-name" or name == "topology-name" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "context-mapping-name"):
                            self.context_mapping_name = value
                            self.context_mapping_name.value_namespace = name_space
                            self.context_mapping_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "context"):
                            self.context = value
                            self.context.value_namespace = name_space
                            self.context.value_namespace_prefix = name_space_prefix
                        if(value_path == "instance-name"):
                            self.instance_name = value
                            self.instance_name.value_namespace = name_space
                            self.instance_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "topology-name"):
                            self.topology_name = value
                            self.topology_name.value_namespace = name_space
                            self.topology_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.context_mapping:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.context_mapping:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "context-mappings" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "context-mapping"):
                        for c in self.context_mapping:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Snmp.Vrfs.Vrf.ContextMappings.ContextMapping()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.context_mapping.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "context-mapping"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.name.is_set or
                    (self.context_mappings is not None and self.context_mappings.has_data()) or
                    (self.contexts is not None and self.contexts.has_data()) or
                    (self.trap_hosts is not None and self.trap_hosts.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.name.yfilter != YFilter.not_set or
                    (self.context_mappings is not None and self.context_mappings.has_operation()) or
                    (self.contexts is not None and self.contexts.has_operation()) or
                    (self.trap_hosts is not None and self.trap_hosts.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "vrf" + "[name='" + self.name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/vrfs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "context-mappings"):
                    if (self.context_mappings is None):
                        self.context_mappings = Snmp.Vrfs.Vrf.ContextMappings()
                        self.context_mappings.parent = self
                        self._children_name_map["context_mappings"] = "context-mappings"
                    return self.context_mappings

                if (child_yang_name == "contexts"):
                    if (self.contexts is None):
                        self.contexts = Snmp.Vrfs.Vrf.Contexts()
                        self.contexts.parent = self
                        self._children_name_map["contexts"] = "contexts"
                    return self.contexts

                if (child_yang_name == "trap-hosts"):
                    if (self.trap_hosts is None):
                        self.trap_hosts = Snmp.Vrfs.Vrf.TrapHosts()
                        self.trap_hosts.parent = self
                        self._children_name_map["trap_hosts"] = "trap-hosts"
                    return self.trap_hosts

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "context-mappings" or name == "contexts" or name == "trap-hosts" or name == "name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "name"):
                    self.name = value
                    self.name.value_namespace = name_space
                    self.name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.vrf:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.vrf:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "vrfs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "vrf"):
                for c in self.vrf:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.Vrfs.Vrf()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.vrf.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "vrf"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Groups(Entity):
        """
        Define a User Security Model group
        
        .. attribute:: group
        
        	Name of the group
        	**type**\: list of    :py:class:`Group <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Groups.Group>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Groups, self).__init__()

            self.yang_name = "groups"
            self.yang_parent_name = "snmp"

            self.group = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Groups, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Groups, self).__setattr__(name, value)


        class Group(Entity):
            """
            Name of the group
            
            .. attribute:: name  <key>
            
            	Name of the group
            	**type**\:  str
            
            	**length:** 1..128
            
            .. attribute:: context_name
            
            	Context name
            	**type**\:  str
            
            .. attribute:: notify_view
            
            	notify view name
            	**type**\:  str
            
            .. attribute:: read_view
            
            	read view name
            	**type**\:  str
            
            .. attribute:: security_model
            
            	security model like auth/noAuth/Priv applicable for v3
            	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
            
            .. attribute:: snmp_version
            
            	snmp version
            	**type**\:   :py:class:`GroupSnmpVersion <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.GroupSnmpVersion>`
            
            	**mandatory**\: True
            
            .. attribute:: v4_access_list
            
            	Ipv4 Access\-list name
            	**type**\:  str
            
            .. attribute:: v4acl_type
            
            	Access\-list type
            	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
            
            .. attribute:: v6_access_list
            
            	Ipv6 Access\-list name
            	**type**\:  str
            
            .. attribute:: v6acl_type
            
            	Access\-list type
            	**type**\:   :py:class:`Snmpacl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmpacl>`
            
            .. attribute:: write_view
            
            	write view name
            	**type**\:  str
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Groups.Group, self).__init__()

                self.yang_name = "group"
                self.yang_parent_name = "groups"

                self.name = YLeaf(YType.str, "name")

                self.context_name = YLeaf(YType.str, "context-name")

                self.notify_view = YLeaf(YType.str, "notify-view")

                self.read_view = YLeaf(YType.str, "read-view")

                self.security_model = YLeaf(YType.enumeration, "security-model")

                self.snmp_version = YLeaf(YType.enumeration, "snmp-version")

                self.v4_access_list = YLeaf(YType.str, "v4-access-list")

                self.v4acl_type = YLeaf(YType.enumeration, "v4acl-type")

                self.v6_access_list = YLeaf(YType.str, "v6-access-list")

                self.v6acl_type = YLeaf(YType.enumeration, "v6acl-type")

                self.write_view = YLeaf(YType.str, "write-view")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("name",
                                "context_name",
                                "notify_view",
                                "read_view",
                                "security_model",
                                "snmp_version",
                                "v4_access_list",
                                "v4acl_type",
                                "v6_access_list",
                                "v6acl_type",
                                "write_view") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Groups.Group, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Groups.Group, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.name.is_set or
                    self.context_name.is_set or
                    self.notify_view.is_set or
                    self.read_view.is_set or
                    self.security_model.is_set or
                    self.snmp_version.is_set or
                    self.v4_access_list.is_set or
                    self.v4acl_type.is_set or
                    self.v6_access_list.is_set or
                    self.v6acl_type.is_set or
                    self.write_view.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.name.yfilter != YFilter.not_set or
                    self.context_name.yfilter != YFilter.not_set or
                    self.notify_view.yfilter != YFilter.not_set or
                    self.read_view.yfilter != YFilter.not_set or
                    self.security_model.yfilter != YFilter.not_set or
                    self.snmp_version.yfilter != YFilter.not_set or
                    self.v4_access_list.yfilter != YFilter.not_set or
                    self.v4acl_type.yfilter != YFilter.not_set or
                    self.v6_access_list.yfilter != YFilter.not_set or
                    self.v6acl_type.yfilter != YFilter.not_set or
                    self.write_view.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "group" + "[name='" + self.name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/groups/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.name.get_name_leafdata())
                if (self.context_name.is_set or self.context_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.context_name.get_name_leafdata())
                if (self.notify_view.is_set or self.notify_view.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.notify_view.get_name_leafdata())
                if (self.read_view.is_set or self.read_view.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.read_view.get_name_leafdata())
                if (self.security_model.is_set or self.security_model.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.security_model.get_name_leafdata())
                if (self.snmp_version.is_set or self.snmp_version.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.snmp_version.get_name_leafdata())
                if (self.v4_access_list.is_set or self.v4_access_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v4_access_list.get_name_leafdata())
                if (self.v4acl_type.is_set or self.v4acl_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v4acl_type.get_name_leafdata())
                if (self.v6_access_list.is_set or self.v6_access_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v6_access_list.get_name_leafdata())
                if (self.v6acl_type.is_set or self.v6acl_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.v6acl_type.get_name_leafdata())
                if (self.write_view.is_set or self.write_view.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.write_view.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "name" or name == "context-name" or name == "notify-view" or name == "read-view" or name == "security-model" or name == "snmp-version" or name == "v4-access-list" or name == "v4acl-type" or name == "v6-access-list" or name == "v6acl-type" or name == "write-view"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "name"):
                    self.name = value
                    self.name.value_namespace = name_space
                    self.name.value_namespace_prefix = name_space_prefix
                if(value_path == "context-name"):
                    self.context_name = value
                    self.context_name.value_namespace = name_space
                    self.context_name.value_namespace_prefix = name_space_prefix
                if(value_path == "notify-view"):
                    self.notify_view = value
                    self.notify_view.value_namespace = name_space
                    self.notify_view.value_namespace_prefix = name_space_prefix
                if(value_path == "read-view"):
                    self.read_view = value
                    self.read_view.value_namespace = name_space
                    self.read_view.value_namespace_prefix = name_space_prefix
                if(value_path == "security-model"):
                    self.security_model = value
                    self.security_model.value_namespace = name_space
                    self.security_model.value_namespace_prefix = name_space_prefix
                if(value_path == "snmp-version"):
                    self.snmp_version = value
                    self.snmp_version.value_namespace = name_space
                    self.snmp_version.value_namespace_prefix = name_space_prefix
                if(value_path == "v4-access-list"):
                    self.v4_access_list = value
                    self.v4_access_list.value_namespace = name_space
                    self.v4_access_list.value_namespace_prefix = name_space_prefix
                if(value_path == "v4acl-type"):
                    self.v4acl_type = value
                    self.v4acl_type.value_namespace = name_space
                    self.v4acl_type.value_namespace_prefix = name_space_prefix
                if(value_path == "v6-access-list"):
                    self.v6_access_list = value
                    self.v6_access_list.value_namespace = name_space
                    self.v6_access_list.value_namespace_prefix = name_space_prefix
                if(value_path == "v6acl-type"):
                    self.v6acl_type = value
                    self.v6acl_type.value_namespace = name_space
                    self.v6acl_type.value_namespace_prefix = name_space_prefix
                if(value_path == "write-view"):
                    self.write_view = value
                    self.write_view.value_namespace = name_space
                    self.write_view.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.group:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.group:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "groups" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "group"):
                for c in self.group:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.Groups.Group()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.group.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "group"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TrapHosts(Entity):
        """
        Specify hosts to receive SNMP notifications
        
        .. attribute:: trap_host
        
        	Specify hosts to receive SNMP notifications
        	**type**\: list of    :py:class:`TrapHost <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.TrapHosts, self).__init__()

            self.yang_name = "trap-hosts"
            self.yang_parent_name = "snmp"

            self.trap_host = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.TrapHosts, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.TrapHosts, self).__setattr__(name, value)


        class TrapHost(Entity):
            """
            Specify hosts to receive SNMP notifications
            
            .. attribute:: ip_address  <key>
            
            	IP address of SNMP notification host
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: default_user_communities
            
            	Container class for defining communities for a trap host
            	**type**\:   :py:class:`DefaultUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.DefaultUserCommunities>`
            
            .. attribute:: encrypted_user_communities
            
            	Container class for defining Clear/encrypt communities for a trap host
            	**type**\:   :py:class:`EncryptedUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.EncryptedUserCommunities>`
            
            .. attribute:: inform_host
            
            	Container class for defining notification type for a Inform host
            	**type**\:   :py:class:`InformHost <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.InformHost>`
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.TrapHosts.TrapHost, self).__init__()

                self.yang_name = "trap-host"
                self.yang_parent_name = "trap-hosts"

                self.ip_address = YLeaf(YType.str, "ip-address")

                self.default_user_communities = Snmp.TrapHosts.TrapHost.DefaultUserCommunities()
                self.default_user_communities.parent = self
                self._children_name_map["default_user_communities"] = "default-user-communities"
                self._children_yang_names.add("default-user-communities")

                self.encrypted_user_communities = Snmp.TrapHosts.TrapHost.EncryptedUserCommunities()
                self.encrypted_user_communities.parent = self
                self._children_name_map["encrypted_user_communities"] = "encrypted-user-communities"
                self._children_yang_names.add("encrypted-user-communities")

                self.inform_host = Snmp.TrapHosts.TrapHost.InformHost()
                self.inform_host.parent = self
                self._children_name_map["inform_host"] = "inform-host"
                self._children_yang_names.add("inform-host")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("ip_address") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.TrapHosts.TrapHost, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.TrapHosts.TrapHost, self).__setattr__(name, value)


            class EncryptedUserCommunities(Entity):
                """
                Container class for defining Clear/encrypt
                communities for a trap host
                
                .. attribute:: encrypted_user_community
                
                	Clear/Encrypt Community name associated with a trap host
                	**type**\: list of    :py:class:`EncryptedUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.TrapHosts.TrapHost.EncryptedUserCommunities, self).__init__()

                    self.yang_name = "encrypted-user-communities"
                    self.yang_parent_name = "trap-host"

                    self.encrypted_user_community = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.TrapHosts.TrapHost.EncryptedUserCommunities, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.TrapHosts.TrapHost.EncryptedUserCommunities, self).__setattr__(name, value)


                class EncryptedUserCommunity(Entity):
                    """
                    Clear/Encrypt Community name associated with
                    a trap host
                    
                    .. attribute:: community_name  <key>
                    
                    	SNMPv1/v2c community string or SNMPv3 user
                    	**type**\:  str
                    
                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                    
                    .. attribute:: advanced_trap_types1
                    
                    	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**mandatory**\: True
                    
                    .. attribute:: advanced_trap_types2
                    
                    	Number to signify the feature traps that needs to be setvalue should always to set as 0
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**mandatory**\: True
                    
                    .. attribute:: basic_trap_types
                    
                    	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**mandatory**\: True
                    
                    .. attribute:: port
                    
                    	UDP port number
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    .. attribute:: security_level
                    
                    	Security level to be used noauth/auth/priv
                    	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                    
                    .. attribute:: version
                    
                    	SNMP Version to be used v1/v2c/v3
                    	**type**\:  str
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity, self).__init__()

                        self.yang_name = "encrypted-user-community"
                        self.yang_parent_name = "encrypted-user-communities"

                        self.community_name = YLeaf(YType.str, "community-name")

                        self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                        self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                        self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                        self.port = YLeaf(YType.uint16, "port")

                        self.security_level = YLeaf(YType.enumeration, "security-level")

                        self.version = YLeaf(YType.str, "version")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("community_name",
                                        "advanced_trap_types1",
                                        "advanced_trap_types2",
                                        "basic_trap_types",
                                        "port",
                                        "security_level",
                                        "version") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.community_name.is_set or
                            self.advanced_trap_types1.is_set or
                            self.advanced_trap_types2.is_set or
                            self.basic_trap_types.is_set or
                            self.port.is_set or
                            self.security_level.is_set or
                            self.version.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.community_name.yfilter != YFilter.not_set or
                            self.advanced_trap_types1.yfilter != YFilter.not_set or
                            self.advanced_trap_types2.yfilter != YFilter.not_set or
                            self.basic_trap_types.yfilter != YFilter.not_set or
                            self.port.yfilter != YFilter.not_set or
                            self.security_level.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "encrypted-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.community_name.get_name_leafdata())
                        if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                        if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                        if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                        if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.port.get_name_leafdata())
                        if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.security_level.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "community-name"):
                            self.community_name = value
                            self.community_name.value_namespace = name_space
                            self.community_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "advanced-trap-types1"):
                            self.advanced_trap_types1 = value
                            self.advanced_trap_types1.value_namespace = name_space
                            self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                        if(value_path == "advanced-trap-types2"):
                            self.advanced_trap_types2 = value
                            self.advanced_trap_types2.value_namespace = name_space
                            self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                        if(value_path == "basic-trap-types"):
                            self.basic_trap_types = value
                            self.basic_trap_types.value_namespace = name_space
                            self.basic_trap_types.value_namespace_prefix = name_space_prefix
                        if(value_path == "port"):
                            self.port = value
                            self.port.value_namespace = name_space
                            self.port.value_namespace_prefix = name_space_prefix
                        if(value_path == "security-level"):
                            self.security_level = value
                            self.security_level.value_namespace = name_space
                            self.security_level.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.encrypted_user_community:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.encrypted_user_community:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "encrypted-user-communities" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "encrypted-user-community"):
                        for c in self.encrypted_user_community:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Snmp.TrapHosts.TrapHost.EncryptedUserCommunities.EncryptedUserCommunity()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.encrypted_user_community.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "encrypted-user-community"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class InformHost(Entity):
                """
                Container class for defining notification type
                for a Inform host
                
                .. attribute:: inform_encrypted_user_communities
                
                	Container class for defining Clear/encrypt communities for a inform host
                	**type**\:   :py:class:`InformEncryptedUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities>`
                
                .. attribute:: inform_user_communities
                
                	Container class for defining communities for a inform host
                	**type**\:   :py:class:`InformUserCommunities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.TrapHosts.TrapHost.InformHost, self).__init__()

                    self.yang_name = "inform-host"
                    self.yang_parent_name = "trap-host"

                    self.inform_encrypted_user_communities = Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities()
                    self.inform_encrypted_user_communities.parent = self
                    self._children_name_map["inform_encrypted_user_communities"] = "inform-encrypted-user-communities"
                    self._children_yang_names.add("inform-encrypted-user-communities")

                    self.inform_user_communities = Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities()
                    self.inform_user_communities.parent = self
                    self._children_name_map["inform_user_communities"] = "inform-user-communities"
                    self._children_yang_names.add("inform-user-communities")


                class InformUserCommunities(Entity):
                    """
                    Container class for defining communities for
                    a inform host
                    
                    .. attribute:: inform_user_community
                    
                    	Unencrpted Community name associated with a inform host
                    	**type**\: list of    :py:class:`InformUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities, self).__init__()

                        self.yang_name = "inform-user-communities"
                        self.yang_parent_name = "inform-host"

                        self.inform_user_community = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities, self).__setattr__(name, value)


                    class InformUserCommunity(Entity):
                        """
                        Unencrpted Community name associated with a
                        inform host
                        
                        .. attribute:: community_name  <key>
                        
                        	SNMPv2c community string or SNMPv3 user
                        	**type**\:  str
                        
                        	**length:** 1..128
                        
                        .. attribute:: advanced_trap_types1
                        
                        	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**mandatory**\: True
                        
                        .. attribute:: advanced_trap_types2
                        
                        	Number to signify the feature traps that needs to be setvalue should always to set as 0
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**mandatory**\: True
                        
                        .. attribute:: basic_trap_types
                        
                        	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072 ,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**mandatory**\: True
                        
                        .. attribute:: port
                        
                        	UDP port number
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        .. attribute:: security_level
                        
                        	Security level to be used noauth/auth/priv
                        	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                        
                        .. attribute:: version
                        
                        	SNMP Version to be used v2c/v3
                        	**type**\:  str
                        
                        	**mandatory**\: True
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity, self).__init__()

                            self.yang_name = "inform-user-community"
                            self.yang_parent_name = "inform-user-communities"

                            self.community_name = YLeaf(YType.str, "community-name")

                            self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                            self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                            self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                            self.port = YLeaf(YType.uint16, "port")

                            self.security_level = YLeaf(YType.enumeration, "security-level")

                            self.version = YLeaf(YType.str, "version")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("community_name",
                                            "advanced_trap_types1",
                                            "advanced_trap_types2",
                                            "basic_trap_types",
                                            "port",
                                            "security_level",
                                            "version") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.community_name.is_set or
                                self.advanced_trap_types1.is_set or
                                self.advanced_trap_types2.is_set or
                                self.basic_trap_types.is_set or
                                self.port.is_set or
                                self.security_level.is_set or
                                self.version.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.community_name.yfilter != YFilter.not_set or
                                self.advanced_trap_types1.yfilter != YFilter.not_set or
                                self.advanced_trap_types2.yfilter != YFilter.not_set or
                                self.basic_trap_types.yfilter != YFilter.not_set or
                                self.port.yfilter != YFilter.not_set or
                                self.security_level.yfilter != YFilter.not_set or
                                self.version.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "inform-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.community_name.get_name_leafdata())
                            if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                            if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                            if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                            if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.port.get_name_leafdata())
                            if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.security_level.get_name_leafdata())
                            if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.version.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "community-name"):
                                self.community_name = value
                                self.community_name.value_namespace = name_space
                                self.community_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "advanced-trap-types1"):
                                self.advanced_trap_types1 = value
                                self.advanced_trap_types1.value_namespace = name_space
                                self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                            if(value_path == "advanced-trap-types2"):
                                self.advanced_trap_types2 = value
                                self.advanced_trap_types2.value_namespace = name_space
                                self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                            if(value_path == "basic-trap-types"):
                                self.basic_trap_types = value
                                self.basic_trap_types.value_namespace = name_space
                                self.basic_trap_types.value_namespace_prefix = name_space_prefix
                            if(value_path == "port"):
                                self.port = value
                                self.port.value_namespace = name_space
                                self.port.value_namespace_prefix = name_space_prefix
                            if(value_path == "security-level"):
                                self.security_level = value
                                self.security_level.value_namespace = name_space
                                self.security_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "version"):
                                self.version = value
                                self.version.value_namespace = name_space
                                self.version.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.inform_user_community:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.inform_user_community:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "inform-user-communities" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "inform-user-community"):
                            for c in self.inform_user_community:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities.InformUserCommunity()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.inform_user_community.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "inform-user-community"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class InformEncryptedUserCommunities(Entity):
                    """
                    Container class for defining Clear/encrypt
                    communities for a inform host
                    
                    .. attribute:: inform_encrypted_user_community
                    
                    	Clear/Encrypt Community name associated with a inform host
                    	**type**\: list of    :py:class:`InformEncryptedUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity>`
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities, self).__init__()

                        self.yang_name = "inform-encrypted-user-communities"
                        self.yang_parent_name = "inform-host"

                        self.inform_encrypted_user_community = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities, self).__setattr__(name, value)


                    class InformEncryptedUserCommunity(Entity):
                        """
                        Clear/Encrypt Community name associated with
                        a inform host
                        
                        .. attribute:: community_name  <key>
                        
                        	SNMPv2c community string or SNMPv3 user
                        	**type**\:  str
                        
                        	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                        
                        .. attribute:: advanced_trap_types1
                        
                        	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**mandatory**\: True
                        
                        .. attribute:: advanced_trap_types2
                        
                        	Number to signify the feature traps that needs to be setvalue should always to set as 0
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**mandatory**\: True
                        
                        .. attribute:: basic_trap_types
                        
                        	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072 ,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**mandatory**\: True
                        
                        .. attribute:: port
                        
                        	UDP port number
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        .. attribute:: security_level
                        
                        	Security level to be used noauth/auth/priv
                        	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                        
                        .. attribute:: version
                        
                        	SNMP Version to be used v2c/v3
                        	**type**\:  str
                        
                        	**mandatory**\: True
                        
                        

                        """

                        _prefix = 'snmp-agent-cfg'
                        _revision = '2015-10-27'

                        def __init__(self):
                            super(Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity, self).__init__()

                            self.yang_name = "inform-encrypted-user-community"
                            self.yang_parent_name = "inform-encrypted-user-communities"

                            self.community_name = YLeaf(YType.str, "community-name")

                            self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                            self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                            self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                            self.port = YLeaf(YType.uint16, "port")

                            self.security_level = YLeaf(YType.enumeration, "security-level")

                            self.version = YLeaf(YType.str, "version")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("community_name",
                                            "advanced_trap_types1",
                                            "advanced_trap_types2",
                                            "basic_trap_types",
                                            "port",
                                            "security_level",
                                            "version") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.community_name.is_set or
                                self.advanced_trap_types1.is_set or
                                self.advanced_trap_types2.is_set or
                                self.basic_trap_types.is_set or
                                self.port.is_set or
                                self.security_level.is_set or
                                self.version.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.community_name.yfilter != YFilter.not_set or
                                self.advanced_trap_types1.yfilter != YFilter.not_set or
                                self.advanced_trap_types2.yfilter != YFilter.not_set or
                                self.basic_trap_types.yfilter != YFilter.not_set or
                                self.port.yfilter != YFilter.not_set or
                                self.security_level.yfilter != YFilter.not_set or
                                self.version.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "inform-encrypted-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.community_name.get_name_leafdata())
                            if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                            if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                            if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                            if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.port.get_name_leafdata())
                            if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.security_level.get_name_leafdata())
                            if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.version.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "community-name"):
                                self.community_name = value
                                self.community_name.value_namespace = name_space
                                self.community_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "advanced-trap-types1"):
                                self.advanced_trap_types1 = value
                                self.advanced_trap_types1.value_namespace = name_space
                                self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                            if(value_path == "advanced-trap-types2"):
                                self.advanced_trap_types2 = value
                                self.advanced_trap_types2.value_namespace = name_space
                                self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                            if(value_path == "basic-trap-types"):
                                self.basic_trap_types = value
                                self.basic_trap_types.value_namespace = name_space
                                self.basic_trap_types.value_namespace_prefix = name_space_prefix
                            if(value_path == "port"):
                                self.port = value
                                self.port.value_namespace = name_space
                                self.port.value_namespace_prefix = name_space_prefix
                            if(value_path == "security-level"):
                                self.security_level = value
                                self.security_level.value_namespace = name_space
                                self.security_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "version"):
                                self.version = value
                                self.version.value_namespace = name_space
                                self.version.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.inform_encrypted_user_community:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.inform_encrypted_user_community:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "inform-encrypted-user-communities" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "inform-encrypted-user-community"):
                            for c in self.inform_encrypted_user_community:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities.InformEncryptedUserCommunity()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.inform_encrypted_user_community.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "inform-encrypted-user-community"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.inform_encrypted_user_communities is not None and self.inform_encrypted_user_communities.has_data()) or
                        (self.inform_user_communities is not None and self.inform_user_communities.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.inform_encrypted_user_communities is not None and self.inform_encrypted_user_communities.has_operation()) or
                        (self.inform_user_communities is not None and self.inform_user_communities.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "inform-host" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "inform-encrypted-user-communities"):
                        if (self.inform_encrypted_user_communities is None):
                            self.inform_encrypted_user_communities = Snmp.TrapHosts.TrapHost.InformHost.InformEncryptedUserCommunities()
                            self.inform_encrypted_user_communities.parent = self
                            self._children_name_map["inform_encrypted_user_communities"] = "inform-encrypted-user-communities"
                        return self.inform_encrypted_user_communities

                    if (child_yang_name == "inform-user-communities"):
                        if (self.inform_user_communities is None):
                            self.inform_user_communities = Snmp.TrapHosts.TrapHost.InformHost.InformUserCommunities()
                            self.inform_user_communities.parent = self
                            self._children_name_map["inform_user_communities"] = "inform-user-communities"
                        return self.inform_user_communities

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "inform-encrypted-user-communities" or name == "inform-user-communities"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class DefaultUserCommunities(Entity):
                """
                Container class for defining communities for a
                trap host
                
                .. attribute:: default_user_community
                
                	Unencrpted Community name associated with a trap host
                	**type**\: list of    :py:class:`DefaultUserCommunity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity>`
                
                

                """

                _prefix = 'snmp-agent-cfg'
                _revision = '2015-10-27'

                def __init__(self):
                    super(Snmp.TrapHosts.TrapHost.DefaultUserCommunities, self).__init__()

                    self.yang_name = "default-user-communities"
                    self.yang_parent_name = "trap-host"

                    self.default_user_community = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Snmp.TrapHosts.TrapHost.DefaultUserCommunities, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Snmp.TrapHosts.TrapHost.DefaultUserCommunities, self).__setattr__(name, value)


                class DefaultUserCommunity(Entity):
                    """
                    Unencrpted Community name associated with a
                    trap host
                    
                    .. attribute:: community_name  <key>
                    
                    	SNMPv1/v2c community string or SNMPv3 user
                    	**type**\:  str
                    
                    	**length:** 1..128
                    
                    .. attribute:: advanced_trap_types1
                    
                    	Number to signify the feature traps that needs to be setUse this for providing copy\-complete trapValue must be set to 0 if not used
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**mandatory**\: True
                    
                    .. attribute:: advanced_trap_types2
                    
                    	Number to signify the feature traps that needs to be setvalue should always to set as 0
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**mandatory**\: True
                    
                    .. attribute:: basic_trap_types
                    
                    	Number to signify the feature traps that needs to be setBasicTrapTypes is used for all traps except copy\-completeSet this value to an integer corresponding to the trapBGP 8192, CONFIG 4096,SYSLOG 131072,SNMP\_TRAP 1COPY\_COMPLETE\_TRAP 64To provide a combination of trap Add the respective numbersValue must be set to 0 for all traps
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**mandatory**\: True
                    
                    .. attribute:: port
                    
                    	UDP port number
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    .. attribute:: security_level
                    
                    	Security level to be used noauth/auth/priv
                    	**type**\:   :py:class:`SnmpSecurityModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpSecurityModel>`
                    
                    .. attribute:: version
                    
                    	SNMP Version to be used v1/v2c/v3
                    	**type**\:  str
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'snmp-agent-cfg'
                    _revision = '2015-10-27'

                    def __init__(self):
                        super(Snmp.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity, self).__init__()

                        self.yang_name = "default-user-community"
                        self.yang_parent_name = "default-user-communities"

                        self.community_name = YLeaf(YType.str, "community-name")

                        self.advanced_trap_types1 = YLeaf(YType.int32, "advanced-trap-types1")

                        self.advanced_trap_types2 = YLeaf(YType.int32, "advanced-trap-types2")

                        self.basic_trap_types = YLeaf(YType.int32, "basic-trap-types")

                        self.port = YLeaf(YType.uint16, "port")

                        self.security_level = YLeaf(YType.enumeration, "security-level")

                        self.version = YLeaf(YType.str, "version")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("community_name",
                                        "advanced_trap_types1",
                                        "advanced_trap_types2",
                                        "basic_trap_types",
                                        "port",
                                        "security_level",
                                        "version") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Snmp.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Snmp.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.community_name.is_set or
                            self.advanced_trap_types1.is_set or
                            self.advanced_trap_types2.is_set or
                            self.basic_trap_types.is_set or
                            self.port.is_set or
                            self.security_level.is_set or
                            self.version.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.community_name.yfilter != YFilter.not_set or
                            self.advanced_trap_types1.yfilter != YFilter.not_set or
                            self.advanced_trap_types2.yfilter != YFilter.not_set or
                            self.basic_trap_types.yfilter != YFilter.not_set or
                            self.port.yfilter != YFilter.not_set or
                            self.security_level.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "default-user-community" + "[community-name='" + self.community_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.community_name.is_set or self.community_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.community_name.get_name_leafdata())
                        if (self.advanced_trap_types1.is_set or self.advanced_trap_types1.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advanced_trap_types1.get_name_leafdata())
                        if (self.advanced_trap_types2.is_set or self.advanced_trap_types2.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advanced_trap_types2.get_name_leafdata())
                        if (self.basic_trap_types.is_set or self.basic_trap_types.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.basic_trap_types.get_name_leafdata())
                        if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.port.get_name_leafdata())
                        if (self.security_level.is_set or self.security_level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.security_level.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "community-name" or name == "advanced-trap-types1" or name == "advanced-trap-types2" or name == "basic-trap-types" or name == "port" or name == "security-level" or name == "version"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "community-name"):
                            self.community_name = value
                            self.community_name.value_namespace = name_space
                            self.community_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "advanced-trap-types1"):
                            self.advanced_trap_types1 = value
                            self.advanced_trap_types1.value_namespace = name_space
                            self.advanced_trap_types1.value_namespace_prefix = name_space_prefix
                        if(value_path == "advanced-trap-types2"):
                            self.advanced_trap_types2 = value
                            self.advanced_trap_types2.value_namespace = name_space
                            self.advanced_trap_types2.value_namespace_prefix = name_space_prefix
                        if(value_path == "basic-trap-types"):
                            self.basic_trap_types = value
                            self.basic_trap_types.value_namespace = name_space
                            self.basic_trap_types.value_namespace_prefix = name_space_prefix
                        if(value_path == "port"):
                            self.port = value
                            self.port.value_namespace = name_space
                            self.port.value_namespace_prefix = name_space_prefix
                        if(value_path == "security-level"):
                            self.security_level = value
                            self.security_level.value_namespace = name_space
                            self.security_level.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.default_user_community:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.default_user_community:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "default-user-communities" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "default-user-community"):
                        for c in self.default_user_community:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Snmp.TrapHosts.TrapHost.DefaultUserCommunities.DefaultUserCommunity()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.default_user_community.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "default-user-community"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.ip_address.is_set or
                    (self.default_user_communities is not None and self.default_user_communities.has_data()) or
                    (self.encrypted_user_communities is not None and self.encrypted_user_communities.has_data()) or
                    (self.inform_host is not None and self.inform_host.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.ip_address.yfilter != YFilter.not_set or
                    (self.default_user_communities is not None and self.default_user_communities.has_operation()) or
                    (self.encrypted_user_communities is not None and self.encrypted_user_communities.has_operation()) or
                    (self.inform_host is not None and self.inform_host.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "trap-host" + "[ip-address='" + self.ip_address.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/trap-hosts/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ip_address.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "default-user-communities"):
                    if (self.default_user_communities is None):
                        self.default_user_communities = Snmp.TrapHosts.TrapHost.DefaultUserCommunities()
                        self.default_user_communities.parent = self
                        self._children_name_map["default_user_communities"] = "default-user-communities"
                    return self.default_user_communities

                if (child_yang_name == "encrypted-user-communities"):
                    if (self.encrypted_user_communities is None):
                        self.encrypted_user_communities = Snmp.TrapHosts.TrapHost.EncryptedUserCommunities()
                        self.encrypted_user_communities.parent = self
                        self._children_name_map["encrypted_user_communities"] = "encrypted-user-communities"
                    return self.encrypted_user_communities

                if (child_yang_name == "inform-host"):
                    if (self.inform_host is None):
                        self.inform_host = Snmp.TrapHosts.TrapHost.InformHost()
                        self.inform_host.parent = self
                        self._children_name_map["inform_host"] = "inform-host"
                    return self.inform_host

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "default-user-communities" or name == "encrypted-user-communities" or name == "inform-host" or name == "ip-address"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "ip-address"):
                    self.ip_address = value
                    self.ip_address.value_namespace = name_space
                    self.ip_address.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.trap_host:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.trap_host:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "trap-hosts" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "trap-host"):
                for c in self.trap_host:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.TrapHosts.TrapHost()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.trap_host.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "trap-host"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Contexts(Entity):
        """
        List of Context Names
        
        .. attribute:: context
        
        	Context Name
        	**type**\: list of    :py:class:`Context <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.Contexts.Context>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.Contexts, self).__init__()

            self.yang_name = "contexts"
            self.yang_parent_name = "snmp"

            self.context = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.Contexts, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.Contexts, self).__setattr__(name, value)


        class Context(Entity):
            """
            Context Name
            
            .. attribute:: context_name  <key>
            
            	Context Name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.Contexts.Context, self).__init__()

                self.yang_name = "context"
                self.yang_parent_name = "contexts"

                self.context_name = YLeaf(YType.str, "context-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("context_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.Contexts.Context, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.Contexts.Context, self).__setattr__(name, value)

            def has_data(self):
                return self.context_name.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.context_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "context" + "[context-name='" + self.context_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/contexts/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.context_name.is_set or self.context_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.context_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "context-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "context-name"):
                    self.context_name = value
                    self.context_name.value_namespace = name_space
                    self.context_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.context:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.context:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "contexts" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "context"):
                for c in self.context:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.Contexts.Context()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.context.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "context"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class ContextMappings(Entity):
        """
        List of context names
        
        .. attribute:: context_mapping
        
        	Context mapping name
        	**type**\: list of    :py:class:`ContextMapping <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Snmp.ContextMappings.ContextMapping>`
        
        

        """

        _prefix = 'snmp-agent-cfg'
        _revision = '2015-10-27'

        def __init__(self):
            super(Snmp.ContextMappings, self).__init__()

            self.yang_name = "context-mappings"
            self.yang_parent_name = "snmp"

            self.context_mapping = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Snmp.ContextMappings, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Snmp.ContextMappings, self).__setattr__(name, value)


        class ContextMapping(Entity):
            """
            Context mapping name
            
            .. attribute:: context_mapping_name  <key>
            
            	Context mapping name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: context
            
            	SNMP context feature type
            	**type**\:   :py:class:`SnmpContext <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.SnmpContext>`
            
            .. attribute:: instance_name
            
            	OSPF protocol instance
            	**type**\:  str
            
            .. attribute:: topology_name
            
            	Topology name associated with the context
            	**type**\:  str
            
            .. attribute:: vrf_name
            
            	VRF name associated with the context
            	**type**\:  str
            
            

            """

            _prefix = 'snmp-agent-cfg'
            _revision = '2015-10-27'

            def __init__(self):
                super(Snmp.ContextMappings.ContextMapping, self).__init__()

                self.yang_name = "context-mapping"
                self.yang_parent_name = "context-mappings"

                self.context_mapping_name = YLeaf(YType.str, "context-mapping-name")

                self.context = YLeaf(YType.enumeration, "context")

                self.instance_name = YLeaf(YType.str, "instance-name")

                self.topology_name = YLeaf(YType.str, "topology-name")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("context_mapping_name",
                                "context",
                                "instance_name",
                                "topology_name",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Snmp.ContextMappings.ContextMapping, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Snmp.ContextMappings.ContextMapping, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.context_mapping_name.is_set or
                    self.context.is_set or
                    self.instance_name.is_set or
                    self.topology_name.is_set or
                    self.vrf_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.context_mapping_name.yfilter != YFilter.not_set or
                    self.context.yfilter != YFilter.not_set or
                    self.instance_name.yfilter != YFilter.not_set or
                    self.topology_name.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "context-mapping" + "[context-mapping-name='" + self.context_mapping_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/context-mappings/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.context_mapping_name.is_set or self.context_mapping_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.context_mapping_name.get_name_leafdata())
                if (self.context.is_set or self.context.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.context.get_name_leafdata())
                if (self.instance_name.is_set or self.instance_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.instance_name.get_name_leafdata())
                if (self.topology_name.is_set or self.topology_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.topology_name.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "context-mapping-name" or name == "context" or name == "instance-name" or name == "topology-name" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "context-mapping-name"):
                    self.context_mapping_name = value
                    self.context_mapping_name.value_namespace = name_space
                    self.context_mapping_name.value_namespace_prefix = name_space_prefix
                if(value_path == "context"):
                    self.context = value
                    self.context.value_namespace = name_space
                    self.context.value_namespace_prefix = name_space_prefix
                if(value_path == "instance-name"):
                    self.instance_name = value
                    self.instance_name.value_namespace = name_space
                    self.instance_name.value_namespace_prefix = name_space_prefix
                if(value_path == "topology-name"):
                    self.topology_name = value
                    self.topology_name.value_namespace = name_space
                    self.topology_name.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.context_mapping:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.context_mapping:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "context-mappings" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "context-mapping"):
                for c in self.context_mapping:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Snmp.ContextMappings.ContextMapping()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.context_mapping.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "context-mapping"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            self.inform_pending.is_set or
            self.inform_retries.is_set or
            self.inform_timeout.is_set or
            self.oid_poll_stats.is_set or
            self.packet_size.is_set or
            self.throttle_time.is_set or
            self.trap_port.is_set or
            self.trap_source.is_set or
            self.trap_source_ipv4.is_set or
            self.trap_source_ipv6.is_set or
            self.vrf_authentication_trap_disable.is_set or
            (self.administration is not None and self.administration.has_data()) or
            (self.agent is not None and self.agent.has_data()) or
            (self.bulk_stats is not None and self.bulk_stats.has_data()) or
            (self.context_mappings is not None and self.context_mappings.has_data()) or
            (self.contexts is not None and self.contexts.has_data()) or
            (self.correlator is not None and self.correlator.has_data()) or
            (self.default_community_maps is not None and self.default_community_maps.has_data()) or
            (self.encrypted_community_maps is not None and self.encrypted_community_maps.has_data()) or
            (self.groups is not None and self.groups.has_data()) or
            (self.ipv4 is not None and self.ipv4.has_data()) or
            (self.ipv6 is not None and self.ipv6.has_data()) or
            (self.logging is not None and self.logging.has_data()) or
            (self.notification is not None and self.notification.has_data()) or
            (self.system is not None and self.system.has_data()) or
            (self.target is not None and self.target.has_data()) or
            (self.timeouts is not None and self.timeouts.has_data()) or
            (self.trap is not None and self.trap.has_data()) or
            (self.trap_hosts is not None and self.trap_hosts.has_data()) or
            (self.users is not None and self.users.has_data()) or
            (self.views is not None and self.views.has_data()) or
            (self.vrfs is not None and self.vrfs.has_data()) or
            (self.overload_control is not None))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            self.inform_pending.yfilter != YFilter.not_set or
            self.inform_retries.yfilter != YFilter.not_set or
            self.inform_timeout.yfilter != YFilter.not_set or
            self.oid_poll_stats.yfilter != YFilter.not_set or
            self.packet_size.yfilter != YFilter.not_set or
            self.throttle_time.yfilter != YFilter.not_set or
            self.trap_port.yfilter != YFilter.not_set or
            self.trap_source.yfilter != YFilter.not_set or
            self.trap_source_ipv4.yfilter != YFilter.not_set or
            self.trap_source_ipv6.yfilter != YFilter.not_set or
            self.vrf_authentication_trap_disable.yfilter != YFilter.not_set or
            (self.administration is not None and self.administration.has_operation()) or
            (self.agent is not None and self.agent.has_operation()) or
            (self.bulk_stats is not None and self.bulk_stats.has_operation()) or
            (self.context_mappings is not None and self.context_mappings.has_operation()) or
            (self.contexts is not None and self.contexts.has_operation()) or
            (self.correlator is not None and self.correlator.has_operation()) or
            (self.default_community_maps is not None and self.default_community_maps.has_operation()) or
            (self.encrypted_community_maps is not None and self.encrypted_community_maps.has_operation()) or
            (self.groups is not None and self.groups.has_operation()) or
            (self.ipv4 is not None and self.ipv4.has_operation()) or
            (self.ipv6 is not None and self.ipv6.has_operation()) or
            (self.logging is not None and self.logging.has_operation()) or
            (self.notification is not None and self.notification.has_operation()) or
            (self.overload_control is not None and self.overload_control.has_operation()) or
            (self.system is not None and self.system.has_operation()) or
            (self.target is not None and self.target.has_operation()) or
            (self.timeouts is not None and self.timeouts.has_operation()) or
            (self.trap is not None and self.trap.has_operation()) or
            (self.trap_hosts is not None and self.trap_hosts.has_operation()) or
            (self.users is not None and self.users.has_operation()) or
            (self.views is not None and self.views.has_operation()) or
            (self.vrfs is not None and self.vrfs.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:snmp" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()
        if (self.inform_pending.is_set or self.inform_pending.yfilter != YFilter.not_set):
            leaf_name_data.append(self.inform_pending.get_name_leafdata())
        if (self.inform_retries.is_set or self.inform_retries.yfilter != YFilter.not_set):
            leaf_name_data.append(self.inform_retries.get_name_leafdata())
        if (self.inform_timeout.is_set or self.inform_timeout.yfilter != YFilter.not_set):
            leaf_name_data.append(self.inform_timeout.get_name_leafdata())
        if (self.oid_poll_stats.is_set or self.oid_poll_stats.yfilter != YFilter.not_set):
            leaf_name_data.append(self.oid_poll_stats.get_name_leafdata())
        if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
            leaf_name_data.append(self.packet_size.get_name_leafdata())
        if (self.throttle_time.is_set or self.throttle_time.yfilter != YFilter.not_set):
            leaf_name_data.append(self.throttle_time.get_name_leafdata())
        if (self.trap_port.is_set or self.trap_port.yfilter != YFilter.not_set):
            leaf_name_data.append(self.trap_port.get_name_leafdata())
        if (self.trap_source.is_set or self.trap_source.yfilter != YFilter.not_set):
            leaf_name_data.append(self.trap_source.get_name_leafdata())
        if (self.trap_source_ipv4.is_set or self.trap_source_ipv4.yfilter != YFilter.not_set):
            leaf_name_data.append(self.trap_source_ipv4.get_name_leafdata())
        if (self.trap_source_ipv6.is_set or self.trap_source_ipv6.yfilter != YFilter.not_set):
            leaf_name_data.append(self.trap_source_ipv6.get_name_leafdata())
        if (self.vrf_authentication_trap_disable.is_set or self.vrf_authentication_trap_disable.yfilter != YFilter.not_set):
            leaf_name_data.append(self.vrf_authentication_trap_disable.get_name_leafdata())

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "administration"):
            if (self.administration is None):
                self.administration = Snmp.Administration()
                self.administration.parent = self
                self._children_name_map["administration"] = "administration"
            return self.administration

        if (child_yang_name == "agent"):
            if (self.agent is None):
                self.agent = Snmp.Agent()
                self.agent.parent = self
                self._children_name_map["agent"] = "agent"
            return self.agent

        if (child_yang_name == "bulk-stats"):
            if (self.bulk_stats is None):
                self.bulk_stats = Snmp.BulkStats()
                self.bulk_stats.parent = self
                self._children_name_map["bulk_stats"] = "bulk-stats"
            return self.bulk_stats

        if (child_yang_name == "context-mappings"):
            if (self.context_mappings is None):
                self.context_mappings = Snmp.ContextMappings()
                self.context_mappings.parent = self
                self._children_name_map["context_mappings"] = "context-mappings"
            return self.context_mappings

        if (child_yang_name == "contexts"):
            if (self.contexts is None):
                self.contexts = Snmp.Contexts()
                self.contexts.parent = self
                self._children_name_map["contexts"] = "contexts"
            return self.contexts

        if (child_yang_name == "correlator"):
            if (self.correlator is None):
                self.correlator = Snmp.Correlator()
                self.correlator.parent = self
                self._children_name_map["correlator"] = "correlator"
            return self.correlator

        if (child_yang_name == "default-community-maps"):
            if (self.default_community_maps is None):
                self.default_community_maps = Snmp.DefaultCommunityMaps()
                self.default_community_maps.parent = self
                self._children_name_map["default_community_maps"] = "default-community-maps"
            return self.default_community_maps

        if (child_yang_name == "encrypted-community-maps"):
            if (self.encrypted_community_maps is None):
                self.encrypted_community_maps = Snmp.EncryptedCommunityMaps()
                self.encrypted_community_maps.parent = self
                self._children_name_map["encrypted_community_maps"] = "encrypted-community-maps"
            return self.encrypted_community_maps

        if (child_yang_name == "groups"):
            if (self.groups is None):
                self.groups = Snmp.Groups()
                self.groups.parent = self
                self._children_name_map["groups"] = "groups"
            return self.groups

        if (child_yang_name == "ipv4"):
            if (self.ipv4 is None):
                self.ipv4 = Snmp.Ipv4()
                self.ipv4.parent = self
                self._children_name_map["ipv4"] = "ipv4"
            return self.ipv4

        if (child_yang_name == "ipv6"):
            if (self.ipv6 is None):
                self.ipv6 = Snmp.Ipv6()
                self.ipv6.parent = self
                self._children_name_map["ipv6"] = "ipv6"
            return self.ipv6

        if (child_yang_name == "logging"):
            if (self.logging is None):
                self.logging = Snmp.Logging()
                self.logging.parent = self
                self._children_name_map["logging"] = "logging"
            return self.logging

        if (child_yang_name == "notification"):
            if (self.notification is None):
                self.notification = Snmp.Notification()
                self.notification.parent = self
                self._children_name_map["notification"] = "notification"
            return self.notification

        if (child_yang_name == "overload-control"):
            if (self.overload_control is None):
                self.overload_control = Snmp.OverloadControl()
                self.overload_control.parent = self
                self._children_name_map["overload_control"] = "overload-control"
            return self.overload_control

        if (child_yang_name == "system"):
            if (self.system is None):
                self.system = Snmp.System()
                self.system.parent = self
                self._children_name_map["system"] = "system"
            return self.system

        if (child_yang_name == "target"):
            if (self.target is None):
                self.target = Snmp.Target()
                self.target.parent = self
                self._children_name_map["target"] = "target"
            return self.target

        if (child_yang_name == "timeouts"):
            if (self.timeouts is None):
                self.timeouts = Snmp.Timeouts()
                self.timeouts.parent = self
                self._children_name_map["timeouts"] = "timeouts"
            return self.timeouts

        if (child_yang_name == "trap"):
            if (self.trap is None):
                self.trap = Snmp.Trap()
                self.trap.parent = self
                self._children_name_map["trap"] = "trap"
            return self.trap

        if (child_yang_name == "trap-hosts"):
            if (self.trap_hosts is None):
                self.trap_hosts = Snmp.TrapHosts()
                self.trap_hosts.parent = self
                self._children_name_map["trap_hosts"] = "trap-hosts"
            return self.trap_hosts

        if (child_yang_name == "users"):
            if (self.users is None):
                self.users = Snmp.Users()
                self.users.parent = self
                self._children_name_map["users"] = "users"
            return self.users

        if (child_yang_name == "views"):
            if (self.views is None):
                self.views = Snmp.Views()
                self.views.parent = self
                self._children_name_map["views"] = "views"
            return self.views

        if (child_yang_name == "vrfs"):
            if (self.vrfs is None):
                self.vrfs = Snmp.Vrfs()
                self.vrfs.parent = self
                self._children_name_map["vrfs"] = "vrfs"
            return self.vrfs

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "administration" or name == "agent" or name == "bulk-stats" or name == "context-mappings" or name == "contexts" or name == "correlator" or name == "default-community-maps" or name == "encrypted-community-maps" or name == "groups" or name == "ipv4" or name == "ipv6" or name == "logging" or name == "notification" or name == "overload-control" or name == "system" or name == "target" or name == "timeouts" or name == "trap" or name == "trap-hosts" or name == "users" or name == "views" or name == "vrfs" or name == "inform-pending" or name == "inform-retries" or name == "inform-timeout" or name == "oid-poll-stats" or name == "packet-size" or name == "throttle-time" or name == "trap-port" or name == "trap-source" or name == "trap-source-ipv4" or name == "trap-source-ipv6" or name == "vrf-authentication-trap-disable"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        if(value_path == "inform-pending"):
            self.inform_pending = value
            self.inform_pending.value_namespace = name_space
            self.inform_pending.value_namespace_prefix = name_space_prefix
        if(value_path == "inform-retries"):
            self.inform_retries = value
            self.inform_retries.value_namespace = name_space
            self.inform_retries.value_namespace_prefix = name_space_prefix
        if(value_path == "inform-timeout"):
            self.inform_timeout = value
            self.inform_timeout.value_namespace = name_space
            self.inform_timeout.value_namespace_prefix = name_space_prefix
        if(value_path == "oid-poll-stats"):
            self.oid_poll_stats = value
            self.oid_poll_stats.value_namespace = name_space
            self.oid_poll_stats.value_namespace_prefix = name_space_prefix
        if(value_path == "packet-size"):
            self.packet_size = value
            self.packet_size.value_namespace = name_space
            self.packet_size.value_namespace_prefix = name_space_prefix
        if(value_path == "throttle-time"):
            self.throttle_time = value
            self.throttle_time.value_namespace = name_space
            self.throttle_time.value_namespace_prefix = name_space_prefix
        if(value_path == "trap-port"):
            self.trap_port = value
            self.trap_port.value_namespace = name_space
            self.trap_port.value_namespace_prefix = name_space_prefix
        if(value_path == "trap-source"):
            self.trap_source = value
            self.trap_source.value_namespace = name_space
            self.trap_source.value_namespace_prefix = name_space_prefix
        if(value_path == "trap-source-ipv4"):
            self.trap_source_ipv4 = value
            self.trap_source_ipv4.value_namespace = name_space
            self.trap_source_ipv4.value_namespace_prefix = name_space_prefix
        if(value_path == "trap-source-ipv6"):
            self.trap_source_ipv6 = value
            self.trap_source_ipv6.value_namespace = name_space
            self.trap_source_ipv6.value_namespace_prefix = name_space_prefix
        if(value_path == "vrf-authentication-trap-disable"):
            self.vrf_authentication_trap_disable = value
            self.vrf_authentication_trap_disable.value_namespace = name_space
            self.vrf_authentication_trap_disable.value_namespace_prefix = name_space_prefix

    def clone_ptr(self):
        self._top_entity = Snmp()
        return self._top_entity

class Mib(Entity):
    """
    mib
    
    .. attribute:: cb_qosmib
    
    	CBQoSMIB configuration
    	**type**\:   :py:class:`CbQosmib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.CbQosmib>`
    
    .. attribute:: entity_mib
    
    	Entity MIB
    	**type**\:   :py:class:`EntityMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.EntityMib>`
    
    .. attribute:: interface_mib
    
    	Interface MIB configuration
    	**type**\:   :py:class:`InterfaceMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.InterfaceMib>`
    
    .. attribute:: mpls_frr_mib
    
    	FRR MIB configuration
    	**type**\:   :py:class:`MplsFrrMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.MplsFrrMib>`
    
    .. attribute:: mpls_p2mp_mib
    
    	MPLS P2MP MIB configuration
    	**type**\:   :py:class:`MplsP2MpMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.MplsP2MpMib>`
    
    .. attribute:: mpls_te_ext_mib
    
    	MPLS TE EXT MIB configuration
    	**type**\:   :py:class:`MplsTeExtMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.MplsTeExtMib>`
    
    .. attribute:: mpls_te_ext_std_mib
    
    	MPLS TE EXT STD MIB configuration
    	**type**\:   :py:class:`MplsTeExtStdMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.MplsTeExtStdMib>`
    
    .. attribute:: mpls_te_mib
    
    	MPLS TE MIB configuration
    	**type**\:   :py:class:`MplsTeMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.MplsTeMib>`
    
    .. attribute:: sensor_mib_cache
    
    	Get cached Sesnsor MIB statistics
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    

    """

    _prefix = 'snmp-agent-cfg'
    _revision = '2015-10-27'

    def __init__(self):
        super(Mib, self).__init__()
        self._top_entity = None

        self.yang_name = "mib"
        self.yang_parent_name = "Cisco-IOS-XR-snmp-agent-cfg"

        self.sensor_mib_cache = YLeaf(YType.empty, "Cisco-IOS-XR-snmp-ciscosensormib-cfg:sensor-mib-cache")

        self.cb_qosmib = Mib.CbQosmib()
        self.cb_qosmib.parent = self
        self._children_name_map["cb_qosmib"] = "cb-qosmib"
        self._children_yang_names.add("cb-qosmib")

        self.entity_mib = Mib.EntityMib()
        self.entity_mib.parent = self
        self._children_name_map["entity_mib"] = "entity-mib"
        self._children_yang_names.add("entity-mib")

        self.interface_mib = Mib.InterfaceMib()
        self.interface_mib.parent = self
        self._children_name_map["interface_mib"] = "interface-mib"
        self._children_yang_names.add("interface-mib")

        self.mpls_frr_mib = Mib.MplsFrrMib()
        self.mpls_frr_mib.parent = self
        self._children_name_map["mpls_frr_mib"] = "mpls-frr-mib"
        self._children_yang_names.add("mpls-frr-mib")

        self.mpls_p2mp_mib = Mib.MplsP2MpMib()
        self.mpls_p2mp_mib.parent = self
        self._children_name_map["mpls_p2mp_mib"] = "mpls-p2mp-mib"
        self._children_yang_names.add("mpls-p2mp-mib")

        self.mpls_te_ext_mib = Mib.MplsTeExtMib()
        self.mpls_te_ext_mib.parent = self
        self._children_name_map["mpls_te_ext_mib"] = "mpls-te-ext-mib"
        self._children_yang_names.add("mpls-te-ext-mib")

        self.mpls_te_ext_std_mib = Mib.MplsTeExtStdMib()
        self.mpls_te_ext_std_mib.parent = self
        self._children_name_map["mpls_te_ext_std_mib"] = "mpls-te-ext-std-mib"
        self._children_yang_names.add("mpls-te-ext-std-mib")

        self.mpls_te_mib = Mib.MplsTeMib()
        self.mpls_te_mib.parent = self
        self._children_name_map["mpls_te_mib"] = "mpls-te-mib"
        self._children_yang_names.add("mpls-te-mib")

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in ("sensor_mib_cache") and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(Mib, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(Mib, self).__setattr__(name, value)


    class MplsTeMib(Entity):
        """
        MPLS TE MIB configuration
        
        .. attribute:: cache_garbage_collect_timer
        
        	Configure the cache garbage collector time for the mib
        	**type**\:  int
        
        	**range:** 0..3600
        
        	**units**\: second
        
        	**default value**\: 1800
        
        .. attribute:: cache_timer
        
        	Configure the cache time for the mib
        	**type**\:  int
        
        	**range:** 0..600
        
        	**units**\: second
        
        	**default value**\: 60
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Mib.MplsTeMib, self).__init__()

            self.yang_name = "mpls-te-mib"
            self.yang_parent_name = "mib"

            self.cache_garbage_collect_timer = YLeaf(YType.uint32, "cache-garbage-collect-timer")

            self.cache_timer = YLeaf(YType.uint32, "cache-timer")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cache_garbage_collect_timer",
                            "cache_timer") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.MplsTeMib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.MplsTeMib, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.cache_garbage_collect_timer.is_set or
                self.cache_timer.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cache_garbage_collect_timer.yfilter != YFilter.not_set or
                self.cache_timer.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te-mib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cache_garbage_collect_timer.is_set or self.cache_garbage_collect_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cache_garbage_collect_timer.get_name_leafdata())
            if (self.cache_timer.is_set or self.cache_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cache_timer.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cache-garbage-collect-timer" or name == "cache-timer"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "cache-garbage-collect-timer"):
                self.cache_garbage_collect_timer = value
                self.cache_garbage_collect_timer.value_namespace = name_space
                self.cache_garbage_collect_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "cache-timer"):
                self.cache_timer = value
                self.cache_timer.value_namespace = name_space
                self.cache_timer.value_namespace_prefix = name_space_prefix


    class MplsP2MpMib(Entity):
        """
        MPLS P2MP MIB configuration
        
        .. attribute:: cache_timer
        
        	Configure the cache time for the mib
        	**type**\:  int
        
        	**range:** 0..600
        
        	**units**\: second
        
        	**default value**\: 60
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Mib.MplsP2MpMib, self).__init__()

            self.yang_name = "mpls-p2mp-mib"
            self.yang_parent_name = "mib"

            self.cache_timer = YLeaf(YType.uint32, "cache-timer")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cache_timer") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.MplsP2MpMib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.MplsP2MpMib, self).__setattr__(name, value)

        def has_data(self):
            return self.cache_timer.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cache_timer.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-p2mp-mib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cache_timer.is_set or self.cache_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cache_timer.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cache-timer"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "cache-timer"):
                self.cache_timer = value
                self.cache_timer.value_namespace = name_space
                self.cache_timer.value_namespace_prefix = name_space_prefix


    class MplsTeExtStdMib(Entity):
        """
        MPLS TE EXT STD MIB configuration
        
        .. attribute:: cache_timer
        
        	Configure the cache time for the mib
        	**type**\:  int
        
        	**range:** 0..600
        
        	**units**\: second
        
        	**default value**\: 60
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Mib.MplsTeExtStdMib, self).__init__()

            self.yang_name = "mpls-te-ext-std-mib"
            self.yang_parent_name = "mib"

            self.cache_timer = YLeaf(YType.uint32, "cache-timer")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cache_timer") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.MplsTeExtStdMib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.MplsTeExtStdMib, self).__setattr__(name, value)

        def has_data(self):
            return self.cache_timer.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cache_timer.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te-ext-std-mib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cache_timer.is_set or self.cache_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cache_timer.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cache-timer"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "cache-timer"):
                self.cache_timer = value
                self.cache_timer.value_namespace = name_space
                self.cache_timer.value_namespace_prefix = name_space_prefix


    class MplsTeExtMib(Entity):
        """
        MPLS TE EXT MIB configuration
        
        .. attribute:: cache_timer
        
        	Configure the cache time for the mib
        	**type**\:  int
        
        	**range:** 0..600
        
        	**units**\: second
        
        	**default value**\: 60
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Mib.MplsTeExtMib, self).__init__()

            self.yang_name = "mpls-te-ext-mib"
            self.yang_parent_name = "mib"

            self.cache_timer = YLeaf(YType.uint32, "cache-timer")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cache_timer") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.MplsTeExtMib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.MplsTeExtMib, self).__setattr__(name, value)

        def has_data(self):
            return self.cache_timer.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cache_timer.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te-ext-mib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cache_timer.is_set or self.cache_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cache_timer.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cache-timer"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "cache-timer"):
                self.cache_timer = value
                self.cache_timer.value_namespace = name_space
                self.cache_timer.value_namespace_prefix = name_space_prefix


    class MplsFrrMib(Entity):
        """
        FRR MIB configuration
        
        .. attribute:: cache_timer
        
        	Configure the cache time for the mib
        	**type**\:  int
        
        	**range:** 0..600
        
        	**units**\: second
        
        	**default value**\: 60
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Mib.MplsFrrMib, self).__init__()

            self.yang_name = "mpls-frr-mib"
            self.yang_parent_name = "mib"

            self.cache_timer = YLeaf(YType.uint32, "cache-timer")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cache_timer") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.MplsFrrMib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.MplsFrrMib, self).__setattr__(name, value)

        def has_data(self):
            return self.cache_timer.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cache_timer.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-frr-mib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cache_timer.is_set or self.cache_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cache_timer.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cache-timer"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "cache-timer"):
                self.cache_timer = value
                self.cache_timer.value_namespace = name_space
                self.cache_timer.value_namespace_prefix = name_space_prefix


    class CbQosmib(Entity):
        """
        CBQoSMIB configuration
        
        .. attribute:: cache
        
        	CBQoSMIB statistics data caching
        	**type**\:   :py:class:`Cache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.CbQosmib.Cache>`
        
        .. attribute:: member_interface_stats
        
        	Enable bundle member interface statistics retrieval
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: persist
        
        	Persist CBQoSMIB config, service\-policy and object indices
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        

        """

        _prefix = 'qos-mibs-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Mib.CbQosmib, self).__init__()

            self.yang_name = "cb-qosmib"
            self.yang_parent_name = "mib"

            self.member_interface_stats = YLeaf(YType.empty, "member-interface-stats")

            self.persist = YLeaf(YType.empty, "persist")

            self.cache = Mib.CbQosmib.Cache()
            self.cache.parent = self
            self._children_name_map["cache"] = "cache"
            self._children_yang_names.add("cache")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("member_interface_stats",
                            "persist") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.CbQosmib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.CbQosmib, self).__setattr__(name, value)


        class Cache(Entity):
            """
            CBQoSMIB statistics data caching
            
            .. attribute:: enable
            
            	Enable CBQoSMIB statistics data caching
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: refresh_time
            
            	Cache refresh time in seconds
            	**type**\:  int
            
            	**range:** 5..60
            
            	**units**\: second
            
            .. attribute:: service_policy_count
            
            	Maximum number of service policies to cache the statistics for
            	**type**\:  int
            
            	**range:** 1..5000
            
            

            """

            _prefix = 'qos-mibs-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Mib.CbQosmib.Cache, self).__init__()

                self.yang_name = "cache"
                self.yang_parent_name = "cb-qosmib"

                self.enable = YLeaf(YType.empty, "enable")

                self.refresh_time = YLeaf(YType.uint32, "refresh-time")

                self.service_policy_count = YLeaf(YType.uint32, "service-policy-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "refresh_time",
                                "service_policy_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mib.CbQosmib.Cache, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mib.CbQosmib.Cache, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.refresh_time.is_set or
                    self.service_policy_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.refresh_time.yfilter != YFilter.not_set or
                    self.service_policy_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "cache" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/Cisco-IOS-XR-qos-mibs-cfg:cb-qosmib/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.refresh_time.is_set or self.refresh_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.refresh_time.get_name_leafdata())
                if (self.service_policy_count.is_set or self.service_policy_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.service_policy_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "refresh-time" or name == "service-policy-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "refresh-time"):
                    self.refresh_time = value
                    self.refresh_time.value_namespace = name_space
                    self.refresh_time.value_namespace_prefix = name_space_prefix
                if(value_path == "service-policy-count"):
                    self.service_policy_count = value
                    self.service_policy_count.value_namespace = name_space
                    self.service_policy_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                self.member_interface_stats.is_set or
                self.persist.is_set or
                (self.cache is not None and self.cache.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.member_interface_stats.yfilter != YFilter.not_set or
                self.persist.yfilter != YFilter.not_set or
                (self.cache is not None and self.cache.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-qos-mibs-cfg:cb-qosmib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.member_interface_stats.is_set or self.member_interface_stats.yfilter != YFilter.not_set):
                leaf_name_data.append(self.member_interface_stats.get_name_leafdata())
            if (self.persist.is_set or self.persist.yfilter != YFilter.not_set):
                leaf_name_data.append(self.persist.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "cache"):
                if (self.cache is None):
                    self.cache = Mib.CbQosmib.Cache()
                    self.cache.parent = self
                    self._children_name_map["cache"] = "cache"
                return self.cache

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cache" or name == "member-interface-stats" or name == "persist"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "member-interface-stats"):
                self.member_interface_stats = value
                self.member_interface_stats.value_namespace = name_space
                self.member_interface_stats.value_namespace_prefix = name_space_prefix
            if(value_path == "persist"):
                self.persist = value
                self.persist.value_namespace = name_space
                self.persist.value_namespace_prefix = name_space_prefix


    class EntityMib(Entity):
        """
        Entity MIB
        
        .. attribute:: entity_index_persistence
        
        	Enable entPhysicalIndex persistence
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        

        """

        _prefix = 'snmp-entitymib-cfg'
        _revision = '2015-01-07'

        def __init__(self):
            super(Mib.EntityMib, self).__init__()

            self.yang_name = "entity-mib"
            self.yang_parent_name = "mib"

            self.entity_index_persistence = YLeaf(YType.empty, "entity-index-persistence")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("entity_index_persistence") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.EntityMib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.EntityMib, self).__setattr__(name, value)

        def has_data(self):
            return self.entity_index_persistence.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.entity_index_persistence.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-snmp-entitymib-cfg:entity-mib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.entity_index_persistence.is_set or self.entity_index_persistence.yfilter != YFilter.not_set):
                leaf_name_data.append(self.entity_index_persistence.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "entity-index-persistence"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "entity-index-persistence"):
                self.entity_index_persistence = value
                self.entity_index_persistence.value_namespace = name_space
                self.entity_index_persistence.value_namespace_prefix = name_space_prefix


    class InterfaceMib(Entity):
        """
        Interface MIB configuration
        
        .. attribute:: interface_alias_long
        
        	Enable support for ifAlias values longer than 64 characters
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: interface_index_persistence
        
        	Enable ifindex persistence
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: interfaces
        
        	Enter the SNMP interface configuration commands
        	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.InterfaceMib.Interfaces>`
        
        .. attribute:: internal_cache
        
        	Get cached interface statistics
        	**type**\:  int
        
        	**range:** 0..60
        
        	**default value**\: 15
        
        .. attribute:: ip_subscriber
        
        	Enable IP subscriber interfaces in IFMIB
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: notification
        
        	MIB notification configuration
        	**type**\:   :py:class:`Notification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.InterfaceMib.Notification>`
        
        .. attribute:: statistics_cache
        
        	Enable cached interface statistics
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: subsets
        
        	Add configuration for an interface subset
        	**type**\:   :py:class:`Subsets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.InterfaceMib.Subsets>`
        
        

        """

        _prefix = 'snmp-ifmib-cfg'
        _revision = '2015-05-14'

        def __init__(self):
            super(Mib.InterfaceMib, self).__init__()

            self.yang_name = "interface-mib"
            self.yang_parent_name = "mib"

            self.interface_alias_long = YLeaf(YType.empty, "interface-alias-long")

            self.interface_index_persistence = YLeaf(YType.empty, "interface-index-persistence")

            self.internal_cache = YLeaf(YType.uint32, "internal-cache")

            self.ip_subscriber = YLeaf(YType.empty, "ip-subscriber")

            self.statistics_cache = YLeaf(YType.empty, "statistics-cache")

            self.interfaces = Mib.InterfaceMib.Interfaces()
            self.interfaces.parent = self
            self._children_name_map["interfaces"] = "interfaces"
            self._children_yang_names.add("interfaces")

            self.notification = Mib.InterfaceMib.Notification()
            self.notification.parent = self
            self._children_name_map["notification"] = "notification"
            self._children_yang_names.add("notification")

            self.subsets = Mib.InterfaceMib.Subsets()
            self.subsets.parent = self
            self._children_name_map["subsets"] = "subsets"
            self._children_yang_names.add("subsets")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("interface_alias_long",
                            "interface_index_persistence",
                            "internal_cache",
                            "ip_subscriber",
                            "statistics_cache") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mib.InterfaceMib, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mib.InterfaceMib, self).__setattr__(name, value)


        class Interfaces(Entity):
            """
            Enter the SNMP interface configuration commands
            
            .. attribute:: interface
            
            	Interface to configure
            	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.InterfaceMib.Interfaces.Interface>`
            
            

            """

            _prefix = 'snmp-ifmib-cfg'
            _revision = '2015-05-14'

            def __init__(self):
                super(Mib.InterfaceMib.Interfaces, self).__init__()

                self.yang_name = "interfaces"
                self.yang_parent_name = "interface-mib"

                self.interface = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mib.InterfaceMib.Interfaces, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mib.InterfaceMib.Interfaces, self).__setattr__(name, value)


            class Interface(Entity):
                """
                Interface to configure
                
                .. attribute:: interface_name  <key>
                
                	The name of the interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: index_persistence
                
                	Enable or disable index persistence
                	**type**\:  bool
                
                .. attribute:: link_up_down
                
                	Enable or disable LinkUpDown notification
                	**type**\:  bool
                
                

                """

                _prefix = 'snmp-ifmib-cfg'
                _revision = '2015-05-14'

                def __init__(self):
                    super(Mib.InterfaceMib.Interfaces.Interface, self).__init__()

                    self.yang_name = "interface"
                    self.yang_parent_name = "interfaces"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.index_persistence = YLeaf(YType.boolean, "index-persistence")

                    self.link_up_down = YLeaf(YType.boolean, "link-up-down")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "index_persistence",
                                    "link_up_down") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mib.InterfaceMib.Interfaces.Interface, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mib.InterfaceMib.Interfaces.Interface, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.index_persistence.is_set or
                        self.link_up_down.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.index_persistence.yfilter != YFilter.not_set or
                        self.link_up_down.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/Cisco-IOS-XR-snmp-ifmib-cfg:interface-mib/interfaces/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.index_persistence.is_set or self.index_persistence.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.index_persistence.get_name_leafdata())
                    if (self.link_up_down.is_set or self.link_up_down.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.link_up_down.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-name" or name == "index-persistence" or name == "link-up-down"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "index-persistence"):
                        self.index_persistence = value
                        self.index_persistence.value_namespace = name_space
                        self.index_persistence.value_namespace_prefix = name_space_prefix
                    if(value_path == "link-up-down"):
                        self.link_up_down = value
                        self.link_up_down.value_namespace = name_space
                        self.link_up_down.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.interface:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.interface:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interfaces" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/Cisco-IOS-XR-snmp-ifmib-cfg:interface-mib/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interface"):
                    for c in self.interface:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mib.InterfaceMib.Interfaces.Interface()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.interface.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Notification(Entity):
            """
            MIB notification configuration
            
            .. attribute:: link_ietf
            
            	Set the varbind of linkupdown trap to the RFC specified varbinds (default cisco)
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'snmp-ifmib-cfg'
            _revision = '2015-05-14'

            def __init__(self):
                super(Mib.InterfaceMib.Notification, self).__init__()

                self.yang_name = "notification"
                self.yang_parent_name = "interface-mib"

                self.link_ietf = YLeaf(YType.empty, "link-ietf")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("link_ietf") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mib.InterfaceMib.Notification, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mib.InterfaceMib.Notification, self).__setattr__(name, value)

            def has_data(self):
                return self.link_ietf.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.link_ietf.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "notification" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/Cisco-IOS-XR-snmp-ifmib-cfg:interface-mib/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.link_ietf.is_set or self.link_ietf.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.link_ietf.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "link-ietf"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "link-ietf"):
                    self.link_ietf = value
                    self.link_ietf.value_namespace = name_space
                    self.link_ietf.value_namespace_prefix = name_space_prefix


        class Subsets(Entity):
            """
            Add configuration for an interface subset
            
            .. attribute:: subset
            
            	Subset priorityID to group ifNames based on Regular Expression
            	**type**\: list of    :py:class:`Subset <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.InterfaceMib.Subsets.Subset>`
            
            

            """

            _prefix = 'snmp-ifmib-cfg'
            _revision = '2015-05-14'

            def __init__(self):
                super(Mib.InterfaceMib.Subsets, self).__init__()

                self.yang_name = "subsets"
                self.yang_parent_name = "interface-mib"

                self.subset = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mib.InterfaceMib.Subsets, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mib.InterfaceMib.Subsets, self).__setattr__(name, value)


            class Subset(Entity):
                """
                Subset priorityID to group ifNames based on
                Regular Expression
                
                .. attribute:: subset_id  <key>
                
                	The interface subset PriorityID
                	**type**\:  int
                
                	**range:** 1..255
                
                .. attribute:: link_up_down
                
                	SNMP linkUp and linkDown notifications
                	**type**\:   :py:class:`LinkUpDown <ydk.models.cisco_ios_xr.Cisco_IOS_XR_snmp_agent_cfg.Mib.InterfaceMib.Subsets.Subset.LinkUpDown>`
                
                

                """

                _prefix = 'snmp-ifmib-cfg'
                _revision = '2015-05-14'

                def __init__(self):
                    super(Mib.InterfaceMib.Subsets.Subset, self).__init__()

                    self.yang_name = "subset"
                    self.yang_parent_name = "subsets"

                    self.subset_id = YLeaf(YType.uint32, "subset-id")

                    self.link_up_down = Mib.InterfaceMib.Subsets.Subset.LinkUpDown()
                    self.link_up_down.parent = self
                    self._children_name_map["link_up_down"] = "link-up-down"
                    self._children_yang_names.add("link-up-down")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("subset_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mib.InterfaceMib.Subsets.Subset, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mib.InterfaceMib.Subsets.Subset, self).__setattr__(name, value)


                class LinkUpDown(Entity):
                    """
                    SNMP linkUp and linkDown notifications
                    
                    .. attribute:: enable
                    
                    	Enable or disable linkupdown notification
                    	**type**\:  bool
                    
                    .. attribute:: regular_expression
                    
                    	Regular expression to match ifName
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'snmp-ifmib-cfg'
                    _revision = '2015-05-14'

                    def __init__(self):
                        super(Mib.InterfaceMib.Subsets.Subset.LinkUpDown, self).__init__()

                        self.yang_name = "link-up-down"
                        self.yang_parent_name = "subset"

                        self.enable = YLeaf(YType.boolean, "enable")

                        self.regular_expression = YLeaf(YType.str, "regular-expression")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "regular_expression") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mib.InterfaceMib.Subsets.Subset.LinkUpDown, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mib.InterfaceMib.Subsets.Subset.LinkUpDown, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.regular_expression.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.regular_expression.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "link-up-down" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.regular_expression.is_set or self.regular_expression.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.regular_expression.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "regular-expression"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "regular-expression"):
                            self.regular_expression = value
                            self.regular_expression.value_namespace = name_space
                            self.regular_expression.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.subset_id.is_set or
                        (self.link_up_down is not None and self.link_up_down.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.subset_id.yfilter != YFilter.not_set or
                        (self.link_up_down is not None and self.link_up_down.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "subset" + "[subset-id='" + self.subset_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/Cisco-IOS-XR-snmp-ifmib-cfg:interface-mib/subsets/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.subset_id.is_set or self.subset_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.subset_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "link-up-down"):
                        if (self.link_up_down is None):
                            self.link_up_down = Mib.InterfaceMib.Subsets.Subset.LinkUpDown()
                            self.link_up_down.parent = self
                            self._children_name_map["link_up_down"] = "link-up-down"
                        return self.link_up_down

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "link-up-down" or name == "subset-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "subset-id"):
                        self.subset_id = value
                        self.subset_id.value_namespace = name_space
                        self.subset_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.subset:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.subset:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "subsets" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/Cisco-IOS-XR-snmp-ifmib-cfg:interface-mib/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "subset"):
                    for c in self.subset:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mib.InterfaceMib.Subsets.Subset()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.subset.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "subset"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.interface_alias_long.is_set or
                self.interface_index_persistence.is_set or
                self.internal_cache.is_set or
                self.ip_subscriber.is_set or
                self.statistics_cache.is_set or
                (self.interfaces is not None and self.interfaces.has_data()) or
                (self.notification is not None and self.notification.has_data()) or
                (self.subsets is not None and self.subsets.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.interface_alias_long.yfilter != YFilter.not_set or
                self.interface_index_persistence.yfilter != YFilter.not_set or
                self.internal_cache.yfilter != YFilter.not_set or
                self.ip_subscriber.yfilter != YFilter.not_set or
                self.statistics_cache.yfilter != YFilter.not_set or
                (self.interfaces is not None and self.interfaces.has_operation()) or
                (self.notification is not None and self.notification.has_operation()) or
                (self.subsets is not None and self.subsets.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "Cisco-IOS-XR-snmp-ifmib-cfg:interface-mib" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.interface_alias_long.is_set or self.interface_alias_long.yfilter != YFilter.not_set):
                leaf_name_data.append(self.interface_alias_long.get_name_leafdata())
            if (self.interface_index_persistence.is_set or self.interface_index_persistence.yfilter != YFilter.not_set):
                leaf_name_data.append(self.interface_index_persistence.get_name_leafdata())
            if (self.internal_cache.is_set or self.internal_cache.yfilter != YFilter.not_set):
                leaf_name_data.append(self.internal_cache.get_name_leafdata())
            if (self.ip_subscriber.is_set or self.ip_subscriber.yfilter != YFilter.not_set):
                leaf_name_data.append(self.ip_subscriber.get_name_leafdata())
            if (self.statistics_cache.is_set or self.statistics_cache.yfilter != YFilter.not_set):
                leaf_name_data.append(self.statistics_cache.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interfaces"):
                if (self.interfaces is None):
                    self.interfaces = Mib.InterfaceMib.Interfaces()
                    self.interfaces.parent = self
                    self._children_name_map["interfaces"] = "interfaces"
                return self.interfaces

            if (child_yang_name == "notification"):
                if (self.notification is None):
                    self.notification = Mib.InterfaceMib.Notification()
                    self.notification.parent = self
                    self._children_name_map["notification"] = "notification"
                return self.notification

            if (child_yang_name == "subsets"):
                if (self.subsets is None):
                    self.subsets = Mib.InterfaceMib.Subsets()
                    self.subsets.parent = self
                    self._children_name_map["subsets"] = "subsets"
                return self.subsets

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interfaces" or name == "notification" or name == "subsets" or name == "interface-alias-long" or name == "interface-index-persistence" or name == "internal-cache" or name == "ip-subscriber" or name == "statistics-cache"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "interface-alias-long"):
                self.interface_alias_long = value
                self.interface_alias_long.value_namespace = name_space
                self.interface_alias_long.value_namespace_prefix = name_space_prefix
            if(value_path == "interface-index-persistence"):
                self.interface_index_persistence = value
                self.interface_index_persistence.value_namespace = name_space
                self.interface_index_persistence.value_namespace_prefix = name_space_prefix
            if(value_path == "internal-cache"):
                self.internal_cache = value
                self.internal_cache.value_namespace = name_space
                self.internal_cache.value_namespace_prefix = name_space_prefix
            if(value_path == "ip-subscriber"):
                self.ip_subscriber = value
                self.ip_subscriber.value_namespace = name_space
                self.ip_subscriber.value_namespace_prefix = name_space_prefix
            if(value_path == "statistics-cache"):
                self.statistics_cache = value
                self.statistics_cache.value_namespace = name_space
                self.statistics_cache.value_namespace_prefix = name_space_prefix

    def has_data(self):
        return (
            self.sensor_mib_cache.is_set or
            (self.cb_qosmib is not None and self.cb_qosmib.has_data()) or
            (self.entity_mib is not None and self.entity_mib.has_data()) or
            (self.interface_mib is not None and self.interface_mib.has_data()) or
            (self.mpls_frr_mib is not None and self.mpls_frr_mib.has_data()) or
            (self.mpls_p2mp_mib is not None and self.mpls_p2mp_mib.has_data()) or
            (self.mpls_te_ext_mib is not None and self.mpls_te_ext_mib.has_data()) or
            (self.mpls_te_ext_std_mib is not None and self.mpls_te_ext_std_mib.has_data()) or
            (self.mpls_te_mib is not None and self.mpls_te_mib.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            self.sensor_mib_cache.yfilter != YFilter.not_set or
            (self.cb_qosmib is not None and self.cb_qosmib.has_operation()) or
            (self.entity_mib is not None and self.entity_mib.has_operation()) or
            (self.interface_mib is not None and self.interface_mib.has_operation()) or
            (self.mpls_frr_mib is not None and self.mpls_frr_mib.has_operation()) or
            (self.mpls_p2mp_mib is not None and self.mpls_p2mp_mib.has_operation()) or
            (self.mpls_te_ext_mib is not None and self.mpls_te_ext_mib.has_operation()) or
            (self.mpls_te_ext_std_mib is not None and self.mpls_te_ext_std_mib.has_operation()) or
            (self.mpls_te_mib is not None and self.mpls_te_mib.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-snmp-agent-cfg:mib" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()
        if (self.sensor_mib_cache.is_set or self.sensor_mib_cache.yfilter != YFilter.not_set):
            leaf_name_data.append(self.sensor_mib_cache.get_name_leafdata())

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "cb-qosmib"):
            if (self.cb_qosmib is None):
                self.cb_qosmib = Mib.CbQosmib()
                self.cb_qosmib.parent = self
                self._children_name_map["cb_qosmib"] = "cb-qosmib"
            return self.cb_qosmib

        if (child_yang_name == "entity-mib"):
            if (self.entity_mib is None):
                self.entity_mib = Mib.EntityMib()
                self.entity_mib.parent = self
                self._children_name_map["entity_mib"] = "entity-mib"
            return self.entity_mib

        if (child_yang_name == "interface-mib"):
            if (self.interface_mib is None):
                self.interface_mib = Mib.InterfaceMib()
                self.interface_mib.parent = self
                self._children_name_map["interface_mib"] = "interface-mib"
            return self.interface_mib

        if (child_yang_name == "mpls-frr-mib"):
            if (self.mpls_frr_mib is None):
                self.mpls_frr_mib = Mib.MplsFrrMib()
                self.mpls_frr_mib.parent = self
                self._children_name_map["mpls_frr_mib"] = "mpls-frr-mib"
            return self.mpls_frr_mib

        if (child_yang_name == "mpls-p2mp-mib"):
            if (self.mpls_p2mp_mib is None):
                self.mpls_p2mp_mib = Mib.MplsP2MpMib()
                self.mpls_p2mp_mib.parent = self
                self._children_name_map["mpls_p2mp_mib"] = "mpls-p2mp-mib"
            return self.mpls_p2mp_mib

        if (child_yang_name == "mpls-te-ext-mib"):
            if (self.mpls_te_ext_mib is None):
                self.mpls_te_ext_mib = Mib.MplsTeExtMib()
                self.mpls_te_ext_mib.parent = self
                self._children_name_map["mpls_te_ext_mib"] = "mpls-te-ext-mib"
            return self.mpls_te_ext_mib

        if (child_yang_name == "mpls-te-ext-std-mib"):
            if (self.mpls_te_ext_std_mib is None):
                self.mpls_te_ext_std_mib = Mib.MplsTeExtStdMib()
                self.mpls_te_ext_std_mib.parent = self
                self._children_name_map["mpls_te_ext_std_mib"] = "mpls-te-ext-std-mib"
            return self.mpls_te_ext_std_mib

        if (child_yang_name == "mpls-te-mib"):
            if (self.mpls_te_mib is None):
                self.mpls_te_mib = Mib.MplsTeMib()
                self.mpls_te_mib.parent = self
                self._children_name_map["mpls_te_mib"] = "mpls-te-mib"
            return self.mpls_te_mib

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "cb-qosmib" or name == "entity-mib" or name == "interface-mib" or name == "mpls-frr-mib" or name == "mpls-p2mp-mib" or name == "mpls-te-ext-mib" or name == "mpls-te-ext-std-mib" or name == "mpls-te-mib" or name == "sensor-mib-cache"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        if(value_path == "sensor-mib-cache"):
            self.sensor_mib_cache = value
            self.sensor_mib_cache.value_namespace = name_space
            self.sensor_mib_cache.value_namespace_prefix = name_space_prefix

    def clone_ptr(self):
        self._top_entity = Mib()
        return self._top_entity

