""" Cisco_IOS_XR_infra_xtc_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR infra\-xtc package operational data.

This module contains definitions
for the following management objects\:
  pce\-lsp\-data\: PCE LSP's data
  pce\-peer\: pce peer
  pce\-topology\: pce topology
  pce\: pce

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class LspSetup(Enum):
    """
    LspSetup

    LSP setup type

    .. data:: setup_rsvp = 0

    	LSP is established using RSVP-TE

    .. data:: setup_sr = 1

    	LSP is established using SR-TE

    .. data:: setup_unknown = 2

    	Unknown LSP establishment method

    """

    setup_rsvp = Enum.YLeaf(0, "setup-rsvp")

    setup_sr = Enum.YLeaf(1, "setup-sr")

    setup_unknown = Enum.YLeaf(2, "setup-unknown")


class LspState(Enum):
    """
    LspState

    LSP setup type

    .. data:: lsp_down = 0

    	LSP is down

    .. data:: lsp_up = 1

    	LSP is up

    """

    lsp_down = Enum.YLeaf(0, "lsp-down")

    lsp_up = Enum.YLeaf(1, "lsp-up")


class PceAfId(Enum):
    """
    PceAfId

    Pce af id

    .. data:: none = 0

    	None

    .. data:: ipv4 = 1

    	IPv4

    .. data:: ipv6 = 2

    	IPv6

    """

    none = Enum.YLeaf(0, "none")

    ipv4 = Enum.YLeaf(1, "ipv4")

    ipv6 = Enum.YLeaf(2, "ipv6")


class PceAsso(Enum):
    """
    PceAsso

    Pce asso

    .. data:: unknown = 0

    	Unknown type

    .. data:: link = 1

    	LINK

    .. data:: node = 2

    	NODE

    .. data:: srlg = 3

    	SRLG

    """

    unknown = Enum.YLeaf(0, "unknown")

    link = Enum.YLeaf(1, "link")

    node = Enum.YLeaf(2, "node")

    srlg = Enum.YLeaf(3, "srlg")


class PceIgpInfoId(Enum):
    """
    PceIgpInfoId

    IGP IDs

    .. data:: isis = 1

    	ISIS

    .. data:: ospf = 2

    	OSPF

    .. data:: bgp = 3

    	BGP

    """

    isis = Enum.YLeaf(1, "isis")

    ospf = Enum.YLeaf(2, "ospf")

    bgp = Enum.YLeaf(3, "bgp")


class PceProto(Enum):
    """
    PceProto

    PCE peer protocol

    .. data:: pcep = 0

    	PCE protocol

    .. data:: netconf = 1

    	Netconf protocol

    """

    pcep = Enum.YLeaf(0, "pcep")

    netconf = Enum.YLeaf(1, "netconf")


class PceRro(Enum):
    """
    PceRro

    PCE RRO type

    .. data:: rro_type_ipv4_address = 0

    	IPv4 Address

    .. data:: rro_type_mpls_label = 1

    	MPLS Label

    .. data:: rro_type_sripv4_node_sid = 2

    	Segment Routing IPv4 Node SID

    .. data:: rro_type_sripv4_adjacency_sid = 3

    	Segment Routing IPv4 Adjacency SID

    .. data:: rro_type_sr_nai_null = 4

    	Segment Routing with NAI null

    """

    rro_type_ipv4_address = Enum.YLeaf(0, "rro-type-ipv4-address")

    rro_type_mpls_label = Enum.YLeaf(1, "rro-type-mpls-label")

    rro_type_sripv4_node_sid = Enum.YLeaf(2, "rro-type-sripv4-node-sid")

    rro_type_sripv4_adjacency_sid = Enum.YLeaf(3, "rro-type-sripv4-adjacency-sid")

    rro_type_sr_nai_null = Enum.YLeaf(4, "rro-type-sr-nai-null")


class PceSrSid(Enum):
    """
    PceSrSid

    PCE SR SID type

    .. data:: ipv4_node_sid = 0

    	IPv4 Node SID

    .. data:: ipv4_adjacency_sid = 1

    	IPv4 Adjacency SID

    .. data:: unknown_sid = 2

    	Unknown SID

    """

    ipv4_node_sid = Enum.YLeaf(0, "ipv4-node-sid")

    ipv4_adjacency_sid = Enum.YLeaf(1, "ipv4-adjacency-sid")

    unknown_sid = Enum.YLeaf(2, "unknown-sid")


class PcepLspState(Enum):
    """
    PcepLspState

    PCEP operation protocol

    .. data:: lsp_down = 0

    	LSP is down

    .. data:: lsp_up = 1

    	LSP is up

    .. data:: lsp_active = 2

    	LSP is active (carrying traffic)

    .. data:: lsp_going_down = 3

    	LSP is going down

    .. data:: lsp_being_signaled = 4

    	LSP is being signaled

    """

    lsp_down = Enum.YLeaf(0, "lsp-down")

    lsp_up = Enum.YLeaf(1, "lsp-up")

    lsp_active = Enum.YLeaf(2, "lsp-active")

    lsp_going_down = Enum.YLeaf(3, "lsp-going-down")

    lsp_being_signaled = Enum.YLeaf(4, "lsp-being-signaled")


class PcepState(Enum):
    """
    PcepState

    PCEP State

    .. data:: tcp_close = 0

    	TCP close

    .. data:: tcp_listen = 1

    	TCP listen

    .. data:: tcp_connect = 2

    	TCP connect

    .. data:: pcep_closed = 3

    	PCEP closed

    .. data:: pcep_opening = 4

    	PCEP opening

    .. data:: pcep_open = 5

    	PCEP open

    """

    tcp_close = Enum.YLeaf(0, "tcp-close")

    tcp_listen = Enum.YLeaf(1, "tcp-listen")

    tcp_connect = Enum.YLeaf(2, "tcp-connect")

    pcep_closed = Enum.YLeaf(3, "pcep-closed")

    pcep_opening = Enum.YLeaf(4, "pcep-opening")

    pcep_open = Enum.YLeaf(5, "pcep-open")


class Sid(Enum):
    """
    Sid

    SID Types

    .. data:: sr_protected_adj_sid = 1

    	Protected Adjacency SID

    .. data:: sr_unprotected_adj_sid = 2

    	Unprotected Adjacency SID

    .. data:: srbgp_egress_peer_engineering_sid = 3

    	BGP egress peer engineering SID

    .. data:: sr_reqular_prefix_sid = 4

    	Regular prefix SID

    .. data:: sr_strict_prefix_sid = 5

    	Strict prefix SID

    """

    sr_protected_adj_sid = Enum.YLeaf(1, "sr-protected-adj-sid")

    sr_unprotected_adj_sid = Enum.YLeaf(2, "sr-unprotected-adj-sid")

    srbgp_egress_peer_engineering_sid = Enum.YLeaf(3, "srbgp-egress-peer-engineering-sid")

    sr_reqular_prefix_sid = Enum.YLeaf(4, "sr-reqular-prefix-sid")

    sr_strict_prefix_sid = Enum.YLeaf(5, "sr-strict-prefix-sid")



class PceLspData(Entity):
    """
    PCE LSP's data
    
    .. attribute:: lsp_summary
    
    	LSP summary database in XTC
    	**type**\:   :py:class:`LspSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.LspSummary>`
    
    .. attribute:: tunnel_detail_infos
    
    	Detailed tunnel database in XTC
    	**type**\:   :py:class:`TunnelDetailInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos>`
    
    .. attribute:: tunnel_infos
    
    	Tunnel database in XTC
    	**type**\:   :py:class:`TunnelInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelInfos>`
    
    

    """

    _prefix = 'infra-xtc-oper'
    _revision = '2016-05-31'

    def __init__(self):
        super(PceLspData, self).__init__()
        self._top_entity = None

        self.yang_name = "pce-lsp-data"
        self.yang_parent_name = "Cisco-IOS-XR-infra-xtc-oper"

        self.lsp_summary = PceLspData.LspSummary()
        self.lsp_summary.parent = self
        self._children_name_map["lsp_summary"] = "lsp-summary"
        self._children_yang_names.add("lsp-summary")

        self.tunnel_detail_infos = PceLspData.TunnelDetailInfos()
        self.tunnel_detail_infos.parent = self
        self._children_name_map["tunnel_detail_infos"] = "tunnel-detail-infos"
        self._children_yang_names.add("tunnel-detail-infos")

        self.tunnel_infos = PceLspData.TunnelInfos()
        self.tunnel_infos.parent = self
        self._children_name_map["tunnel_infos"] = "tunnel-infos"
        self._children_yang_names.add("tunnel-infos")


    class TunnelInfos(Entity):
        """
        Tunnel database in XTC
        
        .. attribute:: tunnel_info
        
        	Tunnel information
        	**type**\: list of    :py:class:`TunnelInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelInfos.TunnelInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PceLspData.TunnelInfos, self).__init__()

            self.yang_name = "tunnel-infos"
            self.yang_parent_name = "pce-lsp-data"

            self.tunnel_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PceLspData.TunnelInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PceLspData.TunnelInfos, self).__setattr__(name, value)


        class TunnelInfo(Entity):
            """
            Tunnel information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: plsp_id  <key>
            
            	PCEP LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: tunnel_name  <key>
            
            	Tunnel name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: brief_lsp_information
            
            	Brief LSP information
            	**type**\: list of    :py:class:`BriefLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelInfos.TunnelInfo.BriefLspInformation>`
            
            .. attribute:: pcc_address
            
            	PCC address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: tunnel_name_xr
            
            	Tunnel Name
            	**type**\:  str
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PceLspData.TunnelInfos.TunnelInfo, self).__init__()

                self.yang_name = "tunnel-info"
                self.yang_parent_name = "tunnel-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.plsp_id = YLeaf(YType.int32, "plsp-id")

                self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                self.pcc_address = YLeaf(YType.str, "pcc-address")

                self.tunnel_name_xr = YLeaf(YType.str, "tunnel-name-xr")

                self.brief_lsp_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "plsp_id",
                                "tunnel_name",
                                "pcc_address",
                                "tunnel_name_xr") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PceLspData.TunnelInfos.TunnelInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PceLspData.TunnelInfos.TunnelInfo, self).__setattr__(name, value)


            class BriefLspInformation(Entity):
                """
                Brief LSP information
                
                .. attribute:: administrative_state
                
                	Admin state
                	**type**\:   :py:class:`LspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspState>`
                
                .. attribute:: binding_sid
                
                	Binding SID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: destination_address
                
                	Destination address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: lsp_setup_type
                
                	LSP Setup Type
                	**type**\:   :py:class:`LspSetup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspSetup>`
                
                .. attribute:: lspid
                
                	LSP ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: operational_state
                
                	Operational state
                	**type**\:   :py:class:`PcepLspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepLspState>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: tunnel_id
                
                	Tunnel ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceLspData.TunnelInfos.TunnelInfo.BriefLspInformation, self).__init__()

                    self.yang_name = "brief-lsp-information"
                    self.yang_parent_name = "tunnel-info"

                    self.administrative_state = YLeaf(YType.enumeration, "administrative-state")

                    self.binding_sid = YLeaf(YType.uint32, "binding-sid")

                    self.destination_address = YLeaf(YType.str, "destination-address")

                    self.lsp_setup_type = YLeaf(YType.enumeration, "lsp-setup-type")

                    self.lspid = YLeaf(YType.uint32, "lspid")

                    self.operational_state = YLeaf(YType.enumeration, "operational-state")

                    self.source_address = YLeaf(YType.str, "source-address")

                    self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("administrative_state",
                                    "binding_sid",
                                    "destination_address",
                                    "lsp_setup_type",
                                    "lspid",
                                    "operational_state",
                                    "source_address",
                                    "tunnel_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceLspData.TunnelInfos.TunnelInfo.BriefLspInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceLspData.TunnelInfos.TunnelInfo.BriefLspInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.administrative_state.is_set or
                        self.binding_sid.is_set or
                        self.destination_address.is_set or
                        self.lsp_setup_type.is_set or
                        self.lspid.is_set or
                        self.operational_state.is_set or
                        self.source_address.is_set or
                        self.tunnel_id.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.administrative_state.yfilter != YFilter.not_set or
                        self.binding_sid.yfilter != YFilter.not_set or
                        self.destination_address.yfilter != YFilter.not_set or
                        self.lsp_setup_type.yfilter != YFilter.not_set or
                        self.lspid.yfilter != YFilter.not_set or
                        self.operational_state.yfilter != YFilter.not_set or
                        self.source_address.yfilter != YFilter.not_set or
                        self.tunnel_id.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "brief-lsp-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.administrative_state.is_set or self.administrative_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.administrative_state.get_name_leafdata())
                    if (self.binding_sid.is_set or self.binding_sid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.binding_sid.get_name_leafdata())
                    if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.destination_address.get_name_leafdata())
                    if (self.lsp_setup_type.is_set or self.lsp_setup_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_setup_type.get_name_leafdata())
                    if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lspid.get_name_leafdata())
                    if (self.operational_state.is_set or self.operational_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.operational_state.get_name_leafdata())
                    if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_address.get_name_leafdata())
                    if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "administrative-state" or name == "binding-sid" or name == "destination-address" or name == "lsp-setup-type" or name == "lspid" or name == "operational-state" or name == "source-address" or name == "tunnel-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "administrative-state"):
                        self.administrative_state = value
                        self.administrative_state.value_namespace = name_space
                        self.administrative_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "binding-sid"):
                        self.binding_sid = value
                        self.binding_sid.value_namespace = name_space
                        self.binding_sid.value_namespace_prefix = name_space_prefix
                    if(value_path == "destination-address"):
                        self.destination_address = value
                        self.destination_address.value_namespace = name_space
                        self.destination_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-setup-type"):
                        self.lsp_setup_type = value
                        self.lsp_setup_type.value_namespace = name_space
                        self.lsp_setup_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "lspid"):
                        self.lspid = value
                        self.lspid.value_namespace = name_space
                        self.lspid.value_namespace_prefix = name_space_prefix
                    if(value_path == "operational-state"):
                        self.operational_state = value
                        self.operational_state.value_namespace = name_space
                        self.operational_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-address"):
                        self.source_address = value
                        self.source_address.value_namespace = name_space
                        self.source_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "tunnel-id"):
                        self.tunnel_id = value
                        self.tunnel_id.value_namespace = name_space
                        self.tunnel_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.brief_lsp_information:
                    if (c.has_data()):
                        return True
                return (
                    self.peer_address.is_set or
                    self.plsp_id.is_set or
                    self.tunnel_name.is_set or
                    self.pcc_address.is_set or
                    self.tunnel_name_xr.is_set)

            def has_operation(self):
                for c in self.brief_lsp_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.plsp_id.yfilter != YFilter.not_set or
                    self.tunnel_name.yfilter != YFilter.not_set or
                    self.pcc_address.yfilter != YFilter.not_set or
                    self.tunnel_name_xr.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel-info" + "[peer-address='" + self.peer_address.get() + "']" + "[plsp-id='" + self.plsp_id.get() + "']" + "[tunnel-name='" + self.tunnel_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/tunnel-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.plsp_id.is_set or self.plsp_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.plsp_id.get_name_leafdata())
                if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name.get_name_leafdata())
                if (self.pcc_address.is_set or self.pcc_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pcc_address.get_name_leafdata())
                if (self.tunnel_name_xr.is_set or self.tunnel_name_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name_xr.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "brief-lsp-information"):
                    for c in self.brief_lsp_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = PceLspData.TunnelInfos.TunnelInfo.BriefLspInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.brief_lsp_information.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "brief-lsp-information" or name == "peer-address" or name == "plsp-id" or name == "tunnel-name" or name == "pcc-address" or name == "tunnel-name-xr"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "plsp-id"):
                    self.plsp_id = value
                    self.plsp_id.value_namespace = name_space
                    self.plsp_id.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name"):
                    self.tunnel_name = value
                    self.tunnel_name.value_namespace = name_space
                    self.tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "pcc-address"):
                    self.pcc_address = value
                    self.pcc_address.value_namespace = name_space
                    self.pcc_address.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name-xr"):
                    self.tunnel_name_xr = value
                    self.tunnel_name_xr.value_namespace = name_space
                    self.tunnel_name_xr.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnel-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel-info"):
                for c in self.tunnel_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = PceLspData.TunnelInfos.TunnelInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class LspSummary(Entity):
        """
        LSP summary database in XTC
        
        .. attribute:: all_ls_ps
        
        	Summary for all peers
        	**type**\:   :py:class:`AllLsPs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.LspSummary.AllLsPs>`
        
        .. attribute:: peer_ls_ps_info
        
        	Number of LSPs for specific peer
        	**type**\: list of    :py:class:`PeerLsPsInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.LspSummary.PeerLsPsInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PceLspData.LspSummary, self).__init__()

            self.yang_name = "lsp-summary"
            self.yang_parent_name = "pce-lsp-data"

            self.all_ls_ps = PceLspData.LspSummary.AllLsPs()
            self.all_ls_ps.parent = self
            self._children_name_map["all_ls_ps"] = "all-ls-ps"
            self._children_yang_names.add("all-ls-ps")

            self.peer_ls_ps_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PceLspData.LspSummary, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PceLspData.LspSummary, self).__setattr__(name, value)


        class AllLsPs(Entity):
            """
            Summary for all peers
            
            .. attribute:: admin_up_ls_ps
            
            	Number of administratively up LSPs
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: all_ls_ps
            
            	Number of all LSPs
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: rsvp_ls_ps
            
            	Number of LSPs with RSVP setup type
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: sr_ls_ps
            
            	Number of LSPs with Segment routing setup type
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_ls_ps
            
            	Number of operational LSPs
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PceLspData.LspSummary.AllLsPs, self).__init__()

                self.yang_name = "all-ls-ps"
                self.yang_parent_name = "lsp-summary"

                self.admin_up_ls_ps = YLeaf(YType.uint32, "admin-up-ls-ps")

                self.all_ls_ps = YLeaf(YType.uint32, "all-ls-ps")

                self.rsvp_ls_ps = YLeaf(YType.uint32, "rsvp-ls-ps")

                self.sr_ls_ps = YLeaf(YType.uint32, "sr-ls-ps")

                self.up_ls_ps = YLeaf(YType.uint32, "up-ls-ps")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("admin_up_ls_ps",
                                "all_ls_ps",
                                "rsvp_ls_ps",
                                "sr_ls_ps",
                                "up_ls_ps") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PceLspData.LspSummary.AllLsPs, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PceLspData.LspSummary.AllLsPs, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.admin_up_ls_ps.is_set or
                    self.all_ls_ps.is_set or
                    self.rsvp_ls_ps.is_set or
                    self.sr_ls_ps.is_set or
                    self.up_ls_ps.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.admin_up_ls_ps.yfilter != YFilter.not_set or
                    self.all_ls_ps.yfilter != YFilter.not_set or
                    self.rsvp_ls_ps.yfilter != YFilter.not_set or
                    self.sr_ls_ps.yfilter != YFilter.not_set or
                    self.up_ls_ps.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "all-ls-ps" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/lsp-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.admin_up_ls_ps.is_set or self.admin_up_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.admin_up_ls_ps.get_name_leafdata())
                if (self.all_ls_ps.is_set or self.all_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.all_ls_ps.get_name_leafdata())
                if (self.rsvp_ls_ps.is_set or self.rsvp_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.rsvp_ls_ps.get_name_leafdata())
                if (self.sr_ls_ps.is_set or self.sr_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sr_ls_ps.get_name_leafdata())
                if (self.up_ls_ps.is_set or self.up_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_ls_ps.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "admin-up-ls-ps" or name == "all-ls-ps" or name == "rsvp-ls-ps" or name == "sr-ls-ps" or name == "up-ls-ps"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "admin-up-ls-ps"):
                    self.admin_up_ls_ps = value
                    self.admin_up_ls_ps.value_namespace = name_space
                    self.admin_up_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "all-ls-ps"):
                    self.all_ls_ps = value
                    self.all_ls_ps.value_namespace = name_space
                    self.all_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "rsvp-ls-ps"):
                    self.rsvp_ls_ps = value
                    self.rsvp_ls_ps.value_namespace = name_space
                    self.rsvp_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "sr-ls-ps"):
                    self.sr_ls_ps = value
                    self.sr_ls_ps.value_namespace = name_space
                    self.sr_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "up-ls-ps"):
                    self.up_ls_ps = value
                    self.up_ls_ps.value_namespace = name_space
                    self.up_ls_ps.value_namespace_prefix = name_space_prefix


        class PeerLsPsInfo(Entity):
            """
            Number of LSPs for specific peer
            
            .. attribute:: lsp_summary
            
            	Number of LSPs for specific peer
            	**type**\:   :py:class:`LspSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.LspSummary.PeerLsPsInfo.LspSummary>`
            
            .. attribute:: peer_address
            
            	Peer IPv4 address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PceLspData.LspSummary.PeerLsPsInfo, self).__init__()

                self.yang_name = "peer-ls-ps-info"
                self.yang_parent_name = "lsp-summary"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.lsp_summary = PceLspData.LspSummary.PeerLsPsInfo.LspSummary()
                self.lsp_summary.parent = self
                self._children_name_map["lsp_summary"] = "lsp-summary"
                self._children_yang_names.add("lsp-summary")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PceLspData.LspSummary.PeerLsPsInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PceLspData.LspSummary.PeerLsPsInfo, self).__setattr__(name, value)


            class LspSummary(Entity):
                """
                Number of LSPs for specific peer
                
                .. attribute:: admin_up_ls_ps
                
                	Number of administratively up LSPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: all_ls_ps
                
                	Number of all LSPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: rsvp_ls_ps
                
                	Number of LSPs with RSVP setup type
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: sr_ls_ps
                
                	Number of LSPs with Segment routing setup type
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_ls_ps
                
                	Number of operational LSPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceLspData.LspSummary.PeerLsPsInfo.LspSummary, self).__init__()

                    self.yang_name = "lsp-summary"
                    self.yang_parent_name = "peer-ls-ps-info"

                    self.admin_up_ls_ps = YLeaf(YType.uint32, "admin-up-ls-ps")

                    self.all_ls_ps = YLeaf(YType.uint32, "all-ls-ps")

                    self.rsvp_ls_ps = YLeaf(YType.uint32, "rsvp-ls-ps")

                    self.sr_ls_ps = YLeaf(YType.uint32, "sr-ls-ps")

                    self.up_ls_ps = YLeaf(YType.uint32, "up-ls-ps")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_up_ls_ps",
                                    "all_ls_ps",
                                    "rsvp_ls_ps",
                                    "sr_ls_ps",
                                    "up_ls_ps") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceLspData.LspSummary.PeerLsPsInfo.LspSummary, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceLspData.LspSummary.PeerLsPsInfo.LspSummary, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.admin_up_ls_ps.is_set or
                        self.all_ls_ps.is_set or
                        self.rsvp_ls_ps.is_set or
                        self.sr_ls_ps.is_set or
                        self.up_ls_ps.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_up_ls_ps.yfilter != YFilter.not_set or
                        self.all_ls_ps.yfilter != YFilter.not_set or
                        self.rsvp_ls_ps.yfilter != YFilter.not_set or
                        self.sr_ls_ps.yfilter != YFilter.not_set or
                        self.up_ls_ps.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-summary" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/lsp-summary/peer-ls-ps-info/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.admin_up_ls_ps.is_set or self.admin_up_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.admin_up_ls_ps.get_name_leafdata())
                    if (self.all_ls_ps.is_set or self.all_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.all_ls_ps.get_name_leafdata())
                    if (self.rsvp_ls_ps.is_set or self.rsvp_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rsvp_ls_ps.get_name_leafdata())
                    if (self.sr_ls_ps.is_set or self.sr_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sr_ls_ps.get_name_leafdata())
                    if (self.up_ls_ps.is_set or self.up_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_ls_ps.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "admin-up-ls-ps" or name == "all-ls-ps" or name == "rsvp-ls-ps" or name == "sr-ls-ps" or name == "up-ls-ps"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-up-ls-ps"):
                        self.admin_up_ls_ps = value
                        self.admin_up_ls_ps.value_namespace = name_space
                        self.admin_up_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "all-ls-ps"):
                        self.all_ls_ps = value
                        self.all_ls_ps.value_namespace = name_space
                        self.all_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "rsvp-ls-ps"):
                        self.rsvp_ls_ps = value
                        self.rsvp_ls_ps.value_namespace = name_space
                        self.rsvp_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "sr-ls-ps"):
                        self.sr_ls_ps = value
                        self.sr_ls_ps.value_namespace = name_space
                        self.sr_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-ls-ps"):
                        self.up_ls_ps = value
                        self.up_ls_ps.value_namespace = name_space
                        self.up_ls_ps.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.peer_address.is_set or
                    (self.lsp_summary is not None and self.lsp_summary.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    (self.lsp_summary is not None and self.lsp_summary.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-ls-ps-info" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/lsp-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "lsp-summary"):
                    if (self.lsp_summary is None):
                        self.lsp_summary = PceLspData.LspSummary.PeerLsPsInfo.LspSummary()
                        self.lsp_summary.parent = self
                        self._children_name_map["lsp_summary"] = "lsp-summary"
                    return self.lsp_summary

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "lsp-summary" or name == "peer-address"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.peer_ls_ps_info:
                if (c.has_data()):
                    return True
            return (self.all_ls_ps is not None and self.all_ls_ps.has_data())

        def has_operation(self):
            for c in self.peer_ls_ps_info:
                if (c.has_operation()):
                    return True
            return (
                self.yfilter != YFilter.not_set or
                (self.all_ls_ps is not None and self.all_ls_ps.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "lsp-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "all-ls-ps"):
                if (self.all_ls_ps is None):
                    self.all_ls_ps = PceLspData.LspSummary.AllLsPs()
                    self.all_ls_ps.parent = self
                    self._children_name_map["all_ls_ps"] = "all-ls-ps"
                return self.all_ls_ps

            if (child_yang_name == "peer-ls-ps-info"):
                for c in self.peer_ls_ps_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = PceLspData.LspSummary.PeerLsPsInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.peer_ls_ps_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "all-ls-ps" or name == "peer-ls-ps-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TunnelDetailInfos(Entity):
        """
        Detailed tunnel database in XTC
        
        .. attribute:: tunnel_detail_info
        
        	Detailed tunnel information
        	**type**\: list of    :py:class:`TunnelDetailInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PceLspData.TunnelDetailInfos, self).__init__()

            self.yang_name = "tunnel-detail-infos"
            self.yang_parent_name = "pce-lsp-data"

            self.tunnel_detail_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PceLspData.TunnelDetailInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PceLspData.TunnelDetailInfos, self).__setattr__(name, value)


        class TunnelDetailInfo(Entity):
            """
            Detailed tunnel information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: plsp_id  <key>
            
            	PCEP LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: tunnel_name  <key>
            
            	Tunnel name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: detail_lsp_information
            
            	Detail LSP information
            	**type**\: list of    :py:class:`DetailLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation>`
            
            .. attribute:: pcc_address
            
            	PCC address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: private_lsp_information
            
            	Private LSP information
            	**type**\:   :py:class:`PrivateLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation>`
            
            .. attribute:: tunnel_name_xr
            
            	Tunnel Name
            	**type**\:  str
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo, self).__init__()

                self.yang_name = "tunnel-detail-info"
                self.yang_parent_name = "tunnel-detail-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.plsp_id = YLeaf(YType.int32, "plsp-id")

                self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                self.pcc_address = YLeaf(YType.str, "pcc-address")

                self.tunnel_name_xr = YLeaf(YType.str, "tunnel-name-xr")

                self.private_lsp_information = PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation()
                self.private_lsp_information.parent = self
                self._children_name_map["private_lsp_information"] = "private-lsp-information"
                self._children_yang_names.add("private-lsp-information")

                self.detail_lsp_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "plsp_id",
                                "tunnel_name",
                                "pcc_address",
                                "tunnel_name_xr") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo, self).__setattr__(name, value)


            class PrivateLspInformation(Entity):
                """
                Private LSP information
                
                .. attribute:: event_buffer
                
                	LSP Event buffer
                	**type**\: list of    :py:class:`EventBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer>`
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation, self).__init__()

                    self.yang_name = "private-lsp-information"
                    self.yang_parent_name = "tunnel-detail-info"

                    self.event_buffer = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation, self).__setattr__(name, value)


                class EventBuffer(Entity):
                    """
                    LSP Event buffer
                    
                    .. attribute:: event_message
                    
                    	Event message
                    	**type**\:  str
                    
                    .. attribute:: time_stamp
                    
                    	Event time, relative to Jan 1, 1970
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer, self).__init__()

                        self.yang_name = "event-buffer"
                        self.yang_parent_name = "private-lsp-information"

                        self.event_message = YLeaf(YType.str, "event-message")

                        self.time_stamp = YLeaf(YType.uint32, "time-stamp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("event_message",
                                        "time_stamp") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.event_message.is_set or
                            self.time_stamp.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.event_message.yfilter != YFilter.not_set or
                            self.time_stamp.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "event-buffer" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.event_message.is_set or self.event_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.event_message.get_name_leafdata())
                        if (self.time_stamp.is_set or self.time_stamp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.time_stamp.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "event-message" or name == "time-stamp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "event-message"):
                            self.event_message = value
                            self.event_message.value_namespace = name_space
                            self.event_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "time-stamp"):
                            self.time_stamp = value
                            self.time_stamp.value_namespace = name_space
                            self.time_stamp.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.event_buffer:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.event_buffer:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "private-lsp-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "event-buffer"):
                        for c in self.event_buffer:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.event_buffer.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "event-buffer"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class DetailLspInformation(Entity):
                """
                Detail LSP information
                
                .. attribute:: actual_bandwidth
                
                	Actual bandwidth utilized in the data\-plane
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: actual_bandwidth_specified
                
                	True if router notifies actual bandwidth
                	**type**\:  bool
                
                .. attribute:: brief_lsp_information
                
                	Brief LSP information
                	**type**\:   :py:class:`BriefLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation>`
                
                .. attribute:: computing_pce
                
                	Computing PCE
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: er_os
                
                	Paths
                	**type**\:   :py:class:`ErOs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs>`
                
                .. attribute:: lsp_association_info
                
                	LSP association information
                	**type**\:   :py:class:`LspAssociationInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo>`
                
                .. attribute:: lsp_attributes
                
                	LSP attributes
                	**type**\:   :py:class:`LspAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes>`
                
                .. attribute:: lsp_role
                
                	LSP Role
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsppcep_information
                
                	PCEP related LSP information
                	**type**\:   :py:class:`LsppcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation>`
                
                .. attribute:: reporting_pcc_address
                
                	Reporting PCC address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: rro
                
                	RRO
                	**type**\: list of    :py:class:`Rro <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro>`
                
                .. attribute:: signaled_bandwidth
                
                	Signaled Bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: signaled_bandwidth_specified
                
                	True if router notifies signal bandwidth
                	**type**\:  bool
                
                .. attribute:: srlg_info
                
                	List of SLRGs used by LSP
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: state_sync_pce
                
                	State\-sync PCE
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: sub_delegated_pce
                
                	Sub delegated PCE
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation, self).__init__()

                    self.yang_name = "detail-lsp-information"
                    self.yang_parent_name = "tunnel-detail-info"

                    self.actual_bandwidth = YLeaf(YType.uint64, "actual-bandwidth")

                    self.actual_bandwidth_specified = YLeaf(YType.boolean, "actual-bandwidth-specified")

                    self.computing_pce = YLeaf(YType.uint32, "computing-pce")

                    self.lsp_role = YLeaf(YType.uint32, "lsp-role")

                    self.reporting_pcc_address = YLeaf(YType.str, "reporting-pcc-address")

                    self.signaled_bandwidth = YLeaf(YType.uint64, "signaled-bandwidth")

                    self.signaled_bandwidth_specified = YLeaf(YType.boolean, "signaled-bandwidth-specified")

                    self.srlg_info = YLeafList(YType.uint32, "srlg-info")

                    self.state_sync_pce = YLeaf(YType.str, "state-sync-pce")

                    self.sub_delegated_pce = YLeaf(YType.str, "sub-delegated-pce")

                    self.brief_lsp_information = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation()
                    self.brief_lsp_information.parent = self
                    self._children_name_map["brief_lsp_information"] = "brief-lsp-information"
                    self._children_yang_names.add("brief-lsp-information")

                    self.er_os = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs()
                    self.er_os.parent = self
                    self._children_name_map["er_os"] = "er-os"
                    self._children_yang_names.add("er-os")

                    self.lsp_association_info = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo()
                    self.lsp_association_info.parent = self
                    self._children_name_map["lsp_association_info"] = "lsp-association-info"
                    self._children_yang_names.add("lsp-association-info")

                    self.lsp_attributes = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes()
                    self.lsp_attributes.parent = self
                    self._children_name_map["lsp_attributes"] = "lsp-attributes"
                    self._children_yang_names.add("lsp-attributes")

                    self.lsppcep_information = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation()
                    self.lsppcep_information.parent = self
                    self._children_name_map["lsppcep_information"] = "lsppcep-information"
                    self._children_yang_names.add("lsppcep-information")

                    self.rro = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("actual_bandwidth",
                                    "actual_bandwidth_specified",
                                    "computing_pce",
                                    "lsp_role",
                                    "reporting_pcc_address",
                                    "signaled_bandwidth",
                                    "signaled_bandwidth_specified",
                                    "srlg_info",
                                    "state_sync_pce",
                                    "sub_delegated_pce") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation, self).__setattr__(name, value)


                class BriefLspInformation(Entity):
                    """
                    Brief LSP information
                    
                    .. attribute:: administrative_state
                    
                    	Admin state
                    	**type**\:   :py:class:`LspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspState>`
                    
                    .. attribute:: binding_sid
                    
                    	Binding SID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: destination_address
                    
                    	Destination address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: lsp_setup_type
                    
                    	LSP Setup Type
                    	**type**\:   :py:class:`LspSetup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspSetup>`
                    
                    .. attribute:: lspid
                    
                    	LSP ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: operational_state
                    
                    	Operational state
                    	**type**\:   :py:class:`PcepLspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepLspState>`
                    
                    .. attribute:: source_address
                    
                    	Source address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: tunnel_id
                    
                    	Tunnel ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation, self).__init__()

                        self.yang_name = "brief-lsp-information"
                        self.yang_parent_name = "detail-lsp-information"

                        self.administrative_state = YLeaf(YType.enumeration, "administrative-state")

                        self.binding_sid = YLeaf(YType.uint32, "binding-sid")

                        self.destination_address = YLeaf(YType.str, "destination-address")

                        self.lsp_setup_type = YLeaf(YType.enumeration, "lsp-setup-type")

                        self.lspid = YLeaf(YType.uint32, "lspid")

                        self.operational_state = YLeaf(YType.enumeration, "operational-state")

                        self.source_address = YLeaf(YType.str, "source-address")

                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("administrative_state",
                                        "binding_sid",
                                        "destination_address",
                                        "lsp_setup_type",
                                        "lspid",
                                        "operational_state",
                                        "source_address",
                                        "tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.administrative_state.is_set or
                            self.binding_sid.is_set or
                            self.destination_address.is_set or
                            self.lsp_setup_type.is_set or
                            self.lspid.is_set or
                            self.operational_state.is_set or
                            self.source_address.is_set or
                            self.tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.administrative_state.yfilter != YFilter.not_set or
                            self.binding_sid.yfilter != YFilter.not_set or
                            self.destination_address.yfilter != YFilter.not_set or
                            self.lsp_setup_type.yfilter != YFilter.not_set or
                            self.lspid.yfilter != YFilter.not_set or
                            self.operational_state.yfilter != YFilter.not_set or
                            self.source_address.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-lsp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.administrative_state.is_set or self.administrative_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.administrative_state.get_name_leafdata())
                        if (self.binding_sid.is_set or self.binding_sid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_sid.get_name_leafdata())
                        if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination_address.get_name_leafdata())
                        if (self.lsp_setup_type.is_set or self.lsp_setup_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_setup_type.get_name_leafdata())
                        if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lspid.get_name_leafdata())
                        if (self.operational_state.is_set or self.operational_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.operational_state.get_name_leafdata())
                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_address.get_name_leafdata())
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "administrative-state" or name == "binding-sid" or name == "destination-address" or name == "lsp-setup-type" or name == "lspid" or name == "operational-state" or name == "source-address" or name == "tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "administrative-state"):
                            self.administrative_state = value
                            self.administrative_state.value_namespace = name_space
                            self.administrative_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-sid"):
                            self.binding_sid = value
                            self.binding_sid.value_namespace = name_space
                            self.binding_sid.value_namespace_prefix = name_space_prefix
                        if(value_path == "destination-address"):
                            self.destination_address = value
                            self.destination_address.value_namespace = name_space
                            self.destination_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-setup-type"):
                            self.lsp_setup_type = value
                            self.lsp_setup_type.value_namespace = name_space
                            self.lsp_setup_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "lspid"):
                            self.lspid = value
                            self.lspid.value_namespace = name_space
                            self.lspid.value_namespace_prefix = name_space_prefix
                        if(value_path == "operational-state"):
                            self.operational_state = value
                            self.operational_state.value_namespace = name_space
                            self.operational_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-address"):
                            self.source_address = value
                            self.source_address.value_namespace = name_space
                            self.source_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix


                class ErOs(Entity):
                    """
                    Paths
                    
                    .. attribute:: computed_hop_list_time
                    
                    	Computed Hop List Time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: computed_metric_type
                    
                    	Computed Metric Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: computed_metric_value
                    
                    	Computed Metric Value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: computed_rsvp_path
                    
                    	Computed RSVP path
                    	**type**\: list of    :py:class:`ComputedRsvpPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath>`
                    
                    .. attribute:: computed_sr_path
                    
                    	Computed SR path
                    	**type**\: list of    :py:class:`ComputedSrPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath>`
                    
                    .. attribute:: reported_metric_type
                    
                    	Reported Metric Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: reported_metric_value
                    
                    	Reported Metric Value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: reported_rsvp_path
                    
                    	Reported RSVP path
                    	**type**\: list of    :py:class:`ReportedRsvpPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath>`
                    
                    .. attribute:: reported_sr_path
                    
                    	Reported SR path
                    	**type**\: list of    :py:class:`ReportedSrPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs, self).__init__()

                        self.yang_name = "er-os"
                        self.yang_parent_name = "detail-lsp-information"

                        self.computed_hop_list_time = YLeaf(YType.uint32, "computed-hop-list-time")

                        self.computed_metric_type = YLeaf(YType.uint32, "computed-metric-type")

                        self.computed_metric_value = YLeaf(YType.uint32, "computed-metric-value")

                        self.reported_metric_type = YLeaf(YType.uint32, "reported-metric-type")

                        self.reported_metric_value = YLeaf(YType.uint32, "reported-metric-value")

                        self.computed_rsvp_path = YList(self)
                        self.computed_sr_path = YList(self)
                        self.reported_rsvp_path = YList(self)
                        self.reported_sr_path = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("computed_hop_list_time",
                                        "computed_metric_type",
                                        "computed_metric_value",
                                        "reported_metric_type",
                                        "reported_metric_value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs, self).__setattr__(name, value)


                    class ReportedRsvpPath(Entity):
                        """
                        Reported RSVP path
                        
                        .. attribute:: hop_address
                        
                        	RSVP hop address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath, self).__init__()

                            self.yang_name = "reported-rsvp-path"
                            self.yang_parent_name = "er-os"

                            self.hop_address = YLeaf(YType.str, "hop-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hop_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath, self).__setattr__(name, value)

                        def has_data(self):
                            return self.hop_address.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hop_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reported-rsvp-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hop_address.is_set or self.hop_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hop_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hop-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hop-address"):
                                self.hop_address = value
                                self.hop_address.value_namespace = name_space
                                self.hop_address.value_namespace_prefix = name_space_prefix


                    class ReportedSrPath(Entity):
                        """
                        Reported SR path
                        
                        .. attribute:: local_addr
                        
                        	Local Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: mpls_label
                        
                        	Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_addr
                        
                        	Remote Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: sid_type
                        
                        	SID type
                        	**type**\:   :py:class:`PceSrSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceSrSid>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath, self).__init__()

                            self.yang_name = "reported-sr-path"
                            self.yang_parent_name = "er-os"

                            self.local_addr = YLeaf(YType.str, "local-addr")

                            self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                            self.remote_addr = YLeaf(YType.str, "remote-addr")

                            self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_addr",
                                            "mpls_label",
                                            "remote_addr",
                                            "sid_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_addr.is_set or
                                self.mpls_label.is_set or
                                self.remote_addr.is_set or
                                self.sid_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_addr.yfilter != YFilter.not_set or
                                self.mpls_label.yfilter != YFilter.not_set or
                                self.remote_addr.yfilter != YFilter.not_set or
                                self.sid_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reported-sr-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_addr.is_set or self.local_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_addr.get_name_leafdata())
                            if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mpls_label.get_name_leafdata())
                            if (self.remote_addr.is_set or self.remote_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_addr.get_name_leafdata())
                            if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sid_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-addr" or name == "mpls-label" or name == "remote-addr" or name == "sid-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-addr"):
                                self.local_addr = value
                                self.local_addr.value_namespace = name_space
                                self.local_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mpls-label"):
                                self.mpls_label = value
                                self.mpls_label.value_namespace = name_space
                                self.mpls_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-addr"):
                                self.remote_addr = value
                                self.remote_addr.value_namespace = name_space
                                self.remote_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "sid-type"):
                                self.sid_type = value
                                self.sid_type.value_namespace = name_space
                                self.sid_type.value_namespace_prefix = name_space_prefix


                    class ComputedRsvpPath(Entity):
                        """
                        Computed RSVP path
                        
                        .. attribute:: hop_address
                        
                        	RSVP hop address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath, self).__init__()

                            self.yang_name = "computed-rsvp-path"
                            self.yang_parent_name = "er-os"

                            self.hop_address = YLeaf(YType.str, "hop-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hop_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath, self).__setattr__(name, value)

                        def has_data(self):
                            return self.hop_address.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hop_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "computed-rsvp-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hop_address.is_set or self.hop_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hop_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hop-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hop-address"):
                                self.hop_address = value
                                self.hop_address.value_namespace = name_space
                                self.hop_address.value_namespace_prefix = name_space_prefix


                    class ComputedSrPath(Entity):
                        """
                        Computed SR path
                        
                        .. attribute:: local_addr
                        
                        	Local Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: mpls_label
                        
                        	Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_addr
                        
                        	Remote Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: sid_type
                        
                        	SID type
                        	**type**\:   :py:class:`PceSrSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceSrSid>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath, self).__init__()

                            self.yang_name = "computed-sr-path"
                            self.yang_parent_name = "er-os"

                            self.local_addr = YLeaf(YType.str, "local-addr")

                            self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                            self.remote_addr = YLeaf(YType.str, "remote-addr")

                            self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_addr",
                                            "mpls_label",
                                            "remote_addr",
                                            "sid_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_addr.is_set or
                                self.mpls_label.is_set or
                                self.remote_addr.is_set or
                                self.sid_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_addr.yfilter != YFilter.not_set or
                                self.mpls_label.yfilter != YFilter.not_set or
                                self.remote_addr.yfilter != YFilter.not_set or
                                self.sid_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "computed-sr-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_addr.is_set or self.local_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_addr.get_name_leafdata())
                            if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mpls_label.get_name_leafdata())
                            if (self.remote_addr.is_set or self.remote_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_addr.get_name_leafdata())
                            if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sid_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-addr" or name == "mpls-label" or name == "remote-addr" or name == "sid-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-addr"):
                                self.local_addr = value
                                self.local_addr.value_namespace = name_space
                                self.local_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mpls-label"):
                                self.mpls_label = value
                                self.mpls_label.value_namespace = name_space
                                self.mpls_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-addr"):
                                self.remote_addr = value
                                self.remote_addr.value_namespace = name_space
                                self.remote_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "sid-type"):
                                self.sid_type = value
                                self.sid_type.value_namespace = name_space
                                self.sid_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.computed_rsvp_path:
                            if (c.has_data()):
                                return True
                        for c in self.computed_sr_path:
                            if (c.has_data()):
                                return True
                        for c in self.reported_rsvp_path:
                            if (c.has_data()):
                                return True
                        for c in self.reported_sr_path:
                            if (c.has_data()):
                                return True
                        return (
                            self.computed_hop_list_time.is_set or
                            self.computed_metric_type.is_set or
                            self.computed_metric_value.is_set or
                            self.reported_metric_type.is_set or
                            self.reported_metric_value.is_set)

                    def has_operation(self):
                        for c in self.computed_rsvp_path:
                            if (c.has_operation()):
                                return True
                        for c in self.computed_sr_path:
                            if (c.has_operation()):
                                return True
                        for c in self.reported_rsvp_path:
                            if (c.has_operation()):
                                return True
                        for c in self.reported_sr_path:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.computed_hop_list_time.yfilter != YFilter.not_set or
                            self.computed_metric_type.yfilter != YFilter.not_set or
                            self.computed_metric_value.yfilter != YFilter.not_set or
                            self.reported_metric_type.yfilter != YFilter.not_set or
                            self.reported_metric_value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "er-os" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.computed_hop_list_time.is_set or self.computed_hop_list_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.computed_hop_list_time.get_name_leafdata())
                        if (self.computed_metric_type.is_set or self.computed_metric_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.computed_metric_type.get_name_leafdata())
                        if (self.computed_metric_value.is_set or self.computed_metric_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.computed_metric_value.get_name_leafdata())
                        if (self.reported_metric_type.is_set or self.reported_metric_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reported_metric_type.get_name_leafdata())
                        if (self.reported_metric_value.is_set or self.reported_metric_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reported_metric_value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "computed-rsvp-path"):
                            for c in self.computed_rsvp_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.computed_rsvp_path.append(c)
                            return c

                        if (child_yang_name == "computed-sr-path"):
                            for c in self.computed_sr_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.computed_sr_path.append(c)
                            return c

                        if (child_yang_name == "reported-rsvp-path"):
                            for c in self.reported_rsvp_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.reported_rsvp_path.append(c)
                            return c

                        if (child_yang_name == "reported-sr-path"):
                            for c in self.reported_sr_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.reported_sr_path.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "computed-rsvp-path" or name == "computed-sr-path" or name == "reported-rsvp-path" or name == "reported-sr-path" or name == "computed-hop-list-time" or name == "computed-metric-type" or name == "computed-metric-value" or name == "reported-metric-type" or name == "reported-metric-value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "computed-hop-list-time"):
                            self.computed_hop_list_time = value
                            self.computed_hop_list_time.value_namespace = name_space
                            self.computed_hop_list_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "computed-metric-type"):
                            self.computed_metric_type = value
                            self.computed_metric_type.value_namespace = name_space
                            self.computed_metric_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "computed-metric-value"):
                            self.computed_metric_value = value
                            self.computed_metric_value.value_namespace = name_space
                            self.computed_metric_value.value_namespace_prefix = name_space_prefix
                        if(value_path == "reported-metric-type"):
                            self.reported_metric_type = value
                            self.reported_metric_type.value_namespace = name_space
                            self.reported_metric_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "reported-metric-value"):
                            self.reported_metric_value = value
                            self.reported_metric_value.value_namespace = name_space
                            self.reported_metric_value.value_namespace_prefix = name_space_prefix


                class LsppcepInformation(Entity):
                    """
                    PCEP related LSP information
                    
                    .. attribute:: pcep_flag_a
                    
                    	PCEP LSP admin flag
                    	**type**\:  bool
                    
                    .. attribute:: pcep_flag_d
                    
                    	PCEP LSP delegation flag
                    	**type**\:  bool
                    
                    .. attribute:: pcep_flag_o
                    
                    	PCEP LSP operation flag
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: pcep_flag_r
                    
                    	PCEP LSP remove flag
                    	**type**\:  bool
                    
                    .. attribute:: pcep_flag_s
                    
                    	PCEP LSP state\-sync flag
                    	**type**\:  bool
                    
                    .. attribute:: pcepid
                    
                    	PCE protocol identifier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rsvp_error
                    
                    	RSVP error info
                    	**type**\:   :py:class:`RsvpError <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation, self).__init__()

                        self.yang_name = "lsppcep-information"
                        self.yang_parent_name = "detail-lsp-information"

                        self.pcep_flag_a = YLeaf(YType.boolean, "pcep-flag-a")

                        self.pcep_flag_d = YLeaf(YType.boolean, "pcep-flag-d")

                        self.pcep_flag_o = YLeaf(YType.uint8, "pcep-flag-o")

                        self.pcep_flag_r = YLeaf(YType.boolean, "pcep-flag-r")

                        self.pcep_flag_s = YLeaf(YType.boolean, "pcep-flag-s")

                        self.pcepid = YLeaf(YType.uint32, "pcepid")

                        self.rsvp_error = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError()
                        self.rsvp_error.parent = self
                        self._children_name_map["rsvp_error"] = "rsvp-error"
                        self._children_yang_names.add("rsvp-error")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pcep_flag_a",
                                        "pcep_flag_d",
                                        "pcep_flag_o",
                                        "pcep_flag_r",
                                        "pcep_flag_s",
                                        "pcepid") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation, self).__setattr__(name, value)


                    class RsvpError(Entity):
                        """
                        RSVP error info
                        
                        .. attribute:: error_code
                        
                        	RSVP error code
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: error_flags
                        
                        	RSVP error flags
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: error_value
                        
                        	RSVP error value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: node_address
                        
                        	RSVP error node address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError, self).__init__()

                            self.yang_name = "rsvp-error"
                            self.yang_parent_name = "lsppcep-information"

                            self.error_code = YLeaf(YType.uint8, "error-code")

                            self.error_flags = YLeaf(YType.uint8, "error-flags")

                            self.error_value = YLeaf(YType.uint16, "error-value")

                            self.node_address = YLeaf(YType.str, "node-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("error_code",
                                            "error_flags",
                                            "error_value",
                                            "node_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.error_code.is_set or
                                self.error_flags.is_set or
                                self.error_value.is_set or
                                self.node_address.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.error_code.yfilter != YFilter.not_set or
                                self.error_flags.yfilter != YFilter.not_set or
                                self.error_value.yfilter != YFilter.not_set or
                                self.node_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rsvp-error" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.error_code.is_set or self.error_code.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.error_code.get_name_leafdata())
                            if (self.error_flags.is_set or self.error_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.error_flags.get_name_leafdata())
                            if (self.error_value.is_set or self.error_value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.error_value.get_name_leafdata())
                            if (self.node_address.is_set or self.node_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "error-code" or name == "error-flags" or name == "error-value" or name == "node-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "error-code"):
                                self.error_code = value
                                self.error_code.value_namespace = name_space
                                self.error_code.value_namespace_prefix = name_space_prefix
                            if(value_path == "error-flags"):
                                self.error_flags = value
                                self.error_flags.value_namespace = name_space
                                self.error_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "error-value"):
                                self.error_value = value
                                self.error_value.value_namespace = name_space
                                self.error_value.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-address"):
                                self.node_address = value
                                self.node_address.value_namespace = name_space
                                self.node_address.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.pcep_flag_a.is_set or
                            self.pcep_flag_d.is_set or
                            self.pcep_flag_o.is_set or
                            self.pcep_flag_r.is_set or
                            self.pcep_flag_s.is_set or
                            self.pcepid.is_set or
                            (self.rsvp_error is not None and self.rsvp_error.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pcep_flag_a.yfilter != YFilter.not_set or
                            self.pcep_flag_d.yfilter != YFilter.not_set or
                            self.pcep_flag_o.yfilter != YFilter.not_set or
                            self.pcep_flag_r.yfilter != YFilter.not_set or
                            self.pcep_flag_s.yfilter != YFilter.not_set or
                            self.pcepid.yfilter != YFilter.not_set or
                            (self.rsvp_error is not None and self.rsvp_error.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsppcep-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pcep_flag_a.is_set or self.pcep_flag_a.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_a.get_name_leafdata())
                        if (self.pcep_flag_d.is_set or self.pcep_flag_d.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_d.get_name_leafdata())
                        if (self.pcep_flag_o.is_set or self.pcep_flag_o.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_o.get_name_leafdata())
                        if (self.pcep_flag_r.is_set or self.pcep_flag_r.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_r.get_name_leafdata())
                        if (self.pcep_flag_s.is_set or self.pcep_flag_s.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_s.get_name_leafdata())
                        if (self.pcepid.is_set or self.pcepid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcepid.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "rsvp-error"):
                            if (self.rsvp_error is None):
                                self.rsvp_error = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError()
                                self.rsvp_error.parent = self
                                self._children_name_map["rsvp_error"] = "rsvp-error"
                            return self.rsvp_error

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rsvp-error" or name == "pcep-flag-a" or name == "pcep-flag-d" or name == "pcep-flag-o" or name == "pcep-flag-r" or name == "pcep-flag-s" or name == "pcepid"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pcep-flag-a"):
                            self.pcep_flag_a = value
                            self.pcep_flag_a.value_namespace = name_space
                            self.pcep_flag_a.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-d"):
                            self.pcep_flag_d = value
                            self.pcep_flag_d.value_namespace = name_space
                            self.pcep_flag_d.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-o"):
                            self.pcep_flag_o = value
                            self.pcep_flag_o.value_namespace = name_space
                            self.pcep_flag_o.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-r"):
                            self.pcep_flag_r = value
                            self.pcep_flag_r.value_namespace = name_space
                            self.pcep_flag_r.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-s"):
                            self.pcep_flag_s = value
                            self.pcep_flag_s.value_namespace = name_space
                            self.pcep_flag_s.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcepid"):
                            self.pcepid = value
                            self.pcepid.value_namespace = name_space
                            self.pcepid.value_namespace_prefix = name_space_prefix


                class LspAssociationInfo(Entity):
                    """
                    LSP association information
                    
                    .. attribute:: association_id
                    
                    	Association ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: association_source
                    
                    	Association Source
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: association_type
                    
                    	Association Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo, self).__init__()

                        self.yang_name = "lsp-association-info"
                        self.yang_parent_name = "detail-lsp-information"

                        self.association_id = YLeaf(YType.uint32, "association-id")

                        self.association_source = YLeaf(YType.str, "association-source")

                        self.association_type = YLeaf(YType.uint32, "association-type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("association_id",
                                        "association_source",
                                        "association_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.association_id.is_set or
                            self.association_source.is_set or
                            self.association_type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.association_id.yfilter != YFilter.not_set or
                            self.association_source.yfilter != YFilter.not_set or
                            self.association_type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-association-info" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.association_id.is_set or self.association_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.association_id.get_name_leafdata())
                        if (self.association_source.is_set or self.association_source.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.association_source.get_name_leafdata())
                        if (self.association_type.is_set or self.association_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.association_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "association-id" or name == "association-source" or name == "association-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "association-id"):
                            self.association_id = value
                            self.association_id.value_namespace = name_space
                            self.association_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "association-source"):
                            self.association_source = value
                            self.association_source.value_namespace = name_space
                            self.association_source.value_namespace_prefix = name_space_prefix
                        if(value_path == "association-type"):
                            self.association_type = value
                            self.association_type.value_namespace = name_space
                            self.association_type.value_namespace_prefix = name_space_prefix


                class LspAttributes(Entity):
                    """
                    LSP attributes
                    
                    .. attribute:: affinity_exclude_any
                    
                    	Affinity exclude any
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: affinity_include_all
                    
                    	Affinity include all
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: affinity_include_any
                    
                    	Affinity include any
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: hold_priority
                    
                    	Hold Priority
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: local_protection
                    
                    	True, if local protection is desired
                    	**type**\:  bool
                    
                    .. attribute:: setup_priority
                    
                    	Setup Priority
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes, self).__init__()

                        self.yang_name = "lsp-attributes"
                        self.yang_parent_name = "detail-lsp-information"

                        self.affinity_exclude_any = YLeaf(YType.uint32, "affinity-exclude-any")

                        self.affinity_include_all = YLeaf(YType.uint32, "affinity-include-all")

                        self.affinity_include_any = YLeaf(YType.uint32, "affinity-include-any")

                        self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                        self.local_protection = YLeaf(YType.boolean, "local-protection")

                        self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("affinity_exclude_any",
                                        "affinity_include_all",
                                        "affinity_include_any",
                                        "hold_priority",
                                        "local_protection",
                                        "setup_priority") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.affinity_exclude_any.is_set or
                            self.affinity_include_all.is_set or
                            self.affinity_include_any.is_set or
                            self.hold_priority.is_set or
                            self.local_protection.is_set or
                            self.setup_priority.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.affinity_exclude_any.yfilter != YFilter.not_set or
                            self.affinity_include_all.yfilter != YFilter.not_set or
                            self.affinity_include_any.yfilter != YFilter.not_set or
                            self.hold_priority.yfilter != YFilter.not_set or
                            self.local_protection.yfilter != YFilter.not_set or
                            self.setup_priority.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-attributes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.affinity_exclude_any.is_set or self.affinity_exclude_any.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.affinity_exclude_any.get_name_leafdata())
                        if (self.affinity_include_all.is_set or self.affinity_include_all.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.affinity_include_all.get_name_leafdata())
                        if (self.affinity_include_any.is_set or self.affinity_include_any.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.affinity_include_any.get_name_leafdata())
                        if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_priority.get_name_leafdata())
                        if (self.local_protection.is_set or self.local_protection.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_protection.get_name_leafdata())
                        if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.setup_priority.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "affinity-exclude-any" or name == "affinity-include-all" or name == "affinity-include-any" or name == "hold-priority" or name == "local-protection" or name == "setup-priority"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "affinity-exclude-any"):
                            self.affinity_exclude_any = value
                            self.affinity_exclude_any.value_namespace = name_space
                            self.affinity_exclude_any.value_namespace_prefix = name_space_prefix
                        if(value_path == "affinity-include-all"):
                            self.affinity_include_all = value
                            self.affinity_include_all.value_namespace = name_space
                            self.affinity_include_all.value_namespace_prefix = name_space_prefix
                        if(value_path == "affinity-include-any"):
                            self.affinity_include_any = value
                            self.affinity_include_any.value_namespace = name_space
                            self.affinity_include_any.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-priority"):
                            self.hold_priority = value
                            self.hold_priority.value_namespace = name_space
                            self.hold_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-protection"):
                            self.local_protection = value
                            self.local_protection.value_namespace = name_space
                            self.local_protection.value_namespace_prefix = name_space_prefix
                        if(value_path == "setup-priority"):
                            self.setup_priority = value
                            self.setup_priority.value_namespace = name_space
                            self.setup_priority.value_namespace_prefix = name_space_prefix


                class Rro(Entity):
                    """
                    RRO
                    
                    .. attribute:: flags
                    
                    	RRO Flags
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4_address
                    
                    	IPv4 address of RRO
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: mpls_label
                    
                    	MPLS label of RRO
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rro_type
                    
                    	RRO Type
                    	**type**\:   :py:class:`PceRro <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceRro>`
                    
                    .. attribute:: sr_rro
                    
                    	Segment Routing RRO info
                    	**type**\:   :py:class:`SrRro <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro, self).__init__()

                        self.yang_name = "rro"
                        self.yang_parent_name = "detail-lsp-information"

                        self.flags = YLeaf(YType.uint8, "flags")

                        self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                        self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                        self.rro_type = YLeaf(YType.enumeration, "rro-type")

                        self.sr_rro = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro()
                        self.sr_rro.parent = self
                        self._children_name_map["sr_rro"] = "sr-rro"
                        self._children_yang_names.add("sr-rro")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("flags",
                                        "ipv4_address",
                                        "mpls_label",
                                        "rro_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro, self).__setattr__(name, value)


                    class SrRro(Entity):
                        """
                        Segment Routing RRO info
                        
                        .. attribute:: local_addr
                        
                        	Local Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: mpls_label
                        
                        	Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_addr
                        
                        	Remote Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: sid_type
                        
                        	SID type
                        	**type**\:   :py:class:`PceSrSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceSrSid>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro, self).__init__()

                            self.yang_name = "sr-rro"
                            self.yang_parent_name = "rro"

                            self.local_addr = YLeaf(YType.str, "local-addr")

                            self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                            self.remote_addr = YLeaf(YType.str, "remote-addr")

                            self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_addr",
                                            "mpls_label",
                                            "remote_addr",
                                            "sid_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_addr.is_set or
                                self.mpls_label.is_set or
                                self.remote_addr.is_set or
                                self.sid_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_addr.yfilter != YFilter.not_set or
                                self.mpls_label.yfilter != YFilter.not_set or
                                self.remote_addr.yfilter != YFilter.not_set or
                                self.sid_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sr-rro" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_addr.is_set or self.local_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_addr.get_name_leafdata())
                            if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mpls_label.get_name_leafdata())
                            if (self.remote_addr.is_set or self.remote_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_addr.get_name_leafdata())
                            if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sid_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-addr" or name == "mpls-label" or name == "remote-addr" or name == "sid-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-addr"):
                                self.local_addr = value
                                self.local_addr.value_namespace = name_space
                                self.local_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mpls-label"):
                                self.mpls_label = value
                                self.mpls_label.value_namespace = name_space
                                self.mpls_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-addr"):
                                self.remote_addr = value
                                self.remote_addr.value_namespace = name_space
                                self.remote_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "sid-type"):
                                self.sid_type = value
                                self.sid_type.value_namespace = name_space
                                self.sid_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.flags.is_set or
                            self.ipv4_address.is_set or
                            self.mpls_label.is_set or
                            self.rro_type.is_set or
                            (self.sr_rro is not None and self.sr_rro.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.flags.yfilter != YFilter.not_set or
                            self.ipv4_address.yfilter != YFilter.not_set or
                            self.mpls_label.yfilter != YFilter.not_set or
                            self.rro_type.yfilter != YFilter.not_set or
                            (self.sr_rro is not None and self.sr_rro.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rro" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.flags.get_name_leafdata())
                        if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                        if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_label.get_name_leafdata())
                        if (self.rro_type.is_set or self.rro_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rro_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sr-rro"):
                            if (self.sr_rro is None):
                                self.sr_rro = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro()
                                self.sr_rro.parent = self
                                self._children_name_map["sr_rro"] = "sr-rro"
                            return self.sr_rro

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sr-rro" or name == "flags" or name == "ipv4-address" or name == "mpls-label" or name == "rro-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "flags"):
                            self.flags = value
                            self.flags.value_namespace = name_space
                            self.flags.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4-address"):
                            self.ipv4_address = value
                            self.ipv4_address.value_namespace = name_space
                            self.ipv4_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "mpls-label"):
                            self.mpls_label = value
                            self.mpls_label.value_namespace = name_space
                            self.mpls_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "rro-type"):
                            self.rro_type = value
                            self.rro_type.value_namespace = name_space
                            self.rro_type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.rro:
                        if (c.has_data()):
                            return True
                    for leaf in self.srlg_info.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.actual_bandwidth.is_set or
                        self.actual_bandwidth_specified.is_set or
                        self.computing_pce.is_set or
                        self.lsp_role.is_set or
                        self.reporting_pcc_address.is_set or
                        self.signaled_bandwidth.is_set or
                        self.signaled_bandwidth_specified.is_set or
                        self.state_sync_pce.is_set or
                        self.sub_delegated_pce.is_set or
                        (self.brief_lsp_information is not None and self.brief_lsp_information.has_data()) or
                        (self.er_os is not None and self.er_os.has_data()) or
                        (self.lsp_association_info is not None and self.lsp_association_info.has_data()) or
                        (self.lsp_attributes is not None and self.lsp_attributes.has_data()) or
                        (self.lsppcep_information is not None and self.lsppcep_information.has_data()))

                def has_operation(self):
                    for c in self.rro:
                        if (c.has_operation()):
                            return True
                    for leaf in self.srlg_info.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.actual_bandwidth.yfilter != YFilter.not_set or
                        self.actual_bandwidth_specified.yfilter != YFilter.not_set or
                        self.computing_pce.yfilter != YFilter.not_set or
                        self.lsp_role.yfilter != YFilter.not_set or
                        self.reporting_pcc_address.yfilter != YFilter.not_set or
                        self.signaled_bandwidth.yfilter != YFilter.not_set or
                        self.signaled_bandwidth_specified.yfilter != YFilter.not_set or
                        self.srlg_info.yfilter != YFilter.not_set or
                        self.state_sync_pce.yfilter != YFilter.not_set or
                        self.sub_delegated_pce.yfilter != YFilter.not_set or
                        (self.brief_lsp_information is not None and self.brief_lsp_information.has_operation()) or
                        (self.er_os is not None and self.er_os.has_operation()) or
                        (self.lsp_association_info is not None and self.lsp_association_info.has_operation()) or
                        (self.lsp_attributes is not None and self.lsp_attributes.has_operation()) or
                        (self.lsppcep_information is not None and self.lsppcep_information.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "detail-lsp-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.actual_bandwidth.is_set or self.actual_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.actual_bandwidth.get_name_leafdata())
                    if (self.actual_bandwidth_specified.is_set or self.actual_bandwidth_specified.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.actual_bandwidth_specified.get_name_leafdata())
                    if (self.computing_pce.is_set or self.computing_pce.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.computing_pce.get_name_leafdata())
                    if (self.lsp_role.is_set or self.lsp_role.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_role.get_name_leafdata())
                    if (self.reporting_pcc_address.is_set or self.reporting_pcc_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reporting_pcc_address.get_name_leafdata())
                    if (self.signaled_bandwidth.is_set or self.signaled_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.signaled_bandwidth.get_name_leafdata())
                    if (self.signaled_bandwidth_specified.is_set or self.signaled_bandwidth_specified.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.signaled_bandwidth_specified.get_name_leafdata())
                    if (self.state_sync_pce.is_set or self.state_sync_pce.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state_sync_pce.get_name_leafdata())
                    if (self.sub_delegated_pce.is_set or self.sub_delegated_pce.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sub_delegated_pce.get_name_leafdata())

                    leaf_name_data.extend(self.srlg_info.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-lsp-information"):
                        if (self.brief_lsp_information is None):
                            self.brief_lsp_information = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation()
                            self.brief_lsp_information.parent = self
                            self._children_name_map["brief_lsp_information"] = "brief-lsp-information"
                        return self.brief_lsp_information

                    if (child_yang_name == "er-os"):
                        if (self.er_os is None):
                            self.er_os = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs()
                            self.er_os.parent = self
                            self._children_name_map["er_os"] = "er-os"
                        return self.er_os

                    if (child_yang_name == "lsp-association-info"):
                        if (self.lsp_association_info is None):
                            self.lsp_association_info = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo()
                            self.lsp_association_info.parent = self
                            self._children_name_map["lsp_association_info"] = "lsp-association-info"
                        return self.lsp_association_info

                    if (child_yang_name == "lsp-attributes"):
                        if (self.lsp_attributes is None):
                            self.lsp_attributes = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes()
                            self.lsp_attributes.parent = self
                            self._children_name_map["lsp_attributes"] = "lsp-attributes"
                        return self.lsp_attributes

                    if (child_yang_name == "lsppcep-information"):
                        if (self.lsppcep_information is None):
                            self.lsppcep_information = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation()
                            self.lsppcep_information.parent = self
                            self._children_name_map["lsppcep_information"] = "lsppcep-information"
                        return self.lsppcep_information

                    if (child_yang_name == "rro"):
                        for c in self.rro:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.rro.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-lsp-information" or name == "er-os" or name == "lsp-association-info" or name == "lsp-attributes" or name == "lsppcep-information" or name == "rro" or name == "actual-bandwidth" or name == "actual-bandwidth-specified" or name == "computing-pce" or name == "lsp-role" or name == "reporting-pcc-address" or name == "signaled-bandwidth" or name == "signaled-bandwidth-specified" or name == "srlg-info" or name == "state-sync-pce" or name == "sub-delegated-pce"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "actual-bandwidth"):
                        self.actual_bandwidth = value
                        self.actual_bandwidth.value_namespace = name_space
                        self.actual_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "actual-bandwidth-specified"):
                        self.actual_bandwidth_specified = value
                        self.actual_bandwidth_specified.value_namespace = name_space
                        self.actual_bandwidth_specified.value_namespace_prefix = name_space_prefix
                    if(value_path == "computing-pce"):
                        self.computing_pce = value
                        self.computing_pce.value_namespace = name_space
                        self.computing_pce.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-role"):
                        self.lsp_role = value
                        self.lsp_role.value_namespace = name_space
                        self.lsp_role.value_namespace_prefix = name_space_prefix
                    if(value_path == "reporting-pcc-address"):
                        self.reporting_pcc_address = value
                        self.reporting_pcc_address.value_namespace = name_space
                        self.reporting_pcc_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "signaled-bandwidth"):
                        self.signaled_bandwidth = value
                        self.signaled_bandwidth.value_namespace = name_space
                        self.signaled_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "signaled-bandwidth-specified"):
                        self.signaled_bandwidth_specified = value
                        self.signaled_bandwidth_specified.value_namespace = name_space
                        self.signaled_bandwidth_specified.value_namespace_prefix = name_space_prefix
                    if(value_path == "srlg-info"):
                        self.srlg_info.append(value)
                    if(value_path == "state-sync-pce"):
                        self.state_sync_pce = value
                        self.state_sync_pce.value_namespace = name_space
                        self.state_sync_pce.value_namespace_prefix = name_space_prefix
                    if(value_path == "sub-delegated-pce"):
                        self.sub_delegated_pce = value
                        self.sub_delegated_pce.value_namespace = name_space
                        self.sub_delegated_pce.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.detail_lsp_information:
                    if (c.has_data()):
                        return True
                return (
                    self.peer_address.is_set or
                    self.plsp_id.is_set or
                    self.tunnel_name.is_set or
                    self.pcc_address.is_set or
                    self.tunnel_name_xr.is_set or
                    (self.private_lsp_information is not None and self.private_lsp_information.has_data()))

            def has_operation(self):
                for c in self.detail_lsp_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.plsp_id.yfilter != YFilter.not_set or
                    self.tunnel_name.yfilter != YFilter.not_set or
                    self.pcc_address.yfilter != YFilter.not_set or
                    self.tunnel_name_xr.yfilter != YFilter.not_set or
                    (self.private_lsp_information is not None and self.private_lsp_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel-detail-info" + "[peer-address='" + self.peer_address.get() + "']" + "[plsp-id='" + self.plsp_id.get() + "']" + "[tunnel-name='" + self.tunnel_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/tunnel-detail-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.plsp_id.is_set or self.plsp_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.plsp_id.get_name_leafdata())
                if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name.get_name_leafdata())
                if (self.pcc_address.is_set or self.pcc_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pcc_address.get_name_leafdata())
                if (self.tunnel_name_xr.is_set or self.tunnel_name_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name_xr.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "detail-lsp-information"):
                    for c in self.detail_lsp_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = PceLspData.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.detail_lsp_information.append(c)
                    return c

                if (child_yang_name == "private-lsp-information"):
                    if (self.private_lsp_information is None):
                        self.private_lsp_information = PceLspData.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation()
                        self.private_lsp_information.parent = self
                        self._children_name_map["private_lsp_information"] = "private-lsp-information"
                    return self.private_lsp_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "detail-lsp-information" or name == "private-lsp-information" or name == "peer-address" or name == "plsp-id" or name == "tunnel-name" or name == "pcc-address" or name == "tunnel-name-xr"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "plsp-id"):
                    self.plsp_id = value
                    self.plsp_id.value_namespace = name_space
                    self.plsp_id.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name"):
                    self.tunnel_name = value
                    self.tunnel_name.value_namespace = name_space
                    self.tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "pcc-address"):
                    self.pcc_address = value
                    self.pcc_address.value_namespace = name_space
                    self.pcc_address.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name-xr"):
                    self.tunnel_name_xr = value
                    self.tunnel_name_xr.value_namespace = name_space
                    self.tunnel_name_xr.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel_detail_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel_detail_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnel-detail-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel-detail-info"):
                for c in self.tunnel_detail_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = PceLspData.TunnelDetailInfos.TunnelDetailInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel_detail_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel-detail-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.lsp_summary is not None and self.lsp_summary.has_data()) or
            (self.tunnel_detail_infos is not None and self.tunnel_detail_infos.has_data()) or
            (self.tunnel_infos is not None and self.tunnel_infos.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.lsp_summary is not None and self.lsp_summary.has_operation()) or
            (self.tunnel_detail_infos is not None and self.tunnel_detail_infos.has_operation()) or
            (self.tunnel_infos is not None and self.tunnel_infos.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-lsp-data" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "lsp-summary"):
            if (self.lsp_summary is None):
                self.lsp_summary = PceLspData.LspSummary()
                self.lsp_summary.parent = self
                self._children_name_map["lsp_summary"] = "lsp-summary"
            return self.lsp_summary

        if (child_yang_name == "tunnel-detail-infos"):
            if (self.tunnel_detail_infos is None):
                self.tunnel_detail_infos = PceLspData.TunnelDetailInfos()
                self.tunnel_detail_infos.parent = self
                self._children_name_map["tunnel_detail_infos"] = "tunnel-detail-infos"
            return self.tunnel_detail_infos

        if (child_yang_name == "tunnel-infos"):
            if (self.tunnel_infos is None):
                self.tunnel_infos = PceLspData.TunnelInfos()
                self.tunnel_infos.parent = self
                self._children_name_map["tunnel_infos"] = "tunnel-infos"
            return self.tunnel_infos

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "lsp-summary" or name == "tunnel-detail-infos" or name == "tunnel-infos"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = PceLspData()
        return self._top_entity

class PcePeer(Entity):
    """
    pce peer
    
    .. attribute:: peer_detail_infos
    
    	Detailed peers database in XTC
    	**type**\:   :py:class:`PeerDetailInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerDetailInfos>`
    
    .. attribute:: peer_infos
    
    	Peers database in XTC
    	**type**\:   :py:class:`PeerInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerInfos>`
    
    

    """

    _prefix = 'infra-xtc-oper'
    _revision = '2016-05-31'

    def __init__(self):
        super(PcePeer, self).__init__()
        self._top_entity = None

        self.yang_name = "pce-peer"
        self.yang_parent_name = "Cisco-IOS-XR-infra-xtc-oper"

        self.peer_detail_infos = PcePeer.PeerDetailInfos()
        self.peer_detail_infos.parent = self
        self._children_name_map["peer_detail_infos"] = "peer-detail-infos"
        self._children_yang_names.add("peer-detail-infos")

        self.peer_infos = PcePeer.PeerInfos()
        self.peer_infos.parent = self
        self._children_name_map["peer_infos"] = "peer-infos"
        self._children_yang_names.add("peer-infos")


    class PeerDetailInfos(Entity):
        """
        Detailed peers database in XTC
        
        .. attribute:: peer_detail_info
        
        	Detailed PCE peer information
        	**type**\: list of    :py:class:`PeerDetailInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerDetailInfos.PeerDetailInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PcePeer.PeerDetailInfos, self).__init__()

            self.yang_name = "peer-detail-infos"
            self.yang_parent_name = "pce-peer"

            self.peer_detail_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PcePeer.PeerDetailInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PcePeer.PeerDetailInfos, self).__setattr__(name, value)


        class PeerDetailInfo(Entity):
            """
            Detailed PCE peer information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: detail_pcep_information
            
            	Detailed PCE protocol information
            	**type**\:   :py:class:`DetailPcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation>`
            
            .. attribute:: peer_address_xr
            
            	Peer address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: peer_protocol
            
            	Protocol between PCE and peer
            	**type**\:   :py:class:`PceProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceProto>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PcePeer.PeerDetailInfos.PeerDetailInfo, self).__init__()

                self.yang_name = "peer-detail-info"
                self.yang_parent_name = "peer-detail-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.peer_address_xr = YLeaf(YType.str, "peer-address-xr")

                self.peer_protocol = YLeaf(YType.enumeration, "peer-protocol")

                self.detail_pcep_information = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation()
                self.detail_pcep_information.parent = self
                self._children_name_map["detail_pcep_information"] = "detail-pcep-information"
                self._children_yang_names.add("detail-pcep-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "peer_address_xr",
                                "peer_protocol") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PcePeer.PeerDetailInfos.PeerDetailInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PcePeer.PeerDetailInfos.PeerDetailInfo, self).__setattr__(name, value)


            class DetailPcepInformation(Entity):
                """
                Detailed PCE protocol information
                
                .. attribute:: brief_pcep_information
                
                	Brief PCE protocol information
                	**type**\:   :py:class:`BriefPcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation>`
                
                .. attribute:: error
                
                	Error (for display only)
                	**type**\:  str
                
                .. attribute:: keepalives
                
                	Keepalive count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: keychain_enabled
                
                	Keychain based Authentication Enabled
                	**type**\:  bool
                
                .. attribute:: last_error_rx
                
                	Last PCError received
                	**type**\:   :py:class:`LastErrorRx <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx>`
                
                .. attribute:: last_error_tx
                
                	Last PCError sent
                	**type**\:   :py:class:`LastErrorTx <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx>`
                
                .. attribute:: local_session_id
                
                	Local PCEP session ID
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: maximum_dead_interval
                
                	Maximum dead interval for the peer
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: md5_enabled
                
                	MD5 Authentication Enabled
                	**type**\:  bool
                
                .. attribute:: minimum_keepalive_interval
                
                	Minimum keepalive interval for the peer
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: negotiated_dead_time
                
                	Negotiated DT
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: negotiated_local_keepalive
                
                	Negotiated KA
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: negotiated_remote_keepalive
                
                	Negotiated KA
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_error_rx
                
                	PCEErr Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_error_tx
                
                	PCEErr Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_initiate_rx
                
                	PCEInit Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_initiate_tx
                
                	PCEInit Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_keepalive_rx
                
                	PCE Keepalive Rx
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: pce_keepalive_tx
                
                	PCE Keepalive Tx
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: pce_open_rx
                
                	PCEOpen Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_open_tx
                
                	PCEOpen Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_reply_rx
                
                	PCERep Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_reply_tx
                
                	PCERep Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_report_rx
                
                	PCERpt Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_report_tx
                
                	PCERpt Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_request_rx
                
                	PCEReq Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_request_tx
                
                	PCEReq Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_update_rx
                
                	PCEUpd Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_update_tx
                
                	PCEUpd Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pcep_up_time
                
                	PCEP Up Time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_session_id
                
                	Remote PCEP session ID
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: speaker_id
                
                	Speaker Entity ID
                	**type**\:  str
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation, self).__init__()

                    self.yang_name = "detail-pcep-information"
                    self.yang_parent_name = "peer-detail-info"

                    self.error = YLeaf(YType.str, "error")

                    self.keepalives = YLeaf(YType.uint32, "keepalives")

                    self.keychain_enabled = YLeaf(YType.boolean, "keychain-enabled")

                    self.local_session_id = YLeaf(YType.uint8, "local-session-id")

                    self.maximum_dead_interval = YLeaf(YType.uint8, "maximum-dead-interval")

                    self.md5_enabled = YLeaf(YType.boolean, "md5-enabled")

                    self.minimum_keepalive_interval = YLeaf(YType.uint8, "minimum-keepalive-interval")

                    self.negotiated_dead_time = YLeaf(YType.uint32, "negotiated-dead-time")

                    self.negotiated_local_keepalive = YLeaf(YType.uint32, "negotiated-local-keepalive")

                    self.negotiated_remote_keepalive = YLeaf(YType.uint32, "negotiated-remote-keepalive")

                    self.pce_error_rx = YLeaf(YType.uint32, "pce-error-rx")

                    self.pce_error_tx = YLeaf(YType.uint32, "pce-error-tx")

                    self.pce_initiate_rx = YLeaf(YType.uint32, "pce-initiate-rx")

                    self.pce_initiate_tx = YLeaf(YType.uint32, "pce-initiate-tx")

                    self.pce_keepalive_rx = YLeaf(YType.uint64, "pce-keepalive-rx")

                    self.pce_keepalive_tx = YLeaf(YType.uint64, "pce-keepalive-tx")

                    self.pce_open_rx = YLeaf(YType.uint32, "pce-open-rx")

                    self.pce_open_tx = YLeaf(YType.uint32, "pce-open-tx")

                    self.pce_reply_rx = YLeaf(YType.uint32, "pce-reply-rx")

                    self.pce_reply_tx = YLeaf(YType.uint32, "pce-reply-tx")

                    self.pce_report_rx = YLeaf(YType.uint32, "pce-report-rx")

                    self.pce_report_tx = YLeaf(YType.uint32, "pce-report-tx")

                    self.pce_request_rx = YLeaf(YType.uint32, "pce-request-rx")

                    self.pce_request_tx = YLeaf(YType.uint32, "pce-request-tx")

                    self.pce_update_rx = YLeaf(YType.uint32, "pce-update-rx")

                    self.pce_update_tx = YLeaf(YType.uint32, "pce-update-tx")

                    self.pcep_up_time = YLeaf(YType.uint32, "pcep-up-time")

                    self.remote_session_id = YLeaf(YType.uint8, "remote-session-id")

                    self.speaker_id = YLeaf(YType.str, "speaker-id")

                    self.brief_pcep_information = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation()
                    self.brief_pcep_information.parent = self
                    self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                    self._children_yang_names.add("brief-pcep-information")

                    self.last_error_rx = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx()
                    self.last_error_rx.parent = self
                    self._children_name_map["last_error_rx"] = "last-error-rx"
                    self._children_yang_names.add("last-error-rx")

                    self.last_error_tx = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx()
                    self.last_error_tx.parent = self
                    self._children_name_map["last_error_tx"] = "last-error-tx"
                    self._children_yang_names.add("last-error-tx")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("error",
                                    "keepalives",
                                    "keychain_enabled",
                                    "local_session_id",
                                    "maximum_dead_interval",
                                    "md5_enabled",
                                    "minimum_keepalive_interval",
                                    "negotiated_dead_time",
                                    "negotiated_local_keepalive",
                                    "negotiated_remote_keepalive",
                                    "pce_error_rx",
                                    "pce_error_tx",
                                    "pce_initiate_rx",
                                    "pce_initiate_tx",
                                    "pce_keepalive_rx",
                                    "pce_keepalive_tx",
                                    "pce_open_rx",
                                    "pce_open_tx",
                                    "pce_reply_rx",
                                    "pce_reply_tx",
                                    "pce_report_rx",
                                    "pce_report_tx",
                                    "pce_request_rx",
                                    "pce_request_tx",
                                    "pce_update_rx",
                                    "pce_update_tx",
                                    "pcep_up_time",
                                    "remote_session_id",
                                    "speaker_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation, self).__setattr__(name, value)


                class BriefPcepInformation(Entity):
                    """
                    Brief PCE protocol information
                    
                    .. attribute:: capability_db_version
                    
                    	DB version capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_delta_sync
                    
                    	Delta Synchronization capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_instantiate
                    
                    	Instantiation capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_segment_routing
                    
                    	Segment Routing capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_triggered_sync
                    
                    	Triggered Synchronization capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_update
                    
                    	Update capability
                    	**type**\:  bool
                    
                    .. attribute:: pcep_state
                    
                    	PCEP State
                    	**type**\:   :py:class:`PcepState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepState>`
                    
                    .. attribute:: stateful
                    
                    	Stateful
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation, self).__init__()

                        self.yang_name = "brief-pcep-information"
                        self.yang_parent_name = "detail-pcep-information"

                        self.capability_db_version = YLeaf(YType.boolean, "capability-db-version")

                        self.capability_delta_sync = YLeaf(YType.boolean, "capability-delta-sync")

                        self.capability_instantiate = YLeaf(YType.boolean, "capability-instantiate")

                        self.capability_segment_routing = YLeaf(YType.boolean, "capability-segment-routing")

                        self.capability_triggered_sync = YLeaf(YType.boolean, "capability-triggered-sync")

                        self.capability_update = YLeaf(YType.boolean, "capability-update")

                        self.pcep_state = YLeaf(YType.enumeration, "pcep-state")

                        self.stateful = YLeaf(YType.boolean, "stateful")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("capability_db_version",
                                        "capability_delta_sync",
                                        "capability_instantiate",
                                        "capability_segment_routing",
                                        "capability_triggered_sync",
                                        "capability_update",
                                        "pcep_state",
                                        "stateful") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.capability_db_version.is_set or
                            self.capability_delta_sync.is_set or
                            self.capability_instantiate.is_set or
                            self.capability_segment_routing.is_set or
                            self.capability_triggered_sync.is_set or
                            self.capability_update.is_set or
                            self.pcep_state.is_set or
                            self.stateful.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.capability_db_version.yfilter != YFilter.not_set or
                            self.capability_delta_sync.yfilter != YFilter.not_set or
                            self.capability_instantiate.yfilter != YFilter.not_set or
                            self.capability_segment_routing.yfilter != YFilter.not_set or
                            self.capability_triggered_sync.yfilter != YFilter.not_set or
                            self.capability_update.yfilter != YFilter.not_set or
                            self.pcep_state.yfilter != YFilter.not_set or
                            self.stateful.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-pcep-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.capability_db_version.is_set or self.capability_db_version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_db_version.get_name_leafdata())
                        if (self.capability_delta_sync.is_set or self.capability_delta_sync.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_delta_sync.get_name_leafdata())
                        if (self.capability_instantiate.is_set or self.capability_instantiate.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_instantiate.get_name_leafdata())
                        if (self.capability_segment_routing.is_set or self.capability_segment_routing.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_segment_routing.get_name_leafdata())
                        if (self.capability_triggered_sync.is_set or self.capability_triggered_sync.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_triggered_sync.get_name_leafdata())
                        if (self.capability_update.is_set or self.capability_update.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_update.get_name_leafdata())
                        if (self.pcep_state.is_set or self.pcep_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_state.get_name_leafdata())
                        if (self.stateful.is_set or self.stateful.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stateful.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "capability-db-version" or name == "capability-delta-sync" or name == "capability-instantiate" or name == "capability-segment-routing" or name == "capability-triggered-sync" or name == "capability-update" or name == "pcep-state" or name == "stateful"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "capability-db-version"):
                            self.capability_db_version = value
                            self.capability_db_version.value_namespace = name_space
                            self.capability_db_version.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-delta-sync"):
                            self.capability_delta_sync = value
                            self.capability_delta_sync.value_namespace = name_space
                            self.capability_delta_sync.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-instantiate"):
                            self.capability_instantiate = value
                            self.capability_instantiate.value_namespace = name_space
                            self.capability_instantiate.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-segment-routing"):
                            self.capability_segment_routing = value
                            self.capability_segment_routing.value_namespace = name_space
                            self.capability_segment_routing.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-triggered-sync"):
                            self.capability_triggered_sync = value
                            self.capability_triggered_sync.value_namespace = name_space
                            self.capability_triggered_sync.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-update"):
                            self.capability_update = value
                            self.capability_update.value_namespace = name_space
                            self.capability_update.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-state"):
                            self.pcep_state = value
                            self.pcep_state.value_namespace = name_space
                            self.pcep_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "stateful"):
                            self.stateful = value
                            self.stateful.value_namespace = name_space
                            self.stateful.value_namespace_prefix = name_space_prefix


                class LastErrorRx(Entity):
                    """
                    Last PCError received
                    
                    .. attribute:: pc_error_type
                    
                    	PCEP Error type
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: pc_error_value
                    
                    	PCEP Error Value
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx, self).__init__()

                        self.yang_name = "last-error-rx"
                        self.yang_parent_name = "detail-pcep-information"

                        self.pc_error_type = YLeaf(YType.uint8, "pc-error-type")

                        self.pc_error_value = YLeaf(YType.uint8, "pc-error-value")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pc_error_type",
                                        "pc_error_value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.pc_error_type.is_set or
                            self.pc_error_value.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pc_error_type.yfilter != YFilter.not_set or
                            self.pc_error_value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-error-rx" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pc_error_type.is_set or self.pc_error_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_type.get_name_leafdata())
                        if (self.pc_error_value.is_set or self.pc_error_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "pc-error-type" or name == "pc-error-value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pc-error-type"):
                            self.pc_error_type = value
                            self.pc_error_type.value_namespace = name_space
                            self.pc_error_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "pc-error-value"):
                            self.pc_error_value = value
                            self.pc_error_value.value_namespace = name_space
                            self.pc_error_value.value_namespace_prefix = name_space_prefix


                class LastErrorTx(Entity):
                    """
                    Last PCError sent
                    
                    .. attribute:: pc_error_type
                    
                    	PCEP Error type
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: pc_error_value
                    
                    	PCEP Error Value
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx, self).__init__()

                        self.yang_name = "last-error-tx"
                        self.yang_parent_name = "detail-pcep-information"

                        self.pc_error_type = YLeaf(YType.uint8, "pc-error-type")

                        self.pc_error_value = YLeaf(YType.uint8, "pc-error-value")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pc_error_type",
                                        "pc_error_value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.pc_error_type.is_set or
                            self.pc_error_value.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pc_error_type.yfilter != YFilter.not_set or
                            self.pc_error_value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-error-tx" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pc_error_type.is_set or self.pc_error_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_type.get_name_leafdata())
                        if (self.pc_error_value.is_set or self.pc_error_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "pc-error-type" or name == "pc-error-value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pc-error-type"):
                            self.pc_error_type = value
                            self.pc_error_type.value_namespace = name_space
                            self.pc_error_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "pc-error-value"):
                            self.pc_error_value = value
                            self.pc_error_value.value_namespace = name_space
                            self.pc_error_value.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.error.is_set or
                        self.keepalives.is_set or
                        self.keychain_enabled.is_set or
                        self.local_session_id.is_set or
                        self.maximum_dead_interval.is_set or
                        self.md5_enabled.is_set or
                        self.minimum_keepalive_interval.is_set or
                        self.negotiated_dead_time.is_set or
                        self.negotiated_local_keepalive.is_set or
                        self.negotiated_remote_keepalive.is_set or
                        self.pce_error_rx.is_set or
                        self.pce_error_tx.is_set or
                        self.pce_initiate_rx.is_set or
                        self.pce_initiate_tx.is_set or
                        self.pce_keepalive_rx.is_set or
                        self.pce_keepalive_tx.is_set or
                        self.pce_open_rx.is_set or
                        self.pce_open_tx.is_set or
                        self.pce_reply_rx.is_set or
                        self.pce_reply_tx.is_set or
                        self.pce_report_rx.is_set or
                        self.pce_report_tx.is_set or
                        self.pce_request_rx.is_set or
                        self.pce_request_tx.is_set or
                        self.pce_update_rx.is_set or
                        self.pce_update_tx.is_set or
                        self.pcep_up_time.is_set or
                        self.remote_session_id.is_set or
                        self.speaker_id.is_set or
                        (self.brief_pcep_information is not None and self.brief_pcep_information.has_data()) or
                        (self.last_error_rx is not None and self.last_error_rx.has_data()) or
                        (self.last_error_tx is not None and self.last_error_tx.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.error.yfilter != YFilter.not_set or
                        self.keepalives.yfilter != YFilter.not_set or
                        self.keychain_enabled.yfilter != YFilter.not_set or
                        self.local_session_id.yfilter != YFilter.not_set or
                        self.maximum_dead_interval.yfilter != YFilter.not_set or
                        self.md5_enabled.yfilter != YFilter.not_set or
                        self.minimum_keepalive_interval.yfilter != YFilter.not_set or
                        self.negotiated_dead_time.yfilter != YFilter.not_set or
                        self.negotiated_local_keepalive.yfilter != YFilter.not_set or
                        self.negotiated_remote_keepalive.yfilter != YFilter.not_set or
                        self.pce_error_rx.yfilter != YFilter.not_set or
                        self.pce_error_tx.yfilter != YFilter.not_set or
                        self.pce_initiate_rx.yfilter != YFilter.not_set or
                        self.pce_initiate_tx.yfilter != YFilter.not_set or
                        self.pce_keepalive_rx.yfilter != YFilter.not_set or
                        self.pce_keepalive_tx.yfilter != YFilter.not_set or
                        self.pce_open_rx.yfilter != YFilter.not_set or
                        self.pce_open_tx.yfilter != YFilter.not_set or
                        self.pce_reply_rx.yfilter != YFilter.not_set or
                        self.pce_reply_tx.yfilter != YFilter.not_set or
                        self.pce_report_rx.yfilter != YFilter.not_set or
                        self.pce_report_tx.yfilter != YFilter.not_set or
                        self.pce_request_rx.yfilter != YFilter.not_set or
                        self.pce_request_tx.yfilter != YFilter.not_set or
                        self.pce_update_rx.yfilter != YFilter.not_set or
                        self.pce_update_tx.yfilter != YFilter.not_set or
                        self.pcep_up_time.yfilter != YFilter.not_set or
                        self.remote_session_id.yfilter != YFilter.not_set or
                        self.speaker_id.yfilter != YFilter.not_set or
                        (self.brief_pcep_information is not None and self.brief_pcep_information.has_operation()) or
                        (self.last_error_rx is not None and self.last_error_rx.has_operation()) or
                        (self.last_error_tx is not None and self.last_error_tx.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "detail-pcep-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.error.is_set or self.error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.error.get_name_leafdata())
                    if (self.keepalives.is_set or self.keepalives.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.keepalives.get_name_leafdata())
                    if (self.keychain_enabled.is_set or self.keychain_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.keychain_enabled.get_name_leafdata())
                    if (self.local_session_id.is_set or self.local_session_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_session_id.get_name_leafdata())
                    if (self.maximum_dead_interval.is_set or self.maximum_dead_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maximum_dead_interval.get_name_leafdata())
                    if (self.md5_enabled.is_set or self.md5_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.md5_enabled.get_name_leafdata())
                    if (self.minimum_keepalive_interval.is_set or self.minimum_keepalive_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.minimum_keepalive_interval.get_name_leafdata())
                    if (self.negotiated_dead_time.is_set or self.negotiated_dead_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.negotiated_dead_time.get_name_leafdata())
                    if (self.negotiated_local_keepalive.is_set or self.negotiated_local_keepalive.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.negotiated_local_keepalive.get_name_leafdata())
                    if (self.negotiated_remote_keepalive.is_set or self.negotiated_remote_keepalive.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.negotiated_remote_keepalive.get_name_leafdata())
                    if (self.pce_error_rx.is_set or self.pce_error_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_error_rx.get_name_leafdata())
                    if (self.pce_error_tx.is_set or self.pce_error_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_error_tx.get_name_leafdata())
                    if (self.pce_initiate_rx.is_set or self.pce_initiate_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_initiate_rx.get_name_leafdata())
                    if (self.pce_initiate_tx.is_set or self.pce_initiate_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_initiate_tx.get_name_leafdata())
                    if (self.pce_keepalive_rx.is_set or self.pce_keepalive_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_keepalive_rx.get_name_leafdata())
                    if (self.pce_keepalive_tx.is_set or self.pce_keepalive_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_keepalive_tx.get_name_leafdata())
                    if (self.pce_open_rx.is_set or self.pce_open_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_open_rx.get_name_leafdata())
                    if (self.pce_open_tx.is_set or self.pce_open_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_open_tx.get_name_leafdata())
                    if (self.pce_reply_rx.is_set or self.pce_reply_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_reply_rx.get_name_leafdata())
                    if (self.pce_reply_tx.is_set or self.pce_reply_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_reply_tx.get_name_leafdata())
                    if (self.pce_report_rx.is_set or self.pce_report_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_report_rx.get_name_leafdata())
                    if (self.pce_report_tx.is_set or self.pce_report_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_report_tx.get_name_leafdata())
                    if (self.pce_request_rx.is_set or self.pce_request_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_request_rx.get_name_leafdata())
                    if (self.pce_request_tx.is_set or self.pce_request_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_request_tx.get_name_leafdata())
                    if (self.pce_update_rx.is_set or self.pce_update_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_update_rx.get_name_leafdata())
                    if (self.pce_update_tx.is_set or self.pce_update_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_update_tx.get_name_leafdata())
                    if (self.pcep_up_time.is_set or self.pcep_up_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pcep_up_time.get_name_leafdata())
                    if (self.remote_session_id.is_set or self.remote_session_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_session_id.get_name_leafdata())
                    if (self.speaker_id.is_set or self.speaker_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.speaker_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-pcep-information"):
                        if (self.brief_pcep_information is None):
                            self.brief_pcep_information = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation()
                            self.brief_pcep_information.parent = self
                            self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                        return self.brief_pcep_information

                    if (child_yang_name == "last-error-rx"):
                        if (self.last_error_rx is None):
                            self.last_error_rx = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx()
                            self.last_error_rx.parent = self
                            self._children_name_map["last_error_rx"] = "last-error-rx"
                        return self.last_error_rx

                    if (child_yang_name == "last-error-tx"):
                        if (self.last_error_tx is None):
                            self.last_error_tx = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx()
                            self.last_error_tx.parent = self
                            self._children_name_map["last_error_tx"] = "last-error-tx"
                        return self.last_error_tx

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-pcep-information" or name == "last-error-rx" or name == "last-error-tx" or name == "error" or name == "keepalives" or name == "keychain-enabled" or name == "local-session-id" or name == "maximum-dead-interval" or name == "md5-enabled" or name == "minimum-keepalive-interval" or name == "negotiated-dead-time" or name == "negotiated-local-keepalive" or name == "negotiated-remote-keepalive" or name == "pce-error-rx" or name == "pce-error-tx" or name == "pce-initiate-rx" or name == "pce-initiate-tx" or name == "pce-keepalive-rx" or name == "pce-keepalive-tx" or name == "pce-open-rx" or name == "pce-open-tx" or name == "pce-reply-rx" or name == "pce-reply-tx" or name == "pce-report-rx" or name == "pce-report-tx" or name == "pce-request-rx" or name == "pce-request-tx" or name == "pce-update-rx" or name == "pce-update-tx" or name == "pcep-up-time" or name == "remote-session-id" or name == "speaker-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "error"):
                        self.error = value
                        self.error.value_namespace = name_space
                        self.error.value_namespace_prefix = name_space_prefix
                    if(value_path == "keepalives"):
                        self.keepalives = value
                        self.keepalives.value_namespace = name_space
                        self.keepalives.value_namespace_prefix = name_space_prefix
                    if(value_path == "keychain-enabled"):
                        self.keychain_enabled = value
                        self.keychain_enabled.value_namespace = name_space
                        self.keychain_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-session-id"):
                        self.local_session_id = value
                        self.local_session_id.value_namespace = name_space
                        self.local_session_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "maximum-dead-interval"):
                        self.maximum_dead_interval = value
                        self.maximum_dead_interval.value_namespace = name_space
                        self.maximum_dead_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "md5-enabled"):
                        self.md5_enabled = value
                        self.md5_enabled.value_namespace = name_space
                        self.md5_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "minimum-keepalive-interval"):
                        self.minimum_keepalive_interval = value
                        self.minimum_keepalive_interval.value_namespace = name_space
                        self.minimum_keepalive_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "negotiated-dead-time"):
                        self.negotiated_dead_time = value
                        self.negotiated_dead_time.value_namespace = name_space
                        self.negotiated_dead_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "negotiated-local-keepalive"):
                        self.negotiated_local_keepalive = value
                        self.negotiated_local_keepalive.value_namespace = name_space
                        self.negotiated_local_keepalive.value_namespace_prefix = name_space_prefix
                    if(value_path == "negotiated-remote-keepalive"):
                        self.negotiated_remote_keepalive = value
                        self.negotiated_remote_keepalive.value_namespace = name_space
                        self.negotiated_remote_keepalive.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-error-rx"):
                        self.pce_error_rx = value
                        self.pce_error_rx.value_namespace = name_space
                        self.pce_error_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-error-tx"):
                        self.pce_error_tx = value
                        self.pce_error_tx.value_namespace = name_space
                        self.pce_error_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-initiate-rx"):
                        self.pce_initiate_rx = value
                        self.pce_initiate_rx.value_namespace = name_space
                        self.pce_initiate_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-initiate-tx"):
                        self.pce_initiate_tx = value
                        self.pce_initiate_tx.value_namespace = name_space
                        self.pce_initiate_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-keepalive-rx"):
                        self.pce_keepalive_rx = value
                        self.pce_keepalive_rx.value_namespace = name_space
                        self.pce_keepalive_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-keepalive-tx"):
                        self.pce_keepalive_tx = value
                        self.pce_keepalive_tx.value_namespace = name_space
                        self.pce_keepalive_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-open-rx"):
                        self.pce_open_rx = value
                        self.pce_open_rx.value_namespace = name_space
                        self.pce_open_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-open-tx"):
                        self.pce_open_tx = value
                        self.pce_open_tx.value_namespace = name_space
                        self.pce_open_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-reply-rx"):
                        self.pce_reply_rx = value
                        self.pce_reply_rx.value_namespace = name_space
                        self.pce_reply_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-reply-tx"):
                        self.pce_reply_tx = value
                        self.pce_reply_tx.value_namespace = name_space
                        self.pce_reply_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-report-rx"):
                        self.pce_report_rx = value
                        self.pce_report_rx.value_namespace = name_space
                        self.pce_report_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-report-tx"):
                        self.pce_report_tx = value
                        self.pce_report_tx.value_namespace = name_space
                        self.pce_report_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-request-rx"):
                        self.pce_request_rx = value
                        self.pce_request_rx.value_namespace = name_space
                        self.pce_request_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-request-tx"):
                        self.pce_request_tx = value
                        self.pce_request_tx.value_namespace = name_space
                        self.pce_request_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-update-rx"):
                        self.pce_update_rx = value
                        self.pce_update_rx.value_namespace = name_space
                        self.pce_update_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-update-tx"):
                        self.pce_update_tx = value
                        self.pce_update_tx.value_namespace = name_space
                        self.pce_update_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pcep-up-time"):
                        self.pcep_up_time = value
                        self.pcep_up_time.value_namespace = name_space
                        self.pcep_up_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-session-id"):
                        self.remote_session_id = value
                        self.remote_session_id.value_namespace = name_space
                        self.remote_session_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "speaker-id"):
                        self.speaker_id = value
                        self.speaker_id.value_namespace = name_space
                        self.speaker_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.peer_address.is_set or
                    self.peer_address_xr.is_set or
                    self.peer_protocol.is_set or
                    (self.detail_pcep_information is not None and self.detail_pcep_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.peer_address_xr.yfilter != YFilter.not_set or
                    self.peer_protocol.yfilter != YFilter.not_set or
                    (self.detail_pcep_information is not None and self.detail_pcep_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-detail-info" + "[peer-address='" + self.peer_address.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-peer/peer-detail-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.peer_address_xr.is_set or self.peer_address_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address_xr.get_name_leafdata())
                if (self.peer_protocol.is_set or self.peer_protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_protocol.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "detail-pcep-information"):
                    if (self.detail_pcep_information is None):
                        self.detail_pcep_information = PcePeer.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation()
                        self.detail_pcep_information.parent = self
                        self._children_name_map["detail_pcep_information"] = "detail-pcep-information"
                    return self.detail_pcep_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "detail-pcep-information" or name == "peer-address" or name == "peer-address-xr" or name == "peer-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-address-xr"):
                    self.peer_address_xr = value
                    self.peer_address_xr.value_namespace = name_space
                    self.peer_address_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-protocol"):
                    self.peer_protocol = value
                    self.peer_protocol.value_namespace = name_space
                    self.peer_protocol.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.peer_detail_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.peer_detail_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "peer-detail-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-peer/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "peer-detail-info"):
                for c in self.peer_detail_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = PcePeer.PeerDetailInfos.PeerDetailInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.peer_detail_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "peer-detail-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class PeerInfos(Entity):
        """
        Peers database in XTC
        
        .. attribute:: peer_info
        
        	PCE peer information
        	**type**\: list of    :py:class:`PeerInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerInfos.PeerInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PcePeer.PeerInfos, self).__init__()

            self.yang_name = "peer-infos"
            self.yang_parent_name = "pce-peer"

            self.peer_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PcePeer.PeerInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PcePeer.PeerInfos, self).__setattr__(name, value)


        class PeerInfo(Entity):
            """
            PCE peer information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: brief_pcep_information
            
            	PCE protocol information
            	**type**\:   :py:class:`BriefPcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcePeer.PeerInfos.PeerInfo.BriefPcepInformation>`
            
            .. attribute:: peer_address_xr
            
            	Peer address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: peer_protocol
            
            	Protocol between PCE and peer
            	**type**\:   :py:class:`PceProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceProto>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PcePeer.PeerInfos.PeerInfo, self).__init__()

                self.yang_name = "peer-info"
                self.yang_parent_name = "peer-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.peer_address_xr = YLeaf(YType.str, "peer-address-xr")

                self.peer_protocol = YLeaf(YType.enumeration, "peer-protocol")

                self.brief_pcep_information = PcePeer.PeerInfos.PeerInfo.BriefPcepInformation()
                self.brief_pcep_information.parent = self
                self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                self._children_yang_names.add("brief-pcep-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "peer_address_xr",
                                "peer_protocol") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PcePeer.PeerInfos.PeerInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PcePeer.PeerInfos.PeerInfo, self).__setattr__(name, value)


            class BriefPcepInformation(Entity):
                """
                PCE protocol information
                
                .. attribute:: capability_db_version
                
                	DB version capability
                	**type**\:  bool
                
                .. attribute:: capability_delta_sync
                
                	Delta Synchronization capability
                	**type**\:  bool
                
                .. attribute:: capability_instantiate
                
                	Instantiation capability
                	**type**\:  bool
                
                .. attribute:: capability_segment_routing
                
                	Segment Routing capability
                	**type**\:  bool
                
                .. attribute:: capability_triggered_sync
                
                	Triggered Synchronization capability
                	**type**\:  bool
                
                .. attribute:: capability_update
                
                	Update capability
                	**type**\:  bool
                
                .. attribute:: pcep_state
                
                	PCEP State
                	**type**\:   :py:class:`PcepState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepState>`
                
                .. attribute:: stateful
                
                	Stateful
                	**type**\:  bool
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PcePeer.PeerInfos.PeerInfo.BriefPcepInformation, self).__init__()

                    self.yang_name = "brief-pcep-information"
                    self.yang_parent_name = "peer-info"

                    self.capability_db_version = YLeaf(YType.boolean, "capability-db-version")

                    self.capability_delta_sync = YLeaf(YType.boolean, "capability-delta-sync")

                    self.capability_instantiate = YLeaf(YType.boolean, "capability-instantiate")

                    self.capability_segment_routing = YLeaf(YType.boolean, "capability-segment-routing")

                    self.capability_triggered_sync = YLeaf(YType.boolean, "capability-triggered-sync")

                    self.capability_update = YLeaf(YType.boolean, "capability-update")

                    self.pcep_state = YLeaf(YType.enumeration, "pcep-state")

                    self.stateful = YLeaf(YType.boolean, "stateful")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("capability_db_version",
                                    "capability_delta_sync",
                                    "capability_instantiate",
                                    "capability_segment_routing",
                                    "capability_triggered_sync",
                                    "capability_update",
                                    "pcep_state",
                                    "stateful") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PcePeer.PeerInfos.PeerInfo.BriefPcepInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PcePeer.PeerInfos.PeerInfo.BriefPcepInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.capability_db_version.is_set or
                        self.capability_delta_sync.is_set or
                        self.capability_instantiate.is_set or
                        self.capability_segment_routing.is_set or
                        self.capability_triggered_sync.is_set or
                        self.capability_update.is_set or
                        self.pcep_state.is_set or
                        self.stateful.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.capability_db_version.yfilter != YFilter.not_set or
                        self.capability_delta_sync.yfilter != YFilter.not_set or
                        self.capability_instantiate.yfilter != YFilter.not_set or
                        self.capability_segment_routing.yfilter != YFilter.not_set or
                        self.capability_triggered_sync.yfilter != YFilter.not_set or
                        self.capability_update.yfilter != YFilter.not_set or
                        self.pcep_state.yfilter != YFilter.not_set or
                        self.stateful.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "brief-pcep-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.capability_db_version.is_set or self.capability_db_version.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_db_version.get_name_leafdata())
                    if (self.capability_delta_sync.is_set or self.capability_delta_sync.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_delta_sync.get_name_leafdata())
                    if (self.capability_instantiate.is_set or self.capability_instantiate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_instantiate.get_name_leafdata())
                    if (self.capability_segment_routing.is_set or self.capability_segment_routing.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_segment_routing.get_name_leafdata())
                    if (self.capability_triggered_sync.is_set or self.capability_triggered_sync.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_triggered_sync.get_name_leafdata())
                    if (self.capability_update.is_set or self.capability_update.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_update.get_name_leafdata())
                    if (self.pcep_state.is_set or self.pcep_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pcep_state.get_name_leafdata())
                    if (self.stateful.is_set or self.stateful.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stateful.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "capability-db-version" or name == "capability-delta-sync" or name == "capability-instantiate" or name == "capability-segment-routing" or name == "capability-triggered-sync" or name == "capability-update" or name == "pcep-state" or name == "stateful"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "capability-db-version"):
                        self.capability_db_version = value
                        self.capability_db_version.value_namespace = name_space
                        self.capability_db_version.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-delta-sync"):
                        self.capability_delta_sync = value
                        self.capability_delta_sync.value_namespace = name_space
                        self.capability_delta_sync.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-instantiate"):
                        self.capability_instantiate = value
                        self.capability_instantiate.value_namespace = name_space
                        self.capability_instantiate.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-segment-routing"):
                        self.capability_segment_routing = value
                        self.capability_segment_routing.value_namespace = name_space
                        self.capability_segment_routing.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-triggered-sync"):
                        self.capability_triggered_sync = value
                        self.capability_triggered_sync.value_namespace = name_space
                        self.capability_triggered_sync.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-update"):
                        self.capability_update = value
                        self.capability_update.value_namespace = name_space
                        self.capability_update.value_namespace_prefix = name_space_prefix
                    if(value_path == "pcep-state"):
                        self.pcep_state = value
                        self.pcep_state.value_namespace = name_space
                        self.pcep_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "stateful"):
                        self.stateful = value
                        self.stateful.value_namespace = name_space
                        self.stateful.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.peer_address.is_set or
                    self.peer_address_xr.is_set or
                    self.peer_protocol.is_set or
                    (self.brief_pcep_information is not None and self.brief_pcep_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.peer_address_xr.yfilter != YFilter.not_set or
                    self.peer_protocol.yfilter != YFilter.not_set or
                    (self.brief_pcep_information is not None and self.brief_pcep_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-info" + "[peer-address='" + self.peer_address.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-peer/peer-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.peer_address_xr.is_set or self.peer_address_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address_xr.get_name_leafdata())
                if (self.peer_protocol.is_set or self.peer_protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_protocol.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "brief-pcep-information"):
                    if (self.brief_pcep_information is None):
                        self.brief_pcep_information = PcePeer.PeerInfos.PeerInfo.BriefPcepInformation()
                        self.brief_pcep_information.parent = self
                        self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                    return self.brief_pcep_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "brief-pcep-information" or name == "peer-address" or name == "peer-address-xr" or name == "peer-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-address-xr"):
                    self.peer_address_xr = value
                    self.peer_address_xr.value_namespace = name_space
                    self.peer_address_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-protocol"):
                    self.peer_protocol = value
                    self.peer_protocol.value_namespace = name_space
                    self.peer_protocol.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.peer_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.peer_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "peer-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-peer/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "peer-info"):
                for c in self.peer_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = PcePeer.PeerInfos.PeerInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.peer_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "peer-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.peer_detail_infos is not None and self.peer_detail_infos.has_data()) or
            (self.peer_infos is not None and self.peer_infos.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.peer_detail_infos is not None and self.peer_detail_infos.has_operation()) or
            (self.peer_infos is not None and self.peer_infos.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-peer" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "peer-detail-infos"):
            if (self.peer_detail_infos is None):
                self.peer_detail_infos = PcePeer.PeerDetailInfos()
                self.peer_detail_infos.parent = self
                self._children_name_map["peer_detail_infos"] = "peer-detail-infos"
            return self.peer_detail_infos

        if (child_yang_name == "peer-infos"):
            if (self.peer_infos is None):
                self.peer_infos = PcePeer.PeerInfos()
                self.peer_infos.parent = self
                self._children_name_map["peer_infos"] = "peer-infos"
            return self.peer_infos

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "peer-detail-infos" or name == "peer-infos"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = PcePeer()
        return self._top_entity

class PceTopology(Entity):
    """
    pce topology
    
    .. attribute:: prefix_infos
    
    	Prefixes database in XTC
    	**type**\:   :py:class:`PrefixInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos>`
    
    .. attribute:: topology_nodes
    
    	Node database in XTC
    	**type**\:   :py:class:`TopologyNodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes>`
    
    .. attribute:: topology_summary
    
    	Node summary database in XTC
    	**type**\:   :py:class:`TopologySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologySummary>`
    
    

    """

    _prefix = 'infra-xtc-oper'
    _revision = '2016-05-31'

    def __init__(self):
        super(PceTopology, self).__init__()
        self._top_entity = None

        self.yang_name = "pce-topology"
        self.yang_parent_name = "Cisco-IOS-XR-infra-xtc-oper"

        self.prefix_infos = PceTopology.PrefixInfos()
        self.prefix_infos.parent = self
        self._children_name_map["prefix_infos"] = "prefix-infos"
        self._children_yang_names.add("prefix-infos")

        self.topology_nodes = PceTopology.TopologyNodes()
        self.topology_nodes.parent = self
        self._children_name_map["topology_nodes"] = "topology-nodes"
        self._children_yang_names.add("topology-nodes")

        self.topology_summary = PceTopology.TopologySummary()
        self.topology_summary.parent = self
        self._children_name_map["topology_summary"] = "topology-summary"
        self._children_yang_names.add("topology-summary")


    class TopologySummary(Entity):
        """
        Node summary database in XTC
        
        .. attribute:: adjacency_sids
        
        	Number of total adjacency SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: epe_links
        
        	Number of EPE links
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: epesids
        
        	Number of total EPE SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: links
        
        	Number of links
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: lookup_nodes
        
        	Number of lookup nodes
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: nodes
        
        	Number of PCE nodes
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: prefix_sids
        
        	Number of total prefix SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: prefixes
        
        	Number of prefixes
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: protected_adjacency_sids
        
        	Number of protected adjacency SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: regular_prefix_sids
        
        	Number of reguar prefix SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: stats_topology_update
        
        	Statistics on topology update
        	**type**\:   :py:class:`StatsTopologyUpdate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologySummary.StatsTopologyUpdate>`
        
        .. attribute:: strict_prefix_sids
        
        	Number of strict prefix SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: topology_consistent
        
        	True if topology is consistent
        	**type**\:  bool
        
        .. attribute:: un_protected_adjacency_sids
        
        	Number of unprotected adjacency SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PceTopology.TopologySummary, self).__init__()

            self.yang_name = "topology-summary"
            self.yang_parent_name = "pce-topology"

            self.adjacency_sids = YLeaf(YType.uint32, "adjacency-sids")

            self.epe_links = YLeaf(YType.uint32, "epe-links")

            self.epesids = YLeaf(YType.uint32, "epesids")

            self.links = YLeaf(YType.uint32, "links")

            self.lookup_nodes = YLeaf(YType.uint32, "lookup-nodes")

            self.nodes = YLeaf(YType.uint32, "nodes")

            self.prefix_sids = YLeaf(YType.uint32, "prefix-sids")

            self.prefixes = YLeaf(YType.uint32, "prefixes")

            self.protected_adjacency_sids = YLeaf(YType.uint32, "protected-adjacency-sids")

            self.regular_prefix_sids = YLeaf(YType.uint32, "regular-prefix-sids")

            self.strict_prefix_sids = YLeaf(YType.uint32, "strict-prefix-sids")

            self.topology_consistent = YLeaf(YType.boolean, "topology-consistent")

            self.un_protected_adjacency_sids = YLeaf(YType.uint32, "un-protected-adjacency-sids")

            self.stats_topology_update = PceTopology.TopologySummary.StatsTopologyUpdate()
            self.stats_topology_update.parent = self
            self._children_name_map["stats_topology_update"] = "stats-topology-update"
            self._children_yang_names.add("stats-topology-update")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("adjacency_sids",
                            "epe_links",
                            "epesids",
                            "links",
                            "lookup_nodes",
                            "nodes",
                            "prefix_sids",
                            "prefixes",
                            "protected_adjacency_sids",
                            "regular_prefix_sids",
                            "strict_prefix_sids",
                            "topology_consistent",
                            "un_protected_adjacency_sids") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PceTopology.TopologySummary, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PceTopology.TopologySummary, self).__setattr__(name, value)


        class StatsTopologyUpdate(Entity):
            """
            Statistics on topology update
            
            .. attribute:: num_links_added
            
            	Number of links added
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_links_deleted
            
            	Number of links deleted
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_nodes_added
            
            	Number of nodes added
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_nodes_deleted
            
            	Number of nodes deleted
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_prefixes_added
            
            	Number of prefixes added
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_prefixes_deleted
            
            	Number of prefixes deleted
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PceTopology.TopologySummary.StatsTopologyUpdate, self).__init__()

                self.yang_name = "stats-topology-update"
                self.yang_parent_name = "topology-summary"

                self.num_links_added = YLeaf(YType.uint32, "num-links-added")

                self.num_links_deleted = YLeaf(YType.uint32, "num-links-deleted")

                self.num_nodes_added = YLeaf(YType.uint32, "num-nodes-added")

                self.num_nodes_deleted = YLeaf(YType.uint32, "num-nodes-deleted")

                self.num_prefixes_added = YLeaf(YType.uint32, "num-prefixes-added")

                self.num_prefixes_deleted = YLeaf(YType.uint32, "num-prefixes-deleted")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("num_links_added",
                                "num_links_deleted",
                                "num_nodes_added",
                                "num_nodes_deleted",
                                "num_prefixes_added",
                                "num_prefixes_deleted") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PceTopology.TopologySummary.StatsTopologyUpdate, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PceTopology.TopologySummary.StatsTopologyUpdate, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.num_links_added.is_set or
                    self.num_links_deleted.is_set or
                    self.num_nodes_added.is_set or
                    self.num_nodes_deleted.is_set or
                    self.num_prefixes_added.is_set or
                    self.num_prefixes_deleted.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.num_links_added.yfilter != YFilter.not_set or
                    self.num_links_deleted.yfilter != YFilter.not_set or
                    self.num_nodes_added.yfilter != YFilter.not_set or
                    self.num_nodes_deleted.yfilter != YFilter.not_set or
                    self.num_prefixes_added.yfilter != YFilter.not_set or
                    self.num_prefixes_deleted.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "stats-topology-update" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-topology/topology-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.num_links_added.is_set or self.num_links_added.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_links_added.get_name_leafdata())
                if (self.num_links_deleted.is_set or self.num_links_deleted.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_links_deleted.get_name_leafdata())
                if (self.num_nodes_added.is_set or self.num_nodes_added.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_nodes_added.get_name_leafdata())
                if (self.num_nodes_deleted.is_set or self.num_nodes_deleted.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_nodes_deleted.get_name_leafdata())
                if (self.num_prefixes_added.is_set or self.num_prefixes_added.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_prefixes_added.get_name_leafdata())
                if (self.num_prefixes_deleted.is_set or self.num_prefixes_deleted.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_prefixes_deleted.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "num-links-added" or name == "num-links-deleted" or name == "num-nodes-added" or name == "num-nodes-deleted" or name == "num-prefixes-added" or name == "num-prefixes-deleted"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "num-links-added"):
                    self.num_links_added = value
                    self.num_links_added.value_namespace = name_space
                    self.num_links_added.value_namespace_prefix = name_space_prefix
                if(value_path == "num-links-deleted"):
                    self.num_links_deleted = value
                    self.num_links_deleted.value_namespace = name_space
                    self.num_links_deleted.value_namespace_prefix = name_space_prefix
                if(value_path == "num-nodes-added"):
                    self.num_nodes_added = value
                    self.num_nodes_added.value_namespace = name_space
                    self.num_nodes_added.value_namespace_prefix = name_space_prefix
                if(value_path == "num-nodes-deleted"):
                    self.num_nodes_deleted = value
                    self.num_nodes_deleted.value_namespace = name_space
                    self.num_nodes_deleted.value_namespace_prefix = name_space_prefix
                if(value_path == "num-prefixes-added"):
                    self.num_prefixes_added = value
                    self.num_prefixes_added.value_namespace = name_space
                    self.num_prefixes_added.value_namespace_prefix = name_space_prefix
                if(value_path == "num-prefixes-deleted"):
                    self.num_prefixes_deleted = value
                    self.num_prefixes_deleted.value_namespace = name_space
                    self.num_prefixes_deleted.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                self.adjacency_sids.is_set or
                self.epe_links.is_set or
                self.epesids.is_set or
                self.links.is_set or
                self.lookup_nodes.is_set or
                self.nodes.is_set or
                self.prefix_sids.is_set or
                self.prefixes.is_set or
                self.protected_adjacency_sids.is_set or
                self.regular_prefix_sids.is_set or
                self.strict_prefix_sids.is_set or
                self.topology_consistent.is_set or
                self.un_protected_adjacency_sids.is_set or
                (self.stats_topology_update is not None and self.stats_topology_update.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.adjacency_sids.yfilter != YFilter.not_set or
                self.epe_links.yfilter != YFilter.not_set or
                self.epesids.yfilter != YFilter.not_set or
                self.links.yfilter != YFilter.not_set or
                self.lookup_nodes.yfilter != YFilter.not_set or
                self.nodes.yfilter != YFilter.not_set or
                self.prefix_sids.yfilter != YFilter.not_set or
                self.prefixes.yfilter != YFilter.not_set or
                self.protected_adjacency_sids.yfilter != YFilter.not_set or
                self.regular_prefix_sids.yfilter != YFilter.not_set or
                self.strict_prefix_sids.yfilter != YFilter.not_set or
                self.topology_consistent.yfilter != YFilter.not_set or
                self.un_protected_adjacency_sids.yfilter != YFilter.not_set or
                (self.stats_topology_update is not None and self.stats_topology_update.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "topology-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-topology/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.adjacency_sids.is_set or self.adjacency_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.adjacency_sids.get_name_leafdata())
            if (self.epe_links.is_set or self.epe_links.yfilter != YFilter.not_set):
                leaf_name_data.append(self.epe_links.get_name_leafdata())
            if (self.epesids.is_set or self.epesids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.epesids.get_name_leafdata())
            if (self.links.is_set or self.links.yfilter != YFilter.not_set):
                leaf_name_data.append(self.links.get_name_leafdata())
            if (self.lookup_nodes.is_set or self.lookup_nodes.yfilter != YFilter.not_set):
                leaf_name_data.append(self.lookup_nodes.get_name_leafdata())
            if (self.nodes.is_set or self.nodes.yfilter != YFilter.not_set):
                leaf_name_data.append(self.nodes.get_name_leafdata())
            if (self.prefix_sids.is_set or self.prefix_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.prefix_sids.get_name_leafdata())
            if (self.prefixes.is_set or self.prefixes.yfilter != YFilter.not_set):
                leaf_name_data.append(self.prefixes.get_name_leafdata())
            if (self.protected_adjacency_sids.is_set or self.protected_adjacency_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.protected_adjacency_sids.get_name_leafdata())
            if (self.regular_prefix_sids.is_set or self.regular_prefix_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.regular_prefix_sids.get_name_leafdata())
            if (self.strict_prefix_sids.is_set or self.strict_prefix_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.strict_prefix_sids.get_name_leafdata())
            if (self.topology_consistent.is_set or self.topology_consistent.yfilter != YFilter.not_set):
                leaf_name_data.append(self.topology_consistent.get_name_leafdata())
            if (self.un_protected_adjacency_sids.is_set or self.un_protected_adjacency_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.un_protected_adjacency_sids.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "stats-topology-update"):
                if (self.stats_topology_update is None):
                    self.stats_topology_update = PceTopology.TopologySummary.StatsTopologyUpdate()
                    self.stats_topology_update.parent = self
                    self._children_name_map["stats_topology_update"] = "stats-topology-update"
                return self.stats_topology_update

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "stats-topology-update" or name == "adjacency-sids" or name == "epe-links" or name == "epesids" or name == "links" or name == "lookup-nodes" or name == "nodes" or name == "prefix-sids" or name == "prefixes" or name == "protected-adjacency-sids" or name == "regular-prefix-sids" or name == "strict-prefix-sids" or name == "topology-consistent" or name == "un-protected-adjacency-sids"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "adjacency-sids"):
                self.adjacency_sids = value
                self.adjacency_sids.value_namespace = name_space
                self.adjacency_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "epe-links"):
                self.epe_links = value
                self.epe_links.value_namespace = name_space
                self.epe_links.value_namespace_prefix = name_space_prefix
            if(value_path == "epesids"):
                self.epesids = value
                self.epesids.value_namespace = name_space
                self.epesids.value_namespace_prefix = name_space_prefix
            if(value_path == "links"):
                self.links = value
                self.links.value_namespace = name_space
                self.links.value_namespace_prefix = name_space_prefix
            if(value_path == "lookup-nodes"):
                self.lookup_nodes = value
                self.lookup_nodes.value_namespace = name_space
                self.lookup_nodes.value_namespace_prefix = name_space_prefix
            if(value_path == "nodes"):
                self.nodes = value
                self.nodes.value_namespace = name_space
                self.nodes.value_namespace_prefix = name_space_prefix
            if(value_path == "prefix-sids"):
                self.prefix_sids = value
                self.prefix_sids.value_namespace = name_space
                self.prefix_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "prefixes"):
                self.prefixes = value
                self.prefixes.value_namespace = name_space
                self.prefixes.value_namespace_prefix = name_space_prefix
            if(value_path == "protected-adjacency-sids"):
                self.protected_adjacency_sids = value
                self.protected_adjacency_sids.value_namespace = name_space
                self.protected_adjacency_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "regular-prefix-sids"):
                self.regular_prefix_sids = value
                self.regular_prefix_sids.value_namespace = name_space
                self.regular_prefix_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "strict-prefix-sids"):
                self.strict_prefix_sids = value
                self.strict_prefix_sids.value_namespace = name_space
                self.strict_prefix_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "topology-consistent"):
                self.topology_consistent = value
                self.topology_consistent.value_namespace = name_space
                self.topology_consistent.value_namespace_prefix = name_space_prefix
            if(value_path == "un-protected-adjacency-sids"):
                self.un_protected_adjacency_sids = value
                self.un_protected_adjacency_sids.value_namespace = name_space
                self.un_protected_adjacency_sids.value_namespace_prefix = name_space_prefix


    class TopologyNodes(Entity):
        """
        Node database in XTC
        
        .. attribute:: topology_node
        
        	Node information
        	**type**\: list of    :py:class:`TopologyNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PceTopology.TopologyNodes, self).__init__()

            self.yang_name = "topology-nodes"
            self.yang_parent_name = "pce-topology"

            self.topology_node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PceTopology.TopologyNodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PceTopology.TopologyNodes, self).__setattr__(name, value)


        class TopologyNode(Entity):
            """
            Node information
            
            .. attribute:: node_identifier  <key>
            
            	Node Identifier
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: ipv4_link
            
            	IPv4 Link information
            	**type**\: list of    :py:class:`Ipv4Link <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link>`
            
            .. attribute:: ipv6_link
            
            	IPv6 Link information
            	**type**\: list of    :py:class:`Ipv6Link <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link>`
            
            .. attribute:: node_identifier_xr
            
            	Node identifier
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_protocol_identifier
            
            	Node protocol identifier
            	**type**\:   :py:class:`NodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier>`
            
            .. attribute:: overload
            
            	Node Overload Bit
            	**type**\:  bool
            
            .. attribute:: prefix_sid
            
            	Prefix SIDs
            	**type**\: list of    :py:class:`PrefixSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.PrefixSid>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PceTopology.TopologyNodes.TopologyNode, self).__init__()

                self.yang_name = "topology-node"
                self.yang_parent_name = "topology-nodes"

                self.node_identifier = YLeaf(YType.int32, "node-identifier")

                self.node_identifier_xr = YLeaf(YType.uint32, "node-identifier-xr")

                self.overload = YLeaf(YType.boolean, "overload")

                self.node_protocol_identifier = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier()
                self.node_protocol_identifier.parent = self
                self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                self._children_yang_names.add("node-protocol-identifier")

                self.ipv4_link = YList(self)
                self.ipv6_link = YList(self)
                self.prefix_sid = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_identifier",
                                "node_identifier_xr",
                                "overload") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PceTopology.TopologyNodes.TopologyNode, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PceTopology.TopologyNodes.TopologyNode, self).__setattr__(name, value)


            class NodeProtocolIdentifier(Entity):
                """
                Node protocol identifier
                
                .. attribute:: igp_information
                
                	IGP information
                	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation>`
                
                .. attribute:: ipv4bgp_router_id
                
                	IPv4 TE router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4bgp_router_id_set
                
                	True if IPv4 BGP router ID is set
                	**type**\:  bool
                
                .. attribute:: ipv4te_router_id
                
                	IPv4 BGP router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4te_router_id_set
                
                	True if IPv4 TE router ID is set
                	**type**\:  bool
                
                .. attribute:: node_name
                
                	Node Name
                	**type**\:  str
                
                .. attribute:: srgb_information
                
                	SRGB information
                	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation>`
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier, self).__init__()

                    self.yang_name = "node-protocol-identifier"
                    self.yang_parent_name = "topology-node"

                    self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                    self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                    self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                    self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                    self.node_name = YLeaf(YType.str, "node-name")

                    self.igp_information = YList(self)
                    self.srgb_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ipv4bgp_router_id",
                                    "ipv4bgp_router_id_set",
                                    "ipv4te_router_id",
                                    "ipv4te_router_id_set",
                                    "node_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier, self).__setattr__(name, value)


                class IgpInformation(Entity):
                    """
                    IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation, self).__init__()

                        self.yang_name = "igp-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class SrgbInformation(Entity):
                    """
                    SRGB information
                    
                    .. attribute:: igp_srgb
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                    
                    .. attribute:: size
                    
                    	SRGB size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: start
                    
                    	SRGB start
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation, self).__init__()

                        self.yang_name = "srgb-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.size = YLeaf(YType.uint32, "size")

                        self.start = YLeaf(YType.uint32, "start")

                        self.igp_srgb = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                        self.igp_srgb.parent = self
                        self._children_name_map["igp_srgb"] = "igp-srgb"
                        self._children_yang_names.add("igp-srgb")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("size",
                                        "start") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                    class IgpSrgb(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                            self.yang_name = "igp-srgb"
                            self.yang_parent_name = "srgb-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp-srgb"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp-srgb"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp-srgb"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-srgb" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.size.is_set or
                            self.start.is_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.size.yfilter != YFilter.not_set or
                            self.start.yfilter != YFilter.not_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "srgb-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.size.get_name_leafdata())
                        if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.start.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-srgb"):
                            if (self.igp_srgb is None):
                                self.igp_srgb = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                self.igp_srgb.parent = self
                                self._children_name_map["igp_srgb"] = "igp-srgb"
                            return self.igp_srgb

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-srgb" or name == "size" or name == "start"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "size"):
                            self.size = value
                            self.size.value_namespace = name_space
                            self.size.value_namespace_prefix = name_space_prefix
                        if(value_path == "start"):
                            self.start = value
                            self.start.value_namespace = name_space
                            self.start.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.igp_information:
                        if (c.has_data()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.ipv4bgp_router_id.is_set or
                        self.ipv4bgp_router_id_set.is_set or
                        self.ipv4te_router_id.is_set or
                        self.ipv4te_router_id_set.is_set or
                        self.node_name.is_set)

                def has_operation(self):
                    for c in self.igp_information:
                        if (c.has_operation()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                        self.ipv4te_router_id.yfilter != YFilter.not_set or
                        self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                        self.node_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "node-protocol-identifier" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                    if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                    if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                    if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "igp-information"):
                        for c in self.igp_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.igp_information.append(c)
                        return c

                    if (child_yang_name == "srgb-information"):
                        for c in self.srgb_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.srgb_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ipv4bgp-router-id"):
                        self.ipv4bgp_router_id = value
                        self.ipv4bgp_router_id.value_namespace = name_space
                        self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4bgp-router-id-set"):
                        self.ipv4bgp_router_id_set = value
                        self.ipv4bgp_router_id_set.value_namespace = name_space
                        self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id"):
                        self.ipv4te_router_id = value
                        self.ipv4te_router_id.value_namespace = name_space
                        self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id-set"):
                        self.ipv4te_router_id_set = value
                        self.ipv4te_router_id_set.value_namespace = name_space
                        self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-name"):
                        self.node_name = value
                        self.node_name.value_namespace = name_space
                        self.node_name.value_namespace_prefix = name_space_prefix


            class PrefixSid(Entity):
                """
                Prefix SIDs
                
                .. attribute:: domain_identifier
                
                	Domain identifier
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: eflag
                
                	E Flag
                	**type**\:  bool
                
                .. attribute:: lflag
                
                	L Flag
                	**type**\:  bool
                
                .. attribute:: mpls_label
                
                	MPLS Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nflag
                
                	N Flag
                	**type**\:  bool
                
                .. attribute:: pflag
                
                	P Flag
                	**type**\:  bool
                
                .. attribute:: rflag
                
                	R Flag
                	**type**\:  bool
                
                .. attribute:: sid_prefix
                
                	Prefix
                	**type**\:   :py:class:`SidPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.PrefixSid.SidPrefix>`
                
                .. attribute:: sid_type
                
                	SID Type
                	**type**\:   :py:class:`Sid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Sid>`
                
                .. attribute:: vflag
                
                	V Flag
                	**type**\:  bool
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceTopology.TopologyNodes.TopologyNode.PrefixSid, self).__init__()

                    self.yang_name = "prefix-sid"
                    self.yang_parent_name = "topology-node"

                    self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                    self.eflag = YLeaf(YType.boolean, "eflag")

                    self.lflag = YLeaf(YType.boolean, "lflag")

                    self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                    self.nflag = YLeaf(YType.boolean, "nflag")

                    self.pflag = YLeaf(YType.boolean, "pflag")

                    self.rflag = YLeaf(YType.boolean, "rflag")

                    self.sid_type = YLeaf(YType.enumeration, "sid-type")

                    self.vflag = YLeaf(YType.boolean, "vflag")

                    self.sid_prefix = PceTopology.TopologyNodes.TopologyNode.PrefixSid.SidPrefix()
                    self.sid_prefix.parent = self
                    self._children_name_map["sid_prefix"] = "sid-prefix"
                    self._children_yang_names.add("sid-prefix")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain_identifier",
                                    "eflag",
                                    "lflag",
                                    "mpls_label",
                                    "nflag",
                                    "pflag",
                                    "rflag",
                                    "sid_type",
                                    "vflag") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceTopology.TopologyNodes.TopologyNode.PrefixSid, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceTopology.TopologyNodes.TopologyNode.PrefixSid, self).__setattr__(name, value)


                class SidPrefix(Entity):
                    """
                    Prefix
                    
                    .. attribute:: af_name
                    
                    	AFName
                    	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.PrefixSid.SidPrefix, self).__init__()

                        self.yang_name = "sid-prefix"
                        self.yang_parent_name = "prefix-sid"

                        self.af_name = YLeaf(YType.enumeration, "af-name")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("af_name",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.PrefixSid.SidPrefix, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.PrefixSid.SidPrefix, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.af_name.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.af_name.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sid-prefix" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.af_name.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "af-name"):
                            self.af_name = value
                            self.af_name.value_namespace = name_space
                            self.af_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.domain_identifier.is_set or
                        self.eflag.is_set or
                        self.lflag.is_set or
                        self.mpls_label.is_set or
                        self.nflag.is_set or
                        self.pflag.is_set or
                        self.rflag.is_set or
                        self.sid_type.is_set or
                        self.vflag.is_set or
                        (self.sid_prefix is not None and self.sid_prefix.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain_identifier.yfilter != YFilter.not_set or
                        self.eflag.yfilter != YFilter.not_set or
                        self.lflag.yfilter != YFilter.not_set or
                        self.mpls_label.yfilter != YFilter.not_set or
                        self.nflag.yfilter != YFilter.not_set or
                        self.pflag.yfilter != YFilter.not_set or
                        self.rflag.yfilter != YFilter.not_set or
                        self.sid_type.yfilter != YFilter.not_set or
                        self.vflag.yfilter != YFilter.not_set or
                        (self.sid_prefix is not None and self.sid_prefix.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "prefix-sid" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain_identifier.get_name_leafdata())
                    if (self.eflag.is_set or self.eflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.eflag.get_name_leafdata())
                    if (self.lflag.is_set or self.lflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lflag.get_name_leafdata())
                    if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mpls_label.get_name_leafdata())
                    if (self.nflag.is_set or self.nflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nflag.get_name_leafdata())
                    if (self.pflag.is_set or self.pflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pflag.get_name_leafdata())
                    if (self.rflag.is_set or self.rflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rflag.get_name_leafdata())
                    if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sid_type.get_name_leafdata())
                    if (self.vflag.is_set or self.vflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vflag.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "sid-prefix"):
                        if (self.sid_prefix is None):
                            self.sid_prefix = PceTopology.TopologyNodes.TopologyNode.PrefixSid.SidPrefix()
                            self.sid_prefix.parent = self
                            self._children_name_map["sid_prefix"] = "sid-prefix"
                        return self.sid_prefix

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "sid-prefix" or name == "domain-identifier" or name == "eflag" or name == "lflag" or name == "mpls-label" or name == "nflag" or name == "pflag" or name == "rflag" or name == "sid-type" or name == "vflag"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain-identifier"):
                        self.domain_identifier = value
                        self.domain_identifier.value_namespace = name_space
                        self.domain_identifier.value_namespace_prefix = name_space_prefix
                    if(value_path == "eflag"):
                        self.eflag = value
                        self.eflag.value_namespace = name_space
                        self.eflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "lflag"):
                        self.lflag = value
                        self.lflag.value_namespace = name_space
                        self.lflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "mpls-label"):
                        self.mpls_label = value
                        self.mpls_label.value_namespace = name_space
                        self.mpls_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "nflag"):
                        self.nflag = value
                        self.nflag.value_namespace = name_space
                        self.nflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "pflag"):
                        self.pflag = value
                        self.pflag.value_namespace = name_space
                        self.pflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "rflag"):
                        self.rflag = value
                        self.rflag.value_namespace = name_space
                        self.rflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "sid-type"):
                        self.sid_type = value
                        self.sid_type.value_namespace = name_space
                        self.sid_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "vflag"):
                        self.vflag = value
                        self.vflag.value_namespace = name_space
                        self.vflag.value_namespace_prefix = name_space_prefix


            class Ipv4Link(Entity):
                """
                IPv4 Link information
                
                .. attribute:: adjacency_sid
                
                	Adjacency SIDs
                	**type**\: list of    :py:class:`AdjacencySid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid>`
                
                .. attribute:: igp_metric
                
                	IGP Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_igp_information
                
                	Local node IGP information
                	**type**\:   :py:class:`LocalIgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation>`
                
                .. attribute:: local_ipv4_address
                
                	Local IPv4 address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: max_reservable_bandwidth
                
                	Max Reservable bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: maximum_link_bandwidth
                
                	Max link bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: remote_ipv4_address
                
                	Remote IPv4 address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: remote_node_protocol_identifier
                
                	Remote node protocol identifier
                	**type**\:   :py:class:`RemoteNodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier>`
                
                .. attribute:: srlgs
                
                	SRLG Values
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_metric
                
                	TE Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link, self).__init__()

                    self.yang_name = "ipv4-link"
                    self.yang_parent_name = "topology-node"

                    self.igp_metric = YLeaf(YType.uint32, "igp-metric")

                    self.local_ipv4_address = YLeaf(YType.str, "local-ipv4-address")

                    self.max_reservable_bandwidth = YLeaf(YType.uint64, "max-reservable-bandwidth")

                    self.maximum_link_bandwidth = YLeaf(YType.uint64, "maximum-link-bandwidth")

                    self.remote_ipv4_address = YLeaf(YType.str, "remote-ipv4-address")

                    self.srlgs = YLeafList(YType.uint32, "srlgs")

                    self.te_metric = YLeaf(YType.uint32, "te-metric")

                    self.local_igp_information = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation()
                    self.local_igp_information.parent = self
                    self._children_name_map["local_igp_information"] = "local-igp-information"
                    self._children_yang_names.add("local-igp-information")

                    self.remote_node_protocol_identifier = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier()
                    self.remote_node_protocol_identifier.parent = self
                    self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                    self._children_yang_names.add("remote-node-protocol-identifier")

                    self.adjacency_sid = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("igp_metric",
                                    "local_ipv4_address",
                                    "max_reservable_bandwidth",
                                    "maximum_link_bandwidth",
                                    "remote_ipv4_address",
                                    "srlgs",
                                    "te_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link, self).__setattr__(name, value)


                class LocalIgpInformation(Entity):
                    """
                    Local node IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation, self).__init__()

                        self.yang_name = "local-igp-information"
                        self.yang_parent_name = "ipv4-link"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "local-igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "local-igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class RemoteNodeProtocolIdentifier(Entity):
                    """
                    Remote node protocol identifier
                    
                    .. attribute:: igp_information
                    
                    	IGP information
                    	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation>`
                    
                    .. attribute:: ipv4bgp_router_id
                    
                    	IPv4 TE router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4bgp_router_id_set
                    
                    	True if IPv4 BGP router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: ipv4te_router_id
                    
                    	IPv4 BGP router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4te_router_id_set
                    
                    	True if IPv4 TE router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: node_name
                    
                    	Node Name
                    	**type**\:  str
                    
                    .. attribute:: srgb_information
                    
                    	SRGB information
                    	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier, self).__init__()

                        self.yang_name = "remote-node-protocol-identifier"
                        self.yang_parent_name = "ipv4-link"

                        self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                        self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                        self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                        self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                        self.node_name = YLeaf(YType.str, "node-name")

                        self.igp_information = YList(self)
                        self.srgb_information = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ipv4bgp_router_id",
                                        "ipv4bgp_router_id_set",
                                        "ipv4te_router_id",
                                        "ipv4te_router_id_set",
                                        "node_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)


                    class IgpInformation(Entity):
                        """
                        IGP information
                        
                        .. attribute:: autonomous_system_number
                        
                        	Autonomous System Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: domain_identifier
                        
                        	Domain identifier
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: igp
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__init__()

                            self.yang_name = "igp-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                            self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                            self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                            self.igp.parent = self
                            self._children_name_map["igp"] = "igp"
                            self._children_yang_names.add("igp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("autonomous_system_number",
                                            "domain_identifier") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                        class Igp(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                                self.yang_name = "igp"
                                self.yang_parent_name = "igp-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.autonomous_system_number.is_set or
                                self.domain_identifier.is_set or
                                (self.igp is not None and self.igp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.autonomous_system_number.yfilter != YFilter.not_set or
                                self.domain_identifier.yfilter != YFilter.not_set or
                                (self.igp is not None and self.igp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                            if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp"):
                                if (self.igp is None):
                                    self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                                    self.igp.parent = self
                                    self._children_name_map["igp"] = "igp"
                                return self.igp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "autonomous-system-number"):
                                self.autonomous_system_number = value
                                self.autonomous_system_number.value_namespace = name_space
                                self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "domain-identifier"):
                                self.domain_identifier = value
                                self.domain_identifier.value_namespace = name_space
                                self.domain_identifier.value_namespace_prefix = name_space_prefix


                    class SrgbInformation(Entity):
                        """
                        SRGB information
                        
                        .. attribute:: igp_srgb
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                        
                        .. attribute:: size
                        
                        	SRGB size
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start
                        
                        	SRGB start
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__init__()

                            self.yang_name = "srgb-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.size = YLeaf(YType.uint32, "size")

                            self.start = YLeaf(YType.uint32, "start")

                            self.igp_srgb = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                            self.igp_srgb.parent = self
                            self._children_name_map["igp_srgb"] = "igp-srgb"
                            self._children_yang_names.add("igp-srgb")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("size",
                                            "start") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                        class IgpSrgb(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                                self.yang_name = "igp-srgb"
                                self.yang_parent_name = "srgb-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp-srgb"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp-srgb"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp-srgb"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp-srgb" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.size.is_set or
                                self.start.is_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.size.yfilter != YFilter.not_set or
                                self.start.yfilter != YFilter.not_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "srgb-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.size.get_name_leafdata())
                            if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp-srgb"):
                                if (self.igp_srgb is None):
                                    self.igp_srgb = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                    self.igp_srgb.parent = self
                                    self._children_name_map["igp_srgb"] = "igp-srgb"
                                return self.igp_srgb

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp-srgb" or name == "size" or name == "start"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "size"):
                                self.size = value
                                self.size.value_namespace = name_space
                                self.size.value_namespace_prefix = name_space_prefix
                            if(value_path == "start"):
                                self.start = value
                                self.start.value_namespace = name_space
                                self.start.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.igp_information:
                            if (c.has_data()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_data()):
                                return True
                        return (
                            self.ipv4bgp_router_id.is_set or
                            self.ipv4bgp_router_id_set.is_set or
                            self.ipv4te_router_id.is_set or
                            self.ipv4te_router_id_set.is_set or
                            self.node_name.is_set)

                    def has_operation(self):
                        for c in self.igp_information:
                            if (c.has_operation()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                            self.ipv4te_router_id.yfilter != YFilter.not_set or
                            self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                            self.node_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-node-protocol-identifier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                        if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                        if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                        if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.node_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-information"):
                            for c in self.igp_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.igp_information.append(c)
                            return c

                        if (child_yang_name == "srgb-information"):
                            for c in self.srgb_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.srgb_information.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ipv4bgp-router-id"):
                            self.ipv4bgp_router_id = value
                            self.ipv4bgp_router_id.value_namespace = name_space
                            self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4bgp-router-id-set"):
                            self.ipv4bgp_router_id_set = value
                            self.ipv4bgp_router_id_set.value_namespace = name_space
                            self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id"):
                            self.ipv4te_router_id = value
                            self.ipv4te_router_id.value_namespace = name_space
                            self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id-set"):
                            self.ipv4te_router_id_set = value
                            self.ipv4te_router_id_set.value_namespace = name_space
                            self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "node-name"):
                            self.node_name = value
                            self.node_name.value_namespace = name_space
                            self.node_name.value_namespace_prefix = name_space_prefix


                class AdjacencySid(Entity):
                    """
                    Adjacency SIDs
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: eflag
                    
                    	E Flag
                    	**type**\:  bool
                    
                    .. attribute:: lflag
                    
                    	L Flag
                    	**type**\:  bool
                    
                    .. attribute:: mpls_label
                    
                    	MPLS Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: nflag
                    
                    	N Flag
                    	**type**\:  bool
                    
                    .. attribute:: pflag
                    
                    	P Flag
                    	**type**\:  bool
                    
                    .. attribute:: rflag
                    
                    	R Flag
                    	**type**\:  bool
                    
                    .. attribute:: sid_prefix
                    
                    	Prefix
                    	**type**\:   :py:class:`SidPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix>`
                    
                    .. attribute:: sid_type
                    
                    	SID Type
                    	**type**\:   :py:class:`Sid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Sid>`
                    
                    .. attribute:: vflag
                    
                    	V Flag
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid, self).__init__()

                        self.yang_name = "adjacency-sid"
                        self.yang_parent_name = "ipv4-link"

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.eflag = YLeaf(YType.boolean, "eflag")

                        self.lflag = YLeaf(YType.boolean, "lflag")

                        self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                        self.nflag = YLeaf(YType.boolean, "nflag")

                        self.pflag = YLeaf(YType.boolean, "pflag")

                        self.rflag = YLeaf(YType.boolean, "rflag")

                        self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        self.vflag = YLeaf(YType.boolean, "vflag")

                        self.sid_prefix = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix()
                        self.sid_prefix.parent = self
                        self._children_name_map["sid_prefix"] = "sid-prefix"
                        self._children_yang_names.add("sid-prefix")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("domain_identifier",
                                        "eflag",
                                        "lflag",
                                        "mpls_label",
                                        "nflag",
                                        "pflag",
                                        "rflag",
                                        "sid_type",
                                        "vflag") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid, self).__setattr__(name, value)


                    class SidPrefix(Entity):
                        """
                        Prefix
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix, self).__init__()

                            self.yang_name = "sid-prefix"
                            self.yang_parent_name = "adjacency-sid"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sid-prefix" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.domain_identifier.is_set or
                            self.eflag.is_set or
                            self.lflag.is_set or
                            self.mpls_label.is_set or
                            self.nflag.is_set or
                            self.pflag.is_set or
                            self.rflag.is_set or
                            self.sid_type.is_set or
                            self.vflag.is_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            self.eflag.yfilter != YFilter.not_set or
                            self.lflag.yfilter != YFilter.not_set or
                            self.mpls_label.yfilter != YFilter.not_set or
                            self.nflag.yfilter != YFilter.not_set or
                            self.pflag.yfilter != YFilter.not_set or
                            self.rflag.yfilter != YFilter.not_set or
                            self.sid_type.yfilter != YFilter.not_set or
                            self.vflag.yfilter != YFilter.not_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "adjacency-sid" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())
                        if (self.eflag.is_set or self.eflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eflag.get_name_leafdata())
                        if (self.lflag.is_set or self.lflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lflag.get_name_leafdata())
                        if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_label.get_name_leafdata())
                        if (self.nflag.is_set or self.nflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nflag.get_name_leafdata())
                        if (self.pflag.is_set or self.pflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pflag.get_name_leafdata())
                        if (self.rflag.is_set or self.rflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rflag.get_name_leafdata())
                        if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sid_type.get_name_leafdata())
                        if (self.vflag.is_set or self.vflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vflag.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sid-prefix"):
                            if (self.sid_prefix is None):
                                self.sid_prefix = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix()
                                self.sid_prefix.parent = self
                                self._children_name_map["sid_prefix"] = "sid-prefix"
                            return self.sid_prefix

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sid-prefix" or name == "domain-identifier" or name == "eflag" or name == "lflag" or name == "mpls-label" or name == "nflag" or name == "pflag" or name == "rflag" or name == "sid-type" or name == "vflag"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix
                        if(value_path == "eflag"):
                            self.eflag = value
                            self.eflag.value_namespace = name_space
                            self.eflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "lflag"):
                            self.lflag = value
                            self.lflag.value_namespace = name_space
                            self.lflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "mpls-label"):
                            self.mpls_label = value
                            self.mpls_label.value_namespace = name_space
                            self.mpls_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "nflag"):
                            self.nflag = value
                            self.nflag.value_namespace = name_space
                            self.nflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "pflag"):
                            self.pflag = value
                            self.pflag.value_namespace = name_space
                            self.pflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "rflag"):
                            self.rflag = value
                            self.rflag.value_namespace = name_space
                            self.rflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "sid-type"):
                            self.sid_type = value
                            self.sid_type.value_namespace = name_space
                            self.sid_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vflag"):
                            self.vflag = value
                            self.vflag.value_namespace = name_space
                            self.vflag.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.adjacency_sid:
                        if (c.has_data()):
                            return True
                    for leaf in self.srlgs.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.igp_metric.is_set or
                        self.local_ipv4_address.is_set or
                        self.max_reservable_bandwidth.is_set or
                        self.maximum_link_bandwidth.is_set or
                        self.remote_ipv4_address.is_set or
                        self.te_metric.is_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_data()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_data()))

                def has_operation(self):
                    for c in self.adjacency_sid:
                        if (c.has_operation()):
                            return True
                    for leaf in self.srlgs.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.igp_metric.yfilter != YFilter.not_set or
                        self.local_ipv4_address.yfilter != YFilter.not_set or
                        self.max_reservable_bandwidth.yfilter != YFilter.not_set or
                        self.maximum_link_bandwidth.yfilter != YFilter.not_set or
                        self.remote_ipv4_address.yfilter != YFilter.not_set or
                        self.srlgs.yfilter != YFilter.not_set or
                        self.te_metric.yfilter != YFilter.not_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_operation()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv4-link" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.igp_metric.is_set or self.igp_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_metric.get_name_leafdata())
                    if (self.local_ipv4_address.is_set or self.local_ipv4_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_ipv4_address.get_name_leafdata())
                    if (self.max_reservable_bandwidth.is_set or self.max_reservable_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.max_reservable_bandwidth.get_name_leafdata())
                    if (self.maximum_link_bandwidth.is_set or self.maximum_link_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maximum_link_bandwidth.get_name_leafdata())
                    if (self.remote_ipv4_address.is_set or self.remote_ipv4_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_ipv4_address.get_name_leafdata())
                    if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_metric.get_name_leafdata())

                    leaf_name_data.extend(self.srlgs.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "adjacency-sid"):
                        for c in self.adjacency_sid:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.adjacency_sid.append(c)
                        return c

                    if (child_yang_name == "local-igp-information"):
                        if (self.local_igp_information is None):
                            self.local_igp_information = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation()
                            self.local_igp_information.parent = self
                            self._children_name_map["local_igp_information"] = "local-igp-information"
                        return self.local_igp_information

                    if (child_yang_name == "remote-node-protocol-identifier"):
                        if (self.remote_node_protocol_identifier is None):
                            self.remote_node_protocol_identifier = PceTopology.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier()
                            self.remote_node_protocol_identifier.parent = self
                            self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                        return self.remote_node_protocol_identifier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjacency-sid" or name == "local-igp-information" or name == "remote-node-protocol-identifier" or name == "igp-metric" or name == "local-ipv4-address" or name == "max-reservable-bandwidth" or name == "maximum-link-bandwidth" or name == "remote-ipv4-address" or name == "srlgs" or name == "te-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "igp-metric"):
                        self.igp_metric = value
                        self.igp_metric.value_namespace = name_space
                        self.igp_metric.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-ipv4-address"):
                        self.local_ipv4_address = value
                        self.local_ipv4_address.value_namespace = name_space
                        self.local_ipv4_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "max-reservable-bandwidth"):
                        self.max_reservable_bandwidth = value
                        self.max_reservable_bandwidth.value_namespace = name_space
                        self.max_reservable_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "maximum-link-bandwidth"):
                        self.maximum_link_bandwidth = value
                        self.maximum_link_bandwidth.value_namespace = name_space
                        self.maximum_link_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-ipv4-address"):
                        self.remote_ipv4_address = value
                        self.remote_ipv4_address.value_namespace = name_space
                        self.remote_ipv4_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "srlgs"):
                        self.srlgs.append(value)
                    if(value_path == "te-metric"):
                        self.te_metric = value
                        self.te_metric.value_namespace = name_space
                        self.te_metric.value_namespace_prefix = name_space_prefix


            class Ipv6Link(Entity):
                """
                IPv6 Link information
                
                .. attribute:: adjacency_sid
                
                	Adjacency SIDs
                	**type**\: list of    :py:class:`AdjacencySid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid>`
                
                .. attribute:: igp_metric
                
                	IGP Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_igp_information
                
                	Local node IGP information
                	**type**\:   :py:class:`LocalIgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation>`
                
                .. attribute:: local_ipv6_address
                
                	Local IPv6 address
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: max_reservable_bandwidth
                
                	Max Reservable bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: maximum_link_bandwidth
                
                	Max link bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: remote_ipv6_address
                
                	Remote IPv6 address
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: remote_node_protocol_identifier
                
                	Remote node protocol identifier
                	**type**\:   :py:class:`RemoteNodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier>`
                
                .. attribute:: te_metric
                
                	TE Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link, self).__init__()

                    self.yang_name = "ipv6-link"
                    self.yang_parent_name = "topology-node"

                    self.igp_metric = YLeaf(YType.uint32, "igp-metric")

                    self.local_ipv6_address = YLeaf(YType.str, "local-ipv6-address")

                    self.max_reservable_bandwidth = YLeaf(YType.uint64, "max-reservable-bandwidth")

                    self.maximum_link_bandwidth = YLeaf(YType.uint64, "maximum-link-bandwidth")

                    self.remote_ipv6_address = YLeaf(YType.str, "remote-ipv6-address")

                    self.te_metric = YLeaf(YType.uint32, "te-metric")

                    self.local_igp_information = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation()
                    self.local_igp_information.parent = self
                    self._children_name_map["local_igp_information"] = "local-igp-information"
                    self._children_yang_names.add("local-igp-information")

                    self.remote_node_protocol_identifier = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier()
                    self.remote_node_protocol_identifier.parent = self
                    self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                    self._children_yang_names.add("remote-node-protocol-identifier")

                    self.adjacency_sid = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("igp_metric",
                                    "local_ipv6_address",
                                    "max_reservable_bandwidth",
                                    "maximum_link_bandwidth",
                                    "remote_ipv6_address",
                                    "te_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link, self).__setattr__(name, value)


                class LocalIgpInformation(Entity):
                    """
                    Local node IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation, self).__init__()

                        self.yang_name = "local-igp-information"
                        self.yang_parent_name = "ipv6-link"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "local-igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "local-igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class RemoteNodeProtocolIdentifier(Entity):
                    """
                    Remote node protocol identifier
                    
                    .. attribute:: igp_information
                    
                    	IGP information
                    	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation>`
                    
                    .. attribute:: ipv4bgp_router_id
                    
                    	IPv4 TE router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4bgp_router_id_set
                    
                    	True if IPv4 BGP router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: ipv4te_router_id
                    
                    	IPv4 BGP router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4te_router_id_set
                    
                    	True if IPv4 TE router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: node_name
                    
                    	Node Name
                    	**type**\:  str
                    
                    .. attribute:: srgb_information
                    
                    	SRGB information
                    	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier, self).__init__()

                        self.yang_name = "remote-node-protocol-identifier"
                        self.yang_parent_name = "ipv6-link"

                        self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                        self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                        self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                        self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                        self.node_name = YLeaf(YType.str, "node-name")

                        self.igp_information = YList(self)
                        self.srgb_information = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ipv4bgp_router_id",
                                        "ipv4bgp_router_id_set",
                                        "ipv4te_router_id",
                                        "ipv4te_router_id_set",
                                        "node_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)


                    class IgpInformation(Entity):
                        """
                        IGP information
                        
                        .. attribute:: autonomous_system_number
                        
                        	Autonomous System Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: domain_identifier
                        
                        	Domain identifier
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: igp
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__init__()

                            self.yang_name = "igp-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                            self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                            self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                            self.igp.parent = self
                            self._children_name_map["igp"] = "igp"
                            self._children_yang_names.add("igp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("autonomous_system_number",
                                            "domain_identifier") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                        class Igp(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                                self.yang_name = "igp"
                                self.yang_parent_name = "igp-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.autonomous_system_number.is_set or
                                self.domain_identifier.is_set or
                                (self.igp is not None and self.igp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.autonomous_system_number.yfilter != YFilter.not_set or
                                self.domain_identifier.yfilter != YFilter.not_set or
                                (self.igp is not None and self.igp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                            if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp"):
                                if (self.igp is None):
                                    self.igp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                                    self.igp.parent = self
                                    self._children_name_map["igp"] = "igp"
                                return self.igp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "autonomous-system-number"):
                                self.autonomous_system_number = value
                                self.autonomous_system_number.value_namespace = name_space
                                self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "domain-identifier"):
                                self.domain_identifier = value
                                self.domain_identifier.value_namespace = name_space
                                self.domain_identifier.value_namespace_prefix = name_space_prefix


                    class SrgbInformation(Entity):
                        """
                        SRGB information
                        
                        .. attribute:: igp_srgb
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                        
                        .. attribute:: size
                        
                        	SRGB size
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start
                        
                        	SRGB start
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__init__()

                            self.yang_name = "srgb-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.size = YLeaf(YType.uint32, "size")

                            self.start = YLeaf(YType.uint32, "start")

                            self.igp_srgb = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                            self.igp_srgb.parent = self
                            self._children_name_map["igp_srgb"] = "igp-srgb"
                            self._children_yang_names.add("igp-srgb")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("size",
                                            "start") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                        class IgpSrgb(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                                self.yang_name = "igp-srgb"
                                self.yang_parent_name = "srgb-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp-srgb"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp-srgb"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp-srgb"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp-srgb" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.size.is_set or
                                self.start.is_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.size.yfilter != YFilter.not_set or
                                self.start.yfilter != YFilter.not_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "srgb-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.size.get_name_leafdata())
                            if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp-srgb"):
                                if (self.igp_srgb is None):
                                    self.igp_srgb = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                    self.igp_srgb.parent = self
                                    self._children_name_map["igp_srgb"] = "igp-srgb"
                                return self.igp_srgb

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp-srgb" or name == "size" or name == "start"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "size"):
                                self.size = value
                                self.size.value_namespace = name_space
                                self.size.value_namespace_prefix = name_space_prefix
                            if(value_path == "start"):
                                self.start = value
                                self.start.value_namespace = name_space
                                self.start.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.igp_information:
                            if (c.has_data()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_data()):
                                return True
                        return (
                            self.ipv4bgp_router_id.is_set or
                            self.ipv4bgp_router_id_set.is_set or
                            self.ipv4te_router_id.is_set or
                            self.ipv4te_router_id_set.is_set or
                            self.node_name.is_set)

                    def has_operation(self):
                        for c in self.igp_information:
                            if (c.has_operation()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                            self.ipv4te_router_id.yfilter != YFilter.not_set or
                            self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                            self.node_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-node-protocol-identifier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                        if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                        if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                        if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.node_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-information"):
                            for c in self.igp_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.igp_information.append(c)
                            return c

                        if (child_yang_name == "srgb-information"):
                            for c in self.srgb_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.srgb_information.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ipv4bgp-router-id"):
                            self.ipv4bgp_router_id = value
                            self.ipv4bgp_router_id.value_namespace = name_space
                            self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4bgp-router-id-set"):
                            self.ipv4bgp_router_id_set = value
                            self.ipv4bgp_router_id_set.value_namespace = name_space
                            self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id"):
                            self.ipv4te_router_id = value
                            self.ipv4te_router_id.value_namespace = name_space
                            self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id-set"):
                            self.ipv4te_router_id_set = value
                            self.ipv4te_router_id_set.value_namespace = name_space
                            self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "node-name"):
                            self.node_name = value
                            self.node_name.value_namespace = name_space
                            self.node_name.value_namespace_prefix = name_space_prefix


                class AdjacencySid(Entity):
                    """
                    Adjacency SIDs
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: eflag
                    
                    	E Flag
                    	**type**\:  bool
                    
                    .. attribute:: lflag
                    
                    	L Flag
                    	**type**\:  bool
                    
                    .. attribute:: mpls_label
                    
                    	MPLS Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: nflag
                    
                    	N Flag
                    	**type**\:  bool
                    
                    .. attribute:: pflag
                    
                    	P Flag
                    	**type**\:  bool
                    
                    .. attribute:: rflag
                    
                    	R Flag
                    	**type**\:  bool
                    
                    .. attribute:: sid_prefix
                    
                    	Prefix
                    	**type**\:   :py:class:`SidPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix>`
                    
                    .. attribute:: sid_type
                    
                    	SID Type
                    	**type**\:   :py:class:`Sid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Sid>`
                    
                    .. attribute:: vflag
                    
                    	V Flag
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid, self).__init__()

                        self.yang_name = "adjacency-sid"
                        self.yang_parent_name = "ipv6-link"

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.eflag = YLeaf(YType.boolean, "eflag")

                        self.lflag = YLeaf(YType.boolean, "lflag")

                        self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                        self.nflag = YLeaf(YType.boolean, "nflag")

                        self.pflag = YLeaf(YType.boolean, "pflag")

                        self.rflag = YLeaf(YType.boolean, "rflag")

                        self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        self.vflag = YLeaf(YType.boolean, "vflag")

                        self.sid_prefix = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix()
                        self.sid_prefix.parent = self
                        self._children_name_map["sid_prefix"] = "sid-prefix"
                        self._children_yang_names.add("sid-prefix")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("domain_identifier",
                                        "eflag",
                                        "lflag",
                                        "mpls_label",
                                        "nflag",
                                        "pflag",
                                        "rflag",
                                        "sid_type",
                                        "vflag") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid, self).__setattr__(name, value)


                    class SidPrefix(Entity):
                        """
                        Prefix
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix, self).__init__()

                            self.yang_name = "sid-prefix"
                            self.yang_parent_name = "adjacency-sid"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sid-prefix" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.domain_identifier.is_set or
                            self.eflag.is_set or
                            self.lflag.is_set or
                            self.mpls_label.is_set or
                            self.nflag.is_set or
                            self.pflag.is_set or
                            self.rflag.is_set or
                            self.sid_type.is_set or
                            self.vflag.is_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            self.eflag.yfilter != YFilter.not_set or
                            self.lflag.yfilter != YFilter.not_set or
                            self.mpls_label.yfilter != YFilter.not_set or
                            self.nflag.yfilter != YFilter.not_set or
                            self.pflag.yfilter != YFilter.not_set or
                            self.rflag.yfilter != YFilter.not_set or
                            self.sid_type.yfilter != YFilter.not_set or
                            self.vflag.yfilter != YFilter.not_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "adjacency-sid" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())
                        if (self.eflag.is_set or self.eflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eflag.get_name_leafdata())
                        if (self.lflag.is_set or self.lflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lflag.get_name_leafdata())
                        if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_label.get_name_leafdata())
                        if (self.nflag.is_set or self.nflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nflag.get_name_leafdata())
                        if (self.pflag.is_set or self.pflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pflag.get_name_leafdata())
                        if (self.rflag.is_set or self.rflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rflag.get_name_leafdata())
                        if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sid_type.get_name_leafdata())
                        if (self.vflag.is_set or self.vflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vflag.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sid-prefix"):
                            if (self.sid_prefix is None):
                                self.sid_prefix = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix()
                                self.sid_prefix.parent = self
                                self._children_name_map["sid_prefix"] = "sid-prefix"
                            return self.sid_prefix

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sid-prefix" or name == "domain-identifier" or name == "eflag" or name == "lflag" or name == "mpls-label" or name == "nflag" or name == "pflag" or name == "rflag" or name == "sid-type" or name == "vflag"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix
                        if(value_path == "eflag"):
                            self.eflag = value
                            self.eflag.value_namespace = name_space
                            self.eflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "lflag"):
                            self.lflag = value
                            self.lflag.value_namespace = name_space
                            self.lflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "mpls-label"):
                            self.mpls_label = value
                            self.mpls_label.value_namespace = name_space
                            self.mpls_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "nflag"):
                            self.nflag = value
                            self.nflag.value_namespace = name_space
                            self.nflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "pflag"):
                            self.pflag = value
                            self.pflag.value_namespace = name_space
                            self.pflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "rflag"):
                            self.rflag = value
                            self.rflag.value_namespace = name_space
                            self.rflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "sid-type"):
                            self.sid_type = value
                            self.sid_type.value_namespace = name_space
                            self.sid_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vflag"):
                            self.vflag = value
                            self.vflag.value_namespace = name_space
                            self.vflag.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.adjacency_sid:
                        if (c.has_data()):
                            return True
                    return (
                        self.igp_metric.is_set or
                        self.local_ipv6_address.is_set or
                        self.max_reservable_bandwidth.is_set or
                        self.maximum_link_bandwidth.is_set or
                        self.remote_ipv6_address.is_set or
                        self.te_metric.is_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_data()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_data()))

                def has_operation(self):
                    for c in self.adjacency_sid:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.igp_metric.yfilter != YFilter.not_set or
                        self.local_ipv6_address.yfilter != YFilter.not_set or
                        self.max_reservable_bandwidth.yfilter != YFilter.not_set or
                        self.maximum_link_bandwidth.yfilter != YFilter.not_set or
                        self.remote_ipv6_address.yfilter != YFilter.not_set or
                        self.te_metric.yfilter != YFilter.not_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_operation()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv6-link" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.igp_metric.is_set or self.igp_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_metric.get_name_leafdata())
                    if (self.local_ipv6_address.is_set or self.local_ipv6_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_ipv6_address.get_name_leafdata())
                    if (self.max_reservable_bandwidth.is_set or self.max_reservable_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.max_reservable_bandwidth.get_name_leafdata())
                    if (self.maximum_link_bandwidth.is_set or self.maximum_link_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maximum_link_bandwidth.get_name_leafdata())
                    if (self.remote_ipv6_address.is_set or self.remote_ipv6_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_ipv6_address.get_name_leafdata())
                    if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_metric.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "adjacency-sid"):
                        for c in self.adjacency_sid:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.adjacency_sid.append(c)
                        return c

                    if (child_yang_name == "local-igp-information"):
                        if (self.local_igp_information is None):
                            self.local_igp_information = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation()
                            self.local_igp_information.parent = self
                            self._children_name_map["local_igp_information"] = "local-igp-information"
                        return self.local_igp_information

                    if (child_yang_name == "remote-node-protocol-identifier"):
                        if (self.remote_node_protocol_identifier is None):
                            self.remote_node_protocol_identifier = PceTopology.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier()
                            self.remote_node_protocol_identifier.parent = self
                            self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                        return self.remote_node_protocol_identifier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjacency-sid" or name == "local-igp-information" or name == "remote-node-protocol-identifier" or name == "igp-metric" or name == "local-ipv6-address" or name == "max-reservable-bandwidth" or name == "maximum-link-bandwidth" or name == "remote-ipv6-address" or name == "te-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "igp-metric"):
                        self.igp_metric = value
                        self.igp_metric.value_namespace = name_space
                        self.igp_metric.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-ipv6-address"):
                        self.local_ipv6_address = value
                        self.local_ipv6_address.value_namespace = name_space
                        self.local_ipv6_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "max-reservable-bandwidth"):
                        self.max_reservable_bandwidth = value
                        self.max_reservable_bandwidth.value_namespace = name_space
                        self.max_reservable_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "maximum-link-bandwidth"):
                        self.maximum_link_bandwidth = value
                        self.maximum_link_bandwidth.value_namespace = name_space
                        self.maximum_link_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-ipv6-address"):
                        self.remote_ipv6_address = value
                        self.remote_ipv6_address.value_namespace = name_space
                        self.remote_ipv6_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-metric"):
                        self.te_metric = value
                        self.te_metric.value_namespace = name_space
                        self.te_metric.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv4_link:
                    if (c.has_data()):
                        return True
                for c in self.ipv6_link:
                    if (c.has_data()):
                        return True
                for c in self.prefix_sid:
                    if (c.has_data()):
                        return True
                return (
                    self.node_identifier.is_set or
                    self.node_identifier_xr.is_set or
                    self.overload.is_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_data()))

            def has_operation(self):
                for c in self.ipv4_link:
                    if (c.has_operation()):
                        return True
                for c in self.ipv6_link:
                    if (c.has_operation()):
                        return True
                for c in self.prefix_sid:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_identifier.yfilter != YFilter.not_set or
                    self.node_identifier_xr.yfilter != YFilter.not_set or
                    self.overload.yfilter != YFilter.not_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "topology-node" + "[node-identifier='" + self.node_identifier.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-topology/topology-nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_identifier.is_set or self.node_identifier.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier.get_name_leafdata())
                if (self.node_identifier_xr.is_set or self.node_identifier_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier_xr.get_name_leafdata())
                if (self.overload.is_set or self.overload.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.overload.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv4-link"):
                    for c in self.ipv4_link:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = PceTopology.TopologyNodes.TopologyNode.Ipv4Link()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv4_link.append(c)
                    return c

                if (child_yang_name == "ipv6-link"):
                    for c in self.ipv6_link:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = PceTopology.TopologyNodes.TopologyNode.Ipv6Link()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv6_link.append(c)
                    return c

                if (child_yang_name == "node-protocol-identifier"):
                    if (self.node_protocol_identifier is None):
                        self.node_protocol_identifier = PceTopology.TopologyNodes.TopologyNode.NodeProtocolIdentifier()
                        self.node_protocol_identifier.parent = self
                        self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                    return self.node_protocol_identifier

                if (child_yang_name == "prefix-sid"):
                    for c in self.prefix_sid:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = PceTopology.TopologyNodes.TopologyNode.PrefixSid()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.prefix_sid.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv4-link" or name == "ipv6-link" or name == "node-protocol-identifier" or name == "prefix-sid" or name == "node-identifier" or name == "node-identifier-xr" or name == "overload"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-identifier"):
                    self.node_identifier = value
                    self.node_identifier.value_namespace = name_space
                    self.node_identifier.value_namespace_prefix = name_space_prefix
                if(value_path == "node-identifier-xr"):
                    self.node_identifier_xr = value
                    self.node_identifier_xr.value_namespace = name_space
                    self.node_identifier_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "overload"):
                    self.overload = value
                    self.overload.value_namespace = name_space
                    self.overload.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.topology_node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.topology_node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "topology-nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-topology/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "topology-node"):
                for c in self.topology_node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = PceTopology.TopologyNodes.TopologyNode()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.topology_node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "topology-node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class PrefixInfos(Entity):
        """
        Prefixes database in XTC
        
        .. attribute:: prefix_info
        
        	PCE prefix information
        	**type**\: list of    :py:class:`PrefixInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(PceTopology.PrefixInfos, self).__init__()

            self.yang_name = "prefix-infos"
            self.yang_parent_name = "pce-topology"

            self.prefix_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(PceTopology.PrefixInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(PceTopology.PrefixInfos, self).__setattr__(name, value)


        class PrefixInfo(Entity):
            """
            PCE prefix information
            
            .. attribute:: node_identifier  <key>
            
            	Node ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: address
            
            	Prefix address
            	**type**\: list of    :py:class:`Address <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.Address>`
            
            .. attribute:: node_identifier_xr
            
            	Node identifier
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_protocol_identifier
            
            	Node protocol identifier
            	**type**\:   :py:class:`NodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(PceTopology.PrefixInfos.PrefixInfo, self).__init__()

                self.yang_name = "prefix-info"
                self.yang_parent_name = "prefix-infos"

                self.node_identifier = YLeaf(YType.int32, "node-identifier")

                self.node_identifier_xr = YLeaf(YType.uint32, "node-identifier-xr")

                self.node_protocol_identifier = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier()
                self.node_protocol_identifier.parent = self
                self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                self._children_yang_names.add("node-protocol-identifier")

                self.address = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_identifier",
                                "node_identifier_xr") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(PceTopology.PrefixInfos.PrefixInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(PceTopology.PrefixInfos.PrefixInfo, self).__setattr__(name, value)


            class NodeProtocolIdentifier(Entity):
                """
                Node protocol identifier
                
                .. attribute:: igp_information
                
                	IGP information
                	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation>`
                
                .. attribute:: ipv4bgp_router_id
                
                	IPv4 TE router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4bgp_router_id_set
                
                	True if IPv4 BGP router ID is set
                	**type**\:  bool
                
                .. attribute:: ipv4te_router_id
                
                	IPv4 BGP router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4te_router_id_set
                
                	True if IPv4 TE router ID is set
                	**type**\:  bool
                
                .. attribute:: node_name
                
                	Node Name
                	**type**\:  str
                
                .. attribute:: srgb_information
                
                	SRGB information
                	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation>`
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier, self).__init__()

                    self.yang_name = "node-protocol-identifier"
                    self.yang_parent_name = "prefix-info"

                    self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                    self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                    self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                    self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                    self.node_name = YLeaf(YType.str, "node-name")

                    self.igp_information = YList(self)
                    self.srgb_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ipv4bgp_router_id",
                                    "ipv4bgp_router_id_set",
                                    "ipv4te_router_id",
                                    "ipv4te_router_id_set",
                                    "node_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier, self).__setattr__(name, value)


                class IgpInformation(Entity):
                    """
                    IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation, self).__init__()

                        self.yang_name = "igp-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class SrgbInformation(Entity):
                    """
                    SRGB information
                    
                    .. attribute:: igp_srgb
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                    
                    .. attribute:: size
                    
                    	SRGB size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: start
                    
                    	SRGB start
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation, self).__init__()

                        self.yang_name = "srgb-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.size = YLeaf(YType.uint32, "size")

                        self.start = YLeaf(YType.uint32, "start")

                        self.igp_srgb = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                        self.igp_srgb.parent = self
                        self._children_name_map["igp_srgb"] = "igp-srgb"
                        self._children_yang_names.add("igp-srgb")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("size",
                                        "start") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                    class IgpSrgb(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                            self.yang_name = "igp-srgb"
                            self.yang_parent_name = "srgb-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp-srgb"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp-srgb"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp-srgb"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-srgb" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.size.is_set or
                            self.start.is_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.size.yfilter != YFilter.not_set or
                            self.start.yfilter != YFilter.not_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "srgb-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.size.get_name_leafdata())
                        if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.start.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-srgb"):
                            if (self.igp_srgb is None):
                                self.igp_srgb = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                self.igp_srgb.parent = self
                                self._children_name_map["igp_srgb"] = "igp-srgb"
                            return self.igp_srgb

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-srgb" or name == "size" or name == "start"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "size"):
                            self.size = value
                            self.size.value_namespace = name_space
                            self.size.value_namespace_prefix = name_space_prefix
                        if(value_path == "start"):
                            self.start = value
                            self.start.value_namespace = name_space
                            self.start.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.igp_information:
                        if (c.has_data()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.ipv4bgp_router_id.is_set or
                        self.ipv4bgp_router_id_set.is_set or
                        self.ipv4te_router_id.is_set or
                        self.ipv4te_router_id_set.is_set or
                        self.node_name.is_set)

                def has_operation(self):
                    for c in self.igp_information:
                        if (c.has_operation()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                        self.ipv4te_router_id.yfilter != YFilter.not_set or
                        self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                        self.node_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "node-protocol-identifier" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                    if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                    if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                    if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "igp-information"):
                        for c in self.igp_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.igp_information.append(c)
                        return c

                    if (child_yang_name == "srgb-information"):
                        for c in self.srgb_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.srgb_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ipv4bgp-router-id"):
                        self.ipv4bgp_router_id = value
                        self.ipv4bgp_router_id.value_namespace = name_space
                        self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4bgp-router-id-set"):
                        self.ipv4bgp_router_id_set = value
                        self.ipv4bgp_router_id_set.value_namespace = name_space
                        self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id"):
                        self.ipv4te_router_id = value
                        self.ipv4te_router_id.value_namespace = name_space
                        self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id-set"):
                        self.ipv4te_router_id_set = value
                        self.ipv4te_router_id_set.value_namespace = name_space
                        self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-name"):
                        self.node_name = value
                        self.node_name.value_namespace = name_space
                        self.node_name.value_namespace_prefix = name_space_prefix


            class Address(Entity):
                """
                Prefix address
                
                .. attribute:: af_name
                
                	AFName
                	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                
                .. attribute:: ipv4
                
                	IPv4 address type
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv6
                
                	IPv6 address type
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(PceTopology.PrefixInfos.PrefixInfo.Address, self).__init__()

                    self.yang_name = "address"
                    self.yang_parent_name = "prefix-info"

                    self.af_name = YLeaf(YType.enumeration, "af-name")

                    self.ipv4 = YLeaf(YType.str, "ipv4")

                    self.ipv6 = YLeaf(YType.str, "ipv6")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("af_name",
                                    "ipv4",
                                    "ipv6") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(PceTopology.PrefixInfos.PrefixInfo.Address, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(PceTopology.PrefixInfos.PrefixInfo.Address, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.af_name.is_set or
                        self.ipv4.is_set or
                        self.ipv6.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.af_name.yfilter != YFilter.not_set or
                        self.ipv4.yfilter != YFilter.not_set or
                        self.ipv6.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "address" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.af_name.get_name_leafdata())
                    if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4.get_name_leafdata())
                    if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv6.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "af-name"):
                        self.af_name = value
                        self.af_name.value_namespace = name_space
                        self.af_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4"):
                        self.ipv4 = value
                        self.ipv4.value_namespace = name_space
                        self.ipv4.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv6"):
                        self.ipv6 = value
                        self.ipv6.value_namespace = name_space
                        self.ipv6.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.address:
                    if (c.has_data()):
                        return True
                return (
                    self.node_identifier.is_set or
                    self.node_identifier_xr.is_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_data()))

            def has_operation(self):
                for c in self.address:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_identifier.yfilter != YFilter.not_set or
                    self.node_identifier_xr.yfilter != YFilter.not_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "prefix-info" + "[node-identifier='" + self.node_identifier.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-topology/prefix-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_identifier.is_set or self.node_identifier.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier.get_name_leafdata())
                if (self.node_identifier_xr.is_set or self.node_identifier_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier_xr.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "address"):
                    for c in self.address:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = PceTopology.PrefixInfos.PrefixInfo.Address()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.address.append(c)
                    return c

                if (child_yang_name == "node-protocol-identifier"):
                    if (self.node_protocol_identifier is None):
                        self.node_protocol_identifier = PceTopology.PrefixInfos.PrefixInfo.NodeProtocolIdentifier()
                        self.node_protocol_identifier.parent = self
                        self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                    return self.node_protocol_identifier

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "address" or name == "node-protocol-identifier" or name == "node-identifier" or name == "node-identifier-xr"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-identifier"):
                    self.node_identifier = value
                    self.node_identifier.value_namespace = name_space
                    self.node_identifier.value_namespace_prefix = name_space_prefix
                if(value_path == "node-identifier-xr"):
                    self.node_identifier_xr = value
                    self.node_identifier_xr.value_namespace = name_space
                    self.node_identifier_xr.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.prefix_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.prefix_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "prefix-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-topology/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "prefix-info"):
                for c in self.prefix_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = PceTopology.PrefixInfos.PrefixInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.prefix_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "prefix-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.prefix_infos is not None and self.prefix_infos.has_data()) or
            (self.topology_nodes is not None and self.topology_nodes.has_data()) or
            (self.topology_summary is not None and self.topology_summary.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.prefix_infos is not None and self.prefix_infos.has_operation()) or
            (self.topology_nodes is not None and self.topology_nodes.has_operation()) or
            (self.topology_summary is not None and self.topology_summary.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce-topology" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "prefix-infos"):
            if (self.prefix_infos is None):
                self.prefix_infos = PceTopology.PrefixInfos()
                self.prefix_infos.parent = self
                self._children_name_map["prefix_infos"] = "prefix-infos"
            return self.prefix_infos

        if (child_yang_name == "topology-nodes"):
            if (self.topology_nodes is None):
                self.topology_nodes = PceTopology.TopologyNodes()
                self.topology_nodes.parent = self
                self._children_name_map["topology_nodes"] = "topology-nodes"
            return self.topology_nodes

        if (child_yang_name == "topology-summary"):
            if (self.topology_summary is None):
                self.topology_summary = PceTopology.TopologySummary()
                self.topology_summary.parent = self
                self._children_name_map["topology_summary"] = "topology-summary"
            return self.topology_summary

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "prefix-infos" or name == "topology-nodes" or name == "topology-summary"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = PceTopology()
        return self._top_entity

class Pce(Entity):
    """
    pce
    
    .. attribute:: association_infos
    
    	Associaition database in XTC
    	**type**\:   :py:class:`AssociationInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.AssociationInfos>`
    
    .. attribute:: lsp_summary
    
    	LSP summary database in XTC
    	**type**\:   :py:class:`LspSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.LspSummary>`
    
    .. attribute:: peer_detail_infos
    
    	Detailed peers database in XTC
    	**type**\:   :py:class:`PeerDetailInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerDetailInfos>`
    
    .. attribute:: peer_infos
    
    	Peers database in XTC
    	**type**\:   :py:class:`PeerInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerInfos>`
    
    .. attribute:: prefix_infos
    
    	Prefixes database in XTC
    	**type**\:   :py:class:`PrefixInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos>`
    
    .. attribute:: topology_nodes
    
    	Node database in XTC
    	**type**\:   :py:class:`TopologyNodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes>`
    
    .. attribute:: topology_summary
    
    	Node summary database in XTC
    	**type**\:   :py:class:`TopologySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologySummary>`
    
    .. attribute:: tunnel_detail_infos
    
    	Detailed tunnel database in XTC
    	**type**\:   :py:class:`TunnelDetailInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos>`
    
    .. attribute:: tunnel_infos
    
    	Tunnel database in XTC
    	**type**\:   :py:class:`TunnelInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelInfos>`
    
    

    """

    _prefix = 'infra-xtc-oper'
    _revision = '2016-05-31'

    def __init__(self):
        super(Pce, self).__init__()
        self._top_entity = None

        self.yang_name = "pce"
        self.yang_parent_name = "Cisco-IOS-XR-infra-xtc-oper"

        self.association_infos = Pce.AssociationInfos()
        self.association_infos.parent = self
        self._children_name_map["association_infos"] = "association-infos"
        self._children_yang_names.add("association-infos")

        self.lsp_summary = Pce.LspSummary()
        self.lsp_summary.parent = self
        self._children_name_map["lsp_summary"] = "lsp-summary"
        self._children_yang_names.add("lsp-summary")

        self.peer_detail_infos = Pce.PeerDetailInfos()
        self.peer_detail_infos.parent = self
        self._children_name_map["peer_detail_infos"] = "peer-detail-infos"
        self._children_yang_names.add("peer-detail-infos")

        self.peer_infos = Pce.PeerInfos()
        self.peer_infos.parent = self
        self._children_name_map["peer_infos"] = "peer-infos"
        self._children_yang_names.add("peer-infos")

        self.prefix_infos = Pce.PrefixInfos()
        self.prefix_infos.parent = self
        self._children_name_map["prefix_infos"] = "prefix-infos"
        self._children_yang_names.add("prefix-infos")

        self.topology_nodes = Pce.TopologyNodes()
        self.topology_nodes.parent = self
        self._children_name_map["topology_nodes"] = "topology-nodes"
        self._children_yang_names.add("topology-nodes")

        self.topology_summary = Pce.TopologySummary()
        self.topology_summary.parent = self
        self._children_name_map["topology_summary"] = "topology-summary"
        self._children_yang_names.add("topology-summary")

        self.tunnel_detail_infos = Pce.TunnelDetailInfos()
        self.tunnel_detail_infos.parent = self
        self._children_name_map["tunnel_detail_infos"] = "tunnel-detail-infos"
        self._children_yang_names.add("tunnel-detail-infos")

        self.tunnel_infos = Pce.TunnelInfos()
        self.tunnel_infos.parent = self
        self._children_name_map["tunnel_infos"] = "tunnel-infos"
        self._children_yang_names.add("tunnel-infos")


    class AssociationInfos(Entity):
        """
        Associaition database in XTC
        
        .. attribute:: association_info
        
        	PCE Association information
        	**type**\: list of    :py:class:`AssociationInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.AssociationInfos.AssociationInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.AssociationInfos, self).__init__()

            self.yang_name = "association-infos"
            self.yang_parent_name = "pce"

            self.association_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.AssociationInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.AssociationInfos, self).__setattr__(name, value)


        class AssociationInfo(Entity):
            """
            PCE Association information
            
            .. attribute:: group_id  <key>
            
            	Group ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: association_id
            
            	Association ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: association_lsp
            
            	Association LSP Info
            	**type**\: list of    :py:class:`AssociationLsp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.AssociationInfos.AssociationInfo.AssociationLsp>`
            
            .. attribute:: association_source
            
            	Association Source
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: association_type
            
            	Association Type
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: headends_swapped
            
            	Headends Swapped
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: status
            
            	Association Status
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: strict
            
            	Association Strict Mode
            	**type**\:  bool
            
            .. attribute:: sub_id
            
            	Sub ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: type
            
            	Type
            	**type**\:   :py:class:`PceAsso <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAsso>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.AssociationInfos.AssociationInfo, self).__init__()

                self.yang_name = "association-info"
                self.yang_parent_name = "association-infos"

                self.group_id = YLeaf(YType.int32, "group-id")

                self.association_id = YLeaf(YType.uint32, "association-id")

                self.association_source = YLeaf(YType.str, "association-source")

                self.association_type = YLeaf(YType.uint32, "association-type")

                self.headends_swapped = YLeaf(YType.uint32, "headends-swapped")

                self.status = YLeaf(YType.uint32, "status")

                self.strict = YLeaf(YType.boolean, "strict")

                self.sub_id = YLeaf(YType.int32, "sub-id")

                self.type = YLeaf(YType.enumeration, "type")

                self.association_lsp = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("group_id",
                                "association_id",
                                "association_source",
                                "association_type",
                                "headends_swapped",
                                "status",
                                "strict",
                                "sub_id",
                                "type") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.AssociationInfos.AssociationInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.AssociationInfos.AssociationInfo, self).__setattr__(name, value)


            class AssociationLsp(Entity):
                """
                Association LSP Info
                
                .. attribute:: lspid
                
                	LSP ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pcc_address
                
                	PCC address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: pce_based
                
                	PCE Based
                	**type**\:  bool
                
                .. attribute:: plsp_id
                
                	PLSP ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: tunnel_id
                
                	Tunnel ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: tunnel_name
                
                	Tunnel Name
                	**type**\:  str
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.AssociationInfos.AssociationInfo.AssociationLsp, self).__init__()

                    self.yang_name = "association-lsp"
                    self.yang_parent_name = "association-info"

                    self.lspid = YLeaf(YType.uint32, "lspid")

                    self.pcc_address = YLeaf(YType.str, "pcc-address")

                    self.pce_based = YLeaf(YType.boolean, "pce-based")

                    self.plsp_id = YLeaf(YType.uint32, "plsp-id")

                    self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                    self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lspid",
                                    "pcc_address",
                                    "pce_based",
                                    "plsp_id",
                                    "tunnel_id",
                                    "tunnel_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.AssociationInfos.AssociationInfo.AssociationLsp, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.AssociationInfos.AssociationInfo.AssociationLsp, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.lspid.is_set or
                        self.pcc_address.is_set or
                        self.pce_based.is_set or
                        self.plsp_id.is_set or
                        self.tunnel_id.is_set or
                        self.tunnel_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lspid.yfilter != YFilter.not_set or
                        self.pcc_address.yfilter != YFilter.not_set or
                        self.pce_based.yfilter != YFilter.not_set or
                        self.plsp_id.yfilter != YFilter.not_set or
                        self.tunnel_id.yfilter != YFilter.not_set or
                        self.tunnel_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-lsp" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lspid.get_name_leafdata())
                    if (self.pcc_address.is_set or self.pcc_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pcc_address.get_name_leafdata())
                    if (self.pce_based.is_set or self.pce_based.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_based.get_name_leafdata())
                    if (self.plsp_id.is_set or self.plsp_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.plsp_id.get_name_leafdata())
                    if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_id.get_name_leafdata())
                    if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lspid" or name == "pcc-address" or name == "pce-based" or name == "plsp-id" or name == "tunnel-id" or name == "tunnel-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lspid"):
                        self.lspid = value
                        self.lspid.value_namespace = name_space
                        self.lspid.value_namespace_prefix = name_space_prefix
                    if(value_path == "pcc-address"):
                        self.pcc_address = value
                        self.pcc_address.value_namespace = name_space
                        self.pcc_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-based"):
                        self.pce_based = value
                        self.pce_based.value_namespace = name_space
                        self.pce_based.value_namespace_prefix = name_space_prefix
                    if(value_path == "plsp-id"):
                        self.plsp_id = value
                        self.plsp_id.value_namespace = name_space
                        self.plsp_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "tunnel-id"):
                        self.tunnel_id = value
                        self.tunnel_id.value_namespace = name_space
                        self.tunnel_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "tunnel-name"):
                        self.tunnel_name = value
                        self.tunnel_name.value_namespace = name_space
                        self.tunnel_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_lsp:
                    if (c.has_data()):
                        return True
                return (
                    self.group_id.is_set or
                    self.association_id.is_set or
                    self.association_source.is_set or
                    self.association_type.is_set or
                    self.headends_swapped.is_set or
                    self.status.is_set or
                    self.strict.is_set or
                    self.sub_id.is_set or
                    self.type.is_set)

            def has_operation(self):
                for c in self.association_lsp:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.group_id.yfilter != YFilter.not_set or
                    self.association_id.yfilter != YFilter.not_set or
                    self.association_source.yfilter != YFilter.not_set or
                    self.association_type.yfilter != YFilter.not_set or
                    self.headends_swapped.yfilter != YFilter.not_set or
                    self.status.yfilter != YFilter.not_set or
                    self.strict.yfilter != YFilter.not_set or
                    self.sub_id.yfilter != YFilter.not_set or
                    self.type.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "association-info" + "[group-id='" + self.group_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/association-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.group_id.is_set or self.group_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.group_id.get_name_leafdata())
                if (self.association_id.is_set or self.association_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.association_id.get_name_leafdata())
                if (self.association_source.is_set or self.association_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.association_source.get_name_leafdata())
                if (self.association_type.is_set or self.association_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.association_type.get_name_leafdata())
                if (self.headends_swapped.is_set or self.headends_swapped.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.headends_swapped.get_name_leafdata())
                if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.status.get_name_leafdata())
                if (self.strict.is_set or self.strict.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.strict.get_name_leafdata())
                if (self.sub_id.is_set or self.sub_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sub_id.get_name_leafdata())
                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.type.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-lsp"):
                    for c in self.association_lsp:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Pce.AssociationInfos.AssociationInfo.AssociationLsp()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_lsp.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-lsp" or name == "group-id" or name == "association-id" or name == "association-source" or name == "association-type" or name == "headends-swapped" or name == "status" or name == "strict" or name == "sub-id" or name == "type"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "group-id"):
                    self.group_id = value
                    self.group_id.value_namespace = name_space
                    self.group_id.value_namespace_prefix = name_space_prefix
                if(value_path == "association-id"):
                    self.association_id = value
                    self.association_id.value_namespace = name_space
                    self.association_id.value_namespace_prefix = name_space_prefix
                if(value_path == "association-source"):
                    self.association_source = value
                    self.association_source.value_namespace = name_space
                    self.association_source.value_namespace_prefix = name_space_prefix
                if(value_path == "association-type"):
                    self.association_type = value
                    self.association_type.value_namespace = name_space
                    self.association_type.value_namespace_prefix = name_space_prefix
                if(value_path == "headends-swapped"):
                    self.headends_swapped = value
                    self.headends_swapped.value_namespace = name_space
                    self.headends_swapped.value_namespace_prefix = name_space_prefix
                if(value_path == "status"):
                    self.status = value
                    self.status.value_namespace = name_space
                    self.status.value_namespace_prefix = name_space_prefix
                if(value_path == "strict"):
                    self.strict = value
                    self.strict.value_namespace = name_space
                    self.strict.value_namespace_prefix = name_space_prefix
                if(value_path == "sub-id"):
                    self.sub_id = value
                    self.sub_id.value_namespace = name_space
                    self.sub_id.value_namespace_prefix = name_space_prefix
                if(value_path == "type"):
                    self.type = value
                    self.type.value_namespace = name_space
                    self.type.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.association_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.association_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "association-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "association-info"):
                for c in self.association_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.AssociationInfos.AssociationInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.association_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "association-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TopologySummary(Entity):
        """
        Node summary database in XTC
        
        .. attribute:: adjacency_sids
        
        	Number of total adjacency SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: epe_links
        
        	Number of EPE links
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: epesids
        
        	Number of total EPE SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: links
        
        	Number of links
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: lookup_nodes
        
        	Number of lookup nodes
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: nodes
        
        	Number of PCE nodes
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: prefix_sids
        
        	Number of total prefix SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: prefixes
        
        	Number of prefixes
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: protected_adjacency_sids
        
        	Number of protected adjacency SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: regular_prefix_sids
        
        	Number of reguar prefix SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: stats_topology_update
        
        	Statistics on topology update
        	**type**\:   :py:class:`StatsTopologyUpdate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologySummary.StatsTopologyUpdate>`
        
        .. attribute:: strict_prefix_sids
        
        	Number of strict prefix SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: topology_consistent
        
        	True if topology is consistent
        	**type**\:  bool
        
        .. attribute:: un_protected_adjacency_sids
        
        	Number of unprotected adjacency SIDs
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.TopologySummary, self).__init__()

            self.yang_name = "topology-summary"
            self.yang_parent_name = "pce"

            self.adjacency_sids = YLeaf(YType.uint32, "adjacency-sids")

            self.epe_links = YLeaf(YType.uint32, "epe-links")

            self.epesids = YLeaf(YType.uint32, "epesids")

            self.links = YLeaf(YType.uint32, "links")

            self.lookup_nodes = YLeaf(YType.uint32, "lookup-nodes")

            self.nodes = YLeaf(YType.uint32, "nodes")

            self.prefix_sids = YLeaf(YType.uint32, "prefix-sids")

            self.prefixes = YLeaf(YType.uint32, "prefixes")

            self.protected_adjacency_sids = YLeaf(YType.uint32, "protected-adjacency-sids")

            self.regular_prefix_sids = YLeaf(YType.uint32, "regular-prefix-sids")

            self.strict_prefix_sids = YLeaf(YType.uint32, "strict-prefix-sids")

            self.topology_consistent = YLeaf(YType.boolean, "topology-consistent")

            self.un_protected_adjacency_sids = YLeaf(YType.uint32, "un-protected-adjacency-sids")

            self.stats_topology_update = Pce.TopologySummary.StatsTopologyUpdate()
            self.stats_topology_update.parent = self
            self._children_name_map["stats_topology_update"] = "stats-topology-update"
            self._children_yang_names.add("stats-topology-update")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("adjacency_sids",
                            "epe_links",
                            "epesids",
                            "links",
                            "lookup_nodes",
                            "nodes",
                            "prefix_sids",
                            "prefixes",
                            "protected_adjacency_sids",
                            "regular_prefix_sids",
                            "strict_prefix_sids",
                            "topology_consistent",
                            "un_protected_adjacency_sids") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.TopologySummary, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.TopologySummary, self).__setattr__(name, value)


        class StatsTopologyUpdate(Entity):
            """
            Statistics on topology update
            
            .. attribute:: num_links_added
            
            	Number of links added
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_links_deleted
            
            	Number of links deleted
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_nodes_added
            
            	Number of nodes added
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_nodes_deleted
            
            	Number of nodes deleted
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_prefixes_added
            
            	Number of prefixes added
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: num_prefixes_deleted
            
            	Number of prefixes deleted
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.TopologySummary.StatsTopologyUpdate, self).__init__()

                self.yang_name = "stats-topology-update"
                self.yang_parent_name = "topology-summary"

                self.num_links_added = YLeaf(YType.uint32, "num-links-added")

                self.num_links_deleted = YLeaf(YType.uint32, "num-links-deleted")

                self.num_nodes_added = YLeaf(YType.uint32, "num-nodes-added")

                self.num_nodes_deleted = YLeaf(YType.uint32, "num-nodes-deleted")

                self.num_prefixes_added = YLeaf(YType.uint32, "num-prefixes-added")

                self.num_prefixes_deleted = YLeaf(YType.uint32, "num-prefixes-deleted")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("num_links_added",
                                "num_links_deleted",
                                "num_nodes_added",
                                "num_nodes_deleted",
                                "num_prefixes_added",
                                "num_prefixes_deleted") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.TopologySummary.StatsTopologyUpdate, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.TopologySummary.StatsTopologyUpdate, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.num_links_added.is_set or
                    self.num_links_deleted.is_set or
                    self.num_nodes_added.is_set or
                    self.num_nodes_deleted.is_set or
                    self.num_prefixes_added.is_set or
                    self.num_prefixes_deleted.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.num_links_added.yfilter != YFilter.not_set or
                    self.num_links_deleted.yfilter != YFilter.not_set or
                    self.num_nodes_added.yfilter != YFilter.not_set or
                    self.num_nodes_deleted.yfilter != YFilter.not_set or
                    self.num_prefixes_added.yfilter != YFilter.not_set or
                    self.num_prefixes_deleted.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "stats-topology-update" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/topology-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.num_links_added.is_set or self.num_links_added.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_links_added.get_name_leafdata())
                if (self.num_links_deleted.is_set or self.num_links_deleted.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_links_deleted.get_name_leafdata())
                if (self.num_nodes_added.is_set or self.num_nodes_added.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_nodes_added.get_name_leafdata())
                if (self.num_nodes_deleted.is_set or self.num_nodes_deleted.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_nodes_deleted.get_name_leafdata())
                if (self.num_prefixes_added.is_set or self.num_prefixes_added.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_prefixes_added.get_name_leafdata())
                if (self.num_prefixes_deleted.is_set or self.num_prefixes_deleted.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.num_prefixes_deleted.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "num-links-added" or name == "num-links-deleted" or name == "num-nodes-added" or name == "num-nodes-deleted" or name == "num-prefixes-added" or name == "num-prefixes-deleted"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "num-links-added"):
                    self.num_links_added = value
                    self.num_links_added.value_namespace = name_space
                    self.num_links_added.value_namespace_prefix = name_space_prefix
                if(value_path == "num-links-deleted"):
                    self.num_links_deleted = value
                    self.num_links_deleted.value_namespace = name_space
                    self.num_links_deleted.value_namespace_prefix = name_space_prefix
                if(value_path == "num-nodes-added"):
                    self.num_nodes_added = value
                    self.num_nodes_added.value_namespace = name_space
                    self.num_nodes_added.value_namespace_prefix = name_space_prefix
                if(value_path == "num-nodes-deleted"):
                    self.num_nodes_deleted = value
                    self.num_nodes_deleted.value_namespace = name_space
                    self.num_nodes_deleted.value_namespace_prefix = name_space_prefix
                if(value_path == "num-prefixes-added"):
                    self.num_prefixes_added = value
                    self.num_prefixes_added.value_namespace = name_space
                    self.num_prefixes_added.value_namespace_prefix = name_space_prefix
                if(value_path == "num-prefixes-deleted"):
                    self.num_prefixes_deleted = value
                    self.num_prefixes_deleted.value_namespace = name_space
                    self.num_prefixes_deleted.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                self.adjacency_sids.is_set or
                self.epe_links.is_set or
                self.epesids.is_set or
                self.links.is_set or
                self.lookup_nodes.is_set or
                self.nodes.is_set or
                self.prefix_sids.is_set or
                self.prefixes.is_set or
                self.protected_adjacency_sids.is_set or
                self.regular_prefix_sids.is_set or
                self.strict_prefix_sids.is_set or
                self.topology_consistent.is_set or
                self.un_protected_adjacency_sids.is_set or
                (self.stats_topology_update is not None and self.stats_topology_update.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.adjacency_sids.yfilter != YFilter.not_set or
                self.epe_links.yfilter != YFilter.not_set or
                self.epesids.yfilter != YFilter.not_set or
                self.links.yfilter != YFilter.not_set or
                self.lookup_nodes.yfilter != YFilter.not_set or
                self.nodes.yfilter != YFilter.not_set or
                self.prefix_sids.yfilter != YFilter.not_set or
                self.prefixes.yfilter != YFilter.not_set or
                self.protected_adjacency_sids.yfilter != YFilter.not_set or
                self.regular_prefix_sids.yfilter != YFilter.not_set or
                self.strict_prefix_sids.yfilter != YFilter.not_set or
                self.topology_consistent.yfilter != YFilter.not_set or
                self.un_protected_adjacency_sids.yfilter != YFilter.not_set or
                (self.stats_topology_update is not None and self.stats_topology_update.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "topology-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.adjacency_sids.is_set or self.adjacency_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.adjacency_sids.get_name_leafdata())
            if (self.epe_links.is_set or self.epe_links.yfilter != YFilter.not_set):
                leaf_name_data.append(self.epe_links.get_name_leafdata())
            if (self.epesids.is_set or self.epesids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.epesids.get_name_leafdata())
            if (self.links.is_set or self.links.yfilter != YFilter.not_set):
                leaf_name_data.append(self.links.get_name_leafdata())
            if (self.lookup_nodes.is_set or self.lookup_nodes.yfilter != YFilter.not_set):
                leaf_name_data.append(self.lookup_nodes.get_name_leafdata())
            if (self.nodes.is_set or self.nodes.yfilter != YFilter.not_set):
                leaf_name_data.append(self.nodes.get_name_leafdata())
            if (self.prefix_sids.is_set or self.prefix_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.prefix_sids.get_name_leafdata())
            if (self.prefixes.is_set or self.prefixes.yfilter != YFilter.not_set):
                leaf_name_data.append(self.prefixes.get_name_leafdata())
            if (self.protected_adjacency_sids.is_set or self.protected_adjacency_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.protected_adjacency_sids.get_name_leafdata())
            if (self.regular_prefix_sids.is_set or self.regular_prefix_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.regular_prefix_sids.get_name_leafdata())
            if (self.strict_prefix_sids.is_set or self.strict_prefix_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.strict_prefix_sids.get_name_leafdata())
            if (self.topology_consistent.is_set or self.topology_consistent.yfilter != YFilter.not_set):
                leaf_name_data.append(self.topology_consistent.get_name_leafdata())
            if (self.un_protected_adjacency_sids.is_set or self.un_protected_adjacency_sids.yfilter != YFilter.not_set):
                leaf_name_data.append(self.un_protected_adjacency_sids.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "stats-topology-update"):
                if (self.stats_topology_update is None):
                    self.stats_topology_update = Pce.TopologySummary.StatsTopologyUpdate()
                    self.stats_topology_update.parent = self
                    self._children_name_map["stats_topology_update"] = "stats-topology-update"
                return self.stats_topology_update

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "stats-topology-update" or name == "adjacency-sids" or name == "epe-links" or name == "epesids" or name == "links" or name == "lookup-nodes" or name == "nodes" or name == "prefix-sids" or name == "prefixes" or name == "protected-adjacency-sids" or name == "regular-prefix-sids" or name == "strict-prefix-sids" or name == "topology-consistent" or name == "un-protected-adjacency-sids"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "adjacency-sids"):
                self.adjacency_sids = value
                self.adjacency_sids.value_namespace = name_space
                self.adjacency_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "epe-links"):
                self.epe_links = value
                self.epe_links.value_namespace = name_space
                self.epe_links.value_namespace_prefix = name_space_prefix
            if(value_path == "epesids"):
                self.epesids = value
                self.epesids.value_namespace = name_space
                self.epesids.value_namespace_prefix = name_space_prefix
            if(value_path == "links"):
                self.links = value
                self.links.value_namespace = name_space
                self.links.value_namespace_prefix = name_space_prefix
            if(value_path == "lookup-nodes"):
                self.lookup_nodes = value
                self.lookup_nodes.value_namespace = name_space
                self.lookup_nodes.value_namespace_prefix = name_space_prefix
            if(value_path == "nodes"):
                self.nodes = value
                self.nodes.value_namespace = name_space
                self.nodes.value_namespace_prefix = name_space_prefix
            if(value_path == "prefix-sids"):
                self.prefix_sids = value
                self.prefix_sids.value_namespace = name_space
                self.prefix_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "prefixes"):
                self.prefixes = value
                self.prefixes.value_namespace = name_space
                self.prefixes.value_namespace_prefix = name_space_prefix
            if(value_path == "protected-adjacency-sids"):
                self.protected_adjacency_sids = value
                self.protected_adjacency_sids.value_namespace = name_space
                self.protected_adjacency_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "regular-prefix-sids"):
                self.regular_prefix_sids = value
                self.regular_prefix_sids.value_namespace = name_space
                self.regular_prefix_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "strict-prefix-sids"):
                self.strict_prefix_sids = value
                self.strict_prefix_sids.value_namespace = name_space
                self.strict_prefix_sids.value_namespace_prefix = name_space_prefix
            if(value_path == "topology-consistent"):
                self.topology_consistent = value
                self.topology_consistent.value_namespace = name_space
                self.topology_consistent.value_namespace_prefix = name_space_prefix
            if(value_path == "un-protected-adjacency-sids"):
                self.un_protected_adjacency_sids = value
                self.un_protected_adjacency_sids.value_namespace = name_space
                self.un_protected_adjacency_sids.value_namespace_prefix = name_space_prefix


    class TunnelInfos(Entity):
        """
        Tunnel database in XTC
        
        .. attribute:: tunnel_info
        
        	Tunnel information
        	**type**\: list of    :py:class:`TunnelInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelInfos.TunnelInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.TunnelInfos, self).__init__()

            self.yang_name = "tunnel-infos"
            self.yang_parent_name = "pce"

            self.tunnel_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.TunnelInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.TunnelInfos, self).__setattr__(name, value)


        class TunnelInfo(Entity):
            """
            Tunnel information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: plsp_id  <key>
            
            	PCEP LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: tunnel_name  <key>
            
            	Tunnel name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: brief_lsp_information
            
            	Brief LSP information
            	**type**\: list of    :py:class:`BriefLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelInfos.TunnelInfo.BriefLspInformation>`
            
            .. attribute:: pcc_address
            
            	PCC address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: tunnel_name_xr
            
            	Tunnel Name
            	**type**\:  str
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.TunnelInfos.TunnelInfo, self).__init__()

                self.yang_name = "tunnel-info"
                self.yang_parent_name = "tunnel-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.plsp_id = YLeaf(YType.int32, "plsp-id")

                self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                self.pcc_address = YLeaf(YType.str, "pcc-address")

                self.tunnel_name_xr = YLeaf(YType.str, "tunnel-name-xr")

                self.brief_lsp_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "plsp_id",
                                "tunnel_name",
                                "pcc_address",
                                "tunnel_name_xr") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.TunnelInfos.TunnelInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.TunnelInfos.TunnelInfo, self).__setattr__(name, value)


            class BriefLspInformation(Entity):
                """
                Brief LSP information
                
                .. attribute:: administrative_state
                
                	Admin state
                	**type**\:   :py:class:`LspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspState>`
                
                .. attribute:: binding_sid
                
                	Binding SID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: destination_address
                
                	Destination address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: lsp_setup_type
                
                	LSP Setup Type
                	**type**\:   :py:class:`LspSetup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspSetup>`
                
                .. attribute:: lspid
                
                	LSP ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: operational_state
                
                	Operational state
                	**type**\:   :py:class:`PcepLspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepLspState>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: tunnel_id
                
                	Tunnel ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.TunnelInfos.TunnelInfo.BriefLspInformation, self).__init__()

                    self.yang_name = "brief-lsp-information"
                    self.yang_parent_name = "tunnel-info"

                    self.administrative_state = YLeaf(YType.enumeration, "administrative-state")

                    self.binding_sid = YLeaf(YType.uint32, "binding-sid")

                    self.destination_address = YLeaf(YType.str, "destination-address")

                    self.lsp_setup_type = YLeaf(YType.enumeration, "lsp-setup-type")

                    self.lspid = YLeaf(YType.uint32, "lspid")

                    self.operational_state = YLeaf(YType.enumeration, "operational-state")

                    self.source_address = YLeaf(YType.str, "source-address")

                    self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("administrative_state",
                                    "binding_sid",
                                    "destination_address",
                                    "lsp_setup_type",
                                    "lspid",
                                    "operational_state",
                                    "source_address",
                                    "tunnel_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.TunnelInfos.TunnelInfo.BriefLspInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.TunnelInfos.TunnelInfo.BriefLspInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.administrative_state.is_set or
                        self.binding_sid.is_set or
                        self.destination_address.is_set or
                        self.lsp_setup_type.is_set or
                        self.lspid.is_set or
                        self.operational_state.is_set or
                        self.source_address.is_set or
                        self.tunnel_id.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.administrative_state.yfilter != YFilter.not_set or
                        self.binding_sid.yfilter != YFilter.not_set or
                        self.destination_address.yfilter != YFilter.not_set or
                        self.lsp_setup_type.yfilter != YFilter.not_set or
                        self.lspid.yfilter != YFilter.not_set or
                        self.operational_state.yfilter != YFilter.not_set or
                        self.source_address.yfilter != YFilter.not_set or
                        self.tunnel_id.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "brief-lsp-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.administrative_state.is_set or self.administrative_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.administrative_state.get_name_leafdata())
                    if (self.binding_sid.is_set or self.binding_sid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.binding_sid.get_name_leafdata())
                    if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.destination_address.get_name_leafdata())
                    if (self.lsp_setup_type.is_set or self.lsp_setup_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_setup_type.get_name_leafdata())
                    if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lspid.get_name_leafdata())
                    if (self.operational_state.is_set or self.operational_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.operational_state.get_name_leafdata())
                    if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_address.get_name_leafdata())
                    if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "administrative-state" or name == "binding-sid" or name == "destination-address" or name == "lsp-setup-type" or name == "lspid" or name == "operational-state" or name == "source-address" or name == "tunnel-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "administrative-state"):
                        self.administrative_state = value
                        self.administrative_state.value_namespace = name_space
                        self.administrative_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "binding-sid"):
                        self.binding_sid = value
                        self.binding_sid.value_namespace = name_space
                        self.binding_sid.value_namespace_prefix = name_space_prefix
                    if(value_path == "destination-address"):
                        self.destination_address = value
                        self.destination_address.value_namespace = name_space
                        self.destination_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-setup-type"):
                        self.lsp_setup_type = value
                        self.lsp_setup_type.value_namespace = name_space
                        self.lsp_setup_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "lspid"):
                        self.lspid = value
                        self.lspid.value_namespace = name_space
                        self.lspid.value_namespace_prefix = name_space_prefix
                    if(value_path == "operational-state"):
                        self.operational_state = value
                        self.operational_state.value_namespace = name_space
                        self.operational_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-address"):
                        self.source_address = value
                        self.source_address.value_namespace = name_space
                        self.source_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "tunnel-id"):
                        self.tunnel_id = value
                        self.tunnel_id.value_namespace = name_space
                        self.tunnel_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.brief_lsp_information:
                    if (c.has_data()):
                        return True
                return (
                    self.peer_address.is_set or
                    self.plsp_id.is_set or
                    self.tunnel_name.is_set or
                    self.pcc_address.is_set or
                    self.tunnel_name_xr.is_set)

            def has_operation(self):
                for c in self.brief_lsp_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.plsp_id.yfilter != YFilter.not_set or
                    self.tunnel_name.yfilter != YFilter.not_set or
                    self.pcc_address.yfilter != YFilter.not_set or
                    self.tunnel_name_xr.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel-info" + "[peer-address='" + self.peer_address.get() + "']" + "[plsp-id='" + self.plsp_id.get() + "']" + "[tunnel-name='" + self.tunnel_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/tunnel-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.plsp_id.is_set or self.plsp_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.plsp_id.get_name_leafdata())
                if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name.get_name_leafdata())
                if (self.pcc_address.is_set or self.pcc_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pcc_address.get_name_leafdata())
                if (self.tunnel_name_xr.is_set or self.tunnel_name_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name_xr.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "brief-lsp-information"):
                    for c in self.brief_lsp_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Pce.TunnelInfos.TunnelInfo.BriefLspInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.brief_lsp_information.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "brief-lsp-information" or name == "peer-address" or name == "plsp-id" or name == "tunnel-name" or name == "pcc-address" or name == "tunnel-name-xr"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "plsp-id"):
                    self.plsp_id = value
                    self.plsp_id.value_namespace = name_space
                    self.plsp_id.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name"):
                    self.tunnel_name = value
                    self.tunnel_name.value_namespace = name_space
                    self.tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "pcc-address"):
                    self.pcc_address = value
                    self.pcc_address.value_namespace = name_space
                    self.pcc_address.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name-xr"):
                    self.tunnel_name_xr = value
                    self.tunnel_name_xr.value_namespace = name_space
                    self.tunnel_name_xr.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnel-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel-info"):
                for c in self.tunnel_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.TunnelInfos.TunnelInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class PeerDetailInfos(Entity):
        """
        Detailed peers database in XTC
        
        .. attribute:: peer_detail_info
        
        	Detailed PCE peer information
        	**type**\: list of    :py:class:`PeerDetailInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerDetailInfos.PeerDetailInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.PeerDetailInfos, self).__init__()

            self.yang_name = "peer-detail-infos"
            self.yang_parent_name = "pce"

            self.peer_detail_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.PeerDetailInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.PeerDetailInfos, self).__setattr__(name, value)


        class PeerDetailInfo(Entity):
            """
            Detailed PCE peer information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: detail_pcep_information
            
            	Detailed PCE protocol information
            	**type**\:   :py:class:`DetailPcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation>`
            
            .. attribute:: peer_address_xr
            
            	Peer address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: peer_protocol
            
            	Protocol between PCE and peer
            	**type**\:   :py:class:`PceProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceProto>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.PeerDetailInfos.PeerDetailInfo, self).__init__()

                self.yang_name = "peer-detail-info"
                self.yang_parent_name = "peer-detail-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.peer_address_xr = YLeaf(YType.str, "peer-address-xr")

                self.peer_protocol = YLeaf(YType.enumeration, "peer-protocol")

                self.detail_pcep_information = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation()
                self.detail_pcep_information.parent = self
                self._children_name_map["detail_pcep_information"] = "detail-pcep-information"
                self._children_yang_names.add("detail-pcep-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "peer_address_xr",
                                "peer_protocol") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.PeerDetailInfos.PeerDetailInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.PeerDetailInfos.PeerDetailInfo, self).__setattr__(name, value)


            class DetailPcepInformation(Entity):
                """
                Detailed PCE protocol information
                
                .. attribute:: brief_pcep_information
                
                	Brief PCE protocol information
                	**type**\:   :py:class:`BriefPcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation>`
                
                .. attribute:: error
                
                	Error (for display only)
                	**type**\:  str
                
                .. attribute:: keepalives
                
                	Keepalive count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: keychain_enabled
                
                	Keychain based Authentication Enabled
                	**type**\:  bool
                
                .. attribute:: last_error_rx
                
                	Last PCError received
                	**type**\:   :py:class:`LastErrorRx <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx>`
                
                .. attribute:: last_error_tx
                
                	Last PCError sent
                	**type**\:   :py:class:`LastErrorTx <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx>`
                
                .. attribute:: local_session_id
                
                	Local PCEP session ID
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: maximum_dead_interval
                
                	Maximum dead interval for the peer
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: md5_enabled
                
                	MD5 Authentication Enabled
                	**type**\:  bool
                
                .. attribute:: minimum_keepalive_interval
                
                	Minimum keepalive interval for the peer
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: negotiated_dead_time
                
                	Negotiated DT
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: negotiated_local_keepalive
                
                	Negotiated KA
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: negotiated_remote_keepalive
                
                	Negotiated KA
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_error_rx
                
                	PCEErr Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_error_tx
                
                	PCEErr Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_initiate_rx
                
                	PCEInit Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_initiate_tx
                
                	PCEInit Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_keepalive_rx
                
                	PCE Keepalive Rx
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: pce_keepalive_tx
                
                	PCE Keepalive Tx
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: pce_open_rx
                
                	PCEOpen Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_open_tx
                
                	PCEOpen Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_reply_rx
                
                	PCERep Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_reply_tx
                
                	PCERep Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_report_rx
                
                	PCERpt Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_report_tx
                
                	PCERpt Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_request_rx
                
                	PCEReq Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_request_tx
                
                	PCEReq Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_update_rx
                
                	PCEUpd Rx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pce_update_tx
                
                	PCEUpd Tx
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: pcep_up_time
                
                	PCEP Up Time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_session_id
                
                	Remote PCEP session ID
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: speaker_id
                
                	Speaker Entity ID
                	**type**\:  str
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation, self).__init__()

                    self.yang_name = "detail-pcep-information"
                    self.yang_parent_name = "peer-detail-info"

                    self.error = YLeaf(YType.str, "error")

                    self.keepalives = YLeaf(YType.uint32, "keepalives")

                    self.keychain_enabled = YLeaf(YType.boolean, "keychain-enabled")

                    self.local_session_id = YLeaf(YType.uint8, "local-session-id")

                    self.maximum_dead_interval = YLeaf(YType.uint8, "maximum-dead-interval")

                    self.md5_enabled = YLeaf(YType.boolean, "md5-enabled")

                    self.minimum_keepalive_interval = YLeaf(YType.uint8, "minimum-keepalive-interval")

                    self.negotiated_dead_time = YLeaf(YType.uint32, "negotiated-dead-time")

                    self.negotiated_local_keepalive = YLeaf(YType.uint32, "negotiated-local-keepalive")

                    self.negotiated_remote_keepalive = YLeaf(YType.uint32, "negotiated-remote-keepalive")

                    self.pce_error_rx = YLeaf(YType.uint32, "pce-error-rx")

                    self.pce_error_tx = YLeaf(YType.uint32, "pce-error-tx")

                    self.pce_initiate_rx = YLeaf(YType.uint32, "pce-initiate-rx")

                    self.pce_initiate_tx = YLeaf(YType.uint32, "pce-initiate-tx")

                    self.pce_keepalive_rx = YLeaf(YType.uint64, "pce-keepalive-rx")

                    self.pce_keepalive_tx = YLeaf(YType.uint64, "pce-keepalive-tx")

                    self.pce_open_rx = YLeaf(YType.uint32, "pce-open-rx")

                    self.pce_open_tx = YLeaf(YType.uint32, "pce-open-tx")

                    self.pce_reply_rx = YLeaf(YType.uint32, "pce-reply-rx")

                    self.pce_reply_tx = YLeaf(YType.uint32, "pce-reply-tx")

                    self.pce_report_rx = YLeaf(YType.uint32, "pce-report-rx")

                    self.pce_report_tx = YLeaf(YType.uint32, "pce-report-tx")

                    self.pce_request_rx = YLeaf(YType.uint32, "pce-request-rx")

                    self.pce_request_tx = YLeaf(YType.uint32, "pce-request-tx")

                    self.pce_update_rx = YLeaf(YType.uint32, "pce-update-rx")

                    self.pce_update_tx = YLeaf(YType.uint32, "pce-update-tx")

                    self.pcep_up_time = YLeaf(YType.uint32, "pcep-up-time")

                    self.remote_session_id = YLeaf(YType.uint8, "remote-session-id")

                    self.speaker_id = YLeaf(YType.str, "speaker-id")

                    self.brief_pcep_information = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation()
                    self.brief_pcep_information.parent = self
                    self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                    self._children_yang_names.add("brief-pcep-information")

                    self.last_error_rx = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx()
                    self.last_error_rx.parent = self
                    self._children_name_map["last_error_rx"] = "last-error-rx"
                    self._children_yang_names.add("last-error-rx")

                    self.last_error_tx = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx()
                    self.last_error_tx.parent = self
                    self._children_name_map["last_error_tx"] = "last-error-tx"
                    self._children_yang_names.add("last-error-tx")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("error",
                                    "keepalives",
                                    "keychain_enabled",
                                    "local_session_id",
                                    "maximum_dead_interval",
                                    "md5_enabled",
                                    "minimum_keepalive_interval",
                                    "negotiated_dead_time",
                                    "negotiated_local_keepalive",
                                    "negotiated_remote_keepalive",
                                    "pce_error_rx",
                                    "pce_error_tx",
                                    "pce_initiate_rx",
                                    "pce_initiate_tx",
                                    "pce_keepalive_rx",
                                    "pce_keepalive_tx",
                                    "pce_open_rx",
                                    "pce_open_tx",
                                    "pce_reply_rx",
                                    "pce_reply_tx",
                                    "pce_report_rx",
                                    "pce_report_tx",
                                    "pce_request_rx",
                                    "pce_request_tx",
                                    "pce_update_rx",
                                    "pce_update_tx",
                                    "pcep_up_time",
                                    "remote_session_id",
                                    "speaker_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation, self).__setattr__(name, value)


                class BriefPcepInformation(Entity):
                    """
                    Brief PCE protocol information
                    
                    .. attribute:: capability_db_version
                    
                    	DB version capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_delta_sync
                    
                    	Delta Synchronization capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_instantiate
                    
                    	Instantiation capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_segment_routing
                    
                    	Segment Routing capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_triggered_sync
                    
                    	Triggered Synchronization capability
                    	**type**\:  bool
                    
                    .. attribute:: capability_update
                    
                    	Update capability
                    	**type**\:  bool
                    
                    .. attribute:: pcep_state
                    
                    	PCEP State
                    	**type**\:   :py:class:`PcepState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepState>`
                    
                    .. attribute:: stateful
                    
                    	Stateful
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation, self).__init__()

                        self.yang_name = "brief-pcep-information"
                        self.yang_parent_name = "detail-pcep-information"

                        self.capability_db_version = YLeaf(YType.boolean, "capability-db-version")

                        self.capability_delta_sync = YLeaf(YType.boolean, "capability-delta-sync")

                        self.capability_instantiate = YLeaf(YType.boolean, "capability-instantiate")

                        self.capability_segment_routing = YLeaf(YType.boolean, "capability-segment-routing")

                        self.capability_triggered_sync = YLeaf(YType.boolean, "capability-triggered-sync")

                        self.capability_update = YLeaf(YType.boolean, "capability-update")

                        self.pcep_state = YLeaf(YType.enumeration, "pcep-state")

                        self.stateful = YLeaf(YType.boolean, "stateful")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("capability_db_version",
                                        "capability_delta_sync",
                                        "capability_instantiate",
                                        "capability_segment_routing",
                                        "capability_triggered_sync",
                                        "capability_update",
                                        "pcep_state",
                                        "stateful") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.capability_db_version.is_set or
                            self.capability_delta_sync.is_set or
                            self.capability_instantiate.is_set or
                            self.capability_segment_routing.is_set or
                            self.capability_triggered_sync.is_set or
                            self.capability_update.is_set or
                            self.pcep_state.is_set or
                            self.stateful.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.capability_db_version.yfilter != YFilter.not_set or
                            self.capability_delta_sync.yfilter != YFilter.not_set or
                            self.capability_instantiate.yfilter != YFilter.not_set or
                            self.capability_segment_routing.yfilter != YFilter.not_set or
                            self.capability_triggered_sync.yfilter != YFilter.not_set or
                            self.capability_update.yfilter != YFilter.not_set or
                            self.pcep_state.yfilter != YFilter.not_set or
                            self.stateful.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-pcep-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.capability_db_version.is_set or self.capability_db_version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_db_version.get_name_leafdata())
                        if (self.capability_delta_sync.is_set or self.capability_delta_sync.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_delta_sync.get_name_leafdata())
                        if (self.capability_instantiate.is_set or self.capability_instantiate.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_instantiate.get_name_leafdata())
                        if (self.capability_segment_routing.is_set or self.capability_segment_routing.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_segment_routing.get_name_leafdata())
                        if (self.capability_triggered_sync.is_set or self.capability_triggered_sync.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_triggered_sync.get_name_leafdata())
                        if (self.capability_update.is_set or self.capability_update.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.capability_update.get_name_leafdata())
                        if (self.pcep_state.is_set or self.pcep_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_state.get_name_leafdata())
                        if (self.stateful.is_set or self.stateful.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stateful.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "capability-db-version" or name == "capability-delta-sync" or name == "capability-instantiate" or name == "capability-segment-routing" or name == "capability-triggered-sync" or name == "capability-update" or name == "pcep-state" or name == "stateful"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "capability-db-version"):
                            self.capability_db_version = value
                            self.capability_db_version.value_namespace = name_space
                            self.capability_db_version.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-delta-sync"):
                            self.capability_delta_sync = value
                            self.capability_delta_sync.value_namespace = name_space
                            self.capability_delta_sync.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-instantiate"):
                            self.capability_instantiate = value
                            self.capability_instantiate.value_namespace = name_space
                            self.capability_instantiate.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-segment-routing"):
                            self.capability_segment_routing = value
                            self.capability_segment_routing.value_namespace = name_space
                            self.capability_segment_routing.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-triggered-sync"):
                            self.capability_triggered_sync = value
                            self.capability_triggered_sync.value_namespace = name_space
                            self.capability_triggered_sync.value_namespace_prefix = name_space_prefix
                        if(value_path == "capability-update"):
                            self.capability_update = value
                            self.capability_update.value_namespace = name_space
                            self.capability_update.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-state"):
                            self.pcep_state = value
                            self.pcep_state.value_namespace = name_space
                            self.pcep_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "stateful"):
                            self.stateful = value
                            self.stateful.value_namespace = name_space
                            self.stateful.value_namespace_prefix = name_space_prefix


                class LastErrorRx(Entity):
                    """
                    Last PCError received
                    
                    .. attribute:: pc_error_type
                    
                    	PCEP Error type
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: pc_error_value
                    
                    	PCEP Error Value
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx, self).__init__()

                        self.yang_name = "last-error-rx"
                        self.yang_parent_name = "detail-pcep-information"

                        self.pc_error_type = YLeaf(YType.uint8, "pc-error-type")

                        self.pc_error_value = YLeaf(YType.uint8, "pc-error-value")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pc_error_type",
                                        "pc_error_value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.pc_error_type.is_set or
                            self.pc_error_value.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pc_error_type.yfilter != YFilter.not_set or
                            self.pc_error_value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-error-rx" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pc_error_type.is_set or self.pc_error_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_type.get_name_leafdata())
                        if (self.pc_error_value.is_set or self.pc_error_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "pc-error-type" or name == "pc-error-value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pc-error-type"):
                            self.pc_error_type = value
                            self.pc_error_type.value_namespace = name_space
                            self.pc_error_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "pc-error-value"):
                            self.pc_error_value = value
                            self.pc_error_value.value_namespace = name_space
                            self.pc_error_value.value_namespace_prefix = name_space_prefix


                class LastErrorTx(Entity):
                    """
                    Last PCError sent
                    
                    .. attribute:: pc_error_type
                    
                    	PCEP Error type
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: pc_error_value
                    
                    	PCEP Error Value
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx, self).__init__()

                        self.yang_name = "last-error-tx"
                        self.yang_parent_name = "detail-pcep-information"

                        self.pc_error_type = YLeaf(YType.uint8, "pc-error-type")

                        self.pc_error_value = YLeaf(YType.uint8, "pc-error-value")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pc_error_type",
                                        "pc_error_value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.pc_error_type.is_set or
                            self.pc_error_value.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pc_error_type.yfilter != YFilter.not_set or
                            self.pc_error_value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-error-tx" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pc_error_type.is_set or self.pc_error_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_type.get_name_leafdata())
                        if (self.pc_error_value.is_set or self.pc_error_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pc_error_value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "pc-error-type" or name == "pc-error-value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pc-error-type"):
                            self.pc_error_type = value
                            self.pc_error_type.value_namespace = name_space
                            self.pc_error_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "pc-error-value"):
                            self.pc_error_value = value
                            self.pc_error_value.value_namespace = name_space
                            self.pc_error_value.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.error.is_set or
                        self.keepalives.is_set or
                        self.keychain_enabled.is_set or
                        self.local_session_id.is_set or
                        self.maximum_dead_interval.is_set or
                        self.md5_enabled.is_set or
                        self.minimum_keepalive_interval.is_set or
                        self.negotiated_dead_time.is_set or
                        self.negotiated_local_keepalive.is_set or
                        self.negotiated_remote_keepalive.is_set or
                        self.pce_error_rx.is_set or
                        self.pce_error_tx.is_set or
                        self.pce_initiate_rx.is_set or
                        self.pce_initiate_tx.is_set or
                        self.pce_keepalive_rx.is_set or
                        self.pce_keepalive_tx.is_set or
                        self.pce_open_rx.is_set or
                        self.pce_open_tx.is_set or
                        self.pce_reply_rx.is_set or
                        self.pce_reply_tx.is_set or
                        self.pce_report_rx.is_set or
                        self.pce_report_tx.is_set or
                        self.pce_request_rx.is_set or
                        self.pce_request_tx.is_set or
                        self.pce_update_rx.is_set or
                        self.pce_update_tx.is_set or
                        self.pcep_up_time.is_set or
                        self.remote_session_id.is_set or
                        self.speaker_id.is_set or
                        (self.brief_pcep_information is not None and self.brief_pcep_information.has_data()) or
                        (self.last_error_rx is not None and self.last_error_rx.has_data()) or
                        (self.last_error_tx is not None and self.last_error_tx.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.error.yfilter != YFilter.not_set or
                        self.keepalives.yfilter != YFilter.not_set or
                        self.keychain_enabled.yfilter != YFilter.not_set or
                        self.local_session_id.yfilter != YFilter.not_set or
                        self.maximum_dead_interval.yfilter != YFilter.not_set or
                        self.md5_enabled.yfilter != YFilter.not_set or
                        self.minimum_keepalive_interval.yfilter != YFilter.not_set or
                        self.negotiated_dead_time.yfilter != YFilter.not_set or
                        self.negotiated_local_keepalive.yfilter != YFilter.not_set or
                        self.negotiated_remote_keepalive.yfilter != YFilter.not_set or
                        self.pce_error_rx.yfilter != YFilter.not_set or
                        self.pce_error_tx.yfilter != YFilter.not_set or
                        self.pce_initiate_rx.yfilter != YFilter.not_set or
                        self.pce_initiate_tx.yfilter != YFilter.not_set or
                        self.pce_keepalive_rx.yfilter != YFilter.not_set or
                        self.pce_keepalive_tx.yfilter != YFilter.not_set or
                        self.pce_open_rx.yfilter != YFilter.not_set or
                        self.pce_open_tx.yfilter != YFilter.not_set or
                        self.pce_reply_rx.yfilter != YFilter.not_set or
                        self.pce_reply_tx.yfilter != YFilter.not_set or
                        self.pce_report_rx.yfilter != YFilter.not_set or
                        self.pce_report_tx.yfilter != YFilter.not_set or
                        self.pce_request_rx.yfilter != YFilter.not_set or
                        self.pce_request_tx.yfilter != YFilter.not_set or
                        self.pce_update_rx.yfilter != YFilter.not_set or
                        self.pce_update_tx.yfilter != YFilter.not_set or
                        self.pcep_up_time.yfilter != YFilter.not_set or
                        self.remote_session_id.yfilter != YFilter.not_set or
                        self.speaker_id.yfilter != YFilter.not_set or
                        (self.brief_pcep_information is not None and self.brief_pcep_information.has_operation()) or
                        (self.last_error_rx is not None and self.last_error_rx.has_operation()) or
                        (self.last_error_tx is not None and self.last_error_tx.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "detail-pcep-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.error.is_set or self.error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.error.get_name_leafdata())
                    if (self.keepalives.is_set or self.keepalives.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.keepalives.get_name_leafdata())
                    if (self.keychain_enabled.is_set or self.keychain_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.keychain_enabled.get_name_leafdata())
                    if (self.local_session_id.is_set or self.local_session_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_session_id.get_name_leafdata())
                    if (self.maximum_dead_interval.is_set or self.maximum_dead_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maximum_dead_interval.get_name_leafdata())
                    if (self.md5_enabled.is_set or self.md5_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.md5_enabled.get_name_leafdata())
                    if (self.minimum_keepalive_interval.is_set or self.minimum_keepalive_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.minimum_keepalive_interval.get_name_leafdata())
                    if (self.negotiated_dead_time.is_set or self.negotiated_dead_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.negotiated_dead_time.get_name_leafdata())
                    if (self.negotiated_local_keepalive.is_set or self.negotiated_local_keepalive.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.negotiated_local_keepalive.get_name_leafdata())
                    if (self.negotiated_remote_keepalive.is_set or self.negotiated_remote_keepalive.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.negotiated_remote_keepalive.get_name_leafdata())
                    if (self.pce_error_rx.is_set or self.pce_error_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_error_rx.get_name_leafdata())
                    if (self.pce_error_tx.is_set or self.pce_error_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_error_tx.get_name_leafdata())
                    if (self.pce_initiate_rx.is_set or self.pce_initiate_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_initiate_rx.get_name_leafdata())
                    if (self.pce_initiate_tx.is_set or self.pce_initiate_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_initiate_tx.get_name_leafdata())
                    if (self.pce_keepalive_rx.is_set or self.pce_keepalive_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_keepalive_rx.get_name_leafdata())
                    if (self.pce_keepalive_tx.is_set or self.pce_keepalive_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_keepalive_tx.get_name_leafdata())
                    if (self.pce_open_rx.is_set or self.pce_open_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_open_rx.get_name_leafdata())
                    if (self.pce_open_tx.is_set or self.pce_open_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_open_tx.get_name_leafdata())
                    if (self.pce_reply_rx.is_set or self.pce_reply_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_reply_rx.get_name_leafdata())
                    if (self.pce_reply_tx.is_set or self.pce_reply_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_reply_tx.get_name_leafdata())
                    if (self.pce_report_rx.is_set or self.pce_report_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_report_rx.get_name_leafdata())
                    if (self.pce_report_tx.is_set or self.pce_report_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_report_tx.get_name_leafdata())
                    if (self.pce_request_rx.is_set or self.pce_request_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_request_rx.get_name_leafdata())
                    if (self.pce_request_tx.is_set or self.pce_request_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_request_tx.get_name_leafdata())
                    if (self.pce_update_rx.is_set or self.pce_update_rx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_update_rx.get_name_leafdata())
                    if (self.pce_update_tx.is_set or self.pce_update_tx.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pce_update_tx.get_name_leafdata())
                    if (self.pcep_up_time.is_set or self.pcep_up_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pcep_up_time.get_name_leafdata())
                    if (self.remote_session_id.is_set or self.remote_session_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_session_id.get_name_leafdata())
                    if (self.speaker_id.is_set or self.speaker_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.speaker_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-pcep-information"):
                        if (self.brief_pcep_information is None):
                            self.brief_pcep_information = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.BriefPcepInformation()
                            self.brief_pcep_information.parent = self
                            self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                        return self.brief_pcep_information

                    if (child_yang_name == "last-error-rx"):
                        if (self.last_error_rx is None):
                            self.last_error_rx = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorRx()
                            self.last_error_rx.parent = self
                            self._children_name_map["last_error_rx"] = "last-error-rx"
                        return self.last_error_rx

                    if (child_yang_name == "last-error-tx"):
                        if (self.last_error_tx is None):
                            self.last_error_tx = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation.LastErrorTx()
                            self.last_error_tx.parent = self
                            self._children_name_map["last_error_tx"] = "last-error-tx"
                        return self.last_error_tx

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-pcep-information" or name == "last-error-rx" or name == "last-error-tx" or name == "error" or name == "keepalives" or name == "keychain-enabled" or name == "local-session-id" or name == "maximum-dead-interval" or name == "md5-enabled" or name == "minimum-keepalive-interval" or name == "negotiated-dead-time" or name == "negotiated-local-keepalive" or name == "negotiated-remote-keepalive" or name == "pce-error-rx" or name == "pce-error-tx" or name == "pce-initiate-rx" or name == "pce-initiate-tx" or name == "pce-keepalive-rx" or name == "pce-keepalive-tx" or name == "pce-open-rx" or name == "pce-open-tx" or name == "pce-reply-rx" or name == "pce-reply-tx" or name == "pce-report-rx" or name == "pce-report-tx" or name == "pce-request-rx" or name == "pce-request-tx" or name == "pce-update-rx" or name == "pce-update-tx" or name == "pcep-up-time" or name == "remote-session-id" or name == "speaker-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "error"):
                        self.error = value
                        self.error.value_namespace = name_space
                        self.error.value_namespace_prefix = name_space_prefix
                    if(value_path == "keepalives"):
                        self.keepalives = value
                        self.keepalives.value_namespace = name_space
                        self.keepalives.value_namespace_prefix = name_space_prefix
                    if(value_path == "keychain-enabled"):
                        self.keychain_enabled = value
                        self.keychain_enabled.value_namespace = name_space
                        self.keychain_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-session-id"):
                        self.local_session_id = value
                        self.local_session_id.value_namespace = name_space
                        self.local_session_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "maximum-dead-interval"):
                        self.maximum_dead_interval = value
                        self.maximum_dead_interval.value_namespace = name_space
                        self.maximum_dead_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "md5-enabled"):
                        self.md5_enabled = value
                        self.md5_enabled.value_namespace = name_space
                        self.md5_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "minimum-keepalive-interval"):
                        self.minimum_keepalive_interval = value
                        self.minimum_keepalive_interval.value_namespace = name_space
                        self.minimum_keepalive_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "negotiated-dead-time"):
                        self.negotiated_dead_time = value
                        self.negotiated_dead_time.value_namespace = name_space
                        self.negotiated_dead_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "negotiated-local-keepalive"):
                        self.negotiated_local_keepalive = value
                        self.negotiated_local_keepalive.value_namespace = name_space
                        self.negotiated_local_keepalive.value_namespace_prefix = name_space_prefix
                    if(value_path == "negotiated-remote-keepalive"):
                        self.negotiated_remote_keepalive = value
                        self.negotiated_remote_keepalive.value_namespace = name_space
                        self.negotiated_remote_keepalive.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-error-rx"):
                        self.pce_error_rx = value
                        self.pce_error_rx.value_namespace = name_space
                        self.pce_error_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-error-tx"):
                        self.pce_error_tx = value
                        self.pce_error_tx.value_namespace = name_space
                        self.pce_error_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-initiate-rx"):
                        self.pce_initiate_rx = value
                        self.pce_initiate_rx.value_namespace = name_space
                        self.pce_initiate_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-initiate-tx"):
                        self.pce_initiate_tx = value
                        self.pce_initiate_tx.value_namespace = name_space
                        self.pce_initiate_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-keepalive-rx"):
                        self.pce_keepalive_rx = value
                        self.pce_keepalive_rx.value_namespace = name_space
                        self.pce_keepalive_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-keepalive-tx"):
                        self.pce_keepalive_tx = value
                        self.pce_keepalive_tx.value_namespace = name_space
                        self.pce_keepalive_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-open-rx"):
                        self.pce_open_rx = value
                        self.pce_open_rx.value_namespace = name_space
                        self.pce_open_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-open-tx"):
                        self.pce_open_tx = value
                        self.pce_open_tx.value_namespace = name_space
                        self.pce_open_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-reply-rx"):
                        self.pce_reply_rx = value
                        self.pce_reply_rx.value_namespace = name_space
                        self.pce_reply_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-reply-tx"):
                        self.pce_reply_tx = value
                        self.pce_reply_tx.value_namespace = name_space
                        self.pce_reply_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-report-rx"):
                        self.pce_report_rx = value
                        self.pce_report_rx.value_namespace = name_space
                        self.pce_report_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-report-tx"):
                        self.pce_report_tx = value
                        self.pce_report_tx.value_namespace = name_space
                        self.pce_report_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-request-rx"):
                        self.pce_request_rx = value
                        self.pce_request_rx.value_namespace = name_space
                        self.pce_request_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-request-tx"):
                        self.pce_request_tx = value
                        self.pce_request_tx.value_namespace = name_space
                        self.pce_request_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-update-rx"):
                        self.pce_update_rx = value
                        self.pce_update_rx.value_namespace = name_space
                        self.pce_update_rx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pce-update-tx"):
                        self.pce_update_tx = value
                        self.pce_update_tx.value_namespace = name_space
                        self.pce_update_tx.value_namespace_prefix = name_space_prefix
                    if(value_path == "pcep-up-time"):
                        self.pcep_up_time = value
                        self.pcep_up_time.value_namespace = name_space
                        self.pcep_up_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-session-id"):
                        self.remote_session_id = value
                        self.remote_session_id.value_namespace = name_space
                        self.remote_session_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "speaker-id"):
                        self.speaker_id = value
                        self.speaker_id.value_namespace = name_space
                        self.speaker_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.peer_address.is_set or
                    self.peer_address_xr.is_set or
                    self.peer_protocol.is_set or
                    (self.detail_pcep_information is not None and self.detail_pcep_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.peer_address_xr.yfilter != YFilter.not_set or
                    self.peer_protocol.yfilter != YFilter.not_set or
                    (self.detail_pcep_information is not None and self.detail_pcep_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-detail-info" + "[peer-address='" + self.peer_address.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/peer-detail-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.peer_address_xr.is_set or self.peer_address_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address_xr.get_name_leafdata())
                if (self.peer_protocol.is_set or self.peer_protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_protocol.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "detail-pcep-information"):
                    if (self.detail_pcep_information is None):
                        self.detail_pcep_information = Pce.PeerDetailInfos.PeerDetailInfo.DetailPcepInformation()
                        self.detail_pcep_information.parent = self
                        self._children_name_map["detail_pcep_information"] = "detail-pcep-information"
                    return self.detail_pcep_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "detail-pcep-information" or name == "peer-address" or name == "peer-address-xr" or name == "peer-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-address-xr"):
                    self.peer_address_xr = value
                    self.peer_address_xr.value_namespace = name_space
                    self.peer_address_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-protocol"):
                    self.peer_protocol = value
                    self.peer_protocol.value_namespace = name_space
                    self.peer_protocol.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.peer_detail_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.peer_detail_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "peer-detail-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "peer-detail-info"):
                for c in self.peer_detail_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.PeerDetailInfos.PeerDetailInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.peer_detail_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "peer-detail-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TopologyNodes(Entity):
        """
        Node database in XTC
        
        .. attribute:: topology_node
        
        	Node information
        	**type**\: list of    :py:class:`TopologyNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.TopologyNodes, self).__init__()

            self.yang_name = "topology-nodes"
            self.yang_parent_name = "pce"

            self.topology_node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.TopologyNodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.TopologyNodes, self).__setattr__(name, value)


        class TopologyNode(Entity):
            """
            Node information
            
            .. attribute:: node_identifier  <key>
            
            	Node Identifier
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: ipv4_link
            
            	IPv4 Link information
            	**type**\: list of    :py:class:`Ipv4Link <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link>`
            
            .. attribute:: ipv6_link
            
            	IPv6 Link information
            	**type**\: list of    :py:class:`Ipv6Link <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link>`
            
            .. attribute:: node_identifier_xr
            
            	Node identifier
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_protocol_identifier
            
            	Node protocol identifier
            	**type**\:   :py:class:`NodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier>`
            
            .. attribute:: overload
            
            	Node Overload Bit
            	**type**\:  bool
            
            .. attribute:: prefix_sid
            
            	Prefix SIDs
            	**type**\: list of    :py:class:`PrefixSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.PrefixSid>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.TopologyNodes.TopologyNode, self).__init__()

                self.yang_name = "topology-node"
                self.yang_parent_name = "topology-nodes"

                self.node_identifier = YLeaf(YType.int32, "node-identifier")

                self.node_identifier_xr = YLeaf(YType.uint32, "node-identifier-xr")

                self.overload = YLeaf(YType.boolean, "overload")

                self.node_protocol_identifier = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier()
                self.node_protocol_identifier.parent = self
                self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                self._children_yang_names.add("node-protocol-identifier")

                self.ipv4_link = YList(self)
                self.ipv6_link = YList(self)
                self.prefix_sid = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_identifier",
                                "node_identifier_xr",
                                "overload") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.TopologyNodes.TopologyNode, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.TopologyNodes.TopologyNode, self).__setattr__(name, value)


            class NodeProtocolIdentifier(Entity):
                """
                Node protocol identifier
                
                .. attribute:: igp_information
                
                	IGP information
                	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation>`
                
                .. attribute:: ipv4bgp_router_id
                
                	IPv4 TE router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4bgp_router_id_set
                
                	True if IPv4 BGP router ID is set
                	**type**\:  bool
                
                .. attribute:: ipv4te_router_id
                
                	IPv4 BGP router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4te_router_id_set
                
                	True if IPv4 TE router ID is set
                	**type**\:  bool
                
                .. attribute:: node_name
                
                	Node Name
                	**type**\:  str
                
                .. attribute:: srgb_information
                
                	SRGB information
                	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation>`
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier, self).__init__()

                    self.yang_name = "node-protocol-identifier"
                    self.yang_parent_name = "topology-node"

                    self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                    self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                    self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                    self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                    self.node_name = YLeaf(YType.str, "node-name")

                    self.igp_information = YList(self)
                    self.srgb_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ipv4bgp_router_id",
                                    "ipv4bgp_router_id_set",
                                    "ipv4te_router_id",
                                    "ipv4te_router_id_set",
                                    "node_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier, self).__setattr__(name, value)


                class IgpInformation(Entity):
                    """
                    IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation, self).__init__()

                        self.yang_name = "igp-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class SrgbInformation(Entity):
                    """
                    SRGB information
                    
                    .. attribute:: igp_srgb
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                    
                    .. attribute:: size
                    
                    	SRGB size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: start
                    
                    	SRGB start
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation, self).__init__()

                        self.yang_name = "srgb-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.size = YLeaf(YType.uint32, "size")

                        self.start = YLeaf(YType.uint32, "start")

                        self.igp_srgb = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                        self.igp_srgb.parent = self
                        self._children_name_map["igp_srgb"] = "igp-srgb"
                        self._children_yang_names.add("igp-srgb")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("size",
                                        "start") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                    class IgpSrgb(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                            self.yang_name = "igp-srgb"
                            self.yang_parent_name = "srgb-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp-srgb"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp-srgb"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp-srgb"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-srgb" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.size.is_set or
                            self.start.is_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.size.yfilter != YFilter.not_set or
                            self.start.yfilter != YFilter.not_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "srgb-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.size.get_name_leafdata())
                        if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.start.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-srgb"):
                            if (self.igp_srgb is None):
                                self.igp_srgb = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                self.igp_srgb.parent = self
                                self._children_name_map["igp_srgb"] = "igp-srgb"
                            return self.igp_srgb

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-srgb" or name == "size" or name == "start"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "size"):
                            self.size = value
                            self.size.value_namespace = name_space
                            self.size.value_namespace_prefix = name_space_prefix
                        if(value_path == "start"):
                            self.start = value
                            self.start.value_namespace = name_space
                            self.start.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.igp_information:
                        if (c.has_data()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.ipv4bgp_router_id.is_set or
                        self.ipv4bgp_router_id_set.is_set or
                        self.ipv4te_router_id.is_set or
                        self.ipv4te_router_id_set.is_set or
                        self.node_name.is_set)

                def has_operation(self):
                    for c in self.igp_information:
                        if (c.has_operation()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                        self.ipv4te_router_id.yfilter != YFilter.not_set or
                        self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                        self.node_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "node-protocol-identifier" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                    if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                    if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                    if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "igp-information"):
                        for c in self.igp_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.IgpInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.igp_information.append(c)
                        return c

                    if (child_yang_name == "srgb-information"):
                        for c in self.srgb_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier.SrgbInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.srgb_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ipv4bgp-router-id"):
                        self.ipv4bgp_router_id = value
                        self.ipv4bgp_router_id.value_namespace = name_space
                        self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4bgp-router-id-set"):
                        self.ipv4bgp_router_id_set = value
                        self.ipv4bgp_router_id_set.value_namespace = name_space
                        self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id"):
                        self.ipv4te_router_id = value
                        self.ipv4te_router_id.value_namespace = name_space
                        self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id-set"):
                        self.ipv4te_router_id_set = value
                        self.ipv4te_router_id_set.value_namespace = name_space
                        self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-name"):
                        self.node_name = value
                        self.node_name.value_namespace = name_space
                        self.node_name.value_namespace_prefix = name_space_prefix


            class PrefixSid(Entity):
                """
                Prefix SIDs
                
                .. attribute:: domain_identifier
                
                	Domain identifier
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: eflag
                
                	E Flag
                	**type**\:  bool
                
                .. attribute:: lflag
                
                	L Flag
                	**type**\:  bool
                
                .. attribute:: mpls_label
                
                	MPLS Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nflag
                
                	N Flag
                	**type**\:  bool
                
                .. attribute:: pflag
                
                	P Flag
                	**type**\:  bool
                
                .. attribute:: rflag
                
                	R Flag
                	**type**\:  bool
                
                .. attribute:: sid_prefix
                
                	Prefix
                	**type**\:   :py:class:`SidPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.PrefixSid.SidPrefix>`
                
                .. attribute:: sid_type
                
                	SID Type
                	**type**\:   :py:class:`Sid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Sid>`
                
                .. attribute:: vflag
                
                	V Flag
                	**type**\:  bool
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.TopologyNodes.TopologyNode.PrefixSid, self).__init__()

                    self.yang_name = "prefix-sid"
                    self.yang_parent_name = "topology-node"

                    self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                    self.eflag = YLeaf(YType.boolean, "eflag")

                    self.lflag = YLeaf(YType.boolean, "lflag")

                    self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                    self.nflag = YLeaf(YType.boolean, "nflag")

                    self.pflag = YLeaf(YType.boolean, "pflag")

                    self.rflag = YLeaf(YType.boolean, "rflag")

                    self.sid_type = YLeaf(YType.enumeration, "sid-type")

                    self.vflag = YLeaf(YType.boolean, "vflag")

                    self.sid_prefix = Pce.TopologyNodes.TopologyNode.PrefixSid.SidPrefix()
                    self.sid_prefix.parent = self
                    self._children_name_map["sid_prefix"] = "sid-prefix"
                    self._children_yang_names.add("sid-prefix")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain_identifier",
                                    "eflag",
                                    "lflag",
                                    "mpls_label",
                                    "nflag",
                                    "pflag",
                                    "rflag",
                                    "sid_type",
                                    "vflag") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.TopologyNodes.TopologyNode.PrefixSid, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.TopologyNodes.TopologyNode.PrefixSid, self).__setattr__(name, value)


                class SidPrefix(Entity):
                    """
                    Prefix
                    
                    .. attribute:: af_name
                    
                    	AFName
                    	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.PrefixSid.SidPrefix, self).__init__()

                        self.yang_name = "sid-prefix"
                        self.yang_parent_name = "prefix-sid"

                        self.af_name = YLeaf(YType.enumeration, "af-name")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("af_name",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.PrefixSid.SidPrefix, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.PrefixSid.SidPrefix, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.af_name.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.af_name.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sid-prefix" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.af_name.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "af-name"):
                            self.af_name = value
                            self.af_name.value_namespace = name_space
                            self.af_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.domain_identifier.is_set or
                        self.eflag.is_set or
                        self.lflag.is_set or
                        self.mpls_label.is_set or
                        self.nflag.is_set or
                        self.pflag.is_set or
                        self.rflag.is_set or
                        self.sid_type.is_set or
                        self.vflag.is_set or
                        (self.sid_prefix is not None and self.sid_prefix.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain_identifier.yfilter != YFilter.not_set or
                        self.eflag.yfilter != YFilter.not_set or
                        self.lflag.yfilter != YFilter.not_set or
                        self.mpls_label.yfilter != YFilter.not_set or
                        self.nflag.yfilter != YFilter.not_set or
                        self.pflag.yfilter != YFilter.not_set or
                        self.rflag.yfilter != YFilter.not_set or
                        self.sid_type.yfilter != YFilter.not_set or
                        self.vflag.yfilter != YFilter.not_set or
                        (self.sid_prefix is not None and self.sid_prefix.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "prefix-sid" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain_identifier.get_name_leafdata())
                    if (self.eflag.is_set or self.eflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.eflag.get_name_leafdata())
                    if (self.lflag.is_set or self.lflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lflag.get_name_leafdata())
                    if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mpls_label.get_name_leafdata())
                    if (self.nflag.is_set or self.nflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nflag.get_name_leafdata())
                    if (self.pflag.is_set or self.pflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pflag.get_name_leafdata())
                    if (self.rflag.is_set or self.rflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rflag.get_name_leafdata())
                    if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sid_type.get_name_leafdata())
                    if (self.vflag.is_set or self.vflag.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vflag.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "sid-prefix"):
                        if (self.sid_prefix is None):
                            self.sid_prefix = Pce.TopologyNodes.TopologyNode.PrefixSid.SidPrefix()
                            self.sid_prefix.parent = self
                            self._children_name_map["sid_prefix"] = "sid-prefix"
                        return self.sid_prefix

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "sid-prefix" or name == "domain-identifier" or name == "eflag" or name == "lflag" or name == "mpls-label" or name == "nflag" or name == "pflag" or name == "rflag" or name == "sid-type" or name == "vflag"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain-identifier"):
                        self.domain_identifier = value
                        self.domain_identifier.value_namespace = name_space
                        self.domain_identifier.value_namespace_prefix = name_space_prefix
                    if(value_path == "eflag"):
                        self.eflag = value
                        self.eflag.value_namespace = name_space
                        self.eflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "lflag"):
                        self.lflag = value
                        self.lflag.value_namespace = name_space
                        self.lflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "mpls-label"):
                        self.mpls_label = value
                        self.mpls_label.value_namespace = name_space
                        self.mpls_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "nflag"):
                        self.nflag = value
                        self.nflag.value_namespace = name_space
                        self.nflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "pflag"):
                        self.pflag = value
                        self.pflag.value_namespace = name_space
                        self.pflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "rflag"):
                        self.rflag = value
                        self.rflag.value_namespace = name_space
                        self.rflag.value_namespace_prefix = name_space_prefix
                    if(value_path == "sid-type"):
                        self.sid_type = value
                        self.sid_type.value_namespace = name_space
                        self.sid_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "vflag"):
                        self.vflag = value
                        self.vflag.value_namespace = name_space
                        self.vflag.value_namespace_prefix = name_space_prefix


            class Ipv4Link(Entity):
                """
                IPv4 Link information
                
                .. attribute:: adjacency_sid
                
                	Adjacency SIDs
                	**type**\: list of    :py:class:`AdjacencySid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid>`
                
                .. attribute:: igp_metric
                
                	IGP Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_igp_information
                
                	Local node IGP information
                	**type**\:   :py:class:`LocalIgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation>`
                
                .. attribute:: local_ipv4_address
                
                	Local IPv4 address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: max_reservable_bandwidth
                
                	Max Reservable bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: maximum_link_bandwidth
                
                	Max link bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: remote_ipv4_address
                
                	Remote IPv4 address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: remote_node_protocol_identifier
                
                	Remote node protocol identifier
                	**type**\:   :py:class:`RemoteNodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier>`
                
                .. attribute:: srlgs
                
                	SRLG Values
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_metric
                
                	TE Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link, self).__init__()

                    self.yang_name = "ipv4-link"
                    self.yang_parent_name = "topology-node"

                    self.igp_metric = YLeaf(YType.uint32, "igp-metric")

                    self.local_ipv4_address = YLeaf(YType.str, "local-ipv4-address")

                    self.max_reservable_bandwidth = YLeaf(YType.uint64, "max-reservable-bandwidth")

                    self.maximum_link_bandwidth = YLeaf(YType.uint64, "maximum-link-bandwidth")

                    self.remote_ipv4_address = YLeaf(YType.str, "remote-ipv4-address")

                    self.srlgs = YLeafList(YType.uint32, "srlgs")

                    self.te_metric = YLeaf(YType.uint32, "te-metric")

                    self.local_igp_information = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation()
                    self.local_igp_information.parent = self
                    self._children_name_map["local_igp_information"] = "local-igp-information"
                    self._children_yang_names.add("local-igp-information")

                    self.remote_node_protocol_identifier = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier()
                    self.remote_node_protocol_identifier.parent = self
                    self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                    self._children_yang_names.add("remote-node-protocol-identifier")

                    self.adjacency_sid = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("igp_metric",
                                    "local_ipv4_address",
                                    "max_reservable_bandwidth",
                                    "maximum_link_bandwidth",
                                    "remote_ipv4_address",
                                    "srlgs",
                                    "te_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link, self).__setattr__(name, value)


                class LocalIgpInformation(Entity):
                    """
                    Local node IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation, self).__init__()

                        self.yang_name = "local-igp-information"
                        self.yang_parent_name = "ipv4-link"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "local-igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "local-igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class RemoteNodeProtocolIdentifier(Entity):
                    """
                    Remote node protocol identifier
                    
                    .. attribute:: igp_information
                    
                    	IGP information
                    	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation>`
                    
                    .. attribute:: ipv4bgp_router_id
                    
                    	IPv4 TE router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4bgp_router_id_set
                    
                    	True if IPv4 BGP router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: ipv4te_router_id
                    
                    	IPv4 BGP router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4te_router_id_set
                    
                    	True if IPv4 TE router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: node_name
                    
                    	Node Name
                    	**type**\:  str
                    
                    .. attribute:: srgb_information
                    
                    	SRGB information
                    	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier, self).__init__()

                        self.yang_name = "remote-node-protocol-identifier"
                        self.yang_parent_name = "ipv4-link"

                        self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                        self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                        self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                        self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                        self.node_name = YLeaf(YType.str, "node-name")

                        self.igp_information = YList(self)
                        self.srgb_information = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ipv4bgp_router_id",
                                        "ipv4bgp_router_id_set",
                                        "ipv4te_router_id",
                                        "ipv4te_router_id_set",
                                        "node_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)


                    class IgpInformation(Entity):
                        """
                        IGP information
                        
                        .. attribute:: autonomous_system_number
                        
                        	Autonomous System Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: domain_identifier
                        
                        	Domain identifier
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: igp
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__init__()

                            self.yang_name = "igp-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                            self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                            self.igp = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                            self.igp.parent = self
                            self._children_name_map["igp"] = "igp"
                            self._children_yang_names.add("igp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("autonomous_system_number",
                                            "domain_identifier") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                        class Igp(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                                self.yang_name = "igp"
                                self.yang_parent_name = "igp-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.autonomous_system_number.is_set or
                                self.domain_identifier.is_set or
                                (self.igp is not None and self.igp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.autonomous_system_number.yfilter != YFilter.not_set or
                                self.domain_identifier.yfilter != YFilter.not_set or
                                (self.igp is not None and self.igp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                            if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp"):
                                if (self.igp is None):
                                    self.igp = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                                    self.igp.parent = self
                                    self._children_name_map["igp"] = "igp"
                                return self.igp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "autonomous-system-number"):
                                self.autonomous_system_number = value
                                self.autonomous_system_number.value_namespace = name_space
                                self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "domain-identifier"):
                                self.domain_identifier = value
                                self.domain_identifier.value_namespace = name_space
                                self.domain_identifier.value_namespace_prefix = name_space_prefix


                    class SrgbInformation(Entity):
                        """
                        SRGB information
                        
                        .. attribute:: igp_srgb
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                        
                        .. attribute:: size
                        
                        	SRGB size
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start
                        
                        	SRGB start
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__init__()

                            self.yang_name = "srgb-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.size = YLeaf(YType.uint32, "size")

                            self.start = YLeaf(YType.uint32, "start")

                            self.igp_srgb = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                            self.igp_srgb.parent = self
                            self._children_name_map["igp_srgb"] = "igp-srgb"
                            self._children_yang_names.add("igp-srgb")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("size",
                                            "start") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                        class IgpSrgb(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                                self.yang_name = "igp-srgb"
                                self.yang_parent_name = "srgb-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp-srgb"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp-srgb"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp-srgb"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp-srgb" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.size.is_set or
                                self.start.is_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.size.yfilter != YFilter.not_set or
                                self.start.yfilter != YFilter.not_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "srgb-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.size.get_name_leafdata())
                            if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp-srgb"):
                                if (self.igp_srgb is None):
                                    self.igp_srgb = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                    self.igp_srgb.parent = self
                                    self._children_name_map["igp_srgb"] = "igp-srgb"
                                return self.igp_srgb

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp-srgb" or name == "size" or name == "start"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "size"):
                                self.size = value
                                self.size.value_namespace = name_space
                                self.size.value_namespace_prefix = name_space_prefix
                            if(value_path == "start"):
                                self.start = value
                                self.start.value_namespace = name_space
                                self.start.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.igp_information:
                            if (c.has_data()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_data()):
                                return True
                        return (
                            self.ipv4bgp_router_id.is_set or
                            self.ipv4bgp_router_id_set.is_set or
                            self.ipv4te_router_id.is_set or
                            self.ipv4te_router_id_set.is_set or
                            self.node_name.is_set)

                    def has_operation(self):
                        for c in self.igp_information:
                            if (c.has_operation()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                            self.ipv4te_router_id.yfilter != YFilter.not_set or
                            self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                            self.node_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-node-protocol-identifier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                        if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                        if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                        if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.node_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-information"):
                            for c in self.igp_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.IgpInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.igp_information.append(c)
                            return c

                        if (child_yang_name == "srgb-information"):
                            for c in self.srgb_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier.SrgbInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.srgb_information.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ipv4bgp-router-id"):
                            self.ipv4bgp_router_id = value
                            self.ipv4bgp_router_id.value_namespace = name_space
                            self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4bgp-router-id-set"):
                            self.ipv4bgp_router_id_set = value
                            self.ipv4bgp_router_id_set.value_namespace = name_space
                            self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id"):
                            self.ipv4te_router_id = value
                            self.ipv4te_router_id.value_namespace = name_space
                            self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id-set"):
                            self.ipv4te_router_id_set = value
                            self.ipv4te_router_id_set.value_namespace = name_space
                            self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "node-name"):
                            self.node_name = value
                            self.node_name.value_namespace = name_space
                            self.node_name.value_namespace_prefix = name_space_prefix


                class AdjacencySid(Entity):
                    """
                    Adjacency SIDs
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: eflag
                    
                    	E Flag
                    	**type**\:  bool
                    
                    .. attribute:: lflag
                    
                    	L Flag
                    	**type**\:  bool
                    
                    .. attribute:: mpls_label
                    
                    	MPLS Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: nflag
                    
                    	N Flag
                    	**type**\:  bool
                    
                    .. attribute:: pflag
                    
                    	P Flag
                    	**type**\:  bool
                    
                    .. attribute:: rflag
                    
                    	R Flag
                    	**type**\:  bool
                    
                    .. attribute:: sid_prefix
                    
                    	Prefix
                    	**type**\:   :py:class:`SidPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix>`
                    
                    .. attribute:: sid_type
                    
                    	SID Type
                    	**type**\:   :py:class:`Sid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Sid>`
                    
                    .. attribute:: vflag
                    
                    	V Flag
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid, self).__init__()

                        self.yang_name = "adjacency-sid"
                        self.yang_parent_name = "ipv4-link"

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.eflag = YLeaf(YType.boolean, "eflag")

                        self.lflag = YLeaf(YType.boolean, "lflag")

                        self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                        self.nflag = YLeaf(YType.boolean, "nflag")

                        self.pflag = YLeaf(YType.boolean, "pflag")

                        self.rflag = YLeaf(YType.boolean, "rflag")

                        self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        self.vflag = YLeaf(YType.boolean, "vflag")

                        self.sid_prefix = Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix()
                        self.sid_prefix.parent = self
                        self._children_name_map["sid_prefix"] = "sid-prefix"
                        self._children_yang_names.add("sid-prefix")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("domain_identifier",
                                        "eflag",
                                        "lflag",
                                        "mpls_label",
                                        "nflag",
                                        "pflag",
                                        "rflag",
                                        "sid_type",
                                        "vflag") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid, self).__setattr__(name, value)


                    class SidPrefix(Entity):
                        """
                        Prefix
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix, self).__init__()

                            self.yang_name = "sid-prefix"
                            self.yang_parent_name = "adjacency-sid"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sid-prefix" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.domain_identifier.is_set or
                            self.eflag.is_set or
                            self.lflag.is_set or
                            self.mpls_label.is_set or
                            self.nflag.is_set or
                            self.pflag.is_set or
                            self.rflag.is_set or
                            self.sid_type.is_set or
                            self.vflag.is_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            self.eflag.yfilter != YFilter.not_set or
                            self.lflag.yfilter != YFilter.not_set or
                            self.mpls_label.yfilter != YFilter.not_set or
                            self.nflag.yfilter != YFilter.not_set or
                            self.pflag.yfilter != YFilter.not_set or
                            self.rflag.yfilter != YFilter.not_set or
                            self.sid_type.yfilter != YFilter.not_set or
                            self.vflag.yfilter != YFilter.not_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "adjacency-sid" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())
                        if (self.eflag.is_set or self.eflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eflag.get_name_leafdata())
                        if (self.lflag.is_set or self.lflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lflag.get_name_leafdata())
                        if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_label.get_name_leafdata())
                        if (self.nflag.is_set or self.nflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nflag.get_name_leafdata())
                        if (self.pflag.is_set or self.pflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pflag.get_name_leafdata())
                        if (self.rflag.is_set or self.rflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rflag.get_name_leafdata())
                        if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sid_type.get_name_leafdata())
                        if (self.vflag.is_set or self.vflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vflag.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sid-prefix"):
                            if (self.sid_prefix is None):
                                self.sid_prefix = Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid.SidPrefix()
                                self.sid_prefix.parent = self
                                self._children_name_map["sid_prefix"] = "sid-prefix"
                            return self.sid_prefix

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sid-prefix" or name == "domain-identifier" or name == "eflag" or name == "lflag" or name == "mpls-label" or name == "nflag" or name == "pflag" or name == "rflag" or name == "sid-type" or name == "vflag"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix
                        if(value_path == "eflag"):
                            self.eflag = value
                            self.eflag.value_namespace = name_space
                            self.eflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "lflag"):
                            self.lflag = value
                            self.lflag.value_namespace = name_space
                            self.lflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "mpls-label"):
                            self.mpls_label = value
                            self.mpls_label.value_namespace = name_space
                            self.mpls_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "nflag"):
                            self.nflag = value
                            self.nflag.value_namespace = name_space
                            self.nflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "pflag"):
                            self.pflag = value
                            self.pflag.value_namespace = name_space
                            self.pflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "rflag"):
                            self.rflag = value
                            self.rflag.value_namespace = name_space
                            self.rflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "sid-type"):
                            self.sid_type = value
                            self.sid_type.value_namespace = name_space
                            self.sid_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vflag"):
                            self.vflag = value
                            self.vflag.value_namespace = name_space
                            self.vflag.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.adjacency_sid:
                        if (c.has_data()):
                            return True
                    for leaf in self.srlgs.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.igp_metric.is_set or
                        self.local_ipv4_address.is_set or
                        self.max_reservable_bandwidth.is_set or
                        self.maximum_link_bandwidth.is_set or
                        self.remote_ipv4_address.is_set or
                        self.te_metric.is_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_data()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_data()))

                def has_operation(self):
                    for c in self.adjacency_sid:
                        if (c.has_operation()):
                            return True
                    for leaf in self.srlgs.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.igp_metric.yfilter != YFilter.not_set or
                        self.local_ipv4_address.yfilter != YFilter.not_set or
                        self.max_reservable_bandwidth.yfilter != YFilter.not_set or
                        self.maximum_link_bandwidth.yfilter != YFilter.not_set or
                        self.remote_ipv4_address.yfilter != YFilter.not_set or
                        self.srlgs.yfilter != YFilter.not_set or
                        self.te_metric.yfilter != YFilter.not_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_operation()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv4-link" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.igp_metric.is_set or self.igp_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_metric.get_name_leafdata())
                    if (self.local_ipv4_address.is_set or self.local_ipv4_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_ipv4_address.get_name_leafdata())
                    if (self.max_reservable_bandwidth.is_set or self.max_reservable_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.max_reservable_bandwidth.get_name_leafdata())
                    if (self.maximum_link_bandwidth.is_set or self.maximum_link_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maximum_link_bandwidth.get_name_leafdata())
                    if (self.remote_ipv4_address.is_set or self.remote_ipv4_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_ipv4_address.get_name_leafdata())
                    if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_metric.get_name_leafdata())

                    leaf_name_data.extend(self.srlgs.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "adjacency-sid"):
                        for c in self.adjacency_sid:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.TopologyNodes.TopologyNode.Ipv4Link.AdjacencySid()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.adjacency_sid.append(c)
                        return c

                    if (child_yang_name == "local-igp-information"):
                        if (self.local_igp_information is None):
                            self.local_igp_information = Pce.TopologyNodes.TopologyNode.Ipv4Link.LocalIgpInformation()
                            self.local_igp_information.parent = self
                            self._children_name_map["local_igp_information"] = "local-igp-information"
                        return self.local_igp_information

                    if (child_yang_name == "remote-node-protocol-identifier"):
                        if (self.remote_node_protocol_identifier is None):
                            self.remote_node_protocol_identifier = Pce.TopologyNodes.TopologyNode.Ipv4Link.RemoteNodeProtocolIdentifier()
                            self.remote_node_protocol_identifier.parent = self
                            self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                        return self.remote_node_protocol_identifier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjacency-sid" or name == "local-igp-information" or name == "remote-node-protocol-identifier" or name == "igp-metric" or name == "local-ipv4-address" or name == "max-reservable-bandwidth" or name == "maximum-link-bandwidth" or name == "remote-ipv4-address" or name == "srlgs" or name == "te-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "igp-metric"):
                        self.igp_metric = value
                        self.igp_metric.value_namespace = name_space
                        self.igp_metric.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-ipv4-address"):
                        self.local_ipv4_address = value
                        self.local_ipv4_address.value_namespace = name_space
                        self.local_ipv4_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "max-reservable-bandwidth"):
                        self.max_reservable_bandwidth = value
                        self.max_reservable_bandwidth.value_namespace = name_space
                        self.max_reservable_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "maximum-link-bandwidth"):
                        self.maximum_link_bandwidth = value
                        self.maximum_link_bandwidth.value_namespace = name_space
                        self.maximum_link_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-ipv4-address"):
                        self.remote_ipv4_address = value
                        self.remote_ipv4_address.value_namespace = name_space
                        self.remote_ipv4_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "srlgs"):
                        self.srlgs.append(value)
                    if(value_path == "te-metric"):
                        self.te_metric = value
                        self.te_metric.value_namespace = name_space
                        self.te_metric.value_namespace_prefix = name_space_prefix


            class Ipv6Link(Entity):
                """
                IPv6 Link information
                
                .. attribute:: adjacency_sid
                
                	Adjacency SIDs
                	**type**\: list of    :py:class:`AdjacencySid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid>`
                
                .. attribute:: igp_metric
                
                	IGP Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_igp_information
                
                	Local node IGP information
                	**type**\:   :py:class:`LocalIgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation>`
                
                .. attribute:: local_ipv6_address
                
                	Local IPv6 address
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: max_reservable_bandwidth
                
                	Max Reservable bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: maximum_link_bandwidth
                
                	Max link bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: remote_ipv6_address
                
                	Remote IPv6 address
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: remote_node_protocol_identifier
                
                	Remote node protocol identifier
                	**type**\:   :py:class:`RemoteNodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier>`
                
                .. attribute:: te_metric
                
                	TE Metric
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link, self).__init__()

                    self.yang_name = "ipv6-link"
                    self.yang_parent_name = "topology-node"

                    self.igp_metric = YLeaf(YType.uint32, "igp-metric")

                    self.local_ipv6_address = YLeaf(YType.str, "local-ipv6-address")

                    self.max_reservable_bandwidth = YLeaf(YType.uint64, "max-reservable-bandwidth")

                    self.maximum_link_bandwidth = YLeaf(YType.uint64, "maximum-link-bandwidth")

                    self.remote_ipv6_address = YLeaf(YType.str, "remote-ipv6-address")

                    self.te_metric = YLeaf(YType.uint32, "te-metric")

                    self.local_igp_information = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation()
                    self.local_igp_information.parent = self
                    self._children_name_map["local_igp_information"] = "local-igp-information"
                    self._children_yang_names.add("local-igp-information")

                    self.remote_node_protocol_identifier = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier()
                    self.remote_node_protocol_identifier.parent = self
                    self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                    self._children_yang_names.add("remote-node-protocol-identifier")

                    self.adjacency_sid = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("igp_metric",
                                    "local_ipv6_address",
                                    "max_reservable_bandwidth",
                                    "maximum_link_bandwidth",
                                    "remote_ipv6_address",
                                    "te_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link, self).__setattr__(name, value)


                class LocalIgpInformation(Entity):
                    """
                    Local node IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation, self).__init__()

                        self.yang_name = "local-igp-information"
                        self.yang_parent_name = "ipv6-link"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "local-igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "local-igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class RemoteNodeProtocolIdentifier(Entity):
                    """
                    Remote node protocol identifier
                    
                    .. attribute:: igp_information
                    
                    	IGP information
                    	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation>`
                    
                    .. attribute:: ipv4bgp_router_id
                    
                    	IPv4 TE router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4bgp_router_id_set
                    
                    	True if IPv4 BGP router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: ipv4te_router_id
                    
                    	IPv4 BGP router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv4te_router_id_set
                    
                    	True if IPv4 TE router ID is set
                    	**type**\:  bool
                    
                    .. attribute:: node_name
                    
                    	Node Name
                    	**type**\:  str
                    
                    .. attribute:: srgb_information
                    
                    	SRGB information
                    	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier, self).__init__()

                        self.yang_name = "remote-node-protocol-identifier"
                        self.yang_parent_name = "ipv6-link"

                        self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                        self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                        self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                        self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                        self.node_name = YLeaf(YType.str, "node-name")

                        self.igp_information = YList(self)
                        self.srgb_information = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ipv4bgp_router_id",
                                        "ipv4bgp_router_id_set",
                                        "ipv4te_router_id",
                                        "ipv4te_router_id_set",
                                        "node_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier, self).__setattr__(name, value)


                    class IgpInformation(Entity):
                        """
                        IGP information
                        
                        .. attribute:: autonomous_system_number
                        
                        	Autonomous System Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: domain_identifier
                        
                        	Domain identifier
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: igp
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__init__()

                            self.yang_name = "igp-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                            self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                            self.igp = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                            self.igp.parent = self
                            self._children_name_map["igp"] = "igp"
                            self._children_yang_names.add("igp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("autonomous_system_number",
                                            "domain_identifier") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                        class Igp(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                                self.yang_name = "igp"
                                self.yang_parent_name = "igp-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.autonomous_system_number.is_set or
                                self.domain_identifier.is_set or
                                (self.igp is not None and self.igp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.autonomous_system_number.yfilter != YFilter.not_set or
                                self.domain_identifier.yfilter != YFilter.not_set or
                                (self.igp is not None and self.igp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                            if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp"):
                                if (self.igp is None):
                                    self.igp = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation.Igp()
                                    self.igp.parent = self
                                    self._children_name_map["igp"] = "igp"
                                return self.igp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "autonomous-system-number"):
                                self.autonomous_system_number = value
                                self.autonomous_system_number.value_namespace = name_space
                                self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "domain-identifier"):
                                self.domain_identifier = value
                                self.domain_identifier.value_namespace = name_space
                                self.domain_identifier.value_namespace_prefix = name_space_prefix


                    class SrgbInformation(Entity):
                        """
                        SRGB information
                        
                        .. attribute:: igp_srgb
                        
                        	IGP\-specific information
                        	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                        
                        .. attribute:: size
                        
                        	SRGB size
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start
                        
                        	SRGB start
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__init__()

                            self.yang_name = "srgb-information"
                            self.yang_parent_name = "remote-node-protocol-identifier"

                            self.size = YLeaf(YType.uint32, "size")

                            self.start = YLeaf(YType.uint32, "start")

                            self.igp_srgb = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                            self.igp_srgb.parent = self
                            self._children_name_map["igp_srgb"] = "igp-srgb"
                            self._children_yang_names.add("igp-srgb")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("size",
                                            "start") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                        class IgpSrgb(Entity):
                            """
                            IGP\-specific information
                            
                            .. attribute:: bgp
                            
                            	BGP information
                            	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                            
                            .. attribute:: igp_id
                            
                            	IGP ID
                            	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                            
                            .. attribute:: isis
                            
                            	ISIS information
                            	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                            
                            .. attribute:: ospf
                            
                            	OSPF information
                            	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                                self.yang_name = "igp-srgb"
                                self.yang_parent_name = "srgb-information"

                                self.igp_id = YLeaf(YType.enumeration, "igp-id")

                                self.bgp = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.isis = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.ospf = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                            class Isis(Entity):
                                """
                                ISIS information
                                
                                .. attribute:: level
                                
                                	ISIS level
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: system_id
                                
                                	ISIS system ID
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "igp-srgb"

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.system_id = YLeaf(YType.str, "system-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "system_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.system_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.system_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.system_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "system-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "system-id"):
                                        self.system_id = value
                                        self.system_id.value_namespace = name_space
                                        self.system_id.value_namespace_prefix = name_space_prefix


                            class Ospf(Entity):
                                """
                                OSPF information
                                
                                .. attribute:: area
                                
                                	OSPF area
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	OSPF router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "igp-srgb"

                                    self.area = YLeaf(YType.uint32, "area")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.area.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area"):
                                        self.area = value
                                        self.area.value_namespace = name_space
                                        self.area.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                BGP information
                                
                                .. attribute:: confed_asn
                                
                                	Confederation ASN
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: router_id
                                
                                	BGP router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-xtc-oper'
                                _revision = '2016-05-31'

                                def __init__(self):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "igp-srgb"

                                    self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("confed_asn",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.confed_asn.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.confed_asn.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "confed-asn" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "confed-asn"):
                                        self.confed_asn = value
                                        self.confed_asn.value_namespace = name_space
                                        self.confed_asn.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_id.is_set or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_id.yfilter != YFilter.not_set or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp-srgb" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-id"):
                                    self.igp_id = value
                                    self.igp_id.value_namespace = name_space
                                    self.igp_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.size.is_set or
                                self.start.is_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.size.yfilter != YFilter.not_set or
                                self.start.yfilter != YFilter.not_set or
                                (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "srgb-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.size.get_name_leafdata())
                            if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp-srgb"):
                                if (self.igp_srgb is None):
                                    self.igp_srgb = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                    self.igp_srgb.parent = self
                                    self._children_name_map["igp_srgb"] = "igp-srgb"
                                return self.igp_srgb

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp-srgb" or name == "size" or name == "start"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "size"):
                                self.size = value
                                self.size.value_namespace = name_space
                                self.size.value_namespace_prefix = name_space_prefix
                            if(value_path == "start"):
                                self.start = value
                                self.start.value_namespace = name_space
                                self.start.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.igp_information:
                            if (c.has_data()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_data()):
                                return True
                        return (
                            self.ipv4bgp_router_id.is_set or
                            self.ipv4bgp_router_id_set.is_set or
                            self.ipv4te_router_id.is_set or
                            self.ipv4te_router_id_set.is_set or
                            self.node_name.is_set)

                    def has_operation(self):
                        for c in self.igp_information:
                            if (c.has_operation()):
                                return True
                        for c in self.srgb_information:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                            self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                            self.ipv4te_router_id.yfilter != YFilter.not_set or
                            self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                            self.node_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-node-protocol-identifier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                        if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                        if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                        if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.node_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-information"):
                            for c in self.igp_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.IgpInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.igp_information.append(c)
                            return c

                        if (child_yang_name == "srgb-information"):
                            for c in self.srgb_information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier.SrgbInformation()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.srgb_information.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ipv4bgp-router-id"):
                            self.ipv4bgp_router_id = value
                            self.ipv4bgp_router_id.value_namespace = name_space
                            self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4bgp-router-id-set"):
                            self.ipv4bgp_router_id_set = value
                            self.ipv4bgp_router_id_set.value_namespace = name_space
                            self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id"):
                            self.ipv4te_router_id = value
                            self.ipv4te_router_id.value_namespace = name_space
                            self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4te-router-id-set"):
                            self.ipv4te_router_id_set = value
                            self.ipv4te_router_id_set.value_namespace = name_space
                            self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "node-name"):
                            self.node_name = value
                            self.node_name.value_namespace = name_space
                            self.node_name.value_namespace_prefix = name_space_prefix


                class AdjacencySid(Entity):
                    """
                    Adjacency SIDs
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: eflag
                    
                    	E Flag
                    	**type**\:  bool
                    
                    .. attribute:: lflag
                    
                    	L Flag
                    	**type**\:  bool
                    
                    .. attribute:: mpls_label
                    
                    	MPLS Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: nflag
                    
                    	N Flag
                    	**type**\:  bool
                    
                    .. attribute:: pflag
                    
                    	P Flag
                    	**type**\:  bool
                    
                    .. attribute:: rflag
                    
                    	R Flag
                    	**type**\:  bool
                    
                    .. attribute:: sid_prefix
                    
                    	Prefix
                    	**type**\:   :py:class:`SidPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix>`
                    
                    .. attribute:: sid_type
                    
                    	SID Type
                    	**type**\:   :py:class:`Sid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Sid>`
                    
                    .. attribute:: vflag
                    
                    	V Flag
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid, self).__init__()

                        self.yang_name = "adjacency-sid"
                        self.yang_parent_name = "ipv6-link"

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.eflag = YLeaf(YType.boolean, "eflag")

                        self.lflag = YLeaf(YType.boolean, "lflag")

                        self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                        self.nflag = YLeaf(YType.boolean, "nflag")

                        self.pflag = YLeaf(YType.boolean, "pflag")

                        self.rflag = YLeaf(YType.boolean, "rflag")

                        self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        self.vflag = YLeaf(YType.boolean, "vflag")

                        self.sid_prefix = Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix()
                        self.sid_prefix.parent = self
                        self._children_name_map["sid_prefix"] = "sid-prefix"
                        self._children_yang_names.add("sid-prefix")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("domain_identifier",
                                        "eflag",
                                        "lflag",
                                        "mpls_label",
                                        "nflag",
                                        "pflag",
                                        "rflag",
                                        "sid_type",
                                        "vflag") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid, self).__setattr__(name, value)


                    class SidPrefix(Entity):
                        """
                        Prefix
                        
                        .. attribute:: af_name
                        
                        	AFName
                        	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix, self).__init__()

                            self.yang_name = "sid-prefix"
                            self.yang_parent_name = "adjacency-sid"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sid-prefix" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.domain_identifier.is_set or
                            self.eflag.is_set or
                            self.lflag.is_set or
                            self.mpls_label.is_set or
                            self.nflag.is_set or
                            self.pflag.is_set or
                            self.rflag.is_set or
                            self.sid_type.is_set or
                            self.vflag.is_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            self.eflag.yfilter != YFilter.not_set or
                            self.lflag.yfilter != YFilter.not_set or
                            self.mpls_label.yfilter != YFilter.not_set or
                            self.nflag.yfilter != YFilter.not_set or
                            self.pflag.yfilter != YFilter.not_set or
                            self.rflag.yfilter != YFilter.not_set or
                            self.sid_type.yfilter != YFilter.not_set or
                            self.vflag.yfilter != YFilter.not_set or
                            (self.sid_prefix is not None and self.sid_prefix.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "adjacency-sid" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())
                        if (self.eflag.is_set or self.eflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eflag.get_name_leafdata())
                        if (self.lflag.is_set or self.lflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lflag.get_name_leafdata())
                        if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_label.get_name_leafdata())
                        if (self.nflag.is_set or self.nflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nflag.get_name_leafdata())
                        if (self.pflag.is_set or self.pflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pflag.get_name_leafdata())
                        if (self.rflag.is_set or self.rflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rflag.get_name_leafdata())
                        if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sid_type.get_name_leafdata())
                        if (self.vflag.is_set or self.vflag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vflag.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sid-prefix"):
                            if (self.sid_prefix is None):
                                self.sid_prefix = Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid.SidPrefix()
                                self.sid_prefix.parent = self
                                self._children_name_map["sid_prefix"] = "sid-prefix"
                            return self.sid_prefix

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sid-prefix" or name == "domain-identifier" or name == "eflag" or name == "lflag" or name == "mpls-label" or name == "nflag" or name == "pflag" or name == "rflag" or name == "sid-type" or name == "vflag"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix
                        if(value_path == "eflag"):
                            self.eflag = value
                            self.eflag.value_namespace = name_space
                            self.eflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "lflag"):
                            self.lflag = value
                            self.lflag.value_namespace = name_space
                            self.lflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "mpls-label"):
                            self.mpls_label = value
                            self.mpls_label.value_namespace = name_space
                            self.mpls_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "nflag"):
                            self.nflag = value
                            self.nflag.value_namespace = name_space
                            self.nflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "pflag"):
                            self.pflag = value
                            self.pflag.value_namespace = name_space
                            self.pflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "rflag"):
                            self.rflag = value
                            self.rflag.value_namespace = name_space
                            self.rflag.value_namespace_prefix = name_space_prefix
                        if(value_path == "sid-type"):
                            self.sid_type = value
                            self.sid_type.value_namespace = name_space
                            self.sid_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vflag"):
                            self.vflag = value
                            self.vflag.value_namespace = name_space
                            self.vflag.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.adjacency_sid:
                        if (c.has_data()):
                            return True
                    return (
                        self.igp_metric.is_set or
                        self.local_ipv6_address.is_set or
                        self.max_reservable_bandwidth.is_set or
                        self.maximum_link_bandwidth.is_set or
                        self.remote_ipv6_address.is_set or
                        self.te_metric.is_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_data()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_data()))

                def has_operation(self):
                    for c in self.adjacency_sid:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.igp_metric.yfilter != YFilter.not_set or
                        self.local_ipv6_address.yfilter != YFilter.not_set or
                        self.max_reservable_bandwidth.yfilter != YFilter.not_set or
                        self.maximum_link_bandwidth.yfilter != YFilter.not_set or
                        self.remote_ipv6_address.yfilter != YFilter.not_set or
                        self.te_metric.yfilter != YFilter.not_set or
                        (self.local_igp_information is not None and self.local_igp_information.has_operation()) or
                        (self.remote_node_protocol_identifier is not None and self.remote_node_protocol_identifier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv6-link" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.igp_metric.is_set or self.igp_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_metric.get_name_leafdata())
                    if (self.local_ipv6_address.is_set or self.local_ipv6_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_ipv6_address.get_name_leafdata())
                    if (self.max_reservable_bandwidth.is_set or self.max_reservable_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.max_reservable_bandwidth.get_name_leafdata())
                    if (self.maximum_link_bandwidth.is_set or self.maximum_link_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maximum_link_bandwidth.get_name_leafdata())
                    if (self.remote_ipv6_address.is_set or self.remote_ipv6_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_ipv6_address.get_name_leafdata())
                    if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_metric.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "adjacency-sid"):
                        for c in self.adjacency_sid:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.TopologyNodes.TopologyNode.Ipv6Link.AdjacencySid()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.adjacency_sid.append(c)
                        return c

                    if (child_yang_name == "local-igp-information"):
                        if (self.local_igp_information is None):
                            self.local_igp_information = Pce.TopologyNodes.TopologyNode.Ipv6Link.LocalIgpInformation()
                            self.local_igp_information.parent = self
                            self._children_name_map["local_igp_information"] = "local-igp-information"
                        return self.local_igp_information

                    if (child_yang_name == "remote-node-protocol-identifier"):
                        if (self.remote_node_protocol_identifier is None):
                            self.remote_node_protocol_identifier = Pce.TopologyNodes.TopologyNode.Ipv6Link.RemoteNodeProtocolIdentifier()
                            self.remote_node_protocol_identifier.parent = self
                            self._children_name_map["remote_node_protocol_identifier"] = "remote-node-protocol-identifier"
                        return self.remote_node_protocol_identifier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjacency-sid" or name == "local-igp-information" or name == "remote-node-protocol-identifier" or name == "igp-metric" or name == "local-ipv6-address" or name == "max-reservable-bandwidth" or name == "maximum-link-bandwidth" or name == "remote-ipv6-address" or name == "te-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "igp-metric"):
                        self.igp_metric = value
                        self.igp_metric.value_namespace = name_space
                        self.igp_metric.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-ipv6-address"):
                        self.local_ipv6_address = value
                        self.local_ipv6_address.value_namespace = name_space
                        self.local_ipv6_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "max-reservable-bandwidth"):
                        self.max_reservable_bandwidth = value
                        self.max_reservable_bandwidth.value_namespace = name_space
                        self.max_reservable_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "maximum-link-bandwidth"):
                        self.maximum_link_bandwidth = value
                        self.maximum_link_bandwidth.value_namespace = name_space
                        self.maximum_link_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-ipv6-address"):
                        self.remote_ipv6_address = value
                        self.remote_ipv6_address.value_namespace = name_space
                        self.remote_ipv6_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-metric"):
                        self.te_metric = value
                        self.te_metric.value_namespace = name_space
                        self.te_metric.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv4_link:
                    if (c.has_data()):
                        return True
                for c in self.ipv6_link:
                    if (c.has_data()):
                        return True
                for c in self.prefix_sid:
                    if (c.has_data()):
                        return True
                return (
                    self.node_identifier.is_set or
                    self.node_identifier_xr.is_set or
                    self.overload.is_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_data()))

            def has_operation(self):
                for c in self.ipv4_link:
                    if (c.has_operation()):
                        return True
                for c in self.ipv6_link:
                    if (c.has_operation()):
                        return True
                for c in self.prefix_sid:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_identifier.yfilter != YFilter.not_set or
                    self.node_identifier_xr.yfilter != YFilter.not_set or
                    self.overload.yfilter != YFilter.not_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "topology-node" + "[node-identifier='" + self.node_identifier.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/topology-nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_identifier.is_set or self.node_identifier.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier.get_name_leafdata())
                if (self.node_identifier_xr.is_set or self.node_identifier_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier_xr.get_name_leafdata())
                if (self.overload.is_set or self.overload.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.overload.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv4-link"):
                    for c in self.ipv4_link:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Pce.TopologyNodes.TopologyNode.Ipv4Link()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv4_link.append(c)
                    return c

                if (child_yang_name == "ipv6-link"):
                    for c in self.ipv6_link:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Pce.TopologyNodes.TopologyNode.Ipv6Link()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv6_link.append(c)
                    return c

                if (child_yang_name == "node-protocol-identifier"):
                    if (self.node_protocol_identifier is None):
                        self.node_protocol_identifier = Pce.TopologyNodes.TopologyNode.NodeProtocolIdentifier()
                        self.node_protocol_identifier.parent = self
                        self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                    return self.node_protocol_identifier

                if (child_yang_name == "prefix-sid"):
                    for c in self.prefix_sid:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Pce.TopologyNodes.TopologyNode.PrefixSid()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.prefix_sid.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv4-link" or name == "ipv6-link" or name == "node-protocol-identifier" or name == "prefix-sid" or name == "node-identifier" or name == "node-identifier-xr" or name == "overload"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-identifier"):
                    self.node_identifier = value
                    self.node_identifier.value_namespace = name_space
                    self.node_identifier.value_namespace_prefix = name_space_prefix
                if(value_path == "node-identifier-xr"):
                    self.node_identifier_xr = value
                    self.node_identifier_xr.value_namespace = name_space
                    self.node_identifier_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "overload"):
                    self.overload = value
                    self.overload.value_namespace = name_space
                    self.overload.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.topology_node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.topology_node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "topology-nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "topology-node"):
                for c in self.topology_node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.TopologyNodes.TopologyNode()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.topology_node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "topology-node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class PrefixInfos(Entity):
        """
        Prefixes database in XTC
        
        .. attribute:: prefix_info
        
        	PCE prefix information
        	**type**\: list of    :py:class:`PrefixInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.PrefixInfos, self).__init__()

            self.yang_name = "prefix-infos"
            self.yang_parent_name = "pce"

            self.prefix_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.PrefixInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.PrefixInfos, self).__setattr__(name, value)


        class PrefixInfo(Entity):
            """
            PCE prefix information
            
            .. attribute:: node_identifier  <key>
            
            	Node ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: address
            
            	Prefix address
            	**type**\: list of    :py:class:`Address <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.Address>`
            
            .. attribute:: node_identifier_xr
            
            	Node identifier
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_protocol_identifier
            
            	Node protocol identifier
            	**type**\:   :py:class:`NodeProtocolIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.PrefixInfos.PrefixInfo, self).__init__()

                self.yang_name = "prefix-info"
                self.yang_parent_name = "prefix-infos"

                self.node_identifier = YLeaf(YType.int32, "node-identifier")

                self.node_identifier_xr = YLeaf(YType.uint32, "node-identifier-xr")

                self.node_protocol_identifier = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier()
                self.node_protocol_identifier.parent = self
                self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                self._children_yang_names.add("node-protocol-identifier")

                self.address = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_identifier",
                                "node_identifier_xr") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.PrefixInfos.PrefixInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.PrefixInfos.PrefixInfo, self).__setattr__(name, value)


            class NodeProtocolIdentifier(Entity):
                """
                Node protocol identifier
                
                .. attribute:: igp_information
                
                	IGP information
                	**type**\: list of    :py:class:`IgpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation>`
                
                .. attribute:: ipv4bgp_router_id
                
                	IPv4 TE router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4bgp_router_id_set
                
                	True if IPv4 BGP router ID is set
                	**type**\:  bool
                
                .. attribute:: ipv4te_router_id
                
                	IPv4 BGP router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv4te_router_id_set
                
                	True if IPv4 TE router ID is set
                	**type**\:  bool
                
                .. attribute:: node_name
                
                	Node Name
                	**type**\:  str
                
                .. attribute:: srgb_information
                
                	SRGB information
                	**type**\: list of    :py:class:`SrgbInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation>`
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier, self).__init__()

                    self.yang_name = "node-protocol-identifier"
                    self.yang_parent_name = "prefix-info"

                    self.ipv4bgp_router_id = YLeaf(YType.str, "ipv4bgp-router-id")

                    self.ipv4bgp_router_id_set = YLeaf(YType.boolean, "ipv4bgp-router-id-set")

                    self.ipv4te_router_id = YLeaf(YType.str, "ipv4te-router-id")

                    self.ipv4te_router_id_set = YLeaf(YType.boolean, "ipv4te-router-id-set")

                    self.node_name = YLeaf(YType.str, "node-name")

                    self.igp_information = YList(self)
                    self.srgb_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ipv4bgp_router_id",
                                    "ipv4bgp_router_id_set",
                                    "ipv4te_router_id",
                                    "ipv4te_router_id_set",
                                    "node_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier, self).__setattr__(name, value)


                class IgpInformation(Entity):
                    """
                    IGP information
                    
                    .. attribute:: autonomous_system_number
                    
                    	Autonomous System Number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: domain_identifier
                    
                    	Domain identifier
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: igp
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation, self).__init__()

                        self.yang_name = "igp-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.autonomous_system_number = YLeaf(YType.uint32, "autonomous-system-number")

                        self.domain_identifier = YLeaf(YType.uint64, "domain-identifier")

                        self.igp = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp()
                        self.igp.parent = self
                        self._children_name_map["igp"] = "igp"
                        self._children_yang_names.add("igp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("autonomous_system_number",
                                        "domain_identifier") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation, self).__setattr__(name, value)


                    class Igp(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp, self).__init__()

                            self.yang_name = "igp"
                            self.yang_parent_name = "igp-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.autonomous_system_number.is_set or
                            self.domain_identifier.is_set or
                            (self.igp is not None and self.igp.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.autonomous_system_number.yfilter != YFilter.not_set or
                            self.domain_identifier.yfilter != YFilter.not_set or
                            (self.igp is not None and self.igp.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "igp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.autonomous_system_number.is_set or self.autonomous_system_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autonomous_system_number.get_name_leafdata())
                        if (self.domain_identifier.is_set or self.domain_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_identifier.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp"):
                            if (self.igp is None):
                                self.igp = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation.Igp()
                                self.igp.parent = self
                                self._children_name_map["igp"] = "igp"
                            return self.igp

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp" or name == "autonomous-system-number" or name == "domain-identifier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "autonomous-system-number"):
                            self.autonomous_system_number = value
                            self.autonomous_system_number.value_namespace = name_space
                            self.autonomous_system_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-identifier"):
                            self.domain_identifier = value
                            self.domain_identifier.value_namespace = name_space
                            self.domain_identifier.value_namespace_prefix = name_space_prefix


                class SrgbInformation(Entity):
                    """
                    SRGB information
                    
                    .. attribute:: igp_srgb
                    
                    	IGP\-specific information
                    	**type**\:   :py:class:`IgpSrgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb>`
                    
                    .. attribute:: size
                    
                    	SRGB size
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: start
                    
                    	SRGB start
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation, self).__init__()

                        self.yang_name = "srgb-information"
                        self.yang_parent_name = "node-protocol-identifier"

                        self.size = YLeaf(YType.uint32, "size")

                        self.start = YLeaf(YType.uint32, "start")

                        self.igp_srgb = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                        self.igp_srgb.parent = self
                        self._children_name_map["igp_srgb"] = "igp-srgb"
                        self._children_yang_names.add("igp-srgb")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("size",
                                        "start") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation, self).__setattr__(name, value)


                    class IgpSrgb(Entity):
                        """
                        IGP\-specific information
                        
                        .. attribute:: bgp
                        
                        	BGP information
                        	**type**\:   :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp>`
                        
                        .. attribute:: igp_id
                        
                        	IGP ID
                        	**type**\:   :py:class:`PceIgpInfoId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceIgpInfoId>`
                        
                        .. attribute:: isis
                        
                        	ISIS information
                        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis>`
                        
                        .. attribute:: ospf
                        
                        	OSPF information
                        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__init__()

                            self.yang_name = "igp-srgb"
                            self.yang_parent_name = "srgb-information"

                            self.igp_id = YLeaf(YType.enumeration, "igp-id")

                            self.bgp = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                            self.bgp.parent = self
                            self._children_name_map["bgp"] = "bgp"
                            self._children_yang_names.add("bgp")

                            self.isis = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                            self.isis.parent = self
                            self._children_name_map["isis"] = "isis"
                            self._children_yang_names.add("isis")

                            self.ospf = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                            self._children_yang_names.add("ospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("igp_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb, self).__setattr__(name, value)


                        class Isis(Entity):
                            """
                            ISIS information
                            
                            .. attribute:: level
                            
                            	ISIS level
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: system_id
                            
                            	ISIS system ID
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__init__()

                                self.yang_name = "isis"
                                self.yang_parent_name = "igp-srgb"

                                self.level = YLeaf(YType.uint32, "level")

                                self.system_id = YLeaf(YType.str, "system-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "system_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.system_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.system_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "isis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.system_id.is_set or self.system_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.system_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "system-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "system-id"):
                                    self.system_id = value
                                    self.system_id.value_namespace = name_space
                                    self.system_id.value_namespace_prefix = name_space_prefix


                        class Ospf(Entity):
                            """
                            OSPF information
                            
                            .. attribute:: area
                            
                            	OSPF area
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	OSPF router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__init__()

                                self.yang_name = "ospf"
                                self.yang_parent_name = "igp-srgb"

                                self.area = YLeaf(YType.uint32, "area")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.area.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area.is_set or self.area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area"):
                                    self.area = value
                                    self.area.value_namespace = name_space
                                    self.area.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            BGP information
                            
                            .. attribute:: confed_asn
                            
                            	Confederation ASN
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: router_id
                            
                            	BGP router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-xtc-oper'
                            _revision = '2016-05-31'

                            def __init__(self):
                                super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "igp-srgb"

                                self.confed_asn = YLeaf(YType.uint32, "confed-asn")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("confed_asn",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.confed_asn.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.confed_asn.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.confed_asn.is_set or self.confed_asn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.confed_asn.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "confed-asn" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "confed-asn"):
                                    self.confed_asn = value
                                    self.confed_asn.value_namespace = name_space
                                    self.confed_asn.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.igp_id.is_set or
                                (self.bgp is not None and self.bgp.has_data()) or
                                (self.isis is not None and self.isis.has_data()) or
                                (self.ospf is not None and self.ospf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.igp_id.yfilter != YFilter.not_set or
                                (self.bgp is not None and self.bgp.has_operation()) or
                                (self.isis is not None and self.isis.has_operation()) or
                                (self.ospf is not None and self.ospf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "igp-srgb" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.igp_id.is_set or self.igp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igp_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                if (self.bgp is None):
                                    self.bgp = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Bgp()
                                    self.bgp.parent = self
                                    self._children_name_map["bgp"] = "bgp"
                                return self.bgp

                            if (child_yang_name == "isis"):
                                if (self.isis is None):
                                    self.isis = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Isis()
                                    self.isis.parent = self
                                    self._children_name_map["isis"] = "isis"
                                return self.isis

                            if (child_yang_name == "ospf"):
                                if (self.ospf is None):
                                    self.ospf = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb.Ospf()
                                    self.ospf.parent = self
                                    self._children_name_map["ospf"] = "ospf"
                                return self.ospf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "isis" or name == "ospf" or name == "igp-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "igp-id"):
                                self.igp_id = value
                                self.igp_id.value_namespace = name_space
                                self.igp_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.size.is_set or
                            self.start.is_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.size.yfilter != YFilter.not_set or
                            self.start.yfilter != YFilter.not_set or
                            (self.igp_srgb is not None and self.igp_srgb.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "srgb-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.size.get_name_leafdata())
                        if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.start.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "igp-srgb"):
                            if (self.igp_srgb is None):
                                self.igp_srgb = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation.IgpSrgb()
                                self.igp_srgb.parent = self
                                self._children_name_map["igp_srgb"] = "igp-srgb"
                            return self.igp_srgb

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "igp-srgb" or name == "size" or name == "start"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "size"):
                            self.size = value
                            self.size.value_namespace = name_space
                            self.size.value_namespace_prefix = name_space_prefix
                        if(value_path == "start"):
                            self.start = value
                            self.start.value_namespace = name_space
                            self.start.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.igp_information:
                        if (c.has_data()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.ipv4bgp_router_id.is_set or
                        self.ipv4bgp_router_id_set.is_set or
                        self.ipv4te_router_id.is_set or
                        self.ipv4te_router_id_set.is_set or
                        self.node_name.is_set)

                def has_operation(self):
                    for c in self.igp_information:
                        if (c.has_operation()):
                            return True
                    for c in self.srgb_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id.yfilter != YFilter.not_set or
                        self.ipv4bgp_router_id_set.yfilter != YFilter.not_set or
                        self.ipv4te_router_id.yfilter != YFilter.not_set or
                        self.ipv4te_router_id_set.yfilter != YFilter.not_set or
                        self.node_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "node-protocol-identifier" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ipv4bgp_router_id.is_set or self.ipv4bgp_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id.get_name_leafdata())
                    if (self.ipv4bgp_router_id_set.is_set or self.ipv4bgp_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4bgp_router_id_set.get_name_leafdata())
                    if (self.ipv4te_router_id.is_set or self.ipv4te_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id.get_name_leafdata())
                    if (self.ipv4te_router_id_set.is_set or self.ipv4te_router_id_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4te_router_id_set.get_name_leafdata())
                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "igp-information"):
                        for c in self.igp_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.IgpInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.igp_information.append(c)
                        return c

                    if (child_yang_name == "srgb-information"):
                        for c in self.srgb_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier.SrgbInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.srgb_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "igp-information" or name == "srgb-information" or name == "ipv4bgp-router-id" or name == "ipv4bgp-router-id-set" or name == "ipv4te-router-id" or name == "ipv4te-router-id-set" or name == "node-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ipv4bgp-router-id"):
                        self.ipv4bgp_router_id = value
                        self.ipv4bgp_router_id.value_namespace = name_space
                        self.ipv4bgp_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4bgp-router-id-set"):
                        self.ipv4bgp_router_id_set = value
                        self.ipv4bgp_router_id_set.value_namespace = name_space
                        self.ipv4bgp_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id"):
                        self.ipv4te_router_id = value
                        self.ipv4te_router_id.value_namespace = name_space
                        self.ipv4te_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4te-router-id-set"):
                        self.ipv4te_router_id_set = value
                        self.ipv4te_router_id_set.value_namespace = name_space
                        self.ipv4te_router_id_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-name"):
                        self.node_name = value
                        self.node_name.value_namespace = name_space
                        self.node_name.value_namespace_prefix = name_space_prefix


            class Address(Entity):
                """
                Prefix address
                
                .. attribute:: af_name
                
                	AFName
                	**type**\:   :py:class:`PceAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceAfId>`
                
                .. attribute:: ipv4
                
                	IPv4 address type
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv6
                
                	IPv6 address type
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.PrefixInfos.PrefixInfo.Address, self).__init__()

                    self.yang_name = "address"
                    self.yang_parent_name = "prefix-info"

                    self.af_name = YLeaf(YType.enumeration, "af-name")

                    self.ipv4 = YLeaf(YType.str, "ipv4")

                    self.ipv6 = YLeaf(YType.str, "ipv6")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("af_name",
                                    "ipv4",
                                    "ipv6") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.PrefixInfos.PrefixInfo.Address, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.PrefixInfos.PrefixInfo.Address, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.af_name.is_set or
                        self.ipv4.is_set or
                        self.ipv6.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.af_name.yfilter != YFilter.not_set or
                        self.ipv4.yfilter != YFilter.not_set or
                        self.ipv6.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "address" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.af_name.get_name_leafdata())
                    if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4.get_name_leafdata())
                    if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv6.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "af-name" or name == "ipv4" or name == "ipv6"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "af-name"):
                        self.af_name = value
                        self.af_name.value_namespace = name_space
                        self.af_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4"):
                        self.ipv4 = value
                        self.ipv4.value_namespace = name_space
                        self.ipv4.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv6"):
                        self.ipv6 = value
                        self.ipv6.value_namespace = name_space
                        self.ipv6.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.address:
                    if (c.has_data()):
                        return True
                return (
                    self.node_identifier.is_set or
                    self.node_identifier_xr.is_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_data()))

            def has_operation(self):
                for c in self.address:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_identifier.yfilter != YFilter.not_set or
                    self.node_identifier_xr.yfilter != YFilter.not_set or
                    (self.node_protocol_identifier is not None and self.node_protocol_identifier.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "prefix-info" + "[node-identifier='" + self.node_identifier.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/prefix-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_identifier.is_set or self.node_identifier.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier.get_name_leafdata())
                if (self.node_identifier_xr.is_set or self.node_identifier_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_identifier_xr.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "address"):
                    for c in self.address:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Pce.PrefixInfos.PrefixInfo.Address()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.address.append(c)
                    return c

                if (child_yang_name == "node-protocol-identifier"):
                    if (self.node_protocol_identifier is None):
                        self.node_protocol_identifier = Pce.PrefixInfos.PrefixInfo.NodeProtocolIdentifier()
                        self.node_protocol_identifier.parent = self
                        self._children_name_map["node_protocol_identifier"] = "node-protocol-identifier"
                    return self.node_protocol_identifier

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "address" or name == "node-protocol-identifier" or name == "node-identifier" or name == "node-identifier-xr"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-identifier"):
                    self.node_identifier = value
                    self.node_identifier.value_namespace = name_space
                    self.node_identifier.value_namespace_prefix = name_space_prefix
                if(value_path == "node-identifier-xr"):
                    self.node_identifier_xr = value
                    self.node_identifier_xr.value_namespace = name_space
                    self.node_identifier_xr.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.prefix_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.prefix_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "prefix-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "prefix-info"):
                for c in self.prefix_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.PrefixInfos.PrefixInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.prefix_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "prefix-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class LspSummary(Entity):
        """
        LSP summary database in XTC
        
        .. attribute:: all_ls_ps
        
        	Summary for all peers
        	**type**\:   :py:class:`AllLsPs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.LspSummary.AllLsPs>`
        
        .. attribute:: peer_ls_ps_info
        
        	Number of LSPs for specific peer
        	**type**\: list of    :py:class:`PeerLsPsInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.LspSummary.PeerLsPsInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.LspSummary, self).__init__()

            self.yang_name = "lsp-summary"
            self.yang_parent_name = "pce"

            self.all_ls_ps = Pce.LspSummary.AllLsPs()
            self.all_ls_ps.parent = self
            self._children_name_map["all_ls_ps"] = "all-ls-ps"
            self._children_yang_names.add("all-ls-ps")

            self.peer_ls_ps_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.LspSummary, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.LspSummary, self).__setattr__(name, value)


        class AllLsPs(Entity):
            """
            Summary for all peers
            
            .. attribute:: admin_up_ls_ps
            
            	Number of administratively up LSPs
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: all_ls_ps
            
            	Number of all LSPs
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: rsvp_ls_ps
            
            	Number of LSPs with RSVP setup type
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: sr_ls_ps
            
            	Number of LSPs with Segment routing setup type
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_ls_ps
            
            	Number of operational LSPs
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.LspSummary.AllLsPs, self).__init__()

                self.yang_name = "all-ls-ps"
                self.yang_parent_name = "lsp-summary"

                self.admin_up_ls_ps = YLeaf(YType.uint32, "admin-up-ls-ps")

                self.all_ls_ps = YLeaf(YType.uint32, "all-ls-ps")

                self.rsvp_ls_ps = YLeaf(YType.uint32, "rsvp-ls-ps")

                self.sr_ls_ps = YLeaf(YType.uint32, "sr-ls-ps")

                self.up_ls_ps = YLeaf(YType.uint32, "up-ls-ps")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("admin_up_ls_ps",
                                "all_ls_ps",
                                "rsvp_ls_ps",
                                "sr_ls_ps",
                                "up_ls_ps") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.LspSummary.AllLsPs, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.LspSummary.AllLsPs, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.admin_up_ls_ps.is_set or
                    self.all_ls_ps.is_set or
                    self.rsvp_ls_ps.is_set or
                    self.sr_ls_ps.is_set or
                    self.up_ls_ps.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.admin_up_ls_ps.yfilter != YFilter.not_set or
                    self.all_ls_ps.yfilter != YFilter.not_set or
                    self.rsvp_ls_ps.yfilter != YFilter.not_set or
                    self.sr_ls_ps.yfilter != YFilter.not_set or
                    self.up_ls_ps.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "all-ls-ps" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/lsp-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.admin_up_ls_ps.is_set or self.admin_up_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.admin_up_ls_ps.get_name_leafdata())
                if (self.all_ls_ps.is_set or self.all_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.all_ls_ps.get_name_leafdata())
                if (self.rsvp_ls_ps.is_set or self.rsvp_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.rsvp_ls_ps.get_name_leafdata())
                if (self.sr_ls_ps.is_set or self.sr_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sr_ls_ps.get_name_leafdata())
                if (self.up_ls_ps.is_set or self.up_ls_ps.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_ls_ps.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "admin-up-ls-ps" or name == "all-ls-ps" or name == "rsvp-ls-ps" or name == "sr-ls-ps" or name == "up-ls-ps"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "admin-up-ls-ps"):
                    self.admin_up_ls_ps = value
                    self.admin_up_ls_ps.value_namespace = name_space
                    self.admin_up_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "all-ls-ps"):
                    self.all_ls_ps = value
                    self.all_ls_ps.value_namespace = name_space
                    self.all_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "rsvp-ls-ps"):
                    self.rsvp_ls_ps = value
                    self.rsvp_ls_ps.value_namespace = name_space
                    self.rsvp_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "sr-ls-ps"):
                    self.sr_ls_ps = value
                    self.sr_ls_ps.value_namespace = name_space
                    self.sr_ls_ps.value_namespace_prefix = name_space_prefix
                if(value_path == "up-ls-ps"):
                    self.up_ls_ps = value
                    self.up_ls_ps.value_namespace = name_space
                    self.up_ls_ps.value_namespace_prefix = name_space_prefix


        class PeerLsPsInfo(Entity):
            """
            Number of LSPs for specific peer
            
            .. attribute:: lsp_summary
            
            	Number of LSPs for specific peer
            	**type**\:   :py:class:`LspSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.LspSummary.PeerLsPsInfo.LspSummary>`
            
            .. attribute:: peer_address
            
            	Peer IPv4 address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.LspSummary.PeerLsPsInfo, self).__init__()

                self.yang_name = "peer-ls-ps-info"
                self.yang_parent_name = "lsp-summary"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.lsp_summary = Pce.LspSummary.PeerLsPsInfo.LspSummary()
                self.lsp_summary.parent = self
                self._children_name_map["lsp_summary"] = "lsp-summary"
                self._children_yang_names.add("lsp-summary")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.LspSummary.PeerLsPsInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.LspSummary.PeerLsPsInfo, self).__setattr__(name, value)


            class LspSummary(Entity):
                """
                Number of LSPs for specific peer
                
                .. attribute:: admin_up_ls_ps
                
                	Number of administratively up LSPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: all_ls_ps
                
                	Number of all LSPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: rsvp_ls_ps
                
                	Number of LSPs with RSVP setup type
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: sr_ls_ps
                
                	Number of LSPs with Segment routing setup type
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_ls_ps
                
                	Number of operational LSPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.LspSummary.PeerLsPsInfo.LspSummary, self).__init__()

                    self.yang_name = "lsp-summary"
                    self.yang_parent_name = "peer-ls-ps-info"

                    self.admin_up_ls_ps = YLeaf(YType.uint32, "admin-up-ls-ps")

                    self.all_ls_ps = YLeaf(YType.uint32, "all-ls-ps")

                    self.rsvp_ls_ps = YLeaf(YType.uint32, "rsvp-ls-ps")

                    self.sr_ls_ps = YLeaf(YType.uint32, "sr-ls-ps")

                    self.up_ls_ps = YLeaf(YType.uint32, "up-ls-ps")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_up_ls_ps",
                                    "all_ls_ps",
                                    "rsvp_ls_ps",
                                    "sr_ls_ps",
                                    "up_ls_ps") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.LspSummary.PeerLsPsInfo.LspSummary, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.LspSummary.PeerLsPsInfo.LspSummary, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.admin_up_ls_ps.is_set or
                        self.all_ls_ps.is_set or
                        self.rsvp_ls_ps.is_set or
                        self.sr_ls_ps.is_set or
                        self.up_ls_ps.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_up_ls_ps.yfilter != YFilter.not_set or
                        self.all_ls_ps.yfilter != YFilter.not_set or
                        self.rsvp_ls_ps.yfilter != YFilter.not_set or
                        self.sr_ls_ps.yfilter != YFilter.not_set or
                        self.up_ls_ps.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-summary" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/lsp-summary/peer-ls-ps-info/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.admin_up_ls_ps.is_set or self.admin_up_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.admin_up_ls_ps.get_name_leafdata())
                    if (self.all_ls_ps.is_set or self.all_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.all_ls_ps.get_name_leafdata())
                    if (self.rsvp_ls_ps.is_set or self.rsvp_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rsvp_ls_ps.get_name_leafdata())
                    if (self.sr_ls_ps.is_set or self.sr_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sr_ls_ps.get_name_leafdata())
                    if (self.up_ls_ps.is_set or self.up_ls_ps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_ls_ps.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "admin-up-ls-ps" or name == "all-ls-ps" or name == "rsvp-ls-ps" or name == "sr-ls-ps" or name == "up-ls-ps"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-up-ls-ps"):
                        self.admin_up_ls_ps = value
                        self.admin_up_ls_ps.value_namespace = name_space
                        self.admin_up_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "all-ls-ps"):
                        self.all_ls_ps = value
                        self.all_ls_ps.value_namespace = name_space
                        self.all_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "rsvp-ls-ps"):
                        self.rsvp_ls_ps = value
                        self.rsvp_ls_ps.value_namespace = name_space
                        self.rsvp_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "sr-ls-ps"):
                        self.sr_ls_ps = value
                        self.sr_ls_ps.value_namespace = name_space
                        self.sr_ls_ps.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-ls-ps"):
                        self.up_ls_ps = value
                        self.up_ls_ps.value_namespace = name_space
                        self.up_ls_ps.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.peer_address.is_set or
                    (self.lsp_summary is not None and self.lsp_summary.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    (self.lsp_summary is not None and self.lsp_summary.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-ls-ps-info" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/lsp-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "lsp-summary"):
                    if (self.lsp_summary is None):
                        self.lsp_summary = Pce.LspSummary.PeerLsPsInfo.LspSummary()
                        self.lsp_summary.parent = self
                        self._children_name_map["lsp_summary"] = "lsp-summary"
                    return self.lsp_summary

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "lsp-summary" or name == "peer-address"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.peer_ls_ps_info:
                if (c.has_data()):
                    return True
            return (self.all_ls_ps is not None and self.all_ls_ps.has_data())

        def has_operation(self):
            for c in self.peer_ls_ps_info:
                if (c.has_operation()):
                    return True
            return (
                self.yfilter != YFilter.not_set or
                (self.all_ls_ps is not None and self.all_ls_ps.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "lsp-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "all-ls-ps"):
                if (self.all_ls_ps is None):
                    self.all_ls_ps = Pce.LspSummary.AllLsPs()
                    self.all_ls_ps.parent = self
                    self._children_name_map["all_ls_ps"] = "all-ls-ps"
                return self.all_ls_ps

            if (child_yang_name == "peer-ls-ps-info"):
                for c in self.peer_ls_ps_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.LspSummary.PeerLsPsInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.peer_ls_ps_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "all-ls-ps" or name == "peer-ls-ps-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class PeerInfos(Entity):
        """
        Peers database in XTC
        
        .. attribute:: peer_info
        
        	PCE peer information
        	**type**\: list of    :py:class:`PeerInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerInfos.PeerInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.PeerInfos, self).__init__()

            self.yang_name = "peer-infos"
            self.yang_parent_name = "pce"

            self.peer_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.PeerInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.PeerInfos, self).__setattr__(name, value)


        class PeerInfo(Entity):
            """
            PCE peer information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: brief_pcep_information
            
            	PCE protocol information
            	**type**\:   :py:class:`BriefPcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.PeerInfos.PeerInfo.BriefPcepInformation>`
            
            .. attribute:: peer_address_xr
            
            	Peer address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: peer_protocol
            
            	Protocol between PCE and peer
            	**type**\:   :py:class:`PceProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceProto>`
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.PeerInfos.PeerInfo, self).__init__()

                self.yang_name = "peer-info"
                self.yang_parent_name = "peer-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.peer_address_xr = YLeaf(YType.str, "peer-address-xr")

                self.peer_protocol = YLeaf(YType.enumeration, "peer-protocol")

                self.brief_pcep_information = Pce.PeerInfos.PeerInfo.BriefPcepInformation()
                self.brief_pcep_information.parent = self
                self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                self._children_yang_names.add("brief-pcep-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "peer_address_xr",
                                "peer_protocol") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.PeerInfos.PeerInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.PeerInfos.PeerInfo, self).__setattr__(name, value)


            class BriefPcepInformation(Entity):
                """
                PCE protocol information
                
                .. attribute:: capability_db_version
                
                	DB version capability
                	**type**\:  bool
                
                .. attribute:: capability_delta_sync
                
                	Delta Synchronization capability
                	**type**\:  bool
                
                .. attribute:: capability_instantiate
                
                	Instantiation capability
                	**type**\:  bool
                
                .. attribute:: capability_segment_routing
                
                	Segment Routing capability
                	**type**\:  bool
                
                .. attribute:: capability_triggered_sync
                
                	Triggered Synchronization capability
                	**type**\:  bool
                
                .. attribute:: capability_update
                
                	Update capability
                	**type**\:  bool
                
                .. attribute:: pcep_state
                
                	PCEP State
                	**type**\:   :py:class:`PcepState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepState>`
                
                .. attribute:: stateful
                
                	Stateful
                	**type**\:  bool
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.PeerInfos.PeerInfo.BriefPcepInformation, self).__init__()

                    self.yang_name = "brief-pcep-information"
                    self.yang_parent_name = "peer-info"

                    self.capability_db_version = YLeaf(YType.boolean, "capability-db-version")

                    self.capability_delta_sync = YLeaf(YType.boolean, "capability-delta-sync")

                    self.capability_instantiate = YLeaf(YType.boolean, "capability-instantiate")

                    self.capability_segment_routing = YLeaf(YType.boolean, "capability-segment-routing")

                    self.capability_triggered_sync = YLeaf(YType.boolean, "capability-triggered-sync")

                    self.capability_update = YLeaf(YType.boolean, "capability-update")

                    self.pcep_state = YLeaf(YType.enumeration, "pcep-state")

                    self.stateful = YLeaf(YType.boolean, "stateful")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("capability_db_version",
                                    "capability_delta_sync",
                                    "capability_instantiate",
                                    "capability_segment_routing",
                                    "capability_triggered_sync",
                                    "capability_update",
                                    "pcep_state",
                                    "stateful") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.PeerInfos.PeerInfo.BriefPcepInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.PeerInfos.PeerInfo.BriefPcepInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.capability_db_version.is_set or
                        self.capability_delta_sync.is_set or
                        self.capability_instantiate.is_set or
                        self.capability_segment_routing.is_set or
                        self.capability_triggered_sync.is_set or
                        self.capability_update.is_set or
                        self.pcep_state.is_set or
                        self.stateful.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.capability_db_version.yfilter != YFilter.not_set or
                        self.capability_delta_sync.yfilter != YFilter.not_set or
                        self.capability_instantiate.yfilter != YFilter.not_set or
                        self.capability_segment_routing.yfilter != YFilter.not_set or
                        self.capability_triggered_sync.yfilter != YFilter.not_set or
                        self.capability_update.yfilter != YFilter.not_set or
                        self.pcep_state.yfilter != YFilter.not_set or
                        self.stateful.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "brief-pcep-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.capability_db_version.is_set or self.capability_db_version.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_db_version.get_name_leafdata())
                    if (self.capability_delta_sync.is_set or self.capability_delta_sync.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_delta_sync.get_name_leafdata())
                    if (self.capability_instantiate.is_set or self.capability_instantiate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_instantiate.get_name_leafdata())
                    if (self.capability_segment_routing.is_set or self.capability_segment_routing.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_segment_routing.get_name_leafdata())
                    if (self.capability_triggered_sync.is_set or self.capability_triggered_sync.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_triggered_sync.get_name_leafdata())
                    if (self.capability_update.is_set or self.capability_update.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_update.get_name_leafdata())
                    if (self.pcep_state.is_set or self.pcep_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pcep_state.get_name_leafdata())
                    if (self.stateful.is_set or self.stateful.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stateful.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "capability-db-version" or name == "capability-delta-sync" or name == "capability-instantiate" or name == "capability-segment-routing" or name == "capability-triggered-sync" or name == "capability-update" or name == "pcep-state" or name == "stateful"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "capability-db-version"):
                        self.capability_db_version = value
                        self.capability_db_version.value_namespace = name_space
                        self.capability_db_version.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-delta-sync"):
                        self.capability_delta_sync = value
                        self.capability_delta_sync.value_namespace = name_space
                        self.capability_delta_sync.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-instantiate"):
                        self.capability_instantiate = value
                        self.capability_instantiate.value_namespace = name_space
                        self.capability_instantiate.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-segment-routing"):
                        self.capability_segment_routing = value
                        self.capability_segment_routing.value_namespace = name_space
                        self.capability_segment_routing.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-triggered-sync"):
                        self.capability_triggered_sync = value
                        self.capability_triggered_sync.value_namespace = name_space
                        self.capability_triggered_sync.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-update"):
                        self.capability_update = value
                        self.capability_update.value_namespace = name_space
                        self.capability_update.value_namespace_prefix = name_space_prefix
                    if(value_path == "pcep-state"):
                        self.pcep_state = value
                        self.pcep_state.value_namespace = name_space
                        self.pcep_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "stateful"):
                        self.stateful = value
                        self.stateful.value_namespace = name_space
                        self.stateful.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.peer_address.is_set or
                    self.peer_address_xr.is_set or
                    self.peer_protocol.is_set or
                    (self.brief_pcep_information is not None and self.brief_pcep_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.peer_address_xr.yfilter != YFilter.not_set or
                    self.peer_protocol.yfilter != YFilter.not_set or
                    (self.brief_pcep_information is not None and self.brief_pcep_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-info" + "[peer-address='" + self.peer_address.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/peer-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.peer_address_xr.is_set or self.peer_address_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address_xr.get_name_leafdata())
                if (self.peer_protocol.is_set or self.peer_protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_protocol.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "brief-pcep-information"):
                    if (self.brief_pcep_information is None):
                        self.brief_pcep_information = Pce.PeerInfos.PeerInfo.BriefPcepInformation()
                        self.brief_pcep_information.parent = self
                        self._children_name_map["brief_pcep_information"] = "brief-pcep-information"
                    return self.brief_pcep_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "brief-pcep-information" or name == "peer-address" or name == "peer-address-xr" or name == "peer-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-address-xr"):
                    self.peer_address_xr = value
                    self.peer_address_xr.value_namespace = name_space
                    self.peer_address_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-protocol"):
                    self.peer_protocol = value
                    self.peer_protocol.value_namespace = name_space
                    self.peer_protocol.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.peer_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.peer_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "peer-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "peer-info"):
                for c in self.peer_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.PeerInfos.PeerInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.peer_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "peer-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TunnelDetailInfos(Entity):
        """
        Detailed tunnel database in XTC
        
        .. attribute:: tunnel_detail_info
        
        	Detailed tunnel information
        	**type**\: list of    :py:class:`TunnelDetailInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo>`
        
        

        """

        _prefix = 'infra-xtc-oper'
        _revision = '2016-05-31'

        def __init__(self):
            super(Pce.TunnelDetailInfos, self).__init__()

            self.yang_name = "tunnel-detail-infos"
            self.yang_parent_name = "pce"

            self.tunnel_detail_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pce.TunnelDetailInfos, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pce.TunnelDetailInfos, self).__setattr__(name, value)


        class TunnelDetailInfo(Entity):
            """
            Detailed tunnel information
            
            .. attribute:: peer_address  <key>
            
            	Peer Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: plsp_id  <key>
            
            	PCEP LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: tunnel_name  <key>
            
            	Tunnel name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: detail_lsp_information
            
            	Detail LSP information
            	**type**\: list of    :py:class:`DetailLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation>`
            
            .. attribute:: pcc_address
            
            	PCC address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: private_lsp_information
            
            	Private LSP information
            	**type**\:   :py:class:`PrivateLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation>`
            
            .. attribute:: tunnel_name_xr
            
            	Tunnel Name
            	**type**\:  str
            
            

            """

            _prefix = 'infra-xtc-oper'
            _revision = '2016-05-31'

            def __init__(self):
                super(Pce.TunnelDetailInfos.TunnelDetailInfo, self).__init__()

                self.yang_name = "tunnel-detail-info"
                self.yang_parent_name = "tunnel-detail-infos"

                self.peer_address = YLeaf(YType.str, "peer-address")

                self.plsp_id = YLeaf(YType.int32, "plsp-id")

                self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                self.pcc_address = YLeaf(YType.str, "pcc-address")

                self.tunnel_name_xr = YLeaf(YType.str, "tunnel-name-xr")

                self.private_lsp_information = Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation()
                self.private_lsp_information.parent = self
                self._children_name_map["private_lsp_information"] = "private-lsp-information"
                self._children_yang_names.add("private-lsp-information")

                self.detail_lsp_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_address",
                                "plsp_id",
                                "tunnel_name",
                                "pcc_address",
                                "tunnel_name_xr") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo, self).__setattr__(name, value)


            class PrivateLspInformation(Entity):
                """
                Private LSP information
                
                .. attribute:: event_buffer
                
                	LSP Event buffer
                	**type**\: list of    :py:class:`EventBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer>`
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation, self).__init__()

                    self.yang_name = "private-lsp-information"
                    self.yang_parent_name = "tunnel-detail-info"

                    self.event_buffer = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation, self).__setattr__(name, value)


                class EventBuffer(Entity):
                    """
                    LSP Event buffer
                    
                    .. attribute:: event_message
                    
                    	Event message
                    	**type**\:  str
                    
                    .. attribute:: time_stamp
                    
                    	Event time, relative to Jan 1, 1970
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer, self).__init__()

                        self.yang_name = "event-buffer"
                        self.yang_parent_name = "private-lsp-information"

                        self.event_message = YLeaf(YType.str, "event-message")

                        self.time_stamp = YLeaf(YType.uint32, "time-stamp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("event_message",
                                        "time_stamp") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.event_message.is_set or
                            self.time_stamp.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.event_message.yfilter != YFilter.not_set or
                            self.time_stamp.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "event-buffer" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.event_message.is_set or self.event_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.event_message.get_name_leafdata())
                        if (self.time_stamp.is_set or self.time_stamp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.time_stamp.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "event-message" or name == "time-stamp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "event-message"):
                            self.event_message = value
                            self.event_message.value_namespace = name_space
                            self.event_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "time-stamp"):
                            self.time_stamp = value
                            self.time_stamp.value_namespace = name_space
                            self.time_stamp.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.event_buffer:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.event_buffer:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "private-lsp-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "event-buffer"):
                        for c in self.event_buffer:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation.EventBuffer()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.event_buffer.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "event-buffer"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class DetailLspInformation(Entity):
                """
                Detail LSP information
                
                .. attribute:: actual_bandwidth
                
                	Actual bandwidth utilized in the data\-plane
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: actual_bandwidth_specified
                
                	True if router notifies actual bandwidth
                	**type**\:  bool
                
                .. attribute:: brief_lsp_information
                
                	Brief LSP information
                	**type**\:   :py:class:`BriefLspInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation>`
                
                .. attribute:: computing_pce
                
                	Computing PCE
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: er_os
                
                	Paths
                	**type**\:   :py:class:`ErOs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs>`
                
                .. attribute:: lsp_association_info
                
                	LSP association information
                	**type**\:   :py:class:`LspAssociationInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo>`
                
                .. attribute:: lsp_attributes
                
                	LSP attributes
                	**type**\:   :py:class:`LspAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes>`
                
                .. attribute:: lsp_role
                
                	LSP Role
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsppcep_information
                
                	PCEP related LSP information
                	**type**\:   :py:class:`LsppcepInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation>`
                
                .. attribute:: reporting_pcc_address
                
                	Reporting PCC address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: rro
                
                	RRO
                	**type**\: list of    :py:class:`Rro <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro>`
                
                .. attribute:: signaled_bandwidth
                
                	Signaled Bandwidth
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: signaled_bandwidth_specified
                
                	True if router notifies signal bandwidth
                	**type**\:  bool
                
                .. attribute:: srlg_info
                
                	List of SLRGs used by LSP
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: state_sync_pce
                
                	State\-sync PCE
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: sub_delegated_pce
                
                	Sub delegated PCE
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'infra-xtc-oper'
                _revision = '2016-05-31'

                def __init__(self):
                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation, self).__init__()

                    self.yang_name = "detail-lsp-information"
                    self.yang_parent_name = "tunnel-detail-info"

                    self.actual_bandwidth = YLeaf(YType.uint64, "actual-bandwidth")

                    self.actual_bandwidth_specified = YLeaf(YType.boolean, "actual-bandwidth-specified")

                    self.computing_pce = YLeaf(YType.uint32, "computing-pce")

                    self.lsp_role = YLeaf(YType.uint32, "lsp-role")

                    self.reporting_pcc_address = YLeaf(YType.str, "reporting-pcc-address")

                    self.signaled_bandwidth = YLeaf(YType.uint64, "signaled-bandwidth")

                    self.signaled_bandwidth_specified = YLeaf(YType.boolean, "signaled-bandwidth-specified")

                    self.srlg_info = YLeafList(YType.uint32, "srlg-info")

                    self.state_sync_pce = YLeaf(YType.str, "state-sync-pce")

                    self.sub_delegated_pce = YLeaf(YType.str, "sub-delegated-pce")

                    self.brief_lsp_information = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation()
                    self.brief_lsp_information.parent = self
                    self._children_name_map["brief_lsp_information"] = "brief-lsp-information"
                    self._children_yang_names.add("brief-lsp-information")

                    self.er_os = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs()
                    self.er_os.parent = self
                    self._children_name_map["er_os"] = "er-os"
                    self._children_yang_names.add("er-os")

                    self.lsp_association_info = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo()
                    self.lsp_association_info.parent = self
                    self._children_name_map["lsp_association_info"] = "lsp-association-info"
                    self._children_yang_names.add("lsp-association-info")

                    self.lsp_attributes = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes()
                    self.lsp_attributes.parent = self
                    self._children_name_map["lsp_attributes"] = "lsp-attributes"
                    self._children_yang_names.add("lsp-attributes")

                    self.lsppcep_information = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation()
                    self.lsppcep_information.parent = self
                    self._children_name_map["lsppcep_information"] = "lsppcep-information"
                    self._children_yang_names.add("lsppcep-information")

                    self.rro = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("actual_bandwidth",
                                    "actual_bandwidth_specified",
                                    "computing_pce",
                                    "lsp_role",
                                    "reporting_pcc_address",
                                    "signaled_bandwidth",
                                    "signaled_bandwidth_specified",
                                    "srlg_info",
                                    "state_sync_pce",
                                    "sub_delegated_pce") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation, self).__setattr__(name, value)


                class BriefLspInformation(Entity):
                    """
                    Brief LSP information
                    
                    .. attribute:: administrative_state
                    
                    	Admin state
                    	**type**\:   :py:class:`LspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspState>`
                    
                    .. attribute:: binding_sid
                    
                    	Binding SID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: destination_address
                    
                    	Destination address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: lsp_setup_type
                    
                    	LSP Setup Type
                    	**type**\:   :py:class:`LspSetup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.LspSetup>`
                    
                    .. attribute:: lspid
                    
                    	LSP ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: operational_state
                    
                    	Operational state
                    	**type**\:   :py:class:`PcepLspState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PcepLspState>`
                    
                    .. attribute:: source_address
                    
                    	Source address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: tunnel_id
                    
                    	Tunnel ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation, self).__init__()

                        self.yang_name = "brief-lsp-information"
                        self.yang_parent_name = "detail-lsp-information"

                        self.administrative_state = YLeaf(YType.enumeration, "administrative-state")

                        self.binding_sid = YLeaf(YType.uint32, "binding-sid")

                        self.destination_address = YLeaf(YType.str, "destination-address")

                        self.lsp_setup_type = YLeaf(YType.enumeration, "lsp-setup-type")

                        self.lspid = YLeaf(YType.uint32, "lspid")

                        self.operational_state = YLeaf(YType.enumeration, "operational-state")

                        self.source_address = YLeaf(YType.str, "source-address")

                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("administrative_state",
                                        "binding_sid",
                                        "destination_address",
                                        "lsp_setup_type",
                                        "lspid",
                                        "operational_state",
                                        "source_address",
                                        "tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.administrative_state.is_set or
                            self.binding_sid.is_set or
                            self.destination_address.is_set or
                            self.lsp_setup_type.is_set or
                            self.lspid.is_set or
                            self.operational_state.is_set or
                            self.source_address.is_set or
                            self.tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.administrative_state.yfilter != YFilter.not_set or
                            self.binding_sid.yfilter != YFilter.not_set or
                            self.destination_address.yfilter != YFilter.not_set or
                            self.lsp_setup_type.yfilter != YFilter.not_set or
                            self.lspid.yfilter != YFilter.not_set or
                            self.operational_state.yfilter != YFilter.not_set or
                            self.source_address.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "brief-lsp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.administrative_state.is_set or self.administrative_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.administrative_state.get_name_leafdata())
                        if (self.binding_sid.is_set or self.binding_sid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_sid.get_name_leafdata())
                        if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination_address.get_name_leafdata())
                        if (self.lsp_setup_type.is_set or self.lsp_setup_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_setup_type.get_name_leafdata())
                        if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lspid.get_name_leafdata())
                        if (self.operational_state.is_set or self.operational_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.operational_state.get_name_leafdata())
                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_address.get_name_leafdata())
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "administrative-state" or name == "binding-sid" or name == "destination-address" or name == "lsp-setup-type" or name == "lspid" or name == "operational-state" or name == "source-address" or name == "tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "administrative-state"):
                            self.administrative_state = value
                            self.administrative_state.value_namespace = name_space
                            self.administrative_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-sid"):
                            self.binding_sid = value
                            self.binding_sid.value_namespace = name_space
                            self.binding_sid.value_namespace_prefix = name_space_prefix
                        if(value_path == "destination-address"):
                            self.destination_address = value
                            self.destination_address.value_namespace = name_space
                            self.destination_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-setup-type"):
                            self.lsp_setup_type = value
                            self.lsp_setup_type.value_namespace = name_space
                            self.lsp_setup_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "lspid"):
                            self.lspid = value
                            self.lspid.value_namespace = name_space
                            self.lspid.value_namespace_prefix = name_space_prefix
                        if(value_path == "operational-state"):
                            self.operational_state = value
                            self.operational_state.value_namespace = name_space
                            self.operational_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-address"):
                            self.source_address = value
                            self.source_address.value_namespace = name_space
                            self.source_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix


                class ErOs(Entity):
                    """
                    Paths
                    
                    .. attribute:: computed_hop_list_time
                    
                    	Computed Hop List Time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: computed_metric_type
                    
                    	Computed Metric Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: computed_metric_value
                    
                    	Computed Metric Value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: computed_rsvp_path
                    
                    	Computed RSVP path
                    	**type**\: list of    :py:class:`ComputedRsvpPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath>`
                    
                    .. attribute:: computed_sr_path
                    
                    	Computed SR path
                    	**type**\: list of    :py:class:`ComputedSrPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath>`
                    
                    .. attribute:: reported_metric_type
                    
                    	Reported Metric Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: reported_metric_value
                    
                    	Reported Metric Value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: reported_rsvp_path
                    
                    	Reported RSVP path
                    	**type**\: list of    :py:class:`ReportedRsvpPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath>`
                    
                    .. attribute:: reported_sr_path
                    
                    	Reported SR path
                    	**type**\: list of    :py:class:`ReportedSrPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs, self).__init__()

                        self.yang_name = "er-os"
                        self.yang_parent_name = "detail-lsp-information"

                        self.computed_hop_list_time = YLeaf(YType.uint32, "computed-hop-list-time")

                        self.computed_metric_type = YLeaf(YType.uint32, "computed-metric-type")

                        self.computed_metric_value = YLeaf(YType.uint32, "computed-metric-value")

                        self.reported_metric_type = YLeaf(YType.uint32, "reported-metric-type")

                        self.reported_metric_value = YLeaf(YType.uint32, "reported-metric-value")

                        self.computed_rsvp_path = YList(self)
                        self.computed_sr_path = YList(self)
                        self.reported_rsvp_path = YList(self)
                        self.reported_sr_path = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("computed_hop_list_time",
                                        "computed_metric_type",
                                        "computed_metric_value",
                                        "reported_metric_type",
                                        "reported_metric_value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs, self).__setattr__(name, value)


                    class ReportedRsvpPath(Entity):
                        """
                        Reported RSVP path
                        
                        .. attribute:: hop_address
                        
                        	RSVP hop address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath, self).__init__()

                            self.yang_name = "reported-rsvp-path"
                            self.yang_parent_name = "er-os"

                            self.hop_address = YLeaf(YType.str, "hop-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hop_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath, self).__setattr__(name, value)

                        def has_data(self):
                            return self.hop_address.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hop_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reported-rsvp-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hop_address.is_set or self.hop_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hop_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hop-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hop-address"):
                                self.hop_address = value
                                self.hop_address.value_namespace = name_space
                                self.hop_address.value_namespace_prefix = name_space_prefix


                    class ReportedSrPath(Entity):
                        """
                        Reported SR path
                        
                        .. attribute:: local_addr
                        
                        	Local Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: mpls_label
                        
                        	Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_addr
                        
                        	Remote Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: sid_type
                        
                        	SID type
                        	**type**\:   :py:class:`PceSrSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceSrSid>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath, self).__init__()

                            self.yang_name = "reported-sr-path"
                            self.yang_parent_name = "er-os"

                            self.local_addr = YLeaf(YType.str, "local-addr")

                            self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                            self.remote_addr = YLeaf(YType.str, "remote-addr")

                            self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_addr",
                                            "mpls_label",
                                            "remote_addr",
                                            "sid_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_addr.is_set or
                                self.mpls_label.is_set or
                                self.remote_addr.is_set or
                                self.sid_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_addr.yfilter != YFilter.not_set or
                                self.mpls_label.yfilter != YFilter.not_set or
                                self.remote_addr.yfilter != YFilter.not_set or
                                self.sid_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reported-sr-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_addr.is_set or self.local_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_addr.get_name_leafdata())
                            if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mpls_label.get_name_leafdata())
                            if (self.remote_addr.is_set or self.remote_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_addr.get_name_leafdata())
                            if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sid_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-addr" or name == "mpls-label" or name == "remote-addr" or name == "sid-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-addr"):
                                self.local_addr = value
                                self.local_addr.value_namespace = name_space
                                self.local_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mpls-label"):
                                self.mpls_label = value
                                self.mpls_label.value_namespace = name_space
                                self.mpls_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-addr"):
                                self.remote_addr = value
                                self.remote_addr.value_namespace = name_space
                                self.remote_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "sid-type"):
                                self.sid_type = value
                                self.sid_type.value_namespace = name_space
                                self.sid_type.value_namespace_prefix = name_space_prefix


                    class ComputedRsvpPath(Entity):
                        """
                        Computed RSVP path
                        
                        .. attribute:: hop_address
                        
                        	RSVP hop address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath, self).__init__()

                            self.yang_name = "computed-rsvp-path"
                            self.yang_parent_name = "er-os"

                            self.hop_address = YLeaf(YType.str, "hop-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hop_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath, self).__setattr__(name, value)

                        def has_data(self):
                            return self.hop_address.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hop_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "computed-rsvp-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hop_address.is_set or self.hop_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hop_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hop-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hop-address"):
                                self.hop_address = value
                                self.hop_address.value_namespace = name_space
                                self.hop_address.value_namespace_prefix = name_space_prefix


                    class ComputedSrPath(Entity):
                        """
                        Computed SR path
                        
                        .. attribute:: local_addr
                        
                        	Local Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: mpls_label
                        
                        	Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_addr
                        
                        	Remote Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: sid_type
                        
                        	SID type
                        	**type**\:   :py:class:`PceSrSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceSrSid>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath, self).__init__()

                            self.yang_name = "computed-sr-path"
                            self.yang_parent_name = "er-os"

                            self.local_addr = YLeaf(YType.str, "local-addr")

                            self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                            self.remote_addr = YLeaf(YType.str, "remote-addr")

                            self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_addr",
                                            "mpls_label",
                                            "remote_addr",
                                            "sid_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_addr.is_set or
                                self.mpls_label.is_set or
                                self.remote_addr.is_set or
                                self.sid_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_addr.yfilter != YFilter.not_set or
                                self.mpls_label.yfilter != YFilter.not_set or
                                self.remote_addr.yfilter != YFilter.not_set or
                                self.sid_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "computed-sr-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_addr.is_set or self.local_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_addr.get_name_leafdata())
                            if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mpls_label.get_name_leafdata())
                            if (self.remote_addr.is_set or self.remote_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_addr.get_name_leafdata())
                            if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sid_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-addr" or name == "mpls-label" or name == "remote-addr" or name == "sid-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-addr"):
                                self.local_addr = value
                                self.local_addr.value_namespace = name_space
                                self.local_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mpls-label"):
                                self.mpls_label = value
                                self.mpls_label.value_namespace = name_space
                                self.mpls_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-addr"):
                                self.remote_addr = value
                                self.remote_addr.value_namespace = name_space
                                self.remote_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "sid-type"):
                                self.sid_type = value
                                self.sid_type.value_namespace = name_space
                                self.sid_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.computed_rsvp_path:
                            if (c.has_data()):
                                return True
                        for c in self.computed_sr_path:
                            if (c.has_data()):
                                return True
                        for c in self.reported_rsvp_path:
                            if (c.has_data()):
                                return True
                        for c in self.reported_sr_path:
                            if (c.has_data()):
                                return True
                        return (
                            self.computed_hop_list_time.is_set or
                            self.computed_metric_type.is_set or
                            self.computed_metric_value.is_set or
                            self.reported_metric_type.is_set or
                            self.reported_metric_value.is_set)

                    def has_operation(self):
                        for c in self.computed_rsvp_path:
                            if (c.has_operation()):
                                return True
                        for c in self.computed_sr_path:
                            if (c.has_operation()):
                                return True
                        for c in self.reported_rsvp_path:
                            if (c.has_operation()):
                                return True
                        for c in self.reported_sr_path:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.computed_hop_list_time.yfilter != YFilter.not_set or
                            self.computed_metric_type.yfilter != YFilter.not_set or
                            self.computed_metric_value.yfilter != YFilter.not_set or
                            self.reported_metric_type.yfilter != YFilter.not_set or
                            self.reported_metric_value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "er-os" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.computed_hop_list_time.is_set or self.computed_hop_list_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.computed_hop_list_time.get_name_leafdata())
                        if (self.computed_metric_type.is_set or self.computed_metric_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.computed_metric_type.get_name_leafdata())
                        if (self.computed_metric_value.is_set or self.computed_metric_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.computed_metric_value.get_name_leafdata())
                        if (self.reported_metric_type.is_set or self.reported_metric_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reported_metric_type.get_name_leafdata())
                        if (self.reported_metric_value.is_set or self.reported_metric_value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reported_metric_value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "computed-rsvp-path"):
                            for c in self.computed_rsvp_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedRsvpPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.computed_rsvp_path.append(c)
                            return c

                        if (child_yang_name == "computed-sr-path"):
                            for c in self.computed_sr_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ComputedSrPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.computed_sr_path.append(c)
                            return c

                        if (child_yang_name == "reported-rsvp-path"):
                            for c in self.reported_rsvp_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedRsvpPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.reported_rsvp_path.append(c)
                            return c

                        if (child_yang_name == "reported-sr-path"):
                            for c in self.reported_sr_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs.ReportedSrPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.reported_sr_path.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "computed-rsvp-path" or name == "computed-sr-path" or name == "reported-rsvp-path" or name == "reported-sr-path" or name == "computed-hop-list-time" or name == "computed-metric-type" or name == "computed-metric-value" or name == "reported-metric-type" or name == "reported-metric-value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "computed-hop-list-time"):
                            self.computed_hop_list_time = value
                            self.computed_hop_list_time.value_namespace = name_space
                            self.computed_hop_list_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "computed-metric-type"):
                            self.computed_metric_type = value
                            self.computed_metric_type.value_namespace = name_space
                            self.computed_metric_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "computed-metric-value"):
                            self.computed_metric_value = value
                            self.computed_metric_value.value_namespace = name_space
                            self.computed_metric_value.value_namespace_prefix = name_space_prefix
                        if(value_path == "reported-metric-type"):
                            self.reported_metric_type = value
                            self.reported_metric_type.value_namespace = name_space
                            self.reported_metric_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "reported-metric-value"):
                            self.reported_metric_value = value
                            self.reported_metric_value.value_namespace = name_space
                            self.reported_metric_value.value_namespace_prefix = name_space_prefix


                class LsppcepInformation(Entity):
                    """
                    PCEP related LSP information
                    
                    .. attribute:: pcep_flag_a
                    
                    	PCEP LSP admin flag
                    	**type**\:  bool
                    
                    .. attribute:: pcep_flag_d
                    
                    	PCEP LSP delegation flag
                    	**type**\:  bool
                    
                    .. attribute:: pcep_flag_o
                    
                    	PCEP LSP operation flag
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: pcep_flag_r
                    
                    	PCEP LSP remove flag
                    	**type**\:  bool
                    
                    .. attribute:: pcep_flag_s
                    
                    	PCEP LSP state\-sync flag
                    	**type**\:  bool
                    
                    .. attribute:: pcepid
                    
                    	PCE protocol identifier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rsvp_error
                    
                    	RSVP error info
                    	**type**\:   :py:class:`RsvpError <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation, self).__init__()

                        self.yang_name = "lsppcep-information"
                        self.yang_parent_name = "detail-lsp-information"

                        self.pcep_flag_a = YLeaf(YType.boolean, "pcep-flag-a")

                        self.pcep_flag_d = YLeaf(YType.boolean, "pcep-flag-d")

                        self.pcep_flag_o = YLeaf(YType.uint8, "pcep-flag-o")

                        self.pcep_flag_r = YLeaf(YType.boolean, "pcep-flag-r")

                        self.pcep_flag_s = YLeaf(YType.boolean, "pcep-flag-s")

                        self.pcepid = YLeaf(YType.uint32, "pcepid")

                        self.rsvp_error = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError()
                        self.rsvp_error.parent = self
                        self._children_name_map["rsvp_error"] = "rsvp-error"
                        self._children_yang_names.add("rsvp-error")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pcep_flag_a",
                                        "pcep_flag_d",
                                        "pcep_flag_o",
                                        "pcep_flag_r",
                                        "pcep_flag_s",
                                        "pcepid") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation, self).__setattr__(name, value)


                    class RsvpError(Entity):
                        """
                        RSVP error info
                        
                        .. attribute:: error_code
                        
                        	RSVP error code
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: error_flags
                        
                        	RSVP error flags
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: error_value
                        
                        	RSVP error value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: node_address
                        
                        	RSVP error node address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError, self).__init__()

                            self.yang_name = "rsvp-error"
                            self.yang_parent_name = "lsppcep-information"

                            self.error_code = YLeaf(YType.uint8, "error-code")

                            self.error_flags = YLeaf(YType.uint8, "error-flags")

                            self.error_value = YLeaf(YType.uint16, "error-value")

                            self.node_address = YLeaf(YType.str, "node-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("error_code",
                                            "error_flags",
                                            "error_value",
                                            "node_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.error_code.is_set or
                                self.error_flags.is_set or
                                self.error_value.is_set or
                                self.node_address.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.error_code.yfilter != YFilter.not_set or
                                self.error_flags.yfilter != YFilter.not_set or
                                self.error_value.yfilter != YFilter.not_set or
                                self.node_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rsvp-error" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.error_code.is_set or self.error_code.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.error_code.get_name_leafdata())
                            if (self.error_flags.is_set or self.error_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.error_flags.get_name_leafdata())
                            if (self.error_value.is_set or self.error_value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.error_value.get_name_leafdata())
                            if (self.node_address.is_set or self.node_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "error-code" or name == "error-flags" or name == "error-value" or name == "node-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "error-code"):
                                self.error_code = value
                                self.error_code.value_namespace = name_space
                                self.error_code.value_namespace_prefix = name_space_prefix
                            if(value_path == "error-flags"):
                                self.error_flags = value
                                self.error_flags.value_namespace = name_space
                                self.error_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "error-value"):
                                self.error_value = value
                                self.error_value.value_namespace = name_space
                                self.error_value.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-address"):
                                self.node_address = value
                                self.node_address.value_namespace = name_space
                                self.node_address.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.pcep_flag_a.is_set or
                            self.pcep_flag_d.is_set or
                            self.pcep_flag_o.is_set or
                            self.pcep_flag_r.is_set or
                            self.pcep_flag_s.is_set or
                            self.pcepid.is_set or
                            (self.rsvp_error is not None and self.rsvp_error.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pcep_flag_a.yfilter != YFilter.not_set or
                            self.pcep_flag_d.yfilter != YFilter.not_set or
                            self.pcep_flag_o.yfilter != YFilter.not_set or
                            self.pcep_flag_r.yfilter != YFilter.not_set or
                            self.pcep_flag_s.yfilter != YFilter.not_set or
                            self.pcepid.yfilter != YFilter.not_set or
                            (self.rsvp_error is not None and self.rsvp_error.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsppcep-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pcep_flag_a.is_set or self.pcep_flag_a.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_a.get_name_leafdata())
                        if (self.pcep_flag_d.is_set or self.pcep_flag_d.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_d.get_name_leafdata())
                        if (self.pcep_flag_o.is_set or self.pcep_flag_o.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_o.get_name_leafdata())
                        if (self.pcep_flag_r.is_set or self.pcep_flag_r.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_r.get_name_leafdata())
                        if (self.pcep_flag_s.is_set or self.pcep_flag_s.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcep_flag_s.get_name_leafdata())
                        if (self.pcepid.is_set or self.pcepid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pcepid.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "rsvp-error"):
                            if (self.rsvp_error is None):
                                self.rsvp_error = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation.RsvpError()
                                self.rsvp_error.parent = self
                                self._children_name_map["rsvp_error"] = "rsvp-error"
                            return self.rsvp_error

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rsvp-error" or name == "pcep-flag-a" or name == "pcep-flag-d" or name == "pcep-flag-o" or name == "pcep-flag-r" or name == "pcep-flag-s" or name == "pcepid"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pcep-flag-a"):
                            self.pcep_flag_a = value
                            self.pcep_flag_a.value_namespace = name_space
                            self.pcep_flag_a.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-d"):
                            self.pcep_flag_d = value
                            self.pcep_flag_d.value_namespace = name_space
                            self.pcep_flag_d.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-o"):
                            self.pcep_flag_o = value
                            self.pcep_flag_o.value_namespace = name_space
                            self.pcep_flag_o.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-r"):
                            self.pcep_flag_r = value
                            self.pcep_flag_r.value_namespace = name_space
                            self.pcep_flag_r.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcep-flag-s"):
                            self.pcep_flag_s = value
                            self.pcep_flag_s.value_namespace = name_space
                            self.pcep_flag_s.value_namespace_prefix = name_space_prefix
                        if(value_path == "pcepid"):
                            self.pcepid = value
                            self.pcepid.value_namespace = name_space
                            self.pcepid.value_namespace_prefix = name_space_prefix


                class LspAssociationInfo(Entity):
                    """
                    LSP association information
                    
                    .. attribute:: association_id
                    
                    	Association ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: association_source
                    
                    	Association Source
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: association_type
                    
                    	Association Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo, self).__init__()

                        self.yang_name = "lsp-association-info"
                        self.yang_parent_name = "detail-lsp-information"

                        self.association_id = YLeaf(YType.uint32, "association-id")

                        self.association_source = YLeaf(YType.str, "association-source")

                        self.association_type = YLeaf(YType.uint32, "association-type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("association_id",
                                        "association_source",
                                        "association_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.association_id.is_set or
                            self.association_source.is_set or
                            self.association_type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.association_id.yfilter != YFilter.not_set or
                            self.association_source.yfilter != YFilter.not_set or
                            self.association_type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-association-info" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.association_id.is_set or self.association_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.association_id.get_name_leafdata())
                        if (self.association_source.is_set or self.association_source.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.association_source.get_name_leafdata())
                        if (self.association_type.is_set or self.association_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.association_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "association-id" or name == "association-source" or name == "association-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "association-id"):
                            self.association_id = value
                            self.association_id.value_namespace = name_space
                            self.association_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "association-source"):
                            self.association_source = value
                            self.association_source.value_namespace = name_space
                            self.association_source.value_namespace_prefix = name_space_prefix
                        if(value_path == "association-type"):
                            self.association_type = value
                            self.association_type.value_namespace = name_space
                            self.association_type.value_namespace_prefix = name_space_prefix


                class LspAttributes(Entity):
                    """
                    LSP attributes
                    
                    .. attribute:: affinity_exclude_any
                    
                    	Affinity exclude any
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: affinity_include_all
                    
                    	Affinity include all
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: affinity_include_any
                    
                    	Affinity include any
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: hold_priority
                    
                    	Hold Priority
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: local_protection
                    
                    	True, if local protection is desired
                    	**type**\:  bool
                    
                    .. attribute:: setup_priority
                    
                    	Setup Priority
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes, self).__init__()

                        self.yang_name = "lsp-attributes"
                        self.yang_parent_name = "detail-lsp-information"

                        self.affinity_exclude_any = YLeaf(YType.uint32, "affinity-exclude-any")

                        self.affinity_include_all = YLeaf(YType.uint32, "affinity-include-all")

                        self.affinity_include_any = YLeaf(YType.uint32, "affinity-include-any")

                        self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                        self.local_protection = YLeaf(YType.boolean, "local-protection")

                        self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("affinity_exclude_any",
                                        "affinity_include_all",
                                        "affinity_include_any",
                                        "hold_priority",
                                        "local_protection",
                                        "setup_priority") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.affinity_exclude_any.is_set or
                            self.affinity_include_all.is_set or
                            self.affinity_include_any.is_set or
                            self.hold_priority.is_set or
                            self.local_protection.is_set or
                            self.setup_priority.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.affinity_exclude_any.yfilter != YFilter.not_set or
                            self.affinity_include_all.yfilter != YFilter.not_set or
                            self.affinity_include_any.yfilter != YFilter.not_set or
                            self.hold_priority.yfilter != YFilter.not_set or
                            self.local_protection.yfilter != YFilter.not_set or
                            self.setup_priority.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-attributes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.affinity_exclude_any.is_set or self.affinity_exclude_any.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.affinity_exclude_any.get_name_leafdata())
                        if (self.affinity_include_all.is_set or self.affinity_include_all.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.affinity_include_all.get_name_leafdata())
                        if (self.affinity_include_any.is_set or self.affinity_include_any.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.affinity_include_any.get_name_leafdata())
                        if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_priority.get_name_leafdata())
                        if (self.local_protection.is_set or self.local_protection.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_protection.get_name_leafdata())
                        if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.setup_priority.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "affinity-exclude-any" or name == "affinity-include-all" or name == "affinity-include-any" or name == "hold-priority" or name == "local-protection" or name == "setup-priority"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "affinity-exclude-any"):
                            self.affinity_exclude_any = value
                            self.affinity_exclude_any.value_namespace = name_space
                            self.affinity_exclude_any.value_namespace_prefix = name_space_prefix
                        if(value_path == "affinity-include-all"):
                            self.affinity_include_all = value
                            self.affinity_include_all.value_namespace = name_space
                            self.affinity_include_all.value_namespace_prefix = name_space_prefix
                        if(value_path == "affinity-include-any"):
                            self.affinity_include_any = value
                            self.affinity_include_any.value_namespace = name_space
                            self.affinity_include_any.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-priority"):
                            self.hold_priority = value
                            self.hold_priority.value_namespace = name_space
                            self.hold_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-protection"):
                            self.local_protection = value
                            self.local_protection.value_namespace = name_space
                            self.local_protection.value_namespace_prefix = name_space_prefix
                        if(value_path == "setup-priority"):
                            self.setup_priority = value
                            self.setup_priority.value_namespace = name_space
                            self.setup_priority.value_namespace_prefix = name_space_prefix


                class Rro(Entity):
                    """
                    RRO
                    
                    .. attribute:: flags
                    
                    	RRO Flags
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4_address
                    
                    	IPv4 address of RRO
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: mpls_label
                    
                    	MPLS label of RRO
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rro_type
                    
                    	RRO Type
                    	**type**\:   :py:class:`PceRro <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceRro>`
                    
                    .. attribute:: sr_rro
                    
                    	Segment Routing RRO info
                    	**type**\:   :py:class:`SrRro <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro>`
                    
                    

                    """

                    _prefix = 'infra-xtc-oper'
                    _revision = '2016-05-31'

                    def __init__(self):
                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro, self).__init__()

                        self.yang_name = "rro"
                        self.yang_parent_name = "detail-lsp-information"

                        self.flags = YLeaf(YType.uint8, "flags")

                        self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                        self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                        self.rro_type = YLeaf(YType.enumeration, "rro-type")

                        self.sr_rro = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro()
                        self.sr_rro.parent = self
                        self._children_name_map["sr_rro"] = "sr-rro"
                        self._children_yang_names.add("sr-rro")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("flags",
                                        "ipv4_address",
                                        "mpls_label",
                                        "rro_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro, self).__setattr__(name, value)


                    class SrRro(Entity):
                        """
                        Segment Routing RRO info
                        
                        .. attribute:: local_addr
                        
                        	Local Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: mpls_label
                        
                        	Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_addr
                        
                        	Remote Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: sid_type
                        
                        	SID type
                        	**type**\:   :py:class:`PceSrSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_xtc_oper.PceSrSid>`
                        
                        

                        """

                        _prefix = 'infra-xtc-oper'
                        _revision = '2016-05-31'

                        def __init__(self):
                            super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro, self).__init__()

                            self.yang_name = "sr-rro"
                            self.yang_parent_name = "rro"

                            self.local_addr = YLeaf(YType.str, "local-addr")

                            self.mpls_label = YLeaf(YType.uint32, "mpls-label")

                            self.remote_addr = YLeaf(YType.str, "remote-addr")

                            self.sid_type = YLeaf(YType.enumeration, "sid-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_addr",
                                            "mpls_label",
                                            "remote_addr",
                                            "sid_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_addr.is_set or
                                self.mpls_label.is_set or
                                self.remote_addr.is_set or
                                self.sid_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_addr.yfilter != YFilter.not_set or
                                self.mpls_label.yfilter != YFilter.not_set or
                                self.remote_addr.yfilter != YFilter.not_set or
                                self.sid_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sr-rro" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_addr.is_set or self.local_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_addr.get_name_leafdata())
                            if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mpls_label.get_name_leafdata())
                            if (self.remote_addr.is_set or self.remote_addr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_addr.get_name_leafdata())
                            if (self.sid_type.is_set or self.sid_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sid_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-addr" or name == "mpls-label" or name == "remote-addr" or name == "sid-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-addr"):
                                self.local_addr = value
                                self.local_addr.value_namespace = name_space
                                self.local_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mpls-label"):
                                self.mpls_label = value
                                self.mpls_label.value_namespace = name_space
                                self.mpls_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-addr"):
                                self.remote_addr = value
                                self.remote_addr.value_namespace = name_space
                                self.remote_addr.value_namespace_prefix = name_space_prefix
                            if(value_path == "sid-type"):
                                self.sid_type = value
                                self.sid_type.value_namespace = name_space
                                self.sid_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.flags.is_set or
                            self.ipv4_address.is_set or
                            self.mpls_label.is_set or
                            self.rro_type.is_set or
                            (self.sr_rro is not None and self.sr_rro.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.flags.yfilter != YFilter.not_set or
                            self.ipv4_address.yfilter != YFilter.not_set or
                            self.mpls_label.yfilter != YFilter.not_set or
                            self.rro_type.yfilter != YFilter.not_set or
                            (self.sr_rro is not None and self.sr_rro.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rro" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.flags.get_name_leafdata())
                        if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                        if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_label.get_name_leafdata())
                        if (self.rro_type.is_set or self.rro_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rro_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sr-rro"):
                            if (self.sr_rro is None):
                                self.sr_rro = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro.SrRro()
                                self.sr_rro.parent = self
                                self._children_name_map["sr_rro"] = "sr-rro"
                            return self.sr_rro

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sr-rro" or name == "flags" or name == "ipv4-address" or name == "mpls-label" or name == "rro-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "flags"):
                            self.flags = value
                            self.flags.value_namespace = name_space
                            self.flags.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4-address"):
                            self.ipv4_address = value
                            self.ipv4_address.value_namespace = name_space
                            self.ipv4_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "mpls-label"):
                            self.mpls_label = value
                            self.mpls_label.value_namespace = name_space
                            self.mpls_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "rro-type"):
                            self.rro_type = value
                            self.rro_type.value_namespace = name_space
                            self.rro_type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.rro:
                        if (c.has_data()):
                            return True
                    for leaf in self.srlg_info.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.actual_bandwidth.is_set or
                        self.actual_bandwidth_specified.is_set or
                        self.computing_pce.is_set or
                        self.lsp_role.is_set or
                        self.reporting_pcc_address.is_set or
                        self.signaled_bandwidth.is_set or
                        self.signaled_bandwidth_specified.is_set or
                        self.state_sync_pce.is_set or
                        self.sub_delegated_pce.is_set or
                        (self.brief_lsp_information is not None and self.brief_lsp_information.has_data()) or
                        (self.er_os is not None and self.er_os.has_data()) or
                        (self.lsp_association_info is not None and self.lsp_association_info.has_data()) or
                        (self.lsp_attributes is not None and self.lsp_attributes.has_data()) or
                        (self.lsppcep_information is not None and self.lsppcep_information.has_data()))

                def has_operation(self):
                    for c in self.rro:
                        if (c.has_operation()):
                            return True
                    for leaf in self.srlg_info.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.actual_bandwidth.yfilter != YFilter.not_set or
                        self.actual_bandwidth_specified.yfilter != YFilter.not_set or
                        self.computing_pce.yfilter != YFilter.not_set or
                        self.lsp_role.yfilter != YFilter.not_set or
                        self.reporting_pcc_address.yfilter != YFilter.not_set or
                        self.signaled_bandwidth.yfilter != YFilter.not_set or
                        self.signaled_bandwidth_specified.yfilter != YFilter.not_set or
                        self.srlg_info.yfilter != YFilter.not_set or
                        self.state_sync_pce.yfilter != YFilter.not_set or
                        self.sub_delegated_pce.yfilter != YFilter.not_set or
                        (self.brief_lsp_information is not None and self.brief_lsp_information.has_operation()) or
                        (self.er_os is not None and self.er_os.has_operation()) or
                        (self.lsp_association_info is not None and self.lsp_association_info.has_operation()) or
                        (self.lsp_attributes is not None and self.lsp_attributes.has_operation()) or
                        (self.lsppcep_information is not None and self.lsppcep_information.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "detail-lsp-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.actual_bandwidth.is_set or self.actual_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.actual_bandwidth.get_name_leafdata())
                    if (self.actual_bandwidth_specified.is_set or self.actual_bandwidth_specified.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.actual_bandwidth_specified.get_name_leafdata())
                    if (self.computing_pce.is_set or self.computing_pce.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.computing_pce.get_name_leafdata())
                    if (self.lsp_role.is_set or self.lsp_role.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_role.get_name_leafdata())
                    if (self.reporting_pcc_address.is_set or self.reporting_pcc_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reporting_pcc_address.get_name_leafdata())
                    if (self.signaled_bandwidth.is_set or self.signaled_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.signaled_bandwidth.get_name_leafdata())
                    if (self.signaled_bandwidth_specified.is_set or self.signaled_bandwidth_specified.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.signaled_bandwidth_specified.get_name_leafdata())
                    if (self.state_sync_pce.is_set or self.state_sync_pce.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state_sync_pce.get_name_leafdata())
                    if (self.sub_delegated_pce.is_set or self.sub_delegated_pce.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sub_delegated_pce.get_name_leafdata())

                    leaf_name_data.extend(self.srlg_info.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "brief-lsp-information"):
                        if (self.brief_lsp_information is None):
                            self.brief_lsp_information = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.BriefLspInformation()
                            self.brief_lsp_information.parent = self
                            self._children_name_map["brief_lsp_information"] = "brief-lsp-information"
                        return self.brief_lsp_information

                    if (child_yang_name == "er-os"):
                        if (self.er_os is None):
                            self.er_os = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.ErOs()
                            self.er_os.parent = self
                            self._children_name_map["er_os"] = "er-os"
                        return self.er_os

                    if (child_yang_name == "lsp-association-info"):
                        if (self.lsp_association_info is None):
                            self.lsp_association_info = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAssociationInfo()
                            self.lsp_association_info.parent = self
                            self._children_name_map["lsp_association_info"] = "lsp-association-info"
                        return self.lsp_association_info

                    if (child_yang_name == "lsp-attributes"):
                        if (self.lsp_attributes is None):
                            self.lsp_attributes = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LspAttributes()
                            self.lsp_attributes.parent = self
                            self._children_name_map["lsp_attributes"] = "lsp-attributes"
                        return self.lsp_attributes

                    if (child_yang_name == "lsppcep-information"):
                        if (self.lsppcep_information is None):
                            self.lsppcep_information = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.LsppcepInformation()
                            self.lsppcep_information.parent = self
                            self._children_name_map["lsppcep_information"] = "lsppcep-information"
                        return self.lsppcep_information

                    if (child_yang_name == "rro"):
                        for c in self.rro:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation.Rro()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.rro.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "brief-lsp-information" or name == "er-os" or name == "lsp-association-info" or name == "lsp-attributes" or name == "lsppcep-information" or name == "rro" or name == "actual-bandwidth" or name == "actual-bandwidth-specified" or name == "computing-pce" or name == "lsp-role" or name == "reporting-pcc-address" or name == "signaled-bandwidth" or name == "signaled-bandwidth-specified" or name == "srlg-info" or name == "state-sync-pce" or name == "sub-delegated-pce"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "actual-bandwidth"):
                        self.actual_bandwidth = value
                        self.actual_bandwidth.value_namespace = name_space
                        self.actual_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "actual-bandwidth-specified"):
                        self.actual_bandwidth_specified = value
                        self.actual_bandwidth_specified.value_namespace = name_space
                        self.actual_bandwidth_specified.value_namespace_prefix = name_space_prefix
                    if(value_path == "computing-pce"):
                        self.computing_pce = value
                        self.computing_pce.value_namespace = name_space
                        self.computing_pce.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-role"):
                        self.lsp_role = value
                        self.lsp_role.value_namespace = name_space
                        self.lsp_role.value_namespace_prefix = name_space_prefix
                    if(value_path == "reporting-pcc-address"):
                        self.reporting_pcc_address = value
                        self.reporting_pcc_address.value_namespace = name_space
                        self.reporting_pcc_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "signaled-bandwidth"):
                        self.signaled_bandwidth = value
                        self.signaled_bandwidth.value_namespace = name_space
                        self.signaled_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "signaled-bandwidth-specified"):
                        self.signaled_bandwidth_specified = value
                        self.signaled_bandwidth_specified.value_namespace = name_space
                        self.signaled_bandwidth_specified.value_namespace_prefix = name_space_prefix
                    if(value_path == "srlg-info"):
                        self.srlg_info.append(value)
                    if(value_path == "state-sync-pce"):
                        self.state_sync_pce = value
                        self.state_sync_pce.value_namespace = name_space
                        self.state_sync_pce.value_namespace_prefix = name_space_prefix
                    if(value_path == "sub-delegated-pce"):
                        self.sub_delegated_pce = value
                        self.sub_delegated_pce.value_namespace = name_space
                        self.sub_delegated_pce.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.detail_lsp_information:
                    if (c.has_data()):
                        return True
                return (
                    self.peer_address.is_set or
                    self.plsp_id.is_set or
                    self.tunnel_name.is_set or
                    self.pcc_address.is_set or
                    self.tunnel_name_xr.is_set or
                    (self.private_lsp_information is not None and self.private_lsp_information.has_data()))

            def has_operation(self):
                for c in self.detail_lsp_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_address.yfilter != YFilter.not_set or
                    self.plsp_id.yfilter != YFilter.not_set or
                    self.tunnel_name.yfilter != YFilter.not_set or
                    self.pcc_address.yfilter != YFilter.not_set or
                    self.tunnel_name_xr.yfilter != YFilter.not_set or
                    (self.private_lsp_information is not None and self.private_lsp_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel-detail-info" + "[peer-address='" + self.peer_address.get() + "']" + "[plsp-id='" + self.plsp_id.get() + "']" + "[tunnel-name='" + self.tunnel_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/tunnel-detail-infos/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_address.is_set or self.peer_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_address.get_name_leafdata())
                if (self.plsp_id.is_set or self.plsp_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.plsp_id.get_name_leafdata())
                if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name.get_name_leafdata())
                if (self.pcc_address.is_set or self.pcc_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pcc_address.get_name_leafdata())
                if (self.tunnel_name_xr.is_set or self.tunnel_name_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tunnel_name_xr.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "detail-lsp-information"):
                    for c in self.detail_lsp_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Pce.TunnelDetailInfos.TunnelDetailInfo.DetailLspInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.detail_lsp_information.append(c)
                    return c

                if (child_yang_name == "private-lsp-information"):
                    if (self.private_lsp_information is None):
                        self.private_lsp_information = Pce.TunnelDetailInfos.TunnelDetailInfo.PrivateLspInformation()
                        self.private_lsp_information.parent = self
                        self._children_name_map["private_lsp_information"] = "private-lsp-information"
                    return self.private_lsp_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "detail-lsp-information" or name == "private-lsp-information" or name == "peer-address" or name == "plsp-id" or name == "tunnel-name" or name == "pcc-address" or name == "tunnel-name-xr"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-address"):
                    self.peer_address = value
                    self.peer_address.value_namespace = name_space
                    self.peer_address.value_namespace_prefix = name_space_prefix
                if(value_path == "plsp-id"):
                    self.plsp_id = value
                    self.plsp_id.value_namespace = name_space
                    self.plsp_id.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name"):
                    self.tunnel_name = value
                    self.tunnel_name.value_namespace = name_space
                    self.tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "pcc-address"):
                    self.pcc_address = value
                    self.pcc_address.value_namespace = name_space
                    self.pcc_address.value_namespace_prefix = name_space_prefix
                if(value_path == "tunnel-name-xr"):
                    self.tunnel_name_xr = value
                    self.tunnel_name_xr.value_namespace = name_space
                    self.tunnel_name_xr.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel_detail_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel_detail_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnel-detail-infos" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel-detail-info"):
                for c in self.tunnel_detail_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pce.TunnelDetailInfos.TunnelDetailInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel_detail_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel-detail-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.association_infos is not None and self.association_infos.has_data()) or
            (self.lsp_summary is not None and self.lsp_summary.has_data()) or
            (self.peer_detail_infos is not None and self.peer_detail_infos.has_data()) or
            (self.peer_infos is not None and self.peer_infos.has_data()) or
            (self.prefix_infos is not None and self.prefix_infos.has_data()) or
            (self.topology_nodes is not None and self.topology_nodes.has_data()) or
            (self.topology_summary is not None and self.topology_summary.has_data()) or
            (self.tunnel_detail_infos is not None and self.tunnel_detail_infos.has_data()) or
            (self.tunnel_infos is not None and self.tunnel_infos.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.association_infos is not None and self.association_infos.has_operation()) or
            (self.lsp_summary is not None and self.lsp_summary.has_operation()) or
            (self.peer_detail_infos is not None and self.peer_detail_infos.has_operation()) or
            (self.peer_infos is not None and self.peer_infos.has_operation()) or
            (self.prefix_infos is not None and self.prefix_infos.has_operation()) or
            (self.topology_nodes is not None and self.topology_nodes.has_operation()) or
            (self.topology_summary is not None and self.topology_summary.has_operation()) or
            (self.tunnel_detail_infos is not None and self.tunnel_detail_infos.has_operation()) or
            (self.tunnel_infos is not None and self.tunnel_infos.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-infra-xtc-oper:pce" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "association-infos"):
            if (self.association_infos is None):
                self.association_infos = Pce.AssociationInfos()
                self.association_infos.parent = self
                self._children_name_map["association_infos"] = "association-infos"
            return self.association_infos

        if (child_yang_name == "lsp-summary"):
            if (self.lsp_summary is None):
                self.lsp_summary = Pce.LspSummary()
                self.lsp_summary.parent = self
                self._children_name_map["lsp_summary"] = "lsp-summary"
            return self.lsp_summary

        if (child_yang_name == "peer-detail-infos"):
            if (self.peer_detail_infos is None):
                self.peer_detail_infos = Pce.PeerDetailInfos()
                self.peer_detail_infos.parent = self
                self._children_name_map["peer_detail_infos"] = "peer-detail-infos"
            return self.peer_detail_infos

        if (child_yang_name == "peer-infos"):
            if (self.peer_infos is None):
                self.peer_infos = Pce.PeerInfos()
                self.peer_infos.parent = self
                self._children_name_map["peer_infos"] = "peer-infos"
            return self.peer_infos

        if (child_yang_name == "prefix-infos"):
            if (self.prefix_infos is None):
                self.prefix_infos = Pce.PrefixInfos()
                self.prefix_infos.parent = self
                self._children_name_map["prefix_infos"] = "prefix-infos"
            return self.prefix_infos

        if (child_yang_name == "topology-nodes"):
            if (self.topology_nodes is None):
                self.topology_nodes = Pce.TopologyNodes()
                self.topology_nodes.parent = self
                self._children_name_map["topology_nodes"] = "topology-nodes"
            return self.topology_nodes

        if (child_yang_name == "topology-summary"):
            if (self.topology_summary is None):
                self.topology_summary = Pce.TopologySummary()
                self.topology_summary.parent = self
                self._children_name_map["topology_summary"] = "topology-summary"
            return self.topology_summary

        if (child_yang_name == "tunnel-detail-infos"):
            if (self.tunnel_detail_infos is None):
                self.tunnel_detail_infos = Pce.TunnelDetailInfos()
                self.tunnel_detail_infos.parent = self
                self._children_name_map["tunnel_detail_infos"] = "tunnel-detail-infos"
            return self.tunnel_detail_infos

        if (child_yang_name == "tunnel-infos"):
            if (self.tunnel_infos is None):
                self.tunnel_infos = Pce.TunnelInfos()
                self.tunnel_infos.parent = self
                self._children_name_map["tunnel_infos"] = "tunnel-infos"
            return self.tunnel_infos

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "association-infos" or name == "lsp-summary" or name == "peer-detail-infos" or name == "peer-infos" or name == "prefix-infos" or name == "topology-nodes" or name == "topology-summary" or name == "tunnel-detail-infos" or name == "tunnel-infos"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Pce()
        return self._top_entity

