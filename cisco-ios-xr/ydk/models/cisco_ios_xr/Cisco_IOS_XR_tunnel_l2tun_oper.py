""" Cisco_IOS_XR_tunnel_l2tun_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR tunnel\-l2tun package operational data.

This module contains definitions
for the following management objects\:
  l2tp\: L2TP operational data
  l2tpv2\: l2tpv2

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class DigestHash(Enum):
    """
    DigestHash

    Digest hash types

    .. data:: md5 = 0

    	MD5

    .. data:: sha1 = 1

    	SHA1

    """

    md5 = Enum.YLeaf(0, "md5")

    sha1 = Enum.YLeaf(1, "sha1")



class L2Tp(Entity):
    """
    L2TP operational data
    
    .. attribute:: classes
    
    	List of L2TP class names
    	**type**\:   :py:class:`Classes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Classes>`
    
    .. attribute:: counter_hist_fail
    
    	Failure events leading to disconnection
    	**type**\:   :py:class:`CounterHistFail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.CounterHistFail>`
    
    .. attribute:: counters
    
    	L2TP control messages counters
    	**type**\:   :py:class:`Counters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters>`
    
    .. attribute:: session
    
    	L2TP control messages counters
    	**type**\:   :py:class:`Session <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Session>`
    
    .. attribute:: sessions
    
    	List of session IDs
    	**type**\:   :py:class:`Sessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Sessions>`
    
    .. attribute:: tunnel_configurations
    
    	List of tunnel IDs
    	**type**\:   :py:class:`TunnelConfigurations <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.TunnelConfigurations>`
    
    .. attribute:: tunnels
    
    	List of tunnel IDs
    	**type**\:   :py:class:`Tunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Tunnels>`
    
    

    """

    _prefix = 'tunnel-l2tun-oper'
    _revision = '2015-11-09'

    def __init__(self):
        super(L2Tp, self).__init__()
        self._top_entity = None

        self.yang_name = "l2tp"
        self.yang_parent_name = "Cisco-IOS-XR-tunnel-l2tun-oper"

        self.classes = L2Tp.Classes()
        self.classes.parent = self
        self._children_name_map["classes"] = "classes"
        self._children_yang_names.add("classes")

        self.counter_hist_fail = L2Tp.CounterHistFail()
        self.counter_hist_fail.parent = self
        self._children_name_map["counter_hist_fail"] = "counter-hist-fail"
        self._children_yang_names.add("counter-hist-fail")

        self.counters = L2Tp.Counters()
        self.counters.parent = self
        self._children_name_map["counters"] = "counters"
        self._children_yang_names.add("counters")

        self.session = L2Tp.Session()
        self.session.parent = self
        self._children_name_map["session"] = "session"
        self._children_yang_names.add("session")

        self.sessions = L2Tp.Sessions()
        self.sessions.parent = self
        self._children_name_map["sessions"] = "sessions"
        self._children_yang_names.add("sessions")

        self.tunnel_configurations = L2Tp.TunnelConfigurations()
        self.tunnel_configurations.parent = self
        self._children_name_map["tunnel_configurations"] = "tunnel-configurations"
        self._children_yang_names.add("tunnel-configurations")

        self.tunnels = L2Tp.Tunnels()
        self.tunnels.parent = self
        self._children_name_map["tunnels"] = "tunnels"
        self._children_yang_names.add("tunnels")


    class Counters(Entity):
        """
        L2TP control messages counters
        
        .. attribute:: control
        
        	L2TP control messages counters
        	**type**\:   :py:class:`Control <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tp.Counters, self).__init__()

            self.yang_name = "counters"
            self.yang_parent_name = "l2tp"

            self.control = L2Tp.Counters.Control()
            self.control.parent = self
            self._children_name_map["control"] = "control"
            self._children_yang_names.add("control")


        class Control(Entity):
            """
            L2TP control messages counters
            
            .. attribute:: tunnel_xr
            
            	L2TP control tunnel messages counters
            	**type**\:   :py:class:`TunnelXr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr>`
            
            .. attribute:: tunnels
            
            	Table of tunnel IDs of control message counters
            	**type**\:   :py:class:`Tunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels>`
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tp.Counters.Control, self).__init__()

                self.yang_name = "control"
                self.yang_parent_name = "counters"

                self.tunnel_xr = L2Tp.Counters.Control.TunnelXr()
                self.tunnel_xr.parent = self
                self._children_name_map["tunnel_xr"] = "tunnel-xr"
                self._children_yang_names.add("tunnel-xr")

                self.tunnels = L2Tp.Counters.Control.Tunnels()
                self.tunnels.parent = self
                self._children_name_map["tunnels"] = "tunnels"
                self._children_yang_names.add("tunnels")


            class TunnelXr(Entity):
                """
                L2TP control tunnel messages counters
                
                .. attribute:: authentication
                
                	Tunnel authentication counters
                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication>`
                
                .. attribute:: global_
                
                	Tunnel counters
                	**type**\:   :py:class:`Global_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Global_>`
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tp.Counters.Control.TunnelXr, self).__init__()

                    self.yang_name = "tunnel-xr"
                    self.yang_parent_name = "control"

                    self.authentication = L2Tp.Counters.Control.TunnelXr.Authentication()
                    self.authentication.parent = self
                    self._children_name_map["authentication"] = "authentication"
                    self._children_yang_names.add("authentication")

                    self.global_ = L2Tp.Counters.Control.TunnelXr.Global_()
                    self.global_.parent = self
                    self._children_name_map["global_"] = "global"
                    self._children_yang_names.add("global")


                class Authentication(Entity):
                    """
                    Tunnel authentication counters
                    
                    .. attribute:: challenge_avp
                    
                    	Challenge AVP statistics
                    	**type**\:   :py:class:`ChallengeAvp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeAvp>`
                    
                    .. attribute:: challenge_reponse
                    
                    	Challenge response statistics
                    	**type**\:   :py:class:`ChallengeReponse <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeReponse>`
                    
                    .. attribute:: common_digest
                    
                    	Common digest statistics
                    	**type**\:   :py:class:`CommonDigest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.CommonDigest>`
                    
                    .. attribute:: integrity_check
                    
                    	Integrity check statistics
                    	**type**\:   :py:class:`IntegrityCheck <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.IntegrityCheck>`
                    
                    .. attribute:: local_secret
                    
                    	Local secret statistics
                    	**type**\:   :py:class:`LocalSecret <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.LocalSecret>`
                    
                    .. attribute:: nonce_avp
                    
                    	Nonce AVP statistics
                    	**type**\:   :py:class:`NonceAvp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.NonceAvp>`
                    
                    .. attribute:: overall_statistics
                    
                    	Overall statistics
                    	**type**\:   :py:class:`OverallStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.OverallStatistics>`
                    
                    .. attribute:: primary_digest
                    
                    	Primary digest statistics
                    	**type**\:   :py:class:`PrimaryDigest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.PrimaryDigest>`
                    
                    .. attribute:: secondary_digest
                    
                    	Secondary digest statistics
                    	**type**\:   :py:class:`SecondaryDigest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Authentication.SecondaryDigest>`
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tp.Counters.Control.TunnelXr.Authentication, self).__init__()

                        self.yang_name = "authentication"
                        self.yang_parent_name = "tunnel-xr"

                        self.challenge_avp = L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeAvp()
                        self.challenge_avp.parent = self
                        self._children_name_map["challenge_avp"] = "challenge-avp"
                        self._children_yang_names.add("challenge-avp")

                        self.challenge_reponse = L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeReponse()
                        self.challenge_reponse.parent = self
                        self._children_name_map["challenge_reponse"] = "challenge-reponse"
                        self._children_yang_names.add("challenge-reponse")

                        self.common_digest = L2Tp.Counters.Control.TunnelXr.Authentication.CommonDigest()
                        self.common_digest.parent = self
                        self._children_name_map["common_digest"] = "common-digest"
                        self._children_yang_names.add("common-digest")

                        self.integrity_check = L2Tp.Counters.Control.TunnelXr.Authentication.IntegrityCheck()
                        self.integrity_check.parent = self
                        self._children_name_map["integrity_check"] = "integrity-check"
                        self._children_yang_names.add("integrity-check")

                        self.local_secret = L2Tp.Counters.Control.TunnelXr.Authentication.LocalSecret()
                        self.local_secret.parent = self
                        self._children_name_map["local_secret"] = "local-secret"
                        self._children_yang_names.add("local-secret")

                        self.nonce_avp = L2Tp.Counters.Control.TunnelXr.Authentication.NonceAvp()
                        self.nonce_avp.parent = self
                        self._children_name_map["nonce_avp"] = "nonce-avp"
                        self._children_yang_names.add("nonce-avp")

                        self.overall_statistics = L2Tp.Counters.Control.TunnelXr.Authentication.OverallStatistics()
                        self.overall_statistics.parent = self
                        self._children_name_map["overall_statistics"] = "overall-statistics"
                        self._children_yang_names.add("overall-statistics")

                        self.primary_digest = L2Tp.Counters.Control.TunnelXr.Authentication.PrimaryDigest()
                        self.primary_digest.parent = self
                        self._children_name_map["primary_digest"] = "primary-digest"
                        self._children_yang_names.add("primary-digest")

                        self.secondary_digest = L2Tp.Counters.Control.TunnelXr.Authentication.SecondaryDigest()
                        self.secondary_digest.parent = self
                        self._children_name_map["secondary_digest"] = "secondary-digest"
                        self._children_yang_names.add("secondary-digest")


                    class NonceAvp(Entity):
                        """
                        Nonce AVP statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.NonceAvp, self).__init__()

                            self.yang_name = "nonce-avp"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.NonceAvp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.NonceAvp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "nonce-avp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class CommonDigest(Entity):
                        """
                        Common digest statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.CommonDigest, self).__init__()

                            self.yang_name = "common-digest"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.CommonDigest, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.CommonDigest, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "common-digest" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class PrimaryDigest(Entity):
                        """
                        Primary digest statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.PrimaryDigest, self).__init__()

                            self.yang_name = "primary-digest"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.PrimaryDigest, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.PrimaryDigest, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "primary-digest" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class SecondaryDigest(Entity):
                        """
                        Secondary digest statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.SecondaryDigest, self).__init__()

                            self.yang_name = "secondary-digest"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.SecondaryDigest, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.SecondaryDigest, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "secondary-digest" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class IntegrityCheck(Entity):
                        """
                        Integrity check statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.IntegrityCheck, self).__init__()

                            self.yang_name = "integrity-check"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.IntegrityCheck, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.IntegrityCheck, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "integrity-check" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class LocalSecret(Entity):
                        """
                        Local secret statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.LocalSecret, self).__init__()

                            self.yang_name = "local-secret"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.LocalSecret, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.LocalSecret, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "local-secret" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class ChallengeAvp(Entity):
                        """
                        Challenge AVP statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeAvp, self).__init__()

                            self.yang_name = "challenge-avp"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeAvp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeAvp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "challenge-avp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class ChallengeReponse(Entity):
                        """
                        Challenge response statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeReponse, self).__init__()

                            self.yang_name = "challenge-reponse"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeReponse, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeReponse, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "challenge-reponse" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class OverallStatistics(Entity):
                        """
                        Overall statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Authentication.OverallStatistics, self).__init__()

                            self.yang_name = "overall-statistics"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Authentication.OverallStatistics, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Authentication.OverallStatistics, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "overall-statistics" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.challenge_avp is not None and self.challenge_avp.has_data()) or
                            (self.challenge_reponse is not None and self.challenge_reponse.has_data()) or
                            (self.common_digest is not None and self.common_digest.has_data()) or
                            (self.integrity_check is not None and self.integrity_check.has_data()) or
                            (self.local_secret is not None and self.local_secret.has_data()) or
                            (self.nonce_avp is not None and self.nonce_avp.has_data()) or
                            (self.overall_statistics is not None and self.overall_statistics.has_data()) or
                            (self.primary_digest is not None and self.primary_digest.has_data()) or
                            (self.secondary_digest is not None and self.secondary_digest.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.challenge_avp is not None and self.challenge_avp.has_operation()) or
                            (self.challenge_reponse is not None and self.challenge_reponse.has_operation()) or
                            (self.common_digest is not None and self.common_digest.has_operation()) or
                            (self.integrity_check is not None and self.integrity_check.has_operation()) or
                            (self.local_secret is not None and self.local_secret.has_operation()) or
                            (self.nonce_avp is not None and self.nonce_avp.has_operation()) or
                            (self.overall_statistics is not None and self.overall_statistics.has_operation()) or
                            (self.primary_digest is not None and self.primary_digest.has_operation()) or
                            (self.secondary_digest is not None and self.secondary_digest.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "authentication" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "challenge-avp"):
                            if (self.challenge_avp is None):
                                self.challenge_avp = L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeAvp()
                                self.challenge_avp.parent = self
                                self._children_name_map["challenge_avp"] = "challenge-avp"
                            return self.challenge_avp

                        if (child_yang_name == "challenge-reponse"):
                            if (self.challenge_reponse is None):
                                self.challenge_reponse = L2Tp.Counters.Control.TunnelXr.Authentication.ChallengeReponse()
                                self.challenge_reponse.parent = self
                                self._children_name_map["challenge_reponse"] = "challenge-reponse"
                            return self.challenge_reponse

                        if (child_yang_name == "common-digest"):
                            if (self.common_digest is None):
                                self.common_digest = L2Tp.Counters.Control.TunnelXr.Authentication.CommonDigest()
                                self.common_digest.parent = self
                                self._children_name_map["common_digest"] = "common-digest"
                            return self.common_digest

                        if (child_yang_name == "integrity-check"):
                            if (self.integrity_check is None):
                                self.integrity_check = L2Tp.Counters.Control.TunnelXr.Authentication.IntegrityCheck()
                                self.integrity_check.parent = self
                                self._children_name_map["integrity_check"] = "integrity-check"
                            return self.integrity_check

                        if (child_yang_name == "local-secret"):
                            if (self.local_secret is None):
                                self.local_secret = L2Tp.Counters.Control.TunnelXr.Authentication.LocalSecret()
                                self.local_secret.parent = self
                                self._children_name_map["local_secret"] = "local-secret"
                            return self.local_secret

                        if (child_yang_name == "nonce-avp"):
                            if (self.nonce_avp is None):
                                self.nonce_avp = L2Tp.Counters.Control.TunnelXr.Authentication.NonceAvp()
                                self.nonce_avp.parent = self
                                self._children_name_map["nonce_avp"] = "nonce-avp"
                            return self.nonce_avp

                        if (child_yang_name == "overall-statistics"):
                            if (self.overall_statistics is None):
                                self.overall_statistics = L2Tp.Counters.Control.TunnelXr.Authentication.OverallStatistics()
                                self.overall_statistics.parent = self
                                self._children_name_map["overall_statistics"] = "overall-statistics"
                            return self.overall_statistics

                        if (child_yang_name == "primary-digest"):
                            if (self.primary_digest is None):
                                self.primary_digest = L2Tp.Counters.Control.TunnelXr.Authentication.PrimaryDigest()
                                self.primary_digest.parent = self
                                self._children_name_map["primary_digest"] = "primary-digest"
                            return self.primary_digest

                        if (child_yang_name == "secondary-digest"):
                            if (self.secondary_digest is None):
                                self.secondary_digest = L2Tp.Counters.Control.TunnelXr.Authentication.SecondaryDigest()
                                self.secondary_digest.parent = self
                                self._children_name_map["secondary_digest"] = "secondary-digest"
                            return self.secondary_digest

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "challenge-avp" or name == "challenge-reponse" or name == "common-digest" or name == "integrity-check" or name == "local-secret" or name == "nonce-avp" or name == "overall-statistics" or name == "primary-digest" or name == "secondary-digest"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Global_(Entity):
                    """
                    Tunnel counters
                    
                    .. attribute:: drop
                    
                    	Drop data
                    	**type**\:   :py:class:`Drop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Global_.Drop>`
                    
                    .. attribute:: received
                    
                    	Received data
                    	**type**\:   :py:class:`Received <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Global_.Received>`
                    
                    .. attribute:: retransmit
                    
                    	Re transmit data
                    	**type**\:   :py:class:`Retransmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Global_.Retransmit>`
                    
                    .. attribute:: total_drop
                    
                    	Total drop
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_received
                    
                    	Total received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_retransmit
                    
                    	Total retransmit
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_transmit
                    
                    	Total transmit
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: transmit
                    
                    	Transmit data
                    	**type**\:   :py:class:`Transmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.TunnelXr.Global_.Transmit>`
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tp.Counters.Control.TunnelXr.Global_, self).__init__()

                        self.yang_name = "global"
                        self.yang_parent_name = "tunnel-xr"

                        self.total_drop = YLeaf(YType.uint32, "total-drop")

                        self.total_received = YLeaf(YType.uint32, "total-received")

                        self.total_retransmit = YLeaf(YType.uint32, "total-retransmit")

                        self.total_transmit = YLeaf(YType.uint32, "total-transmit")

                        self.drop = L2Tp.Counters.Control.TunnelXr.Global_.Drop()
                        self.drop.parent = self
                        self._children_name_map["drop"] = "drop"
                        self._children_yang_names.add("drop")

                        self.received = L2Tp.Counters.Control.TunnelXr.Global_.Received()
                        self.received.parent = self
                        self._children_name_map["received"] = "received"
                        self._children_yang_names.add("received")

                        self.retransmit = L2Tp.Counters.Control.TunnelXr.Global_.Retransmit()
                        self.retransmit.parent = self
                        self._children_name_map["retransmit"] = "retransmit"
                        self._children_yang_names.add("retransmit")

                        self.transmit = L2Tp.Counters.Control.TunnelXr.Global_.Transmit()
                        self.transmit.parent = self
                        self._children_name_map["transmit"] = "transmit"
                        self._children_yang_names.add("transmit")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("total_drop",
                                        "total_received",
                                        "total_retransmit",
                                        "total_transmit") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tp.Counters.Control.TunnelXr.Global_, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tp.Counters.Control.TunnelXr.Global_, self).__setattr__(name, value)


                    class Transmit(Entity):
                        """
                        Transmit data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Global_.Transmit, self).__init__()

                            self.yang_name = "transmit"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Global_.Transmit, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Global_.Transmit, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "transmit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                    class Retransmit(Entity):
                        """
                        Re transmit data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Global_.Retransmit, self).__init__()

                            self.yang_name = "retransmit"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Global_.Retransmit, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Global_.Retransmit, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "retransmit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                    class Received(Entity):
                        """
                        Received data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Global_.Received, self).__init__()

                            self.yang_name = "received"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Global_.Received, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Global_.Received, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "received" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                    class Drop(Entity):
                        """
                        Drop data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.TunnelXr.Global_.Drop, self).__init__()

                            self.yang_name = "drop"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.TunnelXr.Global_.Drop, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.TunnelXr.Global_.Drop, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "drop" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.total_drop.is_set or
                            self.total_received.is_set or
                            self.total_retransmit.is_set or
                            self.total_transmit.is_set or
                            (self.drop is not None and self.drop.has_data()) or
                            (self.received is not None and self.received.has_data()) or
                            (self.retransmit is not None and self.retransmit.has_data()) or
                            (self.transmit is not None and self.transmit.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.total_drop.yfilter != YFilter.not_set or
                            self.total_received.yfilter != YFilter.not_set or
                            self.total_retransmit.yfilter != YFilter.not_set or
                            self.total_transmit.yfilter != YFilter.not_set or
                            (self.drop is not None and self.drop.has_operation()) or
                            (self.received is not None and self.received.has_operation()) or
                            (self.retransmit is not None and self.retransmit.has_operation()) or
                            (self.transmit is not None and self.transmit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnel-xr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.total_drop.is_set or self.total_drop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_drop.get_name_leafdata())
                        if (self.total_received.is_set or self.total_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_received.get_name_leafdata())
                        if (self.total_retransmit.is_set or self.total_retransmit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_retransmit.get_name_leafdata())
                        if (self.total_transmit.is_set or self.total_transmit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_transmit.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "drop"):
                            if (self.drop is None):
                                self.drop = L2Tp.Counters.Control.TunnelXr.Global_.Drop()
                                self.drop.parent = self
                                self._children_name_map["drop"] = "drop"
                            return self.drop

                        if (child_yang_name == "received"):
                            if (self.received is None):
                                self.received = L2Tp.Counters.Control.TunnelXr.Global_.Received()
                                self.received.parent = self
                                self._children_name_map["received"] = "received"
                            return self.received

                        if (child_yang_name == "retransmit"):
                            if (self.retransmit is None):
                                self.retransmit = L2Tp.Counters.Control.TunnelXr.Global_.Retransmit()
                                self.retransmit.parent = self
                                self._children_name_map["retransmit"] = "retransmit"
                            return self.retransmit

                        if (child_yang_name == "transmit"):
                            if (self.transmit is None):
                                self.transmit = L2Tp.Counters.Control.TunnelXr.Global_.Transmit()
                                self.transmit.parent = self
                                self._children_name_map["transmit"] = "transmit"
                            return self.transmit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "drop" or name == "received" or name == "retransmit" or name == "transmit" or name == "total-drop" or name == "total-received" or name == "total-retransmit" or name == "total-transmit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "total-drop"):
                            self.total_drop = value
                            self.total_drop.value_namespace = name_space
                            self.total_drop.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-received"):
                            self.total_received = value
                            self.total_received.value_namespace = name_space
                            self.total_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-retransmit"):
                            self.total_retransmit = value
                            self.total_retransmit.value_namespace = name_space
                            self.total_retransmit.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-transmit"):
                            self.total_transmit = value
                            self.total_transmit.value_namespace = name_space
                            self.total_transmit.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.authentication is not None and self.authentication.has_data()) or
                        (self.global_ is not None and self.global_.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.authentication is not None and self.authentication.has_operation()) or
                        (self.global_ is not None and self.global_.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnel-xr" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "authentication"):
                        if (self.authentication is None):
                            self.authentication = L2Tp.Counters.Control.TunnelXr.Authentication()
                            self.authentication.parent = self
                            self._children_name_map["authentication"] = "authentication"
                        return self.authentication

                    if (child_yang_name == "global"):
                        if (self.global_ is None):
                            self.global_ = L2Tp.Counters.Control.TunnelXr.Global_()
                            self.global_.parent = self
                            self._children_name_map["global_"] = "global"
                        return self.global_

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "authentication" or name == "global"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Tunnels(Entity):
                """
                Table of tunnel IDs of control message counters
                
                .. attribute:: tunnel
                
                	L2TP tunnel control message counters
                	**type**\: list of    :py:class:`Tunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels.Tunnel>`
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tp.Counters.Control.Tunnels, self).__init__()

                    self.yang_name = "tunnels"
                    self.yang_parent_name = "control"

                    self.tunnel = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tp.Counters.Control.Tunnels, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tp.Counters.Control.Tunnels, self).__setattr__(name, value)


                class Tunnel(Entity):
                    """
                    L2TP tunnel control message counters
                    
                    .. attribute:: tunnel_id  <key>
                    
                    	L2TP tunnel ID
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: brief
                    
                    	L2TP control message local and remote addresses
                    	**type**\:   :py:class:`Brief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels.Tunnel.Brief>`
                    
                    .. attribute:: global_
                    
                    	Global data
                    	**type**\:   :py:class:`Global_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels.Tunnel.Global_>`
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tp.Counters.Control.Tunnels.Tunnel, self).__init__()

                        self.yang_name = "tunnel"
                        self.yang_parent_name = "tunnels"

                        self.tunnel_id = YLeaf(YType.int32, "tunnel-id")

                        self.brief = L2Tp.Counters.Control.Tunnels.Tunnel.Brief()
                        self.brief.parent = self
                        self._children_name_map["brief"] = "brief"
                        self._children_yang_names.add("brief")

                        self.global_ = L2Tp.Counters.Control.Tunnels.Tunnel.Global_()
                        self.global_.parent = self
                        self._children_name_map["global_"] = "global"
                        self._children_yang_names.add("global")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tp.Counters.Control.Tunnels.Tunnel, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tp.Counters.Control.Tunnels.Tunnel, self).__setattr__(name, value)


                    class Brief(Entity):
                        """
                        L2TP control message local and remote addresses
                        
                        .. attribute:: local_address
                        
                        	Local IP address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: remote_address
                        
                        	Remote IP address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: remote_tunnel_id
                        
                        	Remote tunnel ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.Tunnels.Tunnel.Brief, self).__init__()

                            self.yang_name = "brief"
                            self.yang_parent_name = "tunnel"

                            self.local_address = YLeaf(YType.str, "local-address")

                            self.remote_address = YLeaf(YType.str, "remote-address")

                            self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_address",
                                            "remote_address",
                                            "remote_tunnel_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.Tunnels.Tunnel.Brief, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.Tunnels.Tunnel.Brief, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_address.is_set or
                                self.remote_address.is_set or
                                self.remote_tunnel_id.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_address.yfilter != YFilter.not_set or
                                self.remote_address.yfilter != YFilter.not_set or
                                self.remote_tunnel_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "brief" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_address.get_name_leafdata())
                            if (self.remote_address.is_set or self.remote_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_address.get_name_leafdata())
                            if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-address" or name == "remote-address" or name == "remote-tunnel-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-address"):
                                self.local_address = value
                                self.local_address.value_namespace = name_space
                                self.local_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-address"):
                                self.remote_address = value
                                self.remote_address.value_namespace = name_space
                                self.remote_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-tunnel-id"):
                                self.remote_tunnel_id = value
                                self.remote_tunnel_id.value_namespace = name_space
                                self.remote_tunnel_id.value_namespace_prefix = name_space_prefix


                    class Global_(Entity):
                        """
                        Global data
                        
                        .. attribute:: drop
                        
                        	Drop data
                        	**type**\:   :py:class:`Drop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Drop>`
                        
                        .. attribute:: received
                        
                        	Received data
                        	**type**\:   :py:class:`Received <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Received>`
                        
                        .. attribute:: retransmit
                        
                        	Re transmit data
                        	**type**\:   :py:class:`Retransmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Retransmit>`
                        
                        .. attribute:: total_drop
                        
                        	Total drop
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_received
                        
                        	Total received
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_retransmit
                        
                        	Total retransmit
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_transmit
                        
                        	Total transmit
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: transmit
                        
                        	Transmit data
                        	**type**\:   :py:class:`Transmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Transmit>`
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_, self).__init__()

                            self.yang_name = "global"
                            self.yang_parent_name = "tunnel"

                            self.total_drop = YLeaf(YType.uint32, "total-drop")

                            self.total_received = YLeaf(YType.uint32, "total-received")

                            self.total_retransmit = YLeaf(YType.uint32, "total-retransmit")

                            self.total_transmit = YLeaf(YType.uint32, "total-transmit")

                            self.drop = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Drop()
                            self.drop.parent = self
                            self._children_name_map["drop"] = "drop"
                            self._children_yang_names.add("drop")

                            self.received = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Received()
                            self.received.parent = self
                            self._children_name_map["received"] = "received"
                            self._children_yang_names.add("received")

                            self.retransmit = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Retransmit()
                            self.retransmit.parent = self
                            self._children_name_map["retransmit"] = "retransmit"
                            self._children_yang_names.add("retransmit")

                            self.transmit = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Transmit()
                            self.transmit.parent = self
                            self._children_name_map["transmit"] = "transmit"
                            self._children_yang_names.add("transmit")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("total_drop",
                                            "total_received",
                                            "total_retransmit",
                                            "total_transmit") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_, self).__setattr__(name, value)


                        class Transmit(Entity):
                            """
                            Transmit data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Transmit, self).__init__()

                                self.yang_name = "transmit"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Transmit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Transmit, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "transmit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                        class Retransmit(Entity):
                            """
                            Re transmit data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Retransmit, self).__init__()

                                self.yang_name = "retransmit"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Retransmit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Retransmit, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "retransmit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                        class Received(Entity):
                            """
                            Received data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Received, self).__init__()

                                self.yang_name = "received"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Received, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Received, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "received" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                        class Drop(Entity):
                            """
                            Drop data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Drop, self).__init__()

                                self.yang_name = "drop"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Drop, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Drop, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "drop" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.total_drop.is_set or
                                self.total_received.is_set or
                                self.total_retransmit.is_set or
                                self.total_transmit.is_set or
                                (self.drop is not None and self.drop.has_data()) or
                                (self.received is not None and self.received.has_data()) or
                                (self.retransmit is not None and self.retransmit.has_data()) or
                                (self.transmit is not None and self.transmit.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.total_drop.yfilter != YFilter.not_set or
                                self.total_received.yfilter != YFilter.not_set or
                                self.total_retransmit.yfilter != YFilter.not_set or
                                self.total_transmit.yfilter != YFilter.not_set or
                                (self.drop is not None and self.drop.has_operation()) or
                                (self.received is not None and self.received.has_operation()) or
                                (self.retransmit is not None and self.retransmit.has_operation()) or
                                (self.transmit is not None and self.transmit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "global" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.total_drop.is_set or self.total_drop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_drop.get_name_leafdata())
                            if (self.total_received.is_set or self.total_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_received.get_name_leafdata())
                            if (self.total_retransmit.is_set or self.total_retransmit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_retransmit.get_name_leafdata())
                            if (self.total_transmit.is_set or self.total_transmit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_transmit.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "drop"):
                                if (self.drop is None):
                                    self.drop = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Drop()
                                    self.drop.parent = self
                                    self._children_name_map["drop"] = "drop"
                                return self.drop

                            if (child_yang_name == "received"):
                                if (self.received is None):
                                    self.received = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Received()
                                    self.received.parent = self
                                    self._children_name_map["received"] = "received"
                                return self.received

                            if (child_yang_name == "retransmit"):
                                if (self.retransmit is None):
                                    self.retransmit = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Retransmit()
                                    self.retransmit.parent = self
                                    self._children_name_map["retransmit"] = "retransmit"
                                return self.retransmit

                            if (child_yang_name == "transmit"):
                                if (self.transmit is None):
                                    self.transmit = L2Tp.Counters.Control.Tunnels.Tunnel.Global_.Transmit()
                                    self.transmit.parent = self
                                    self._children_name_map["transmit"] = "transmit"
                                return self.transmit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "drop" or name == "received" or name == "retransmit" or name == "transmit" or name == "total-drop" or name == "total-received" or name == "total-retransmit" or name == "total-transmit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "total-drop"):
                                self.total_drop = value
                                self.total_drop.value_namespace = name_space
                                self.total_drop.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-received"):
                                self.total_received = value
                                self.total_received.value_namespace = name_space
                                self.total_received.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-retransmit"):
                                self.total_retransmit = value
                                self.total_retransmit.value_namespace = name_space
                                self.total_retransmit.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-transmit"):
                                self.total_transmit = value
                                self.total_transmit.value_namespace = name_space
                                self.total_transmit.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.tunnel_id.is_set or
                            (self.brief is not None and self.brief.has_data()) or
                            (self.global_ is not None and self.global_.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set or
                            (self.brief is not None and self.brief.has_operation()) or
                            (self.global_ is not None and self.global_.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel" + "[tunnel-id='" + self.tunnel_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/tunnels/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "brief"):
                            if (self.brief is None):
                                self.brief = L2Tp.Counters.Control.Tunnels.Tunnel.Brief()
                                self.brief.parent = self
                                self._children_name_map["brief"] = "brief"
                            return self.brief

                        if (child_yang_name == "global"):
                            if (self.global_ is None):
                                self.global_ = L2Tp.Counters.Control.Tunnels.Tunnel.Global_()
                                self.global_.parent = self
                                self._children_name_map["global_"] = "global"
                            return self.global_

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "brief" or name == "global" or name == "tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.tunnel:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.tunnel:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnels" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/control/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "tunnel"):
                        for c in self.tunnel:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = L2Tp.Counters.Control.Tunnels.Tunnel()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.tunnel.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "tunnel"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.tunnel_xr is not None and self.tunnel_xr.has_data()) or
                    (self.tunnels is not None and self.tunnels.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.tunnel_xr is not None and self.tunnel_xr.has_operation()) or
                    (self.tunnels is not None and self.tunnels.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "control" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "tunnel-xr"):
                    if (self.tunnel_xr is None):
                        self.tunnel_xr = L2Tp.Counters.Control.TunnelXr()
                        self.tunnel_xr.parent = self
                        self._children_name_map["tunnel_xr"] = "tunnel-xr"
                    return self.tunnel_xr

                if (child_yang_name == "tunnels"):
                    if (self.tunnels is None):
                        self.tunnels = L2Tp.Counters.Control.Tunnels()
                        self.tunnels.parent = self
                        self._children_name_map["tunnels"] = "tunnels"
                    return self.tunnels

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "tunnel-xr" or name == "tunnels"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.control is not None and self.control.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.control is not None and self.control.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "control"):
                if (self.control is None):
                    self.control = L2Tp.Counters.Control()
                    self.control.parent = self
                    self._children_name_map["control"] = "control"
                return self.control

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "control"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TunnelConfigurations(Entity):
        """
        List of tunnel IDs
        
        .. attribute:: tunnel_configuration
        
        	L2TP tunnel information
        	**type**\: list of    :py:class:`TunnelConfiguration <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.TunnelConfigurations.TunnelConfiguration>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tp.TunnelConfigurations, self).__init__()

            self.yang_name = "tunnel-configurations"
            self.yang_parent_name = "l2tp"

            self.tunnel_configuration = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tp.TunnelConfigurations, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tp.TunnelConfigurations, self).__setattr__(name, value)


        class TunnelConfiguration(Entity):
            """
            L2TP tunnel information
            
            .. attribute:: local_tunnel_id  <key>
            
            	Local tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: l2tp_class
            
            	L2Tp class data
            	**type**\:   :py:class:`L2TpClass <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.TunnelConfigurations.TunnelConfiguration.L2TpClass>`
            
            .. attribute:: remote_tunnel_id
            
            	Remote tunnel ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tp.TunnelConfigurations.TunnelConfiguration, self).__init__()

                self.yang_name = "tunnel-configuration"
                self.yang_parent_name = "tunnel-configurations"

                self.local_tunnel_id = YLeaf(YType.int32, "local-tunnel-id")

                self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                self.l2tp_class = L2Tp.TunnelConfigurations.TunnelConfiguration.L2TpClass()
                self.l2tp_class.parent = self
                self._children_name_map["l2tp_class"] = "l2tp-class"
                self._children_yang_names.add("l2tp-class")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("local_tunnel_id",
                                "remote_tunnel_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tp.TunnelConfigurations.TunnelConfiguration, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tp.TunnelConfigurations.TunnelConfiguration, self).__setattr__(name, value)


            class L2TpClass(Entity):
                """
                L2Tp class data
                
                .. attribute:: accounting_method_list
                
                	Accounting List
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: class_name_xr
                
                	Class name
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: digest_hash
                
                	Hash configured as MD5 or SHA1
                	**type**\:   :py:class:`DigestHash <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.DigestHash>`
                
                .. attribute:: encoded_password
                
                	Encoded password
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: hello_timeout
                
                	Hello timeout value in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: host_name
                
                	Host name
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: initial_retransmit_maximum_timeout
                
                	Initial timeout maximum in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: initial_retransmit_minimum_timeout
                
                	Initial timeout minimum in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: initial_retransmit_retries
                
                	Initial retransmit retries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: ip_tos
                
                	IP TOS
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: is_authentication_enabled
                
                	True if authentication is enabled
                	**type**\:  bool
                
                .. attribute:: is_congestion_control_enabled
                
                	True if congestion control is enabled
                	**type**\:  bool
                
                .. attribute:: is_digest_check_enabled
                
                	True if digest check is enabled
                	**type**\:  bool
                
                .. attribute:: is_digest_enabled
                
                	True if digest authentication is enabled
                	**type**\:  bool
                
                .. attribute:: is_hidden
                
                	True if class is hidden
                	**type**\:  bool
                
                .. attribute:: is_peer_address_checked
                
                	True if peer address is checked
                	**type**\:  bool
                
                .. attribute:: password
                
                	Password
                	**type**\:  str
                
                	**length:** 0..25
                
                .. attribute:: receive_window_size
                
                	Receive window size
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: retransmit_maximum_timeout
                
                	Retransmit maximum timeout in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: retransmit_minimum_timeout
                
                	Retransmit minimum timeout in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: retransmit_retries
                
                	Retransmit retries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: setup_timeout
                
                	Timeout setup value in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: timeout_no_user
                
                	Timeout no user
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: vrf_name
                
                	VRF name
                	**type**\:  str
                
                	**length:** 0..256
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tp.TunnelConfigurations.TunnelConfiguration.L2TpClass, self).__init__()

                    self.yang_name = "l2tp-class"
                    self.yang_parent_name = "tunnel-configuration"

                    self.accounting_method_list = YLeaf(YType.str, "accounting-method-list")

                    self.class_name_xr = YLeaf(YType.str, "class-name-xr")

                    self.digest_hash = YLeaf(YType.enumeration, "digest-hash")

                    self.encoded_password = YLeaf(YType.str, "encoded-password")

                    self.hello_timeout = YLeaf(YType.uint32, "hello-timeout")

                    self.host_name = YLeaf(YType.str, "host-name")

                    self.initial_retransmit_maximum_timeout = YLeaf(YType.uint32, "initial-retransmit-maximum-timeout")

                    self.initial_retransmit_minimum_timeout = YLeaf(YType.uint32, "initial-retransmit-minimum-timeout")

                    self.initial_retransmit_retries = YLeaf(YType.uint32, "initial-retransmit-retries")

                    self.ip_tos = YLeaf(YType.uint8, "ip-tos")

                    self.is_authentication_enabled = YLeaf(YType.boolean, "is-authentication-enabled")

                    self.is_congestion_control_enabled = YLeaf(YType.boolean, "is-congestion-control-enabled")

                    self.is_digest_check_enabled = YLeaf(YType.boolean, "is-digest-check-enabled")

                    self.is_digest_enabled = YLeaf(YType.boolean, "is-digest-enabled")

                    self.is_hidden = YLeaf(YType.boolean, "is-hidden")

                    self.is_peer_address_checked = YLeaf(YType.boolean, "is-peer-address-checked")

                    self.password = YLeaf(YType.str, "password")

                    self.receive_window_size = YLeaf(YType.uint16, "receive-window-size")

                    self.retransmit_maximum_timeout = YLeaf(YType.uint32, "retransmit-maximum-timeout")

                    self.retransmit_minimum_timeout = YLeaf(YType.uint32, "retransmit-minimum-timeout")

                    self.retransmit_retries = YLeaf(YType.uint32, "retransmit-retries")

                    self.setup_timeout = YLeaf(YType.uint32, "setup-timeout")

                    self.timeout_no_user = YLeaf(YType.uint32, "timeout-no-user")

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("accounting_method_list",
                                    "class_name_xr",
                                    "digest_hash",
                                    "encoded_password",
                                    "hello_timeout",
                                    "host_name",
                                    "initial_retransmit_maximum_timeout",
                                    "initial_retransmit_minimum_timeout",
                                    "initial_retransmit_retries",
                                    "ip_tos",
                                    "is_authentication_enabled",
                                    "is_congestion_control_enabled",
                                    "is_digest_check_enabled",
                                    "is_digest_enabled",
                                    "is_hidden",
                                    "is_peer_address_checked",
                                    "password",
                                    "receive_window_size",
                                    "retransmit_maximum_timeout",
                                    "retransmit_minimum_timeout",
                                    "retransmit_retries",
                                    "setup_timeout",
                                    "timeout_no_user",
                                    "vrf_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tp.TunnelConfigurations.TunnelConfiguration.L2TpClass, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tp.TunnelConfigurations.TunnelConfiguration.L2TpClass, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.accounting_method_list.is_set or
                        self.class_name_xr.is_set or
                        self.digest_hash.is_set or
                        self.encoded_password.is_set or
                        self.hello_timeout.is_set or
                        self.host_name.is_set or
                        self.initial_retransmit_maximum_timeout.is_set or
                        self.initial_retransmit_minimum_timeout.is_set or
                        self.initial_retransmit_retries.is_set or
                        self.ip_tos.is_set or
                        self.is_authentication_enabled.is_set or
                        self.is_congestion_control_enabled.is_set or
                        self.is_digest_check_enabled.is_set or
                        self.is_digest_enabled.is_set or
                        self.is_hidden.is_set or
                        self.is_peer_address_checked.is_set or
                        self.password.is_set or
                        self.receive_window_size.is_set or
                        self.retransmit_maximum_timeout.is_set or
                        self.retransmit_minimum_timeout.is_set or
                        self.retransmit_retries.is_set or
                        self.setup_timeout.is_set or
                        self.timeout_no_user.is_set or
                        self.vrf_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.accounting_method_list.yfilter != YFilter.not_set or
                        self.class_name_xr.yfilter != YFilter.not_set or
                        self.digest_hash.yfilter != YFilter.not_set or
                        self.encoded_password.yfilter != YFilter.not_set or
                        self.hello_timeout.yfilter != YFilter.not_set or
                        self.host_name.yfilter != YFilter.not_set or
                        self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set or
                        self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set or
                        self.initial_retransmit_retries.yfilter != YFilter.not_set or
                        self.ip_tos.yfilter != YFilter.not_set or
                        self.is_authentication_enabled.yfilter != YFilter.not_set or
                        self.is_congestion_control_enabled.yfilter != YFilter.not_set or
                        self.is_digest_check_enabled.yfilter != YFilter.not_set or
                        self.is_digest_enabled.yfilter != YFilter.not_set or
                        self.is_hidden.yfilter != YFilter.not_set or
                        self.is_peer_address_checked.yfilter != YFilter.not_set or
                        self.password.yfilter != YFilter.not_set or
                        self.receive_window_size.yfilter != YFilter.not_set or
                        self.retransmit_maximum_timeout.yfilter != YFilter.not_set or
                        self.retransmit_minimum_timeout.yfilter != YFilter.not_set or
                        self.retransmit_retries.yfilter != YFilter.not_set or
                        self.setup_timeout.yfilter != YFilter.not_set or
                        self.timeout_no_user.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "l2tp-class" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.accounting_method_list.is_set or self.accounting_method_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.accounting_method_list.get_name_leafdata())
                    if (self.class_name_xr.is_set or self.class_name_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.class_name_xr.get_name_leafdata())
                    if (self.digest_hash.is_set or self.digest_hash.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.digest_hash.get_name_leafdata())
                    if (self.encoded_password.is_set or self.encoded_password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.encoded_password.get_name_leafdata())
                    if (self.hello_timeout.is_set or self.hello_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_timeout.get_name_leafdata())
                    if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.host_name.get_name_leafdata())
                    if (self.initial_retransmit_maximum_timeout.is_set or self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.initial_retransmit_maximum_timeout.get_name_leafdata())
                    if (self.initial_retransmit_minimum_timeout.is_set or self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.initial_retransmit_minimum_timeout.get_name_leafdata())
                    if (self.initial_retransmit_retries.is_set or self.initial_retransmit_retries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.initial_retransmit_retries.get_name_leafdata())
                    if (self.ip_tos.is_set or self.ip_tos.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ip_tos.get_name_leafdata())
                    if (self.is_authentication_enabled.is_set or self.is_authentication_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_authentication_enabled.get_name_leafdata())
                    if (self.is_congestion_control_enabled.is_set or self.is_congestion_control_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_congestion_control_enabled.get_name_leafdata())
                    if (self.is_digest_check_enabled.is_set or self.is_digest_check_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_digest_check_enabled.get_name_leafdata())
                    if (self.is_digest_enabled.is_set or self.is_digest_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_digest_enabled.get_name_leafdata())
                    if (self.is_hidden.is_set or self.is_hidden.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_hidden.get_name_leafdata())
                    if (self.is_peer_address_checked.is_set or self.is_peer_address_checked.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_peer_address_checked.get_name_leafdata())
                    if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.password.get_name_leafdata())
                    if (self.receive_window_size.is_set or self.receive_window_size.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.receive_window_size.get_name_leafdata())
                    if (self.retransmit_maximum_timeout.is_set or self.retransmit_maximum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retransmit_maximum_timeout.get_name_leafdata())
                    if (self.retransmit_minimum_timeout.is_set or self.retransmit_minimum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retransmit_minimum_timeout.get_name_leafdata())
                    if (self.retransmit_retries.is_set or self.retransmit_retries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retransmit_retries.get_name_leafdata())
                    if (self.setup_timeout.is_set or self.setup_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.setup_timeout.get_name_leafdata())
                    if (self.timeout_no_user.is_set or self.timeout_no_user.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.timeout_no_user.get_name_leafdata())
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "accounting-method-list" or name == "class-name-xr" or name == "digest-hash" or name == "encoded-password" or name == "hello-timeout" or name == "host-name" or name == "initial-retransmit-maximum-timeout" or name == "initial-retransmit-minimum-timeout" or name == "initial-retransmit-retries" or name == "ip-tos" or name == "is-authentication-enabled" or name == "is-congestion-control-enabled" or name == "is-digest-check-enabled" or name == "is-digest-enabled" or name == "is-hidden" or name == "is-peer-address-checked" or name == "password" or name == "receive-window-size" or name == "retransmit-maximum-timeout" or name == "retransmit-minimum-timeout" or name == "retransmit-retries" or name == "setup-timeout" or name == "timeout-no-user" or name == "vrf-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "accounting-method-list"):
                        self.accounting_method_list = value
                        self.accounting_method_list.value_namespace = name_space
                        self.accounting_method_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "class-name-xr"):
                        self.class_name_xr = value
                        self.class_name_xr.value_namespace = name_space
                        self.class_name_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "digest-hash"):
                        self.digest_hash = value
                        self.digest_hash.value_namespace = name_space
                        self.digest_hash.value_namespace_prefix = name_space_prefix
                    if(value_path == "encoded-password"):
                        self.encoded_password = value
                        self.encoded_password.value_namespace = name_space
                        self.encoded_password.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-timeout"):
                        self.hello_timeout = value
                        self.hello_timeout.value_namespace = name_space
                        self.hello_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "host-name"):
                        self.host_name = value
                        self.host_name.value_namespace = name_space
                        self.host_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "initial-retransmit-maximum-timeout"):
                        self.initial_retransmit_maximum_timeout = value
                        self.initial_retransmit_maximum_timeout.value_namespace = name_space
                        self.initial_retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "initial-retransmit-minimum-timeout"):
                        self.initial_retransmit_minimum_timeout = value
                        self.initial_retransmit_minimum_timeout.value_namespace = name_space
                        self.initial_retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "initial-retransmit-retries"):
                        self.initial_retransmit_retries = value
                        self.initial_retransmit_retries.value_namespace = name_space
                        self.initial_retransmit_retries.value_namespace_prefix = name_space_prefix
                    if(value_path == "ip-tos"):
                        self.ip_tos = value
                        self.ip_tos.value_namespace = name_space
                        self.ip_tos.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-authentication-enabled"):
                        self.is_authentication_enabled = value
                        self.is_authentication_enabled.value_namespace = name_space
                        self.is_authentication_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-congestion-control-enabled"):
                        self.is_congestion_control_enabled = value
                        self.is_congestion_control_enabled.value_namespace = name_space
                        self.is_congestion_control_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-digest-check-enabled"):
                        self.is_digest_check_enabled = value
                        self.is_digest_check_enabled.value_namespace = name_space
                        self.is_digest_check_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-digest-enabled"):
                        self.is_digest_enabled = value
                        self.is_digest_enabled.value_namespace = name_space
                        self.is_digest_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-hidden"):
                        self.is_hidden = value
                        self.is_hidden.value_namespace = name_space
                        self.is_hidden.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-peer-address-checked"):
                        self.is_peer_address_checked = value
                        self.is_peer_address_checked.value_namespace = name_space
                        self.is_peer_address_checked.value_namespace_prefix = name_space_prefix
                    if(value_path == "password"):
                        self.password = value
                        self.password.value_namespace = name_space
                        self.password.value_namespace_prefix = name_space_prefix
                    if(value_path == "receive-window-size"):
                        self.receive_window_size = value
                        self.receive_window_size.value_namespace = name_space
                        self.receive_window_size.value_namespace_prefix = name_space_prefix
                    if(value_path == "retransmit-maximum-timeout"):
                        self.retransmit_maximum_timeout = value
                        self.retransmit_maximum_timeout.value_namespace = name_space
                        self.retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "retransmit-minimum-timeout"):
                        self.retransmit_minimum_timeout = value
                        self.retransmit_minimum_timeout.value_namespace = name_space
                        self.retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "retransmit-retries"):
                        self.retransmit_retries = value
                        self.retransmit_retries.value_namespace = name_space
                        self.retransmit_retries.value_namespace_prefix = name_space_prefix
                    if(value_path == "setup-timeout"):
                        self.setup_timeout = value
                        self.setup_timeout.value_namespace = name_space
                        self.setup_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "timeout-no-user"):
                        self.timeout_no_user = value
                        self.timeout_no_user.value_namespace = name_space
                        self.timeout_no_user.value_namespace_prefix = name_space_prefix
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.local_tunnel_id.is_set or
                    self.remote_tunnel_id.is_set or
                    (self.l2tp_class is not None and self.l2tp_class.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.local_tunnel_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_id.yfilter != YFilter.not_set or
                    (self.l2tp_class is not None and self.l2tp_class.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel-configuration" + "[local-tunnel-id='" + self.local_tunnel_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/tunnel-configurations/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.local_tunnel_id.is_set or self.local_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_id.get_name_leafdata())
                if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "l2tp-class"):
                    if (self.l2tp_class is None):
                        self.l2tp_class = L2Tp.TunnelConfigurations.TunnelConfiguration.L2TpClass()
                        self.l2tp_class.parent = self
                        self._children_name_map["l2tp_class"] = "l2tp-class"
                    return self.l2tp_class

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "l2tp-class" or name == "local-tunnel-id" or name == "remote-tunnel-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "local-tunnel-id"):
                    self.local_tunnel_id = value
                    self.local_tunnel_id.value_namespace = name_space
                    self.local_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-id"):
                    self.remote_tunnel_id = value
                    self.remote_tunnel_id.value_namespace = name_space
                    self.remote_tunnel_id.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel_configuration:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel_configuration:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnel-configurations" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel-configuration"):
                for c in self.tunnel_configuration:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tp.TunnelConfigurations.TunnelConfiguration()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel_configuration.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel-configuration"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class CounterHistFail(Entity):
        """
        Failure events leading to disconnection
        
        .. attribute:: pkt_timeout
        
        	timeout events by packet
        	**type**\:  list of int
        
        	**range:** 0..4294967295
        
        .. attribute:: rx_counters
        
        	Receive side counters
        	**type**\:  str
        
        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
        
        .. attribute:: sess_down_tmout
        
        	sesions affected due to timeout
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: tx_counters
        
        	Send side counters
        	**type**\:  str
        
        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tp.CounterHistFail, self).__init__()

            self.yang_name = "counter-hist-fail"
            self.yang_parent_name = "l2tp"

            self.pkt_timeout = YLeafList(YType.uint32, "pkt-timeout")

            self.rx_counters = YLeaf(YType.str, "rx-counters")

            self.sess_down_tmout = YLeaf(YType.uint32, "sess-down-tmout")

            self.tx_counters = YLeaf(YType.str, "tx-counters")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("pkt_timeout",
                            "rx_counters",
                            "sess_down_tmout",
                            "tx_counters") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tp.CounterHistFail, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tp.CounterHistFail, self).__setattr__(name, value)

        def has_data(self):
            for leaf in self.pkt_timeout.getYLeafs():
                if (leaf.yfilter != YFilter.not_set):
                    return True
            return (
                self.rx_counters.is_set or
                self.sess_down_tmout.is_set or
                self.tx_counters.is_set)

        def has_operation(self):
            for leaf in self.pkt_timeout.getYLeafs():
                if (leaf.is_set):
                    return True
            return (
                self.yfilter != YFilter.not_set or
                self.pkt_timeout.yfilter != YFilter.not_set or
                self.rx_counters.yfilter != YFilter.not_set or
                self.sess_down_tmout.yfilter != YFilter.not_set or
                self.tx_counters.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "counter-hist-fail" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.rx_counters.is_set or self.rx_counters.yfilter != YFilter.not_set):
                leaf_name_data.append(self.rx_counters.get_name_leafdata())
            if (self.sess_down_tmout.is_set or self.sess_down_tmout.yfilter != YFilter.not_set):
                leaf_name_data.append(self.sess_down_tmout.get_name_leafdata())
            if (self.tx_counters.is_set or self.tx_counters.yfilter != YFilter.not_set):
                leaf_name_data.append(self.tx_counters.get_name_leafdata())

            leaf_name_data.extend(self.pkt_timeout.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "pkt-timeout" or name == "rx-counters" or name == "sess-down-tmout" or name == "tx-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "pkt-timeout"):
                self.pkt_timeout.append(value)
            if(value_path == "rx-counters"):
                self.rx_counters = value
                self.rx_counters.value_namespace = name_space
                self.rx_counters.value_namespace_prefix = name_space_prefix
            if(value_path == "sess-down-tmout"):
                self.sess_down_tmout = value
                self.sess_down_tmout.value_namespace = name_space
                self.sess_down_tmout.value_namespace_prefix = name_space_prefix
            if(value_path == "tx-counters"):
                self.tx_counters = value
                self.tx_counters.value_namespace = name_space
                self.tx_counters.value_namespace_prefix = name_space_prefix


    class Classes(Entity):
        """
        List of L2TP class names
        
        .. attribute:: class_
        
        	L2TP class name
        	**type**\: list of    :py:class:`Class_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Classes.Class_>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tp.Classes, self).__init__()

            self.yang_name = "classes"
            self.yang_parent_name = "l2tp"

            self.class_ = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tp.Classes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tp.Classes, self).__setattr__(name, value)


        class Class_(Entity):
            """
            L2TP class name
            
            .. attribute:: class_name  <key>
            
            	L2TP class name
            	**type**\:  str
            
            	**length:** 1..31
            
            .. attribute:: accounting_method_list
            
            	Accounting List
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: class_name_xr
            
            	Class name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: digest_hash
            
            	Hash configured as MD5 or SHA1
            	**type**\:   :py:class:`DigestHash <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.DigestHash>`
            
            .. attribute:: encoded_password
            
            	Encoded password
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: hello_timeout
            
            	Hello timeout value in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: host_name
            
            	Host name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: initial_retransmit_maximum_timeout
            
            	Initial timeout maximum in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: initial_retransmit_minimum_timeout
            
            	Initial timeout minimum in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: initial_retransmit_retries
            
            	Initial retransmit retries
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ip_tos
            
            	IP TOS
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: is_authentication_enabled
            
            	True if authentication is enabled
            	**type**\:  bool
            
            .. attribute:: is_congestion_control_enabled
            
            	True if congestion control is enabled
            	**type**\:  bool
            
            .. attribute:: is_digest_check_enabled
            
            	True if digest check is enabled
            	**type**\:  bool
            
            .. attribute:: is_digest_enabled
            
            	True if digest authentication is enabled
            	**type**\:  bool
            
            .. attribute:: is_hidden
            
            	True if class is hidden
            	**type**\:  bool
            
            .. attribute:: is_peer_address_checked
            
            	True if peer address is checked
            	**type**\:  bool
            
            .. attribute:: password
            
            	Password
            	**type**\:  str
            
            	**length:** 0..25
            
            .. attribute:: receive_window_size
            
            	Receive window size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: retransmit_maximum_timeout
            
            	Retransmit maximum timeout in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: retransmit_minimum_timeout
            
            	Retransmit minimum timeout in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: retransmit_retries
            
            	Retransmit retries
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: setup_timeout
            
            	Timeout setup value in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: timeout_no_user
            
            	Timeout no user
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**length:** 0..256
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tp.Classes.Class_, self).__init__()

                self.yang_name = "class"
                self.yang_parent_name = "classes"

                self.class_name = YLeaf(YType.str, "class-name")

                self.accounting_method_list = YLeaf(YType.str, "accounting-method-list")

                self.class_name_xr = YLeaf(YType.str, "class-name-xr")

                self.digest_hash = YLeaf(YType.enumeration, "digest-hash")

                self.encoded_password = YLeaf(YType.str, "encoded-password")

                self.hello_timeout = YLeaf(YType.uint32, "hello-timeout")

                self.host_name = YLeaf(YType.str, "host-name")

                self.initial_retransmit_maximum_timeout = YLeaf(YType.uint32, "initial-retransmit-maximum-timeout")

                self.initial_retransmit_minimum_timeout = YLeaf(YType.uint32, "initial-retransmit-minimum-timeout")

                self.initial_retransmit_retries = YLeaf(YType.uint32, "initial-retransmit-retries")

                self.ip_tos = YLeaf(YType.uint8, "ip-tos")

                self.is_authentication_enabled = YLeaf(YType.boolean, "is-authentication-enabled")

                self.is_congestion_control_enabled = YLeaf(YType.boolean, "is-congestion-control-enabled")

                self.is_digest_check_enabled = YLeaf(YType.boolean, "is-digest-check-enabled")

                self.is_digest_enabled = YLeaf(YType.boolean, "is-digest-enabled")

                self.is_hidden = YLeaf(YType.boolean, "is-hidden")

                self.is_peer_address_checked = YLeaf(YType.boolean, "is-peer-address-checked")

                self.password = YLeaf(YType.str, "password")

                self.receive_window_size = YLeaf(YType.uint16, "receive-window-size")

                self.retransmit_maximum_timeout = YLeaf(YType.uint32, "retransmit-maximum-timeout")

                self.retransmit_minimum_timeout = YLeaf(YType.uint32, "retransmit-minimum-timeout")

                self.retransmit_retries = YLeaf(YType.uint32, "retransmit-retries")

                self.setup_timeout = YLeaf(YType.uint32, "setup-timeout")

                self.timeout_no_user = YLeaf(YType.uint32, "timeout-no-user")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("class_name",
                                "accounting_method_list",
                                "class_name_xr",
                                "digest_hash",
                                "encoded_password",
                                "hello_timeout",
                                "host_name",
                                "initial_retransmit_maximum_timeout",
                                "initial_retransmit_minimum_timeout",
                                "initial_retransmit_retries",
                                "ip_tos",
                                "is_authentication_enabled",
                                "is_congestion_control_enabled",
                                "is_digest_check_enabled",
                                "is_digest_enabled",
                                "is_hidden",
                                "is_peer_address_checked",
                                "password",
                                "receive_window_size",
                                "retransmit_maximum_timeout",
                                "retransmit_minimum_timeout",
                                "retransmit_retries",
                                "setup_timeout",
                                "timeout_no_user",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tp.Classes.Class_, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tp.Classes.Class_, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.class_name.is_set or
                    self.accounting_method_list.is_set or
                    self.class_name_xr.is_set or
                    self.digest_hash.is_set or
                    self.encoded_password.is_set or
                    self.hello_timeout.is_set or
                    self.host_name.is_set or
                    self.initial_retransmit_maximum_timeout.is_set or
                    self.initial_retransmit_minimum_timeout.is_set or
                    self.initial_retransmit_retries.is_set or
                    self.ip_tos.is_set or
                    self.is_authentication_enabled.is_set or
                    self.is_congestion_control_enabled.is_set or
                    self.is_digest_check_enabled.is_set or
                    self.is_digest_enabled.is_set or
                    self.is_hidden.is_set or
                    self.is_peer_address_checked.is_set or
                    self.password.is_set or
                    self.receive_window_size.is_set or
                    self.retransmit_maximum_timeout.is_set or
                    self.retransmit_minimum_timeout.is_set or
                    self.retransmit_retries.is_set or
                    self.setup_timeout.is_set or
                    self.timeout_no_user.is_set or
                    self.vrf_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.class_name.yfilter != YFilter.not_set or
                    self.accounting_method_list.yfilter != YFilter.not_set or
                    self.class_name_xr.yfilter != YFilter.not_set or
                    self.digest_hash.yfilter != YFilter.not_set or
                    self.encoded_password.yfilter != YFilter.not_set or
                    self.hello_timeout.yfilter != YFilter.not_set or
                    self.host_name.yfilter != YFilter.not_set or
                    self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set or
                    self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set or
                    self.initial_retransmit_retries.yfilter != YFilter.not_set or
                    self.ip_tos.yfilter != YFilter.not_set or
                    self.is_authentication_enabled.yfilter != YFilter.not_set or
                    self.is_congestion_control_enabled.yfilter != YFilter.not_set or
                    self.is_digest_check_enabled.yfilter != YFilter.not_set or
                    self.is_digest_enabled.yfilter != YFilter.not_set or
                    self.is_hidden.yfilter != YFilter.not_set or
                    self.is_peer_address_checked.yfilter != YFilter.not_set or
                    self.password.yfilter != YFilter.not_set or
                    self.receive_window_size.yfilter != YFilter.not_set or
                    self.retransmit_maximum_timeout.yfilter != YFilter.not_set or
                    self.retransmit_minimum_timeout.yfilter != YFilter.not_set or
                    self.retransmit_retries.yfilter != YFilter.not_set or
                    self.setup_timeout.yfilter != YFilter.not_set or
                    self.timeout_no_user.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "class" + "[class-name='" + self.class_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/classes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.class_name.is_set or self.class_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.class_name.get_name_leafdata())
                if (self.accounting_method_list.is_set or self.accounting_method_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.accounting_method_list.get_name_leafdata())
                if (self.class_name_xr.is_set or self.class_name_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.class_name_xr.get_name_leafdata())
                if (self.digest_hash.is_set or self.digest_hash.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.digest_hash.get_name_leafdata())
                if (self.encoded_password.is_set or self.encoded_password.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.encoded_password.get_name_leafdata())
                if (self.hello_timeout.is_set or self.hello_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.hello_timeout.get_name_leafdata())
                if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.host_name.get_name_leafdata())
                if (self.initial_retransmit_maximum_timeout.is_set or self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.initial_retransmit_maximum_timeout.get_name_leafdata())
                if (self.initial_retransmit_minimum_timeout.is_set or self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.initial_retransmit_minimum_timeout.get_name_leafdata())
                if (self.initial_retransmit_retries.is_set or self.initial_retransmit_retries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.initial_retransmit_retries.get_name_leafdata())
                if (self.ip_tos.is_set or self.ip_tos.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ip_tos.get_name_leafdata())
                if (self.is_authentication_enabled.is_set or self.is_authentication_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_authentication_enabled.get_name_leafdata())
                if (self.is_congestion_control_enabled.is_set or self.is_congestion_control_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_congestion_control_enabled.get_name_leafdata())
                if (self.is_digest_check_enabled.is_set or self.is_digest_check_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_digest_check_enabled.get_name_leafdata())
                if (self.is_digest_enabled.is_set or self.is_digest_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_digest_enabled.get_name_leafdata())
                if (self.is_hidden.is_set or self.is_hidden.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_hidden.get_name_leafdata())
                if (self.is_peer_address_checked.is_set or self.is_peer_address_checked.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_peer_address_checked.get_name_leafdata())
                if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.password.get_name_leafdata())
                if (self.receive_window_size.is_set or self.receive_window_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.receive_window_size.get_name_leafdata())
                if (self.retransmit_maximum_timeout.is_set or self.retransmit_maximum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmit_maximum_timeout.get_name_leafdata())
                if (self.retransmit_minimum_timeout.is_set or self.retransmit_minimum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmit_minimum_timeout.get_name_leafdata())
                if (self.retransmit_retries.is_set or self.retransmit_retries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmit_retries.get_name_leafdata())
                if (self.setup_timeout.is_set or self.setup_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.setup_timeout.get_name_leafdata())
                if (self.timeout_no_user.is_set or self.timeout_no_user.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.timeout_no_user.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "class-name" or name == "accounting-method-list" or name == "class-name-xr" or name == "digest-hash" or name == "encoded-password" or name == "hello-timeout" or name == "host-name" or name == "initial-retransmit-maximum-timeout" or name == "initial-retransmit-minimum-timeout" or name == "initial-retransmit-retries" or name == "ip-tos" or name == "is-authentication-enabled" or name == "is-congestion-control-enabled" or name == "is-digest-check-enabled" or name == "is-digest-enabled" or name == "is-hidden" or name == "is-peer-address-checked" or name == "password" or name == "receive-window-size" or name == "retransmit-maximum-timeout" or name == "retransmit-minimum-timeout" or name == "retransmit-retries" or name == "setup-timeout" or name == "timeout-no-user" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "class-name"):
                    self.class_name = value
                    self.class_name.value_namespace = name_space
                    self.class_name.value_namespace_prefix = name_space_prefix
                if(value_path == "accounting-method-list"):
                    self.accounting_method_list = value
                    self.accounting_method_list.value_namespace = name_space
                    self.accounting_method_list.value_namespace_prefix = name_space_prefix
                if(value_path == "class-name-xr"):
                    self.class_name_xr = value
                    self.class_name_xr.value_namespace = name_space
                    self.class_name_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "digest-hash"):
                    self.digest_hash = value
                    self.digest_hash.value_namespace = name_space
                    self.digest_hash.value_namespace_prefix = name_space_prefix
                if(value_path == "encoded-password"):
                    self.encoded_password = value
                    self.encoded_password.value_namespace = name_space
                    self.encoded_password.value_namespace_prefix = name_space_prefix
                if(value_path == "hello-timeout"):
                    self.hello_timeout = value
                    self.hello_timeout.value_namespace = name_space
                    self.hello_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "host-name"):
                    self.host_name = value
                    self.host_name.value_namespace = name_space
                    self.host_name.value_namespace_prefix = name_space_prefix
                if(value_path == "initial-retransmit-maximum-timeout"):
                    self.initial_retransmit_maximum_timeout = value
                    self.initial_retransmit_maximum_timeout.value_namespace = name_space
                    self.initial_retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "initial-retransmit-minimum-timeout"):
                    self.initial_retransmit_minimum_timeout = value
                    self.initial_retransmit_minimum_timeout.value_namespace = name_space
                    self.initial_retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "initial-retransmit-retries"):
                    self.initial_retransmit_retries = value
                    self.initial_retransmit_retries.value_namespace = name_space
                    self.initial_retransmit_retries.value_namespace_prefix = name_space_prefix
                if(value_path == "ip-tos"):
                    self.ip_tos = value
                    self.ip_tos.value_namespace = name_space
                    self.ip_tos.value_namespace_prefix = name_space_prefix
                if(value_path == "is-authentication-enabled"):
                    self.is_authentication_enabled = value
                    self.is_authentication_enabled.value_namespace = name_space
                    self.is_authentication_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-congestion-control-enabled"):
                    self.is_congestion_control_enabled = value
                    self.is_congestion_control_enabled.value_namespace = name_space
                    self.is_congestion_control_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-digest-check-enabled"):
                    self.is_digest_check_enabled = value
                    self.is_digest_check_enabled.value_namespace = name_space
                    self.is_digest_check_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-digest-enabled"):
                    self.is_digest_enabled = value
                    self.is_digest_enabled.value_namespace = name_space
                    self.is_digest_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-hidden"):
                    self.is_hidden = value
                    self.is_hidden.value_namespace = name_space
                    self.is_hidden.value_namespace_prefix = name_space_prefix
                if(value_path == "is-peer-address-checked"):
                    self.is_peer_address_checked = value
                    self.is_peer_address_checked.value_namespace = name_space
                    self.is_peer_address_checked.value_namespace_prefix = name_space_prefix
                if(value_path == "password"):
                    self.password = value
                    self.password.value_namespace = name_space
                    self.password.value_namespace_prefix = name_space_prefix
                if(value_path == "receive-window-size"):
                    self.receive_window_size = value
                    self.receive_window_size.value_namespace = name_space
                    self.receive_window_size.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-maximum-timeout"):
                    self.retransmit_maximum_timeout = value
                    self.retransmit_maximum_timeout.value_namespace = name_space
                    self.retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-minimum-timeout"):
                    self.retransmit_minimum_timeout = value
                    self.retransmit_minimum_timeout.value_namespace = name_space
                    self.retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-retries"):
                    self.retransmit_retries = value
                    self.retransmit_retries.value_namespace = name_space
                    self.retransmit_retries.value_namespace_prefix = name_space_prefix
                if(value_path == "setup-timeout"):
                    self.setup_timeout = value
                    self.setup_timeout.value_namespace = name_space
                    self.setup_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "timeout-no-user"):
                    self.timeout_no_user = value
                    self.timeout_no_user.value_namespace = name_space
                    self.timeout_no_user.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.class_:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.class_:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "classes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "class"):
                for c in self.class_:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tp.Classes.Class_()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.class_.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "class"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Tunnels(Entity):
        """
        List of tunnel IDs
        
        .. attribute:: tunnel
        
        	L2TP tunnel  information
        	**type**\: list of    :py:class:`Tunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Tunnels.Tunnel>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tp.Tunnels, self).__init__()

            self.yang_name = "tunnels"
            self.yang_parent_name = "l2tp"

            self.tunnel = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tp.Tunnels, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tp.Tunnels, self).__setattr__(name, value)


        class Tunnel(Entity):
            """
            L2TP tunnel  information
            
            .. attribute:: local_tunnel_id  <key>
            
            	Local tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: active_sessions
            
            	Number of active sessions
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: class_name
            
            	L2TP class name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: digest_secrets
            
            	Control message authentication with digest secrets
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: is_congestion_control_enabled
            
            	True if congestion control is enabled else false
            	**type**\:  bool
            
            .. attribute:: is_pmtu_enabled
            
            	True if tunnel PMTU checking is enabled
            	**type**\:  bool
            
            .. attribute:: is_tunnel_up
            
            	True if tunnel is up
            	**type**\:  bool
            
            .. attribute:: local_address
            
            	Local tunnel address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: local_port
            
            	Local port
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: local_tunnel_name
            
            	Local tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: local_window_size
            
            	Local window size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: maximum_retransmission_time
            
            	Maximum retransmission time in seconds
            	**type**\:  int
            
            	**range:** 0..65535
            
            	**units**\: second
            
            .. attribute:: order_queue_size
            
            	Order queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: packet_queue_check
            
            	Current number session packet queue check
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: protocol
            
            	Protocol
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: remote_address
            
            	Remote tunnel address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: remote_port
            
            	Remote port
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: remote_tunnel_id
            
            	Remote tunnel ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_tunnel_name
            
            	Remote tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: remote_window_size
            
            	Remote window size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: resend_maximum_queue_size
            
            	Resend maximum queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: resend_queue_size
            
            	Resend queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: resends
            
            	Total resends
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: retransmission_time
            
            	Retransmission time in seconds
            	**type**\:  int
            
            	**range:** 0..65535
            
            	**units**\: second
            
            .. attribute:: retransmit_time
            
            	Retransmit time distribution in seconds
            	**type**\:  list of int
            
            	**range:** 0..65535
            
            	**units**\: second
            
            .. attribute:: sequence_nr
            
            	Sequence NR
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: sequence_ns
            
            	Sequence NS
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: total_out_of_order_drop_packets
            
            	Total out of order dropped packets
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_out_of_order_reorder_packets
            
            	Total out of order reorder packets
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_peer_authentication_failures
            
            	Number of peer authentication failures
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unsent_maximum_queue_size
            
            	Unsent maximum queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: unsent_queue_size
            
            	Unsent queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: zero_length_body_acknowledgement_sent
            
            	Total zero length body acknowledgement
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tp.Tunnels.Tunnel, self).__init__()

                self.yang_name = "tunnel"
                self.yang_parent_name = "tunnels"

                self.local_tunnel_id = YLeaf(YType.int32, "local-tunnel-id")

                self.active_sessions = YLeaf(YType.uint32, "active-sessions")

                self.class_name = YLeaf(YType.str, "class-name")

                self.digest_secrets = YLeaf(YType.uint16, "digest-secrets")

                self.is_congestion_control_enabled = YLeaf(YType.boolean, "is-congestion-control-enabled")

                self.is_pmtu_enabled = YLeaf(YType.boolean, "is-pmtu-enabled")

                self.is_tunnel_up = YLeaf(YType.boolean, "is-tunnel-up")

                self.local_address = YLeaf(YType.str, "local-address")

                self.local_port = YLeaf(YType.uint16, "local-port")

                self.local_tunnel_name = YLeaf(YType.str, "local-tunnel-name")

                self.local_window_size = YLeaf(YType.uint16, "local-window-size")

                self.maximum_retransmission_time = YLeaf(YType.uint16, "maximum-retransmission-time")

                self.order_queue_size = YLeaf(YType.uint16, "order-queue-size")

                self.packet_queue_check = YLeaf(YType.uint16, "packet-queue-check")

                self.protocol = YLeaf(YType.uint8, "protocol")

                self.remote_address = YLeaf(YType.str, "remote-address")

                self.remote_port = YLeaf(YType.uint16, "remote-port")

                self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                self.remote_tunnel_name = YLeaf(YType.str, "remote-tunnel-name")

                self.remote_window_size = YLeaf(YType.uint16, "remote-window-size")

                self.resend_maximum_queue_size = YLeaf(YType.uint16, "resend-maximum-queue-size")

                self.resend_queue_size = YLeaf(YType.uint16, "resend-queue-size")

                self.resends = YLeaf(YType.uint32, "resends")

                self.retransmission_time = YLeaf(YType.uint16, "retransmission-time")

                self.retransmit_time = YLeafList(YType.uint16, "retransmit-time")

                self.sequence_nr = YLeaf(YType.uint16, "sequence-nr")

                self.sequence_ns = YLeaf(YType.uint16, "sequence-ns")

                self.total_out_of_order_drop_packets = YLeaf(YType.uint32, "total-out-of-order-drop-packets")

                self.total_out_of_order_reorder_packets = YLeaf(YType.uint32, "total-out-of-order-reorder-packets")

                self.total_peer_authentication_failures = YLeaf(YType.uint32, "total-peer-authentication-failures")

                self.unsent_maximum_queue_size = YLeaf(YType.uint16, "unsent-maximum-queue-size")

                self.unsent_queue_size = YLeaf(YType.uint16, "unsent-queue-size")

                self.zero_length_body_acknowledgement_sent = YLeaf(YType.uint32, "zero-length-body-acknowledgement-sent")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("local_tunnel_id",
                                "active_sessions",
                                "class_name",
                                "digest_secrets",
                                "is_congestion_control_enabled",
                                "is_pmtu_enabled",
                                "is_tunnel_up",
                                "local_address",
                                "local_port",
                                "local_tunnel_name",
                                "local_window_size",
                                "maximum_retransmission_time",
                                "order_queue_size",
                                "packet_queue_check",
                                "protocol",
                                "remote_address",
                                "remote_port",
                                "remote_tunnel_id",
                                "remote_tunnel_name",
                                "remote_window_size",
                                "resend_maximum_queue_size",
                                "resend_queue_size",
                                "resends",
                                "retransmission_time",
                                "retransmit_time",
                                "sequence_nr",
                                "sequence_ns",
                                "total_out_of_order_drop_packets",
                                "total_out_of_order_reorder_packets",
                                "total_peer_authentication_failures",
                                "unsent_maximum_queue_size",
                                "unsent_queue_size",
                                "zero_length_body_acknowledgement_sent") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tp.Tunnels.Tunnel, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tp.Tunnels.Tunnel, self).__setattr__(name, value)

            def has_data(self):
                for leaf in self.retransmit_time.getYLeafs():
                    if (leaf.yfilter != YFilter.not_set):
                        return True
                return (
                    self.local_tunnel_id.is_set or
                    self.active_sessions.is_set or
                    self.class_name.is_set or
                    self.digest_secrets.is_set or
                    self.is_congestion_control_enabled.is_set or
                    self.is_pmtu_enabled.is_set or
                    self.is_tunnel_up.is_set or
                    self.local_address.is_set or
                    self.local_port.is_set or
                    self.local_tunnel_name.is_set or
                    self.local_window_size.is_set or
                    self.maximum_retransmission_time.is_set or
                    self.order_queue_size.is_set or
                    self.packet_queue_check.is_set or
                    self.protocol.is_set or
                    self.remote_address.is_set or
                    self.remote_port.is_set or
                    self.remote_tunnel_id.is_set or
                    self.remote_tunnel_name.is_set or
                    self.remote_window_size.is_set or
                    self.resend_maximum_queue_size.is_set or
                    self.resend_queue_size.is_set or
                    self.resends.is_set or
                    self.retransmission_time.is_set or
                    self.sequence_nr.is_set or
                    self.sequence_ns.is_set or
                    self.total_out_of_order_drop_packets.is_set or
                    self.total_out_of_order_reorder_packets.is_set or
                    self.total_peer_authentication_failures.is_set or
                    self.unsent_maximum_queue_size.is_set or
                    self.unsent_queue_size.is_set or
                    self.zero_length_body_acknowledgement_sent.is_set)

            def has_operation(self):
                for leaf in self.retransmit_time.getYLeafs():
                    if (leaf.is_set):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.local_tunnel_id.yfilter != YFilter.not_set or
                    self.active_sessions.yfilter != YFilter.not_set or
                    self.class_name.yfilter != YFilter.not_set or
                    self.digest_secrets.yfilter != YFilter.not_set or
                    self.is_congestion_control_enabled.yfilter != YFilter.not_set or
                    self.is_pmtu_enabled.yfilter != YFilter.not_set or
                    self.is_tunnel_up.yfilter != YFilter.not_set or
                    self.local_address.yfilter != YFilter.not_set or
                    self.local_port.yfilter != YFilter.not_set or
                    self.local_tunnel_name.yfilter != YFilter.not_set or
                    self.local_window_size.yfilter != YFilter.not_set or
                    self.maximum_retransmission_time.yfilter != YFilter.not_set or
                    self.order_queue_size.yfilter != YFilter.not_set or
                    self.packet_queue_check.yfilter != YFilter.not_set or
                    self.protocol.yfilter != YFilter.not_set or
                    self.remote_address.yfilter != YFilter.not_set or
                    self.remote_port.yfilter != YFilter.not_set or
                    self.remote_tunnel_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_name.yfilter != YFilter.not_set or
                    self.remote_window_size.yfilter != YFilter.not_set or
                    self.resend_maximum_queue_size.yfilter != YFilter.not_set or
                    self.resend_queue_size.yfilter != YFilter.not_set or
                    self.resends.yfilter != YFilter.not_set or
                    self.retransmission_time.yfilter != YFilter.not_set or
                    self.retransmit_time.yfilter != YFilter.not_set or
                    self.sequence_nr.yfilter != YFilter.not_set or
                    self.sequence_ns.yfilter != YFilter.not_set or
                    self.total_out_of_order_drop_packets.yfilter != YFilter.not_set or
                    self.total_out_of_order_reorder_packets.yfilter != YFilter.not_set or
                    self.total_peer_authentication_failures.yfilter != YFilter.not_set or
                    self.unsent_maximum_queue_size.yfilter != YFilter.not_set or
                    self.unsent_queue_size.yfilter != YFilter.not_set or
                    self.zero_length_body_acknowledgement_sent.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel" + "[local-tunnel-id='" + self.local_tunnel_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/tunnels/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.local_tunnel_id.is_set or self.local_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_id.get_name_leafdata())
                if (self.active_sessions.is_set or self.active_sessions.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.active_sessions.get_name_leafdata())
                if (self.class_name.is_set or self.class_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.class_name.get_name_leafdata())
                if (self.digest_secrets.is_set or self.digest_secrets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.digest_secrets.get_name_leafdata())
                if (self.is_congestion_control_enabled.is_set or self.is_congestion_control_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_congestion_control_enabled.get_name_leafdata())
                if (self.is_pmtu_enabled.is_set or self.is_pmtu_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_pmtu_enabled.get_name_leafdata())
                if (self.is_tunnel_up.is_set or self.is_tunnel_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_tunnel_up.get_name_leafdata())
                if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_address.get_name_leafdata())
                if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_port.get_name_leafdata())
                if (self.local_tunnel_name.is_set or self.local_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_name.get_name_leafdata())
                if (self.local_window_size.is_set or self.local_window_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_window_size.get_name_leafdata())
                if (self.maximum_retransmission_time.is_set or self.maximum_retransmission_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.maximum_retransmission_time.get_name_leafdata())
                if (self.order_queue_size.is_set or self.order_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.order_queue_size.get_name_leafdata())
                if (self.packet_queue_check.is_set or self.packet_queue_check.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.packet_queue_check.get_name_leafdata())
                if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocol.get_name_leafdata())
                if (self.remote_address.is_set or self.remote_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_address.get_name_leafdata())
                if (self.remote_port.is_set or self.remote_port.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_port.get_name_leafdata())
                if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())
                if (self.remote_tunnel_name.is_set or self.remote_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_name.get_name_leafdata())
                if (self.remote_window_size.is_set or self.remote_window_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_window_size.get_name_leafdata())
                if (self.resend_maximum_queue_size.is_set or self.resend_maximum_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.resend_maximum_queue_size.get_name_leafdata())
                if (self.resend_queue_size.is_set or self.resend_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.resend_queue_size.get_name_leafdata())
                if (self.resends.is_set or self.resends.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.resends.get_name_leafdata())
                if (self.retransmission_time.is_set or self.retransmission_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmission_time.get_name_leafdata())
                if (self.sequence_nr.is_set or self.sequence_nr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sequence_nr.get_name_leafdata())
                if (self.sequence_ns.is_set or self.sequence_ns.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sequence_ns.get_name_leafdata())
                if (self.total_out_of_order_drop_packets.is_set or self.total_out_of_order_drop_packets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_out_of_order_drop_packets.get_name_leafdata())
                if (self.total_out_of_order_reorder_packets.is_set or self.total_out_of_order_reorder_packets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_out_of_order_reorder_packets.get_name_leafdata())
                if (self.total_peer_authentication_failures.is_set or self.total_peer_authentication_failures.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_peer_authentication_failures.get_name_leafdata())
                if (self.unsent_maximum_queue_size.is_set or self.unsent_maximum_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unsent_maximum_queue_size.get_name_leafdata())
                if (self.unsent_queue_size.is_set or self.unsent_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unsent_queue_size.get_name_leafdata())
                if (self.zero_length_body_acknowledgement_sent.is_set or self.zero_length_body_acknowledgement_sent.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.zero_length_body_acknowledgement_sent.get_name_leafdata())

                leaf_name_data.extend(self.retransmit_time.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "local-tunnel-id" or name == "active-sessions" or name == "class-name" or name == "digest-secrets" or name == "is-congestion-control-enabled" or name == "is-pmtu-enabled" or name == "is-tunnel-up" or name == "local-address" or name == "local-port" or name == "local-tunnel-name" or name == "local-window-size" or name == "maximum-retransmission-time" or name == "order-queue-size" or name == "packet-queue-check" or name == "protocol" or name == "remote-address" or name == "remote-port" or name == "remote-tunnel-id" or name == "remote-tunnel-name" or name == "remote-window-size" or name == "resend-maximum-queue-size" or name == "resend-queue-size" or name == "resends" or name == "retransmission-time" or name == "retransmit-time" or name == "sequence-nr" or name == "sequence-ns" or name == "total-out-of-order-drop-packets" or name == "total-out-of-order-reorder-packets" or name == "total-peer-authentication-failures" or name == "unsent-maximum-queue-size" or name == "unsent-queue-size" or name == "zero-length-body-acknowledgement-sent"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "local-tunnel-id"):
                    self.local_tunnel_id = value
                    self.local_tunnel_id.value_namespace = name_space
                    self.local_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "active-sessions"):
                    self.active_sessions = value
                    self.active_sessions.value_namespace = name_space
                    self.active_sessions.value_namespace_prefix = name_space_prefix
                if(value_path == "class-name"):
                    self.class_name = value
                    self.class_name.value_namespace = name_space
                    self.class_name.value_namespace_prefix = name_space_prefix
                if(value_path == "digest-secrets"):
                    self.digest_secrets = value
                    self.digest_secrets.value_namespace = name_space
                    self.digest_secrets.value_namespace_prefix = name_space_prefix
                if(value_path == "is-congestion-control-enabled"):
                    self.is_congestion_control_enabled = value
                    self.is_congestion_control_enabled.value_namespace = name_space
                    self.is_congestion_control_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-pmtu-enabled"):
                    self.is_pmtu_enabled = value
                    self.is_pmtu_enabled.value_namespace = name_space
                    self.is_pmtu_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-tunnel-up"):
                    self.is_tunnel_up = value
                    self.is_tunnel_up.value_namespace = name_space
                    self.is_tunnel_up.value_namespace_prefix = name_space_prefix
                if(value_path == "local-address"):
                    self.local_address = value
                    self.local_address.value_namespace = name_space
                    self.local_address.value_namespace_prefix = name_space_prefix
                if(value_path == "local-port"):
                    self.local_port = value
                    self.local_port.value_namespace = name_space
                    self.local_port.value_namespace_prefix = name_space_prefix
                if(value_path == "local-tunnel-name"):
                    self.local_tunnel_name = value
                    self.local_tunnel_name.value_namespace = name_space
                    self.local_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "local-window-size"):
                    self.local_window_size = value
                    self.local_window_size.value_namespace = name_space
                    self.local_window_size.value_namespace_prefix = name_space_prefix
                if(value_path == "maximum-retransmission-time"):
                    self.maximum_retransmission_time = value
                    self.maximum_retransmission_time.value_namespace = name_space
                    self.maximum_retransmission_time.value_namespace_prefix = name_space_prefix
                if(value_path == "order-queue-size"):
                    self.order_queue_size = value
                    self.order_queue_size.value_namespace = name_space
                    self.order_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "packet-queue-check"):
                    self.packet_queue_check = value
                    self.packet_queue_check.value_namespace = name_space
                    self.packet_queue_check.value_namespace_prefix = name_space_prefix
                if(value_path == "protocol"):
                    self.protocol = value
                    self.protocol.value_namespace = name_space
                    self.protocol.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-address"):
                    self.remote_address = value
                    self.remote_address.value_namespace = name_space
                    self.remote_address.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-port"):
                    self.remote_port = value
                    self.remote_port.value_namespace = name_space
                    self.remote_port.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-id"):
                    self.remote_tunnel_id = value
                    self.remote_tunnel_id.value_namespace = name_space
                    self.remote_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-name"):
                    self.remote_tunnel_name = value
                    self.remote_tunnel_name.value_namespace = name_space
                    self.remote_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-window-size"):
                    self.remote_window_size = value
                    self.remote_window_size.value_namespace = name_space
                    self.remote_window_size.value_namespace_prefix = name_space_prefix
                if(value_path == "resend-maximum-queue-size"):
                    self.resend_maximum_queue_size = value
                    self.resend_maximum_queue_size.value_namespace = name_space
                    self.resend_maximum_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "resend-queue-size"):
                    self.resend_queue_size = value
                    self.resend_queue_size.value_namespace = name_space
                    self.resend_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "resends"):
                    self.resends = value
                    self.resends.value_namespace = name_space
                    self.resends.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmission-time"):
                    self.retransmission_time = value
                    self.retransmission_time.value_namespace = name_space
                    self.retransmission_time.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-time"):
                    self.retransmit_time.append(value)
                if(value_path == "sequence-nr"):
                    self.sequence_nr = value
                    self.sequence_nr.value_namespace = name_space
                    self.sequence_nr.value_namespace_prefix = name_space_prefix
                if(value_path == "sequence-ns"):
                    self.sequence_ns = value
                    self.sequence_ns.value_namespace = name_space
                    self.sequence_ns.value_namespace_prefix = name_space_prefix
                if(value_path == "total-out-of-order-drop-packets"):
                    self.total_out_of_order_drop_packets = value
                    self.total_out_of_order_drop_packets.value_namespace = name_space
                    self.total_out_of_order_drop_packets.value_namespace_prefix = name_space_prefix
                if(value_path == "total-out-of-order-reorder-packets"):
                    self.total_out_of_order_reorder_packets = value
                    self.total_out_of_order_reorder_packets.value_namespace = name_space
                    self.total_out_of_order_reorder_packets.value_namespace_prefix = name_space_prefix
                if(value_path == "total-peer-authentication-failures"):
                    self.total_peer_authentication_failures = value
                    self.total_peer_authentication_failures.value_namespace = name_space
                    self.total_peer_authentication_failures.value_namespace_prefix = name_space_prefix
                if(value_path == "unsent-maximum-queue-size"):
                    self.unsent_maximum_queue_size = value
                    self.unsent_maximum_queue_size.value_namespace = name_space
                    self.unsent_maximum_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "unsent-queue-size"):
                    self.unsent_queue_size = value
                    self.unsent_queue_size.value_namespace = name_space
                    self.unsent_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "zero-length-body-acknowledgement-sent"):
                    self.zero_length_body_acknowledgement_sent = value
                    self.zero_length_body_acknowledgement_sent.value_namespace = name_space
                    self.zero_length_body_acknowledgement_sent.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnels" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel"):
                for c in self.tunnel:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tp.Tunnels.Tunnel()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Sessions(Entity):
        """
        List of session IDs
        
        .. attribute:: session
        
        	L2TP information for a particular session
        	**type**\: list of    :py:class:`Session <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Sessions.Session>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tp.Sessions, self).__init__()

            self.yang_name = "sessions"
            self.yang_parent_name = "l2tp"

            self.session = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tp.Sessions, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tp.Sessions, self).__setattr__(name, value)


        class Session(Entity):
            """
            L2TP information for a particular session
            
            .. attribute:: local_tunnel_id  <key>
            
            	Local tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: local_session_id  <key>
            
            	Local session ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: call_serial_number
            
            	Call serial number
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_name
            
            	Interface name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: is_conditional_debug_enabled
            
            	True if conditional debugging is enabled
            	**type**\:  bool
            
            .. attribute:: is_sequencing_on
            
            	True if session sequence is on
            	**type**\:  bool
            
            .. attribute:: is_session_locally_initiated
            
            	True if session initiated locally
            	**type**\:  bool
            
            .. attribute:: is_session_manual
            
            	True if session is manual
            	**type**\:  bool
            
            .. attribute:: is_session_state_established
            
            	True if session state is established
            	**type**\:  bool
            
            .. attribute:: is_session_up
            
            	True if session is up
            	**type**\:  bool
            
            .. attribute:: is_udp_checksum_enabled
            
            	True if UDP checksum enabled
            	**type**\:  bool
            
            .. attribute:: l2tp_sh_sess_tie_breaker
            
            	l2tp sh sess tie breaker
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            .. attribute:: l2tp_sh_sess_tie_breaker_enabled
            
            	l2tp sh sess tie breaker enabled
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: l2tp_sh_sess_udp_lport
            
            	l2tp sh sess udp lport
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: l2tp_sh_sess_udp_rport
            
            	l2tp sh sess udp rport
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: local_ip_address
            
            	Local session IP address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: local_tunnel_name
            
            	Local tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: protocol
            
            	Protocol
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: remote_ip_address
            
            	Remote session IP address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: remote_session_id
            
            	Remote session ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_tunnel_id
            
            	Remote tunnel ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_tunnel_name
            
            	Remote tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: session_application_data
            
            	Session application data
            	**type**\:   :py:class:`SessionApplicationData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Sessions.Session.SessionApplicationData>`
            
            .. attribute:: unique_id
            
            	Unique ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tp.Sessions.Session, self).__init__()

                self.yang_name = "session"
                self.yang_parent_name = "sessions"

                self.local_tunnel_id = YLeaf(YType.int32, "local-tunnel-id")

                self.local_session_id = YLeaf(YType.int32, "local-session-id")

                self.call_serial_number = YLeaf(YType.uint32, "call-serial-number")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.is_conditional_debug_enabled = YLeaf(YType.boolean, "is-conditional-debug-enabled")

                self.is_sequencing_on = YLeaf(YType.boolean, "is-sequencing-on")

                self.is_session_locally_initiated = YLeaf(YType.boolean, "is-session-locally-initiated")

                self.is_session_manual = YLeaf(YType.boolean, "is-session-manual")

                self.is_session_state_established = YLeaf(YType.boolean, "is-session-state-established")

                self.is_session_up = YLeaf(YType.boolean, "is-session-up")

                self.is_udp_checksum_enabled = YLeaf(YType.boolean, "is-udp-checksum-enabled")

                self.l2tp_sh_sess_tie_breaker = YLeaf(YType.uint64, "l2tp-sh-sess-tie-breaker")

                self.l2tp_sh_sess_tie_breaker_enabled = YLeaf(YType.uint8, "l2tp-sh-sess-tie-breaker-enabled")

                self.l2tp_sh_sess_udp_lport = YLeaf(YType.uint16, "l2tp-sh-sess-udp-lport")

                self.l2tp_sh_sess_udp_rport = YLeaf(YType.uint16, "l2tp-sh-sess-udp-rport")

                self.local_ip_address = YLeaf(YType.str, "local-ip-address")

                self.local_tunnel_name = YLeaf(YType.str, "local-tunnel-name")

                self.protocol = YLeaf(YType.uint8, "protocol")

                self.remote_ip_address = YLeaf(YType.str, "remote-ip-address")

                self.remote_session_id = YLeaf(YType.uint32, "remote-session-id")

                self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                self.remote_tunnel_name = YLeaf(YType.str, "remote-tunnel-name")

                self.unique_id = YLeaf(YType.uint32, "unique-id")

                self.session_application_data = L2Tp.Sessions.Session.SessionApplicationData()
                self.session_application_data.parent = self
                self._children_name_map["session_application_data"] = "session-application-data"
                self._children_yang_names.add("session-application-data")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("local_tunnel_id",
                                "local_session_id",
                                "call_serial_number",
                                "interface_name",
                                "is_conditional_debug_enabled",
                                "is_sequencing_on",
                                "is_session_locally_initiated",
                                "is_session_manual",
                                "is_session_state_established",
                                "is_session_up",
                                "is_udp_checksum_enabled",
                                "l2tp_sh_sess_tie_breaker",
                                "l2tp_sh_sess_tie_breaker_enabled",
                                "l2tp_sh_sess_udp_lport",
                                "l2tp_sh_sess_udp_rport",
                                "local_ip_address",
                                "local_tunnel_name",
                                "protocol",
                                "remote_ip_address",
                                "remote_session_id",
                                "remote_tunnel_id",
                                "remote_tunnel_name",
                                "unique_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tp.Sessions.Session, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tp.Sessions.Session, self).__setattr__(name, value)


            class SessionApplicationData(Entity):
                """
                Session application data
                
                .. attribute:: l2tp_sh_sess_app_type
                
                	l2tp sh sess app type
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: vpdn
                
                	VPDN data
                	**type**\:   :py:class:`Vpdn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Sessions.Session.SessionApplicationData.Vpdn>`
                
                .. attribute:: xconnect
                
                	Xconnect data
                	**type**\:   :py:class:`Xconnect <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Sessions.Session.SessionApplicationData.Xconnect>`
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tp.Sessions.Session.SessionApplicationData, self).__init__()

                    self.yang_name = "session-application-data"
                    self.yang_parent_name = "session"

                    self.l2tp_sh_sess_app_type = YLeaf(YType.uint32, "l2tp-sh-sess-app-type")

                    self.vpdn = L2Tp.Sessions.Session.SessionApplicationData.Vpdn()
                    self.vpdn.parent = self
                    self._children_name_map["vpdn"] = "vpdn"
                    self._children_yang_names.add("vpdn")

                    self.xconnect = L2Tp.Sessions.Session.SessionApplicationData.Xconnect()
                    self.xconnect.parent = self
                    self._children_name_map["xconnect"] = "xconnect"
                    self._children_yang_names.add("xconnect")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("l2tp_sh_sess_app_type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tp.Sessions.Session.SessionApplicationData, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tp.Sessions.Session.SessionApplicationData, self).__setattr__(name, value)


                class Xconnect(Entity):
                    """
                    Xconnect data
                    
                    .. attribute:: circuit_name
                    
                    	Circuit name
                    	**type**\:  str
                    
                    .. attribute:: ipv6_protocol_tunneling
                    
                    	IPv6ProtocolTunneling
                    	**type**\:  bool
                    
                    .. attribute:: is_circuit_state_up
                    
                    	True if circuit state is up
                    	**type**\:  bool
                    
                    .. attribute:: is_local_circuit_state_up
                    
                    	True if local circuit state is up
                    	**type**\:  bool
                    
                    .. attribute:: is_remote_circuit_state_up
                    
                    	True if remote circuit state is up
                    	**type**\:  bool
                    
                    .. attribute:: sessionvc_id
                    
                    	Session VC ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tp.Sessions.Session.SessionApplicationData.Xconnect, self).__init__()

                        self.yang_name = "xconnect"
                        self.yang_parent_name = "session-application-data"

                        self.circuit_name = YLeaf(YType.str, "circuit-name")

                        self.ipv6_protocol_tunneling = YLeaf(YType.boolean, "ipv6-protocol-tunneling")

                        self.is_circuit_state_up = YLeaf(YType.boolean, "is-circuit-state-up")

                        self.is_local_circuit_state_up = YLeaf(YType.boolean, "is-local-circuit-state-up")

                        self.is_remote_circuit_state_up = YLeaf(YType.boolean, "is-remote-circuit-state-up")

                        self.sessionvc_id = YLeaf(YType.uint32, "sessionvc-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("circuit_name",
                                        "ipv6_protocol_tunneling",
                                        "is_circuit_state_up",
                                        "is_local_circuit_state_up",
                                        "is_remote_circuit_state_up",
                                        "sessionvc_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tp.Sessions.Session.SessionApplicationData.Xconnect, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tp.Sessions.Session.SessionApplicationData.Xconnect, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.circuit_name.is_set or
                            self.ipv6_protocol_tunneling.is_set or
                            self.is_circuit_state_up.is_set or
                            self.is_local_circuit_state_up.is_set or
                            self.is_remote_circuit_state_up.is_set or
                            self.sessionvc_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.circuit_name.yfilter != YFilter.not_set or
                            self.ipv6_protocol_tunneling.yfilter != YFilter.not_set or
                            self.is_circuit_state_up.yfilter != YFilter.not_set or
                            self.is_local_circuit_state_up.yfilter != YFilter.not_set or
                            self.is_remote_circuit_state_up.yfilter != YFilter.not_set or
                            self.sessionvc_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "xconnect" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.circuit_name.is_set or self.circuit_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.circuit_name.get_name_leafdata())
                        if (self.ipv6_protocol_tunneling.is_set or self.ipv6_protocol_tunneling.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6_protocol_tunneling.get_name_leafdata())
                        if (self.is_circuit_state_up.is_set or self.is_circuit_state_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_circuit_state_up.get_name_leafdata())
                        if (self.is_local_circuit_state_up.is_set or self.is_local_circuit_state_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_local_circuit_state_up.get_name_leafdata())
                        if (self.is_remote_circuit_state_up.is_set or self.is_remote_circuit_state_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_remote_circuit_state_up.get_name_leafdata())
                        if (self.sessionvc_id.is_set or self.sessionvc_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sessionvc_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "circuit-name" or name == "ipv6-protocol-tunneling" or name == "is-circuit-state-up" or name == "is-local-circuit-state-up" or name == "is-remote-circuit-state-up" or name == "sessionvc-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "circuit-name"):
                            self.circuit_name = value
                            self.circuit_name.value_namespace = name_space
                            self.circuit_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6-protocol-tunneling"):
                            self.ipv6_protocol_tunneling = value
                            self.ipv6_protocol_tunneling.value_namespace = name_space
                            self.ipv6_protocol_tunneling.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-circuit-state-up"):
                            self.is_circuit_state_up = value
                            self.is_circuit_state_up.value_namespace = name_space
                            self.is_circuit_state_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-local-circuit-state-up"):
                            self.is_local_circuit_state_up = value
                            self.is_local_circuit_state_up.value_namespace = name_space
                            self.is_local_circuit_state_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-remote-circuit-state-up"):
                            self.is_remote_circuit_state_up = value
                            self.is_remote_circuit_state_up.value_namespace = name_space
                            self.is_remote_circuit_state_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "sessionvc-id"):
                            self.sessionvc_id = value
                            self.sessionvc_id.value_namespace = name_space
                            self.sessionvc_id.value_namespace_prefix = name_space_prefix


                class Vpdn(Entity):
                    """
                    VPDN data
                    
                    .. attribute:: interface_name
                    
                    	Interface name
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: username
                    
                    	Session username
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tp.Sessions.Session.SessionApplicationData.Vpdn, self).__init__()

                        self.yang_name = "vpdn"
                        self.yang_parent_name = "session-application-data"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.username = YLeaf(YType.str, "username")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name",
                                        "username") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tp.Sessions.Session.SessionApplicationData.Vpdn, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tp.Sessions.Session.SessionApplicationData.Vpdn, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            self.username.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.username.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "vpdn" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.username.is_set or self.username.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.username.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface-name" or name == "username"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "username"):
                            self.username = value
                            self.username.value_namespace = name_space
                            self.username.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.l2tp_sh_sess_app_type.is_set or
                        (self.vpdn is not None and self.vpdn.has_data()) or
                        (self.xconnect is not None and self.xconnect.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.l2tp_sh_sess_app_type.yfilter != YFilter.not_set or
                        (self.vpdn is not None and self.vpdn.has_operation()) or
                        (self.xconnect is not None and self.xconnect.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-application-data" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.l2tp_sh_sess_app_type.is_set or self.l2tp_sh_sess_app_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.l2tp_sh_sess_app_type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "vpdn"):
                        if (self.vpdn is None):
                            self.vpdn = L2Tp.Sessions.Session.SessionApplicationData.Vpdn()
                            self.vpdn.parent = self
                            self._children_name_map["vpdn"] = "vpdn"
                        return self.vpdn

                    if (child_yang_name == "xconnect"):
                        if (self.xconnect is None):
                            self.xconnect = L2Tp.Sessions.Session.SessionApplicationData.Xconnect()
                            self.xconnect.parent = self
                            self._children_name_map["xconnect"] = "xconnect"
                        return self.xconnect

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vpdn" or name == "xconnect" or name == "l2tp-sh-sess-app-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "l2tp-sh-sess-app-type"):
                        self.l2tp_sh_sess_app_type = value
                        self.l2tp_sh_sess_app_type.value_namespace = name_space
                        self.l2tp_sh_sess_app_type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.local_tunnel_id.is_set or
                    self.local_session_id.is_set or
                    self.call_serial_number.is_set or
                    self.interface_name.is_set or
                    self.is_conditional_debug_enabled.is_set or
                    self.is_sequencing_on.is_set or
                    self.is_session_locally_initiated.is_set or
                    self.is_session_manual.is_set or
                    self.is_session_state_established.is_set or
                    self.is_session_up.is_set or
                    self.is_udp_checksum_enabled.is_set or
                    self.l2tp_sh_sess_tie_breaker.is_set or
                    self.l2tp_sh_sess_tie_breaker_enabled.is_set or
                    self.l2tp_sh_sess_udp_lport.is_set or
                    self.l2tp_sh_sess_udp_rport.is_set or
                    self.local_ip_address.is_set or
                    self.local_tunnel_name.is_set or
                    self.protocol.is_set or
                    self.remote_ip_address.is_set or
                    self.remote_session_id.is_set or
                    self.remote_tunnel_id.is_set or
                    self.remote_tunnel_name.is_set or
                    self.unique_id.is_set or
                    (self.session_application_data is not None and self.session_application_data.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.local_tunnel_id.yfilter != YFilter.not_set or
                    self.local_session_id.yfilter != YFilter.not_set or
                    self.call_serial_number.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.is_conditional_debug_enabled.yfilter != YFilter.not_set or
                    self.is_sequencing_on.yfilter != YFilter.not_set or
                    self.is_session_locally_initiated.yfilter != YFilter.not_set or
                    self.is_session_manual.yfilter != YFilter.not_set or
                    self.is_session_state_established.yfilter != YFilter.not_set or
                    self.is_session_up.yfilter != YFilter.not_set or
                    self.is_udp_checksum_enabled.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_tie_breaker.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_tie_breaker_enabled.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_udp_lport.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_udp_rport.yfilter != YFilter.not_set or
                    self.local_ip_address.yfilter != YFilter.not_set or
                    self.local_tunnel_name.yfilter != YFilter.not_set or
                    self.protocol.yfilter != YFilter.not_set or
                    self.remote_ip_address.yfilter != YFilter.not_set or
                    self.remote_session_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_name.yfilter != YFilter.not_set or
                    self.unique_id.yfilter != YFilter.not_set or
                    (self.session_application_data is not None and self.session_application_data.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session" + "[local-tunnel-id='" + self.local_tunnel_id.get() + "']" + "[local-session-id='" + self.local_session_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/sessions/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.local_tunnel_id.is_set or self.local_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_id.get_name_leafdata())
                if (self.local_session_id.is_set or self.local_session_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_session_id.get_name_leafdata())
                if (self.call_serial_number.is_set or self.call_serial_number.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.call_serial_number.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.is_conditional_debug_enabled.is_set or self.is_conditional_debug_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_conditional_debug_enabled.get_name_leafdata())
                if (self.is_sequencing_on.is_set or self.is_sequencing_on.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_sequencing_on.get_name_leafdata())
                if (self.is_session_locally_initiated.is_set or self.is_session_locally_initiated.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_locally_initiated.get_name_leafdata())
                if (self.is_session_manual.is_set or self.is_session_manual.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_manual.get_name_leafdata())
                if (self.is_session_state_established.is_set or self.is_session_state_established.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_state_established.get_name_leafdata())
                if (self.is_session_up.is_set or self.is_session_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_up.get_name_leafdata())
                if (self.is_udp_checksum_enabled.is_set or self.is_udp_checksum_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_udp_checksum_enabled.get_name_leafdata())
                if (self.l2tp_sh_sess_tie_breaker.is_set or self.l2tp_sh_sess_tie_breaker.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_tie_breaker.get_name_leafdata())
                if (self.l2tp_sh_sess_tie_breaker_enabled.is_set or self.l2tp_sh_sess_tie_breaker_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_tie_breaker_enabled.get_name_leafdata())
                if (self.l2tp_sh_sess_udp_lport.is_set or self.l2tp_sh_sess_udp_lport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_udp_lport.get_name_leafdata())
                if (self.l2tp_sh_sess_udp_rport.is_set or self.l2tp_sh_sess_udp_rport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_udp_rport.get_name_leafdata())
                if (self.local_ip_address.is_set or self.local_ip_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ip_address.get_name_leafdata())
                if (self.local_tunnel_name.is_set or self.local_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_name.get_name_leafdata())
                if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocol.get_name_leafdata())
                if (self.remote_ip_address.is_set or self.remote_ip_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ip_address.get_name_leafdata())
                if (self.remote_session_id.is_set or self.remote_session_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_session_id.get_name_leafdata())
                if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())
                if (self.remote_tunnel_name.is_set or self.remote_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_name.get_name_leafdata())
                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-application-data"):
                    if (self.session_application_data is None):
                        self.session_application_data = L2Tp.Sessions.Session.SessionApplicationData()
                        self.session_application_data.parent = self
                        self._children_name_map["session_application_data"] = "session-application-data"
                    return self.session_application_data

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-application-data" or name == "local-tunnel-id" or name == "local-session-id" or name == "call-serial-number" or name == "interface-name" or name == "is-conditional-debug-enabled" or name == "is-sequencing-on" or name == "is-session-locally-initiated" or name == "is-session-manual" or name == "is-session-state-established" or name == "is-session-up" or name == "is-udp-checksum-enabled" or name == "l2tp-sh-sess-tie-breaker" or name == "l2tp-sh-sess-tie-breaker-enabled" or name == "l2tp-sh-sess-udp-lport" or name == "l2tp-sh-sess-udp-rport" or name == "local-ip-address" or name == "local-tunnel-name" or name == "protocol" or name == "remote-ip-address" or name == "remote-session-id" or name == "remote-tunnel-id" or name == "remote-tunnel-name" or name == "unique-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "local-tunnel-id"):
                    self.local_tunnel_id = value
                    self.local_tunnel_id.value_namespace = name_space
                    self.local_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "local-session-id"):
                    self.local_session_id = value
                    self.local_session_id.value_namespace = name_space
                    self.local_session_id.value_namespace_prefix = name_space_prefix
                if(value_path == "call-serial-number"):
                    self.call_serial_number = value
                    self.call_serial_number.value_namespace = name_space
                    self.call_serial_number.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "is-conditional-debug-enabled"):
                    self.is_conditional_debug_enabled = value
                    self.is_conditional_debug_enabled.value_namespace = name_space
                    self.is_conditional_debug_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-sequencing-on"):
                    self.is_sequencing_on = value
                    self.is_sequencing_on.value_namespace = name_space
                    self.is_sequencing_on.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-locally-initiated"):
                    self.is_session_locally_initiated = value
                    self.is_session_locally_initiated.value_namespace = name_space
                    self.is_session_locally_initiated.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-manual"):
                    self.is_session_manual = value
                    self.is_session_manual.value_namespace = name_space
                    self.is_session_manual.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-state-established"):
                    self.is_session_state_established = value
                    self.is_session_state_established.value_namespace = name_space
                    self.is_session_state_established.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-up"):
                    self.is_session_up = value
                    self.is_session_up.value_namespace = name_space
                    self.is_session_up.value_namespace_prefix = name_space_prefix
                if(value_path == "is-udp-checksum-enabled"):
                    self.is_udp_checksum_enabled = value
                    self.is_udp_checksum_enabled.value_namespace = name_space
                    self.is_udp_checksum_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-tie-breaker"):
                    self.l2tp_sh_sess_tie_breaker = value
                    self.l2tp_sh_sess_tie_breaker.value_namespace = name_space
                    self.l2tp_sh_sess_tie_breaker.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-tie-breaker-enabled"):
                    self.l2tp_sh_sess_tie_breaker_enabled = value
                    self.l2tp_sh_sess_tie_breaker_enabled.value_namespace = name_space
                    self.l2tp_sh_sess_tie_breaker_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-udp-lport"):
                    self.l2tp_sh_sess_udp_lport = value
                    self.l2tp_sh_sess_udp_lport.value_namespace = name_space
                    self.l2tp_sh_sess_udp_lport.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-udp-rport"):
                    self.l2tp_sh_sess_udp_rport = value
                    self.l2tp_sh_sess_udp_rport.value_namespace = name_space
                    self.l2tp_sh_sess_udp_rport.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ip-address"):
                    self.local_ip_address = value
                    self.local_ip_address.value_namespace = name_space
                    self.local_ip_address.value_namespace_prefix = name_space_prefix
                if(value_path == "local-tunnel-name"):
                    self.local_tunnel_name = value
                    self.local_tunnel_name.value_namespace = name_space
                    self.local_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "protocol"):
                    self.protocol = value
                    self.protocol.value_namespace = name_space
                    self.protocol.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ip-address"):
                    self.remote_ip_address = value
                    self.remote_ip_address.value_namespace = name_space
                    self.remote_ip_address.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-session-id"):
                    self.remote_session_id = value
                    self.remote_session_id.value_namespace = name_space
                    self.remote_session_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-id"):
                    self.remote_tunnel_id = value
                    self.remote_tunnel_id.value_namespace = name_space
                    self.remote_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-name"):
                    self.remote_tunnel_name = value
                    self.remote_tunnel_name.value_namespace = name_space
                    self.remote_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "unique-id"):
                    self.unique_id = value
                    self.unique_id.value_namespace = name_space
                    self.unique_id.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.session:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.session:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "sessions" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session"):
                for c in self.session:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tp.Sessions.Session()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.session.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Session(Entity):
        """
        L2TP control messages counters
        
        .. attribute:: unavailable
        
        	L2TP session unavailable  information
        	**type**\:   :py:class:`Unavailable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tp.Session.Unavailable>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tp.Session, self).__init__()

            self.yang_name = "session"
            self.yang_parent_name = "l2tp"

            self.unavailable = L2Tp.Session.Unavailable()
            self.unavailable.parent = self
            self._children_name_map["unavailable"] = "unavailable"
            self._children_yang_names.add("unavailable")


        class Unavailable(Entity):
            """
            L2TP session unavailable  information
            
            .. attribute:: sessions_on_hold
            
            	Number of session ID in hold database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tp.Session.Unavailable, self).__init__()

                self.yang_name = "unavailable"
                self.yang_parent_name = "session"

                self.sessions_on_hold = YLeaf(YType.uint32, "sessions-on-hold")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("sessions_on_hold") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tp.Session.Unavailable, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tp.Session.Unavailable, self).__setattr__(name, value)

            def has_data(self):
                return self.sessions_on_hold.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.sessions_on_hold.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "unavailable" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/session/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.sessions_on_hold.is_set or self.sessions_on_hold.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sessions_on_hold.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "sessions-on-hold"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "sessions-on-hold"):
                    self.sessions_on_hold = value
                    self.sessions_on_hold.value_namespace = name_space
                    self.sessions_on_hold.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.unavailable is not None and self.unavailable.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.unavailable is not None and self.unavailable.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "session" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "unavailable"):
                if (self.unavailable is None):
                    self.unavailable = L2Tp.Session.Unavailable()
                    self.unavailable.parent = self
                    self._children_name_map["unavailable"] = "unavailable"
                return self.unavailable

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "unavailable"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.classes is not None and self.classes.has_data()) or
            (self.counter_hist_fail is not None and self.counter_hist_fail.has_data()) or
            (self.counters is not None and self.counters.has_data()) or
            (self.session is not None and self.session.has_data()) or
            (self.sessions is not None and self.sessions.has_data()) or
            (self.tunnel_configurations is not None and self.tunnel_configurations.has_data()) or
            (self.tunnels is not None and self.tunnels.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.classes is not None and self.classes.has_operation()) or
            (self.counter_hist_fail is not None and self.counter_hist_fail.has_operation()) or
            (self.counters is not None and self.counters.has_operation()) or
            (self.session is not None and self.session.has_operation()) or
            (self.sessions is not None and self.sessions.has_operation()) or
            (self.tunnel_configurations is not None and self.tunnel_configurations.has_operation()) or
            (self.tunnels is not None and self.tunnels.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tp" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "classes"):
            if (self.classes is None):
                self.classes = L2Tp.Classes()
                self.classes.parent = self
                self._children_name_map["classes"] = "classes"
            return self.classes

        if (child_yang_name == "counter-hist-fail"):
            if (self.counter_hist_fail is None):
                self.counter_hist_fail = L2Tp.CounterHistFail()
                self.counter_hist_fail.parent = self
                self._children_name_map["counter_hist_fail"] = "counter-hist-fail"
            return self.counter_hist_fail

        if (child_yang_name == "counters"):
            if (self.counters is None):
                self.counters = L2Tp.Counters()
                self.counters.parent = self
                self._children_name_map["counters"] = "counters"
            return self.counters

        if (child_yang_name == "session"):
            if (self.session is None):
                self.session = L2Tp.Session()
                self.session.parent = self
                self._children_name_map["session"] = "session"
            return self.session

        if (child_yang_name == "sessions"):
            if (self.sessions is None):
                self.sessions = L2Tp.Sessions()
                self.sessions.parent = self
                self._children_name_map["sessions"] = "sessions"
            return self.sessions

        if (child_yang_name == "tunnel-configurations"):
            if (self.tunnel_configurations is None):
                self.tunnel_configurations = L2Tp.TunnelConfigurations()
                self.tunnel_configurations.parent = self
                self._children_name_map["tunnel_configurations"] = "tunnel-configurations"
            return self.tunnel_configurations

        if (child_yang_name == "tunnels"):
            if (self.tunnels is None):
                self.tunnels = L2Tp.Tunnels()
                self.tunnels.parent = self
                self._children_name_map["tunnels"] = "tunnels"
            return self.tunnels

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "classes" or name == "counter-hist-fail" or name == "counters" or name == "session" or name == "sessions" or name == "tunnel-configurations" or name == "tunnels"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = L2Tp()
        return self._top_entity

class L2Tpv2(Entity):
    """
    l2tpv2
    
    .. attribute:: classes
    
    	List of L2TP class names
    	**type**\:   :py:class:`Classes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Classes>`
    
    .. attribute:: counter_hist_fail
    
    	Failure events leading to disconnection
    	**type**\:   :py:class:`CounterHistFail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.CounterHistFail>`
    
    .. attribute:: counters
    
    	L2TP control messages counters
    	**type**\:   :py:class:`Counters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters>`
    
    .. attribute:: session
    
    	L2TP control messages counters
    	**type**\:   :py:class:`Session <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Session>`
    
    .. attribute:: sessions
    
    	List of session IDs
    	**type**\:   :py:class:`Sessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Sessions>`
    
    .. attribute:: statistics
    
    	L2TP v2 statistics information
    	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Statistics>`
    
    .. attribute:: tunnel
    
    	L2TPv2 tunnel 
    	**type**\:   :py:class:`Tunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Tunnel>`
    
    .. attribute:: tunnel_configurations
    
    	List of tunnel IDs
    	**type**\:   :py:class:`TunnelConfigurations <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.TunnelConfigurations>`
    
    .. attribute:: tunnels
    
    	List of tunnel IDs
    	**type**\:   :py:class:`Tunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Tunnels>`
    
    

    """

    _prefix = 'tunnel-l2tun-oper'
    _revision = '2015-11-09'

    def __init__(self):
        super(L2Tpv2, self).__init__()
        self._top_entity = None

        self.yang_name = "l2tpv2"
        self.yang_parent_name = "Cisco-IOS-XR-tunnel-l2tun-oper"

        self.classes = L2Tpv2.Classes()
        self.classes.parent = self
        self._children_name_map["classes"] = "classes"
        self._children_yang_names.add("classes")

        self.counter_hist_fail = L2Tpv2.CounterHistFail()
        self.counter_hist_fail.parent = self
        self._children_name_map["counter_hist_fail"] = "counter-hist-fail"
        self._children_yang_names.add("counter-hist-fail")

        self.counters = L2Tpv2.Counters()
        self.counters.parent = self
        self._children_name_map["counters"] = "counters"
        self._children_yang_names.add("counters")

        self.session = L2Tpv2.Session()
        self.session.parent = self
        self._children_name_map["session"] = "session"
        self._children_yang_names.add("session")

        self.sessions = L2Tpv2.Sessions()
        self.sessions.parent = self
        self._children_name_map["sessions"] = "sessions"
        self._children_yang_names.add("sessions")

        self.statistics = L2Tpv2.Statistics()
        self.statistics.parent = self
        self._children_name_map["statistics"] = "statistics"
        self._children_yang_names.add("statistics")

        self.tunnel = L2Tpv2.Tunnel()
        self.tunnel.parent = self
        self._children_name_map["tunnel"] = "tunnel"
        self._children_yang_names.add("tunnel")

        self.tunnel_configurations = L2Tpv2.TunnelConfigurations()
        self.tunnel_configurations.parent = self
        self._children_name_map["tunnel_configurations"] = "tunnel-configurations"
        self._children_yang_names.add("tunnel-configurations")

        self.tunnels = L2Tpv2.Tunnels()
        self.tunnels.parent = self
        self._children_name_map["tunnels"] = "tunnels"
        self._children_yang_names.add("tunnels")


    class Counters(Entity):
        """
        L2TP control messages counters
        
        .. attribute:: control
        
        	L2TP control messages counters
        	**type**\:   :py:class:`Control <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control>`
        
        .. attribute:: forwarding
        
        	L2TP forwarding messages counters
        	**type**\:   :py:class:`Forwarding <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Forwarding>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.Counters, self).__init__()

            self.yang_name = "counters"
            self.yang_parent_name = "l2tpv2"

            self.control = L2Tpv2.Counters.Control()
            self.control.parent = self
            self._children_name_map["control"] = "control"
            self._children_yang_names.add("control")

            self.forwarding = L2Tpv2.Counters.Forwarding()
            self.forwarding.parent = self
            self._children_name_map["forwarding"] = "forwarding"
            self._children_yang_names.add("forwarding")


        class Forwarding(Entity):
            """
            L2TP forwarding messages counters
            
            .. attribute:: sessions
            
            	List of class and session IDs
            	**type**\:   :py:class:`Sessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Forwarding.Sessions>`
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.Counters.Forwarding, self).__init__()

                self.yang_name = "forwarding"
                self.yang_parent_name = "counters"

                self.sessions = L2Tpv2.Counters.Forwarding.Sessions()
                self.sessions.parent = self
                self._children_name_map["sessions"] = "sessions"
                self._children_yang_names.add("sessions")


            class Sessions(Entity):
                """
                List of class and session IDs
                
                .. attribute:: session
                
                	L2TP information for a particular session
                	**type**\: list of    :py:class:`Session <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Forwarding.Sessions.Session>`
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tpv2.Counters.Forwarding.Sessions, self).__init__()

                    self.yang_name = "sessions"
                    self.yang_parent_name = "forwarding"

                    self.session = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tpv2.Counters.Forwarding.Sessions, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tpv2.Counters.Forwarding.Sessions, self).__setattr__(name, value)


                class Session(Entity):
                    """
                    L2TP information for a particular session
                    
                    .. attribute:: tunnel_id  <key>
                    
                    	Local tunnel ID
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: session_id  <key>
                    
                    	Local session ID
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: in_bytes
                    
                    	Number of bytes sent in
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: byte
                    
                    .. attribute:: in_packets
                    
                    	Number of packets sent in
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: out_bytes
                    
                    	Number of bytes sent out
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: byte
                    
                    .. attribute:: out_packets
                    
                    	Number of packets sent out
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: remote_session_id
                    
                    	Remote session ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tpv2.Counters.Forwarding.Sessions.Session, self).__init__()

                        self.yang_name = "session"
                        self.yang_parent_name = "sessions"

                        self.tunnel_id = YLeaf(YType.int32, "tunnel-id")

                        self.session_id = YLeaf(YType.int32, "session-id")

                        self.in_bytes = YLeaf(YType.uint64, "in-bytes")

                        self.in_packets = YLeaf(YType.uint64, "in-packets")

                        self.out_bytes = YLeaf(YType.uint64, "out-bytes")

                        self.out_packets = YLeaf(YType.uint64, "out-packets")

                        self.remote_session_id = YLeaf(YType.uint32, "remote-session-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("tunnel_id",
                                        "session_id",
                                        "in_bytes",
                                        "in_packets",
                                        "out_bytes",
                                        "out_packets",
                                        "remote_session_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tpv2.Counters.Forwarding.Sessions.Session, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tpv2.Counters.Forwarding.Sessions.Session, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.tunnel_id.is_set or
                            self.session_id.is_set or
                            self.in_bytes.is_set or
                            self.in_packets.is_set or
                            self.out_bytes.is_set or
                            self.out_packets.is_set or
                            self.remote_session_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set or
                            self.session_id.yfilter != YFilter.not_set or
                            self.in_bytes.yfilter != YFilter.not_set or
                            self.in_packets.yfilter != YFilter.not_set or
                            self.out_bytes.yfilter != YFilter.not_set or
                            self.out_packets.yfilter != YFilter.not_set or
                            self.remote_session_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session" + "[tunnel-id='" + self.tunnel_id.get() + "']" + "[session-id='" + self.session_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/forwarding/sessions/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())
                        if (self.session_id.is_set or self.session_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_id.get_name_leafdata())
                        if (self.in_bytes.is_set or self.in_bytes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_bytes.get_name_leafdata())
                        if (self.in_packets.is_set or self.in_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_packets.get_name_leafdata())
                        if (self.out_bytes.is_set or self.out_bytes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.out_bytes.get_name_leafdata())
                        if (self.out_packets.is_set or self.out_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.out_packets.get_name_leafdata())
                        if (self.remote_session_id.is_set or self.remote_session_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_session_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "tunnel-id" or name == "session-id" or name == "in-bytes" or name == "in-packets" or name == "out-bytes" or name == "out-packets" or name == "remote-session-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-id"):
                            self.session_id = value
                            self.session_id.value_namespace = name_space
                            self.session_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-bytes"):
                            self.in_bytes = value
                            self.in_bytes.value_namespace = name_space
                            self.in_bytes.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-packets"):
                            self.in_packets = value
                            self.in_packets.value_namespace = name_space
                            self.in_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "out-bytes"):
                            self.out_bytes = value
                            self.out_bytes.value_namespace = name_space
                            self.out_bytes.value_namespace_prefix = name_space_prefix
                        if(value_path == "out-packets"):
                            self.out_packets = value
                            self.out_packets.value_namespace = name_space
                            self.out_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-session-id"):
                            self.remote_session_id = value
                            self.remote_session_id.value_namespace = name_space
                            self.remote_session_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.session:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.session:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "sessions" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/forwarding/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "session"):
                        for c in self.session:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = L2Tpv2.Counters.Forwarding.Sessions.Session()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.session.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "session"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (self.sessions is not None and self.sessions.has_data())

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.sessions is not None and self.sessions.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "forwarding" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "sessions"):
                    if (self.sessions is None):
                        self.sessions = L2Tpv2.Counters.Forwarding.Sessions()
                        self.sessions.parent = self
                        self._children_name_map["sessions"] = "sessions"
                    return self.sessions

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "sessions"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Control(Entity):
            """
            L2TP control messages counters
            
            .. attribute:: tunnel_xr
            
            	L2TP control tunnel messages counters
            	**type**\:   :py:class:`TunnelXr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr>`
            
            .. attribute:: tunnels
            
            	Table of tunnel IDs of control message counters
            	**type**\:   :py:class:`Tunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels>`
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.Counters.Control, self).__init__()

                self.yang_name = "control"
                self.yang_parent_name = "counters"

                self.tunnel_xr = L2Tpv2.Counters.Control.TunnelXr()
                self.tunnel_xr.parent = self
                self._children_name_map["tunnel_xr"] = "tunnel-xr"
                self._children_yang_names.add("tunnel-xr")

                self.tunnels = L2Tpv2.Counters.Control.Tunnels()
                self.tunnels.parent = self
                self._children_name_map["tunnels"] = "tunnels"
                self._children_yang_names.add("tunnels")


            class TunnelXr(Entity):
                """
                L2TP control tunnel messages counters
                
                .. attribute:: authentication
                
                	Tunnel authentication counters
                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication>`
                
                .. attribute:: global_
                
                	Tunnel counters
                	**type**\:   :py:class:`Global_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Global_>`
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tpv2.Counters.Control.TunnelXr, self).__init__()

                    self.yang_name = "tunnel-xr"
                    self.yang_parent_name = "control"

                    self.authentication = L2Tpv2.Counters.Control.TunnelXr.Authentication()
                    self.authentication.parent = self
                    self._children_name_map["authentication"] = "authentication"
                    self._children_yang_names.add("authentication")

                    self.global_ = L2Tpv2.Counters.Control.TunnelXr.Global_()
                    self.global_.parent = self
                    self._children_name_map["global_"] = "global"
                    self._children_yang_names.add("global")


                class Authentication(Entity):
                    """
                    Tunnel authentication counters
                    
                    .. attribute:: challenge_avp
                    
                    	Challenge AVP statistics
                    	**type**\:   :py:class:`ChallengeAvp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeAvp>`
                    
                    .. attribute:: challenge_reponse
                    
                    	Challenge response statistics
                    	**type**\:   :py:class:`ChallengeReponse <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeReponse>`
                    
                    .. attribute:: common_digest
                    
                    	Common digest statistics
                    	**type**\:   :py:class:`CommonDigest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.CommonDigest>`
                    
                    .. attribute:: integrity_check
                    
                    	Integrity check statistics
                    	**type**\:   :py:class:`IntegrityCheck <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.IntegrityCheck>`
                    
                    .. attribute:: local_secret
                    
                    	Local secret statistics
                    	**type**\:   :py:class:`LocalSecret <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.LocalSecret>`
                    
                    .. attribute:: nonce_avp
                    
                    	Nonce AVP statistics
                    	**type**\:   :py:class:`NonceAvp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.NonceAvp>`
                    
                    .. attribute:: overall_statistics
                    
                    	Overall statistics
                    	**type**\:   :py:class:`OverallStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.OverallStatistics>`
                    
                    .. attribute:: primary_digest
                    
                    	Primary digest statistics
                    	**type**\:   :py:class:`PrimaryDigest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.PrimaryDigest>`
                    
                    .. attribute:: secondary_digest
                    
                    	Secondary digest statistics
                    	**type**\:   :py:class:`SecondaryDigest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Authentication.SecondaryDigest>`
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication, self).__init__()

                        self.yang_name = "authentication"
                        self.yang_parent_name = "tunnel-xr"

                        self.challenge_avp = L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeAvp()
                        self.challenge_avp.parent = self
                        self._children_name_map["challenge_avp"] = "challenge-avp"
                        self._children_yang_names.add("challenge-avp")

                        self.challenge_reponse = L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeReponse()
                        self.challenge_reponse.parent = self
                        self._children_name_map["challenge_reponse"] = "challenge-reponse"
                        self._children_yang_names.add("challenge-reponse")

                        self.common_digest = L2Tpv2.Counters.Control.TunnelXr.Authentication.CommonDigest()
                        self.common_digest.parent = self
                        self._children_name_map["common_digest"] = "common-digest"
                        self._children_yang_names.add("common-digest")

                        self.integrity_check = L2Tpv2.Counters.Control.TunnelXr.Authentication.IntegrityCheck()
                        self.integrity_check.parent = self
                        self._children_name_map["integrity_check"] = "integrity-check"
                        self._children_yang_names.add("integrity-check")

                        self.local_secret = L2Tpv2.Counters.Control.TunnelXr.Authentication.LocalSecret()
                        self.local_secret.parent = self
                        self._children_name_map["local_secret"] = "local-secret"
                        self._children_yang_names.add("local-secret")

                        self.nonce_avp = L2Tpv2.Counters.Control.TunnelXr.Authentication.NonceAvp()
                        self.nonce_avp.parent = self
                        self._children_name_map["nonce_avp"] = "nonce-avp"
                        self._children_yang_names.add("nonce-avp")

                        self.overall_statistics = L2Tpv2.Counters.Control.TunnelXr.Authentication.OverallStatistics()
                        self.overall_statistics.parent = self
                        self._children_name_map["overall_statistics"] = "overall-statistics"
                        self._children_yang_names.add("overall-statistics")

                        self.primary_digest = L2Tpv2.Counters.Control.TunnelXr.Authentication.PrimaryDigest()
                        self.primary_digest.parent = self
                        self._children_name_map["primary_digest"] = "primary-digest"
                        self._children_yang_names.add("primary-digest")

                        self.secondary_digest = L2Tpv2.Counters.Control.TunnelXr.Authentication.SecondaryDigest()
                        self.secondary_digest.parent = self
                        self._children_name_map["secondary_digest"] = "secondary-digest"
                        self._children_yang_names.add("secondary-digest")


                    class NonceAvp(Entity):
                        """
                        Nonce AVP statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.NonceAvp, self).__init__()

                            self.yang_name = "nonce-avp"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.NonceAvp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.NonceAvp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "nonce-avp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class CommonDigest(Entity):
                        """
                        Common digest statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.CommonDigest, self).__init__()

                            self.yang_name = "common-digest"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.CommonDigest, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.CommonDigest, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "common-digest" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class PrimaryDigest(Entity):
                        """
                        Primary digest statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.PrimaryDigest, self).__init__()

                            self.yang_name = "primary-digest"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.PrimaryDigest, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.PrimaryDigest, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "primary-digest" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class SecondaryDigest(Entity):
                        """
                        Secondary digest statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.SecondaryDigest, self).__init__()

                            self.yang_name = "secondary-digest"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.SecondaryDigest, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.SecondaryDigest, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "secondary-digest" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class IntegrityCheck(Entity):
                        """
                        Integrity check statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.IntegrityCheck, self).__init__()

                            self.yang_name = "integrity-check"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.IntegrityCheck, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.IntegrityCheck, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "integrity-check" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class LocalSecret(Entity):
                        """
                        Local secret statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.LocalSecret, self).__init__()

                            self.yang_name = "local-secret"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.LocalSecret, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.LocalSecret, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "local-secret" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class ChallengeAvp(Entity):
                        """
                        Challenge AVP statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeAvp, self).__init__()

                            self.yang_name = "challenge-avp"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeAvp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeAvp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "challenge-avp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class ChallengeReponse(Entity):
                        """
                        Challenge response statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeReponse, self).__init__()

                            self.yang_name = "challenge-reponse"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeReponse, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeReponse, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "challenge-reponse" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix


                    class OverallStatistics(Entity):
                        """
                        Overall statistics
                        
                        .. attribute:: bad_hash
                        
                        	Bad hash
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bad_length
                        
                        	Bad length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: failed
                        
                        	Failed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: generate_response_failures
                        
                        	Generate response fail
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ignored
                        
                        	Ignored
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: missing
                        
                        	Missing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: passed
                        
                        	Passed
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: skipped
                        
                        	Skipped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected
                        
                        	Unexpected
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unexpected_zlb
                        
                        	Unexpected ZLB
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: validate
                        
                        	Validate
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Authentication.OverallStatistics, self).__init__()

                            self.yang_name = "overall-statistics"
                            self.yang_parent_name = "authentication"

                            self.bad_hash = YLeaf(YType.uint32, "bad-hash")

                            self.bad_length = YLeaf(YType.uint32, "bad-length")

                            self.failed = YLeaf(YType.uint32, "failed")

                            self.generate_response_failures = YLeaf(YType.uint32, "generate-response-failures")

                            self.ignored = YLeaf(YType.uint32, "ignored")

                            self.missing = YLeaf(YType.uint32, "missing")

                            self.passed = YLeaf(YType.uint32, "passed")

                            self.skipped = YLeaf(YType.uint32, "skipped")

                            self.unexpected = YLeaf(YType.uint32, "unexpected")

                            self.unexpected_zlb = YLeaf(YType.uint32, "unexpected-zlb")

                            self.validate = YLeaf(YType.uint32, "validate")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bad_hash",
                                            "bad_length",
                                            "failed",
                                            "generate_response_failures",
                                            "ignored",
                                            "missing",
                                            "passed",
                                            "skipped",
                                            "unexpected",
                                            "unexpected_zlb",
                                            "validate") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Authentication.OverallStatistics, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Authentication.OverallStatistics, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bad_hash.is_set or
                                self.bad_length.is_set or
                                self.failed.is_set or
                                self.generate_response_failures.is_set or
                                self.ignored.is_set or
                                self.missing.is_set or
                                self.passed.is_set or
                                self.skipped.is_set or
                                self.unexpected.is_set or
                                self.unexpected_zlb.is_set or
                                self.validate.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bad_hash.yfilter != YFilter.not_set or
                                self.bad_length.yfilter != YFilter.not_set or
                                self.failed.yfilter != YFilter.not_set or
                                self.generate_response_failures.yfilter != YFilter.not_set or
                                self.ignored.yfilter != YFilter.not_set or
                                self.missing.yfilter != YFilter.not_set or
                                self.passed.yfilter != YFilter.not_set or
                                self.skipped.yfilter != YFilter.not_set or
                                self.unexpected.yfilter != YFilter.not_set or
                                self.unexpected_zlb.yfilter != YFilter.not_set or
                                self.validate.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "overall-statistics" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/authentication/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bad_hash.is_set or self.bad_hash.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_hash.get_name_leafdata())
                            if (self.bad_length.is_set or self.bad_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bad_length.get_name_leafdata())
                            if (self.failed.is_set or self.failed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.failed.get_name_leafdata())
                            if (self.generate_response_failures.is_set or self.generate_response_failures.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.generate_response_failures.get_name_leafdata())
                            if (self.ignored.is_set or self.ignored.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignored.get_name_leafdata())
                            if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.missing.get_name_leafdata())
                            if (self.passed.is_set or self.passed.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passed.get_name_leafdata())
                            if (self.skipped.is_set or self.skipped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.skipped.get_name_leafdata())
                            if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected.get_name_leafdata())
                            if (self.unexpected_zlb.is_set or self.unexpected_zlb.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unexpected_zlb.get_name_leafdata())
                            if (self.validate.is_set or self.validate.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.validate.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bad-hash" or name == "bad-length" or name == "failed" or name == "generate-response-failures" or name == "ignored" or name == "missing" or name == "passed" or name == "skipped" or name == "unexpected" or name == "unexpected-zlb" or name == "validate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bad-hash"):
                                self.bad_hash = value
                                self.bad_hash.value_namespace = name_space
                                self.bad_hash.value_namespace_prefix = name_space_prefix
                            if(value_path == "bad-length"):
                                self.bad_length = value
                                self.bad_length.value_namespace = name_space
                                self.bad_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "failed"):
                                self.failed = value
                                self.failed.value_namespace = name_space
                                self.failed.value_namespace_prefix = name_space_prefix
                            if(value_path == "generate-response-failures"):
                                self.generate_response_failures = value
                                self.generate_response_failures.value_namespace = name_space
                                self.generate_response_failures.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignored"):
                                self.ignored = value
                                self.ignored.value_namespace = name_space
                                self.ignored.value_namespace_prefix = name_space_prefix
                            if(value_path == "missing"):
                                self.missing = value
                                self.missing.value_namespace = name_space
                                self.missing.value_namespace_prefix = name_space_prefix
                            if(value_path == "passed"):
                                self.passed = value
                                self.passed.value_namespace = name_space
                                self.passed.value_namespace_prefix = name_space_prefix
                            if(value_path == "skipped"):
                                self.skipped = value
                                self.skipped.value_namespace = name_space
                                self.skipped.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected"):
                                self.unexpected = value
                                self.unexpected.value_namespace = name_space
                                self.unexpected.value_namespace_prefix = name_space_prefix
                            if(value_path == "unexpected-zlb"):
                                self.unexpected_zlb = value
                                self.unexpected_zlb.value_namespace = name_space
                                self.unexpected_zlb.value_namespace_prefix = name_space_prefix
                            if(value_path == "validate"):
                                self.validate = value
                                self.validate.value_namespace = name_space
                                self.validate.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.challenge_avp is not None and self.challenge_avp.has_data()) or
                            (self.challenge_reponse is not None and self.challenge_reponse.has_data()) or
                            (self.common_digest is not None and self.common_digest.has_data()) or
                            (self.integrity_check is not None and self.integrity_check.has_data()) or
                            (self.local_secret is not None and self.local_secret.has_data()) or
                            (self.nonce_avp is not None and self.nonce_avp.has_data()) or
                            (self.overall_statistics is not None and self.overall_statistics.has_data()) or
                            (self.primary_digest is not None and self.primary_digest.has_data()) or
                            (self.secondary_digest is not None and self.secondary_digest.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.challenge_avp is not None and self.challenge_avp.has_operation()) or
                            (self.challenge_reponse is not None and self.challenge_reponse.has_operation()) or
                            (self.common_digest is not None and self.common_digest.has_operation()) or
                            (self.integrity_check is not None and self.integrity_check.has_operation()) or
                            (self.local_secret is not None and self.local_secret.has_operation()) or
                            (self.nonce_avp is not None and self.nonce_avp.has_operation()) or
                            (self.overall_statistics is not None and self.overall_statistics.has_operation()) or
                            (self.primary_digest is not None and self.primary_digest.has_operation()) or
                            (self.secondary_digest is not None and self.secondary_digest.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "authentication" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "challenge-avp"):
                            if (self.challenge_avp is None):
                                self.challenge_avp = L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeAvp()
                                self.challenge_avp.parent = self
                                self._children_name_map["challenge_avp"] = "challenge-avp"
                            return self.challenge_avp

                        if (child_yang_name == "challenge-reponse"):
                            if (self.challenge_reponse is None):
                                self.challenge_reponse = L2Tpv2.Counters.Control.TunnelXr.Authentication.ChallengeReponse()
                                self.challenge_reponse.parent = self
                                self._children_name_map["challenge_reponse"] = "challenge-reponse"
                            return self.challenge_reponse

                        if (child_yang_name == "common-digest"):
                            if (self.common_digest is None):
                                self.common_digest = L2Tpv2.Counters.Control.TunnelXr.Authentication.CommonDigest()
                                self.common_digest.parent = self
                                self._children_name_map["common_digest"] = "common-digest"
                            return self.common_digest

                        if (child_yang_name == "integrity-check"):
                            if (self.integrity_check is None):
                                self.integrity_check = L2Tpv2.Counters.Control.TunnelXr.Authentication.IntegrityCheck()
                                self.integrity_check.parent = self
                                self._children_name_map["integrity_check"] = "integrity-check"
                            return self.integrity_check

                        if (child_yang_name == "local-secret"):
                            if (self.local_secret is None):
                                self.local_secret = L2Tpv2.Counters.Control.TunnelXr.Authentication.LocalSecret()
                                self.local_secret.parent = self
                                self._children_name_map["local_secret"] = "local-secret"
                            return self.local_secret

                        if (child_yang_name == "nonce-avp"):
                            if (self.nonce_avp is None):
                                self.nonce_avp = L2Tpv2.Counters.Control.TunnelXr.Authentication.NonceAvp()
                                self.nonce_avp.parent = self
                                self._children_name_map["nonce_avp"] = "nonce-avp"
                            return self.nonce_avp

                        if (child_yang_name == "overall-statistics"):
                            if (self.overall_statistics is None):
                                self.overall_statistics = L2Tpv2.Counters.Control.TunnelXr.Authentication.OverallStatistics()
                                self.overall_statistics.parent = self
                                self._children_name_map["overall_statistics"] = "overall-statistics"
                            return self.overall_statistics

                        if (child_yang_name == "primary-digest"):
                            if (self.primary_digest is None):
                                self.primary_digest = L2Tpv2.Counters.Control.TunnelXr.Authentication.PrimaryDigest()
                                self.primary_digest.parent = self
                                self._children_name_map["primary_digest"] = "primary-digest"
                            return self.primary_digest

                        if (child_yang_name == "secondary-digest"):
                            if (self.secondary_digest is None):
                                self.secondary_digest = L2Tpv2.Counters.Control.TunnelXr.Authentication.SecondaryDigest()
                                self.secondary_digest.parent = self
                                self._children_name_map["secondary_digest"] = "secondary-digest"
                            return self.secondary_digest

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "challenge-avp" or name == "challenge-reponse" or name == "common-digest" or name == "integrity-check" or name == "local-secret" or name == "nonce-avp" or name == "overall-statistics" or name == "primary-digest" or name == "secondary-digest"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Global_(Entity):
                    """
                    Tunnel counters
                    
                    .. attribute:: drop
                    
                    	Drop data
                    	**type**\:   :py:class:`Drop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Global_.Drop>`
                    
                    .. attribute:: received
                    
                    	Received data
                    	**type**\:   :py:class:`Received <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Global_.Received>`
                    
                    .. attribute:: retransmit
                    
                    	Re transmit data
                    	**type**\:   :py:class:`Retransmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Global_.Retransmit>`
                    
                    .. attribute:: total_drop
                    
                    	Total drop
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_received
                    
                    	Total received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_retransmit
                    
                    	Total retransmit
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_transmit
                    
                    	Total transmit
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: transmit
                    
                    	Transmit data
                    	**type**\:   :py:class:`Transmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.TunnelXr.Global_.Transmit>`
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tpv2.Counters.Control.TunnelXr.Global_, self).__init__()

                        self.yang_name = "global"
                        self.yang_parent_name = "tunnel-xr"

                        self.total_drop = YLeaf(YType.uint32, "total-drop")

                        self.total_received = YLeaf(YType.uint32, "total-received")

                        self.total_retransmit = YLeaf(YType.uint32, "total-retransmit")

                        self.total_transmit = YLeaf(YType.uint32, "total-transmit")

                        self.drop = L2Tpv2.Counters.Control.TunnelXr.Global_.Drop()
                        self.drop.parent = self
                        self._children_name_map["drop"] = "drop"
                        self._children_yang_names.add("drop")

                        self.received = L2Tpv2.Counters.Control.TunnelXr.Global_.Received()
                        self.received.parent = self
                        self._children_name_map["received"] = "received"
                        self._children_yang_names.add("received")

                        self.retransmit = L2Tpv2.Counters.Control.TunnelXr.Global_.Retransmit()
                        self.retransmit.parent = self
                        self._children_name_map["retransmit"] = "retransmit"
                        self._children_yang_names.add("retransmit")

                        self.transmit = L2Tpv2.Counters.Control.TunnelXr.Global_.Transmit()
                        self.transmit.parent = self
                        self._children_name_map["transmit"] = "transmit"
                        self._children_yang_names.add("transmit")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("total_drop",
                                        "total_received",
                                        "total_retransmit",
                                        "total_transmit") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tpv2.Counters.Control.TunnelXr.Global_, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tpv2.Counters.Control.TunnelXr.Global_, self).__setattr__(name, value)


                    class Transmit(Entity):
                        """
                        Transmit data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Global_.Transmit, self).__init__()

                            self.yang_name = "transmit"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Global_.Transmit, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Global_.Transmit, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "transmit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                    class Retransmit(Entity):
                        """
                        Re transmit data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Global_.Retransmit, self).__init__()

                            self.yang_name = "retransmit"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Global_.Retransmit, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Global_.Retransmit, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "retransmit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                    class Received(Entity):
                        """
                        Received data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Global_.Received, self).__init__()

                            self.yang_name = "received"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Global_.Received, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Global_.Received, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "received" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                    class Drop(Entity):
                        """
                        Drop data
                        
                        .. attribute:: acknowledgement_packets
                        
                        	Packets acknowledgement
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: call_disconnect_notify_packets
                        
                        	Call disconnect notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hello_packets
                        
                        	Keep alive messages
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_connected_packets
                        
                        	Incoming call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_replies
                        
                        	Incoming call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: incoming_call_requests
                        
                        	Incoming call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_connected_packets
                        
                        	Outgoing call connected packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_replies
                        
                        	Outgoing call replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: outgoing_call_requests
                        
                        	Outgoing call requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_replies
                        
                        	Service relay reply counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: service_relay_requests
                        
                        	Service relay request counts
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: set_link_info_packets
                        
                        	Set link info packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_notifications
                        
                        	Start control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_replies
                        
                        	Start control connection replies
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: start_control_connection_requests
                        
                        	Start control connection requests
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: stop_control_connection_notifications
                        
                        	Stop control connection notifications
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_packets
                        
                        	Unknown packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: wan_error_notify_packets
                        
                        	WAN error notify packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: zero_length_body_packets
                        
                        	Zero length body packets
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.TunnelXr.Global_.Drop, self).__init__()

                            self.yang_name = "drop"
                            self.yang_parent_name = "global"

                            self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                            self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                            self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                            self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                            self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                            self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                            self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                            self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                            self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                            self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                            self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                            self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                            self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                            self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                            self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                            self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                            self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                            self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                            self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("acknowledgement_packets",
                                            "call_disconnect_notify_packets",
                                            "hello_packets",
                                            "incoming_call_connected_packets",
                                            "incoming_call_replies",
                                            "incoming_call_requests",
                                            "outgoing_call_connected_packets",
                                            "outgoing_call_replies",
                                            "outgoing_call_requests",
                                            "service_relay_replies",
                                            "service_relay_requests",
                                            "set_link_info_packets",
                                            "start_control_connection_notifications",
                                            "start_control_connection_replies",
                                            "start_control_connection_requests",
                                            "stop_control_connection_notifications",
                                            "unknown_packets",
                                            "wan_error_notify_packets",
                                            "zero_length_body_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.TunnelXr.Global_.Drop, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.TunnelXr.Global_.Drop, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.acknowledgement_packets.is_set or
                                self.call_disconnect_notify_packets.is_set or
                                self.hello_packets.is_set or
                                self.incoming_call_connected_packets.is_set or
                                self.incoming_call_replies.is_set or
                                self.incoming_call_requests.is_set or
                                self.outgoing_call_connected_packets.is_set or
                                self.outgoing_call_replies.is_set or
                                self.outgoing_call_requests.is_set or
                                self.service_relay_replies.is_set or
                                self.service_relay_requests.is_set or
                                self.set_link_info_packets.is_set or
                                self.start_control_connection_notifications.is_set or
                                self.start_control_connection_replies.is_set or
                                self.start_control_connection_requests.is_set or
                                self.stop_control_connection_notifications.is_set or
                                self.unknown_packets.is_set or
                                self.wan_error_notify_packets.is_set or
                                self.zero_length_body_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.acknowledgement_packets.yfilter != YFilter.not_set or
                                self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                self.hello_packets.yfilter != YFilter.not_set or
                                self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                self.incoming_call_replies.yfilter != YFilter.not_set or
                                self.incoming_call_requests.yfilter != YFilter.not_set or
                                self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                self.outgoing_call_replies.yfilter != YFilter.not_set or
                                self.outgoing_call_requests.yfilter != YFilter.not_set or
                                self.service_relay_replies.yfilter != YFilter.not_set or
                                self.service_relay_requests.yfilter != YFilter.not_set or
                                self.set_link_info_packets.yfilter != YFilter.not_set or
                                self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                self.start_control_connection_replies.yfilter != YFilter.not_set or
                                self.start_control_connection_requests.yfilter != YFilter.not_set or
                                self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                self.unknown_packets.yfilter != YFilter.not_set or
                                self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                self.zero_length_body_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "drop" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/global/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                            if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                            if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_packets.get_name_leafdata())
                            if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                            if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                            if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                            if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                            if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                            if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                            if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                            if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                            if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                            if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                            if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                            if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                            if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                            if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                            if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                            if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "acknowledgement-packets"):
                                self.acknowledgement_packets = value
                                self.acknowledgement_packets.value_namespace = name_space
                                self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "call-disconnect-notify-packets"):
                                self.call_disconnect_notify_packets = value
                                self.call_disconnect_notify_packets.value_namespace = name_space
                                self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-packets"):
                                self.hello_packets = value
                                self.hello_packets.value_namespace = name_space
                                self.hello_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-connected-packets"):
                                self.incoming_call_connected_packets = value
                                self.incoming_call_connected_packets.value_namespace = name_space
                                self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-replies"):
                                self.incoming_call_replies = value
                                self.incoming_call_replies.value_namespace = name_space
                                self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "incoming-call-requests"):
                                self.incoming_call_requests = value
                                self.incoming_call_requests.value_namespace = name_space
                                self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-connected-packets"):
                                self.outgoing_call_connected_packets = value
                                self.outgoing_call_connected_packets.value_namespace = name_space
                                self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-replies"):
                                self.outgoing_call_replies = value
                                self.outgoing_call_replies.value_namespace = name_space
                                self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-call-requests"):
                                self.outgoing_call_requests = value
                                self.outgoing_call_requests.value_namespace = name_space
                                self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-replies"):
                                self.service_relay_replies = value
                                self.service_relay_replies.value_namespace = name_space
                                self.service_relay_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "service-relay-requests"):
                                self.service_relay_requests = value
                                self.service_relay_requests.value_namespace = name_space
                                self.service_relay_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "set-link-info-packets"):
                                self.set_link_info_packets = value
                                self.set_link_info_packets.value_namespace = name_space
                                self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-notifications"):
                                self.start_control_connection_notifications = value
                                self.start_control_connection_notifications.value_namespace = name_space
                                self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-replies"):
                                self.start_control_connection_replies = value
                                self.start_control_connection_replies.value_namespace = name_space
                                self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-control-connection-requests"):
                                self.start_control_connection_requests = value
                                self.start_control_connection_requests.value_namespace = name_space
                                self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                            if(value_path == "stop-control-connection-notifications"):
                                self.stop_control_connection_notifications = value
                                self.stop_control_connection_notifications.value_namespace = name_space
                                self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-packets"):
                                self.unknown_packets = value
                                self.unknown_packets.value_namespace = name_space
                                self.unknown_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "wan-error-notify-packets"):
                                self.wan_error_notify_packets = value
                                self.wan_error_notify_packets.value_namespace = name_space
                                self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "zero-length-body-packets"):
                                self.zero_length_body_packets = value
                                self.zero_length_body_packets.value_namespace = name_space
                                self.zero_length_body_packets.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.total_drop.is_set or
                            self.total_received.is_set or
                            self.total_retransmit.is_set or
                            self.total_transmit.is_set or
                            (self.drop is not None and self.drop.has_data()) or
                            (self.received is not None and self.received.has_data()) or
                            (self.retransmit is not None and self.retransmit.has_data()) or
                            (self.transmit is not None and self.transmit.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.total_drop.yfilter != YFilter.not_set or
                            self.total_received.yfilter != YFilter.not_set or
                            self.total_retransmit.yfilter != YFilter.not_set or
                            self.total_transmit.yfilter != YFilter.not_set or
                            (self.drop is not None and self.drop.has_operation()) or
                            (self.received is not None and self.received.has_operation()) or
                            (self.retransmit is not None and self.retransmit.has_operation()) or
                            (self.transmit is not None and self.transmit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnel-xr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.total_drop.is_set or self.total_drop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_drop.get_name_leafdata())
                        if (self.total_received.is_set or self.total_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_received.get_name_leafdata())
                        if (self.total_retransmit.is_set or self.total_retransmit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_retransmit.get_name_leafdata())
                        if (self.total_transmit.is_set or self.total_transmit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_transmit.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "drop"):
                            if (self.drop is None):
                                self.drop = L2Tpv2.Counters.Control.TunnelXr.Global_.Drop()
                                self.drop.parent = self
                                self._children_name_map["drop"] = "drop"
                            return self.drop

                        if (child_yang_name == "received"):
                            if (self.received is None):
                                self.received = L2Tpv2.Counters.Control.TunnelXr.Global_.Received()
                                self.received.parent = self
                                self._children_name_map["received"] = "received"
                            return self.received

                        if (child_yang_name == "retransmit"):
                            if (self.retransmit is None):
                                self.retransmit = L2Tpv2.Counters.Control.TunnelXr.Global_.Retransmit()
                                self.retransmit.parent = self
                                self._children_name_map["retransmit"] = "retransmit"
                            return self.retransmit

                        if (child_yang_name == "transmit"):
                            if (self.transmit is None):
                                self.transmit = L2Tpv2.Counters.Control.TunnelXr.Global_.Transmit()
                                self.transmit.parent = self
                                self._children_name_map["transmit"] = "transmit"
                            return self.transmit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "drop" or name == "received" or name == "retransmit" or name == "transmit" or name == "total-drop" or name == "total-received" or name == "total-retransmit" or name == "total-transmit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "total-drop"):
                            self.total_drop = value
                            self.total_drop.value_namespace = name_space
                            self.total_drop.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-received"):
                            self.total_received = value
                            self.total_received.value_namespace = name_space
                            self.total_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-retransmit"):
                            self.total_retransmit = value
                            self.total_retransmit.value_namespace = name_space
                            self.total_retransmit.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-transmit"):
                            self.total_transmit = value
                            self.total_transmit.value_namespace = name_space
                            self.total_transmit.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.authentication is not None and self.authentication.has_data()) or
                        (self.global_ is not None and self.global_.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.authentication is not None and self.authentication.has_operation()) or
                        (self.global_ is not None and self.global_.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnel-xr" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "authentication"):
                        if (self.authentication is None):
                            self.authentication = L2Tpv2.Counters.Control.TunnelXr.Authentication()
                            self.authentication.parent = self
                            self._children_name_map["authentication"] = "authentication"
                        return self.authentication

                    if (child_yang_name == "global"):
                        if (self.global_ is None):
                            self.global_ = L2Tpv2.Counters.Control.TunnelXr.Global_()
                            self.global_.parent = self
                            self._children_name_map["global_"] = "global"
                        return self.global_

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "authentication" or name == "global"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Tunnels(Entity):
                """
                Table of tunnel IDs of control message counters
                
                .. attribute:: tunnel
                
                	L2TP tunnel control message counters
                	**type**\: list of    :py:class:`Tunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels.Tunnel>`
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tpv2.Counters.Control.Tunnels, self).__init__()

                    self.yang_name = "tunnels"
                    self.yang_parent_name = "control"

                    self.tunnel = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tpv2.Counters.Control.Tunnels, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tpv2.Counters.Control.Tunnels, self).__setattr__(name, value)


                class Tunnel(Entity):
                    """
                    L2TP tunnel control message counters
                    
                    .. attribute:: tunnel_id  <key>
                    
                    	L2TP tunnel ID
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: brief
                    
                    	L2TP control message local and remote addresses
                    	**type**\:   :py:class:`Brief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels.Tunnel.Brief>`
                    
                    .. attribute:: global_
                    
                    	Global data
                    	**type**\:   :py:class:`Global_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_>`
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tpv2.Counters.Control.Tunnels.Tunnel, self).__init__()

                        self.yang_name = "tunnel"
                        self.yang_parent_name = "tunnels"

                        self.tunnel_id = YLeaf(YType.int32, "tunnel-id")

                        self.brief = L2Tpv2.Counters.Control.Tunnels.Tunnel.Brief()
                        self.brief.parent = self
                        self._children_name_map["brief"] = "brief"
                        self._children_yang_names.add("brief")

                        self.global_ = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_()
                        self.global_.parent = self
                        self._children_name_map["global_"] = "global"
                        self._children_yang_names.add("global")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tpv2.Counters.Control.Tunnels.Tunnel, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tpv2.Counters.Control.Tunnels.Tunnel, self).__setattr__(name, value)


                    class Brief(Entity):
                        """
                        L2TP control message local and remote addresses
                        
                        .. attribute:: local_address
                        
                        	Local IP address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: remote_address
                        
                        	Remote IP address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: remote_tunnel_id
                        
                        	Remote tunnel ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Brief, self).__init__()

                            self.yang_name = "brief"
                            self.yang_parent_name = "tunnel"

                            self.local_address = YLeaf(YType.str, "local-address")

                            self.remote_address = YLeaf(YType.str, "remote-address")

                            self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_address",
                                            "remote_address",
                                            "remote_tunnel_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Brief, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Brief, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.local_address.is_set or
                                self.remote_address.is_set or
                                self.remote_tunnel_id.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_address.yfilter != YFilter.not_set or
                                self.remote_address.yfilter != YFilter.not_set or
                                self.remote_tunnel_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "brief" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_address.get_name_leafdata())
                            if (self.remote_address.is_set or self.remote_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_address.get_name_leafdata())
                            if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "local-address" or name == "remote-address" or name == "remote-tunnel-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-address"):
                                self.local_address = value
                                self.local_address.value_namespace = name_space
                                self.local_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-address"):
                                self.remote_address = value
                                self.remote_address.value_namespace = name_space
                                self.remote_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-tunnel-id"):
                                self.remote_tunnel_id = value
                                self.remote_tunnel_id.value_namespace = name_space
                                self.remote_tunnel_id.value_namespace_prefix = name_space_prefix


                    class Global_(Entity):
                        """
                        Global data
                        
                        .. attribute:: drop
                        
                        	Drop data
                        	**type**\:   :py:class:`Drop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Drop>`
                        
                        .. attribute:: received
                        
                        	Received data
                        	**type**\:   :py:class:`Received <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Received>`
                        
                        .. attribute:: retransmit
                        
                        	Re transmit data
                        	**type**\:   :py:class:`Retransmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Retransmit>`
                        
                        .. attribute:: total_drop
                        
                        	Total drop
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_received
                        
                        	Total received
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_retransmit
                        
                        	Total retransmit
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_transmit
                        
                        	Total transmit
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: transmit
                        
                        	Transmit data
                        	**type**\:   :py:class:`Transmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Transmit>`
                        
                        

                        """

                        _prefix = 'tunnel-l2tun-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_, self).__init__()

                            self.yang_name = "global"
                            self.yang_parent_name = "tunnel"

                            self.total_drop = YLeaf(YType.uint32, "total-drop")

                            self.total_received = YLeaf(YType.uint32, "total-received")

                            self.total_retransmit = YLeaf(YType.uint32, "total-retransmit")

                            self.total_transmit = YLeaf(YType.uint32, "total-transmit")

                            self.drop = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Drop()
                            self.drop.parent = self
                            self._children_name_map["drop"] = "drop"
                            self._children_yang_names.add("drop")

                            self.received = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Received()
                            self.received.parent = self
                            self._children_name_map["received"] = "received"
                            self._children_yang_names.add("received")

                            self.retransmit = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Retransmit()
                            self.retransmit.parent = self
                            self._children_name_map["retransmit"] = "retransmit"
                            self._children_yang_names.add("retransmit")

                            self.transmit = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Transmit()
                            self.transmit.parent = self
                            self._children_name_map["transmit"] = "transmit"
                            self._children_yang_names.add("transmit")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("total_drop",
                                            "total_received",
                                            "total_retransmit",
                                            "total_transmit") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_, self).__setattr__(name, value)


                        class Transmit(Entity):
                            """
                            Transmit data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Transmit, self).__init__()

                                self.yang_name = "transmit"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Transmit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Transmit, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "transmit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                        class Retransmit(Entity):
                            """
                            Re transmit data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Retransmit, self).__init__()

                                self.yang_name = "retransmit"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Retransmit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Retransmit, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "retransmit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                        class Received(Entity):
                            """
                            Received data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Received, self).__init__()

                                self.yang_name = "received"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Received, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Received, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "received" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix


                        class Drop(Entity):
                            """
                            Drop data
                            
                            .. attribute:: acknowledgement_packets
                            
                            	Packets acknowledgement
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: call_disconnect_notify_packets
                            
                            	Call disconnect notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hello_packets
                            
                            	Keep alive messages
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_connected_packets
                            
                            	Incoming call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_replies
                            
                            	Incoming call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incoming_call_requests
                            
                            	Incoming call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_connected_packets
                            
                            	Outgoing call connected packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_replies
                            
                            	Outgoing call replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_call_requests
                            
                            	Outgoing call requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_replies
                            
                            	Service relay reply counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: service_relay_requests
                            
                            	Service relay request counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: set_link_info_packets
                            
                            	Set link info packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_notifications
                            
                            	Start control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_replies
                            
                            	Start control connection replies
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: start_control_connection_requests
                            
                            	Start control connection requests
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stop_control_connection_notifications
                            
                            	Stop control connection notifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unknown_packets
                            
                            	Unknown packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: wan_error_notify_packets
                            
                            	WAN error notify packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: zero_length_body_packets
                            
                            	Zero length body packets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'tunnel-l2tun-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Drop, self).__init__()

                                self.yang_name = "drop"
                                self.yang_parent_name = "global"

                                self.acknowledgement_packets = YLeaf(YType.uint32, "acknowledgement-packets")

                                self.call_disconnect_notify_packets = YLeaf(YType.uint32, "call-disconnect-notify-packets")

                                self.hello_packets = YLeaf(YType.uint32, "hello-packets")

                                self.incoming_call_connected_packets = YLeaf(YType.uint32, "incoming-call-connected-packets")

                                self.incoming_call_replies = YLeaf(YType.uint32, "incoming-call-replies")

                                self.incoming_call_requests = YLeaf(YType.uint32, "incoming-call-requests")

                                self.outgoing_call_connected_packets = YLeaf(YType.uint32, "outgoing-call-connected-packets")

                                self.outgoing_call_replies = YLeaf(YType.uint32, "outgoing-call-replies")

                                self.outgoing_call_requests = YLeaf(YType.uint32, "outgoing-call-requests")

                                self.service_relay_replies = YLeaf(YType.uint32, "service-relay-replies")

                                self.service_relay_requests = YLeaf(YType.uint32, "service-relay-requests")

                                self.set_link_info_packets = YLeaf(YType.uint32, "set-link-info-packets")

                                self.start_control_connection_notifications = YLeaf(YType.uint32, "start-control-connection-notifications")

                                self.start_control_connection_replies = YLeaf(YType.uint32, "start-control-connection-replies")

                                self.start_control_connection_requests = YLeaf(YType.uint32, "start-control-connection-requests")

                                self.stop_control_connection_notifications = YLeaf(YType.uint32, "stop-control-connection-notifications")

                                self.unknown_packets = YLeaf(YType.uint32, "unknown-packets")

                                self.wan_error_notify_packets = YLeaf(YType.uint32, "wan-error-notify-packets")

                                self.zero_length_body_packets = YLeaf(YType.uint32, "zero-length-body-packets")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("acknowledgement_packets",
                                                "call_disconnect_notify_packets",
                                                "hello_packets",
                                                "incoming_call_connected_packets",
                                                "incoming_call_replies",
                                                "incoming_call_requests",
                                                "outgoing_call_connected_packets",
                                                "outgoing_call_replies",
                                                "outgoing_call_requests",
                                                "service_relay_replies",
                                                "service_relay_requests",
                                                "set_link_info_packets",
                                                "start_control_connection_notifications",
                                                "start_control_connection_replies",
                                                "start_control_connection_requests",
                                                "stop_control_connection_notifications",
                                                "unknown_packets",
                                                "wan_error_notify_packets",
                                                "zero_length_body_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Drop, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Drop, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.acknowledgement_packets.is_set or
                                    self.call_disconnect_notify_packets.is_set or
                                    self.hello_packets.is_set or
                                    self.incoming_call_connected_packets.is_set or
                                    self.incoming_call_replies.is_set or
                                    self.incoming_call_requests.is_set or
                                    self.outgoing_call_connected_packets.is_set or
                                    self.outgoing_call_replies.is_set or
                                    self.outgoing_call_requests.is_set or
                                    self.service_relay_replies.is_set or
                                    self.service_relay_requests.is_set or
                                    self.set_link_info_packets.is_set or
                                    self.start_control_connection_notifications.is_set or
                                    self.start_control_connection_replies.is_set or
                                    self.start_control_connection_requests.is_set or
                                    self.stop_control_connection_notifications.is_set or
                                    self.unknown_packets.is_set or
                                    self.wan_error_notify_packets.is_set or
                                    self.zero_length_body_packets.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.acknowledgement_packets.yfilter != YFilter.not_set or
                                    self.call_disconnect_notify_packets.yfilter != YFilter.not_set or
                                    self.hello_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_connected_packets.yfilter != YFilter.not_set or
                                    self.incoming_call_replies.yfilter != YFilter.not_set or
                                    self.incoming_call_requests.yfilter != YFilter.not_set or
                                    self.outgoing_call_connected_packets.yfilter != YFilter.not_set or
                                    self.outgoing_call_replies.yfilter != YFilter.not_set or
                                    self.outgoing_call_requests.yfilter != YFilter.not_set or
                                    self.service_relay_replies.yfilter != YFilter.not_set or
                                    self.service_relay_requests.yfilter != YFilter.not_set or
                                    self.set_link_info_packets.yfilter != YFilter.not_set or
                                    self.start_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.start_control_connection_replies.yfilter != YFilter.not_set or
                                    self.start_control_connection_requests.yfilter != YFilter.not_set or
                                    self.stop_control_connection_notifications.yfilter != YFilter.not_set or
                                    self.unknown_packets.yfilter != YFilter.not_set or
                                    self.wan_error_notify_packets.yfilter != YFilter.not_set or
                                    self.zero_length_body_packets.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "drop" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.acknowledgement_packets.is_set or self.acknowledgement_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acknowledgement_packets.get_name_leafdata())
                                if (self.call_disconnect_notify_packets.is_set or self.call_disconnect_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.call_disconnect_notify_packets.get_name_leafdata())
                                if (self.hello_packets.is_set or self.hello_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_packets.get_name_leafdata())
                                if (self.incoming_call_connected_packets.is_set or self.incoming_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_connected_packets.get_name_leafdata())
                                if (self.incoming_call_replies.is_set or self.incoming_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_replies.get_name_leafdata())
                                if (self.incoming_call_requests.is_set or self.incoming_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incoming_call_requests.get_name_leafdata())
                                if (self.outgoing_call_connected_packets.is_set or self.outgoing_call_connected_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_connected_packets.get_name_leafdata())
                                if (self.outgoing_call_replies.is_set or self.outgoing_call_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_replies.get_name_leafdata())
                                if (self.outgoing_call_requests.is_set or self.outgoing_call_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_call_requests.get_name_leafdata())
                                if (self.service_relay_replies.is_set or self.service_relay_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_replies.get_name_leafdata())
                                if (self.service_relay_requests.is_set or self.service_relay_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.service_relay_requests.get_name_leafdata())
                                if (self.set_link_info_packets.is_set or self.set_link_info_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.set_link_info_packets.get_name_leafdata())
                                if (self.start_control_connection_notifications.is_set or self.start_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_notifications.get_name_leafdata())
                                if (self.start_control_connection_replies.is_set or self.start_control_connection_replies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_replies.get_name_leafdata())
                                if (self.start_control_connection_requests.is_set or self.start_control_connection_requests.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_control_connection_requests.get_name_leafdata())
                                if (self.stop_control_connection_notifications.is_set or self.stop_control_connection_notifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stop_control_connection_notifications.get_name_leafdata())
                                if (self.unknown_packets.is_set or self.unknown_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unknown_packets.get_name_leafdata())
                                if (self.wan_error_notify_packets.is_set or self.wan_error_notify_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wan_error_notify_packets.get_name_leafdata())
                                if (self.zero_length_body_packets.is_set or self.zero_length_body_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.zero_length_body_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "acknowledgement-packets" or name == "call-disconnect-notify-packets" or name == "hello-packets" or name == "incoming-call-connected-packets" or name == "incoming-call-replies" or name == "incoming-call-requests" or name == "outgoing-call-connected-packets" or name == "outgoing-call-replies" or name == "outgoing-call-requests" or name == "service-relay-replies" or name == "service-relay-requests" or name == "set-link-info-packets" or name == "start-control-connection-notifications" or name == "start-control-connection-replies" or name == "start-control-connection-requests" or name == "stop-control-connection-notifications" or name == "unknown-packets" or name == "wan-error-notify-packets" or name == "zero-length-body-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "acknowledgement-packets"):
                                    self.acknowledgement_packets = value
                                    self.acknowledgement_packets.value_namespace = name_space
                                    self.acknowledgement_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "call-disconnect-notify-packets"):
                                    self.call_disconnect_notify_packets = value
                                    self.call_disconnect_notify_packets.value_namespace = name_space
                                    self.call_disconnect_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-packets"):
                                    self.hello_packets = value
                                    self.hello_packets.value_namespace = name_space
                                    self.hello_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-connected-packets"):
                                    self.incoming_call_connected_packets = value
                                    self.incoming_call_connected_packets.value_namespace = name_space
                                    self.incoming_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-replies"):
                                    self.incoming_call_replies = value
                                    self.incoming_call_replies.value_namespace = name_space
                                    self.incoming_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "incoming-call-requests"):
                                    self.incoming_call_requests = value
                                    self.incoming_call_requests.value_namespace = name_space
                                    self.incoming_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-connected-packets"):
                                    self.outgoing_call_connected_packets = value
                                    self.outgoing_call_connected_packets.value_namespace = name_space
                                    self.outgoing_call_connected_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-replies"):
                                    self.outgoing_call_replies = value
                                    self.outgoing_call_replies.value_namespace = name_space
                                    self.outgoing_call_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-call-requests"):
                                    self.outgoing_call_requests = value
                                    self.outgoing_call_requests.value_namespace = name_space
                                    self.outgoing_call_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-replies"):
                                    self.service_relay_replies = value
                                    self.service_relay_replies.value_namespace = name_space
                                    self.service_relay_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "service-relay-requests"):
                                    self.service_relay_requests = value
                                    self.service_relay_requests.value_namespace = name_space
                                    self.service_relay_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "set-link-info-packets"):
                                    self.set_link_info_packets = value
                                    self.set_link_info_packets.value_namespace = name_space
                                    self.set_link_info_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-notifications"):
                                    self.start_control_connection_notifications = value
                                    self.start_control_connection_notifications.value_namespace = name_space
                                    self.start_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-replies"):
                                    self.start_control_connection_replies = value
                                    self.start_control_connection_replies.value_namespace = name_space
                                    self.start_control_connection_replies.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-control-connection-requests"):
                                    self.start_control_connection_requests = value
                                    self.start_control_connection_requests.value_namespace = name_space
                                    self.start_control_connection_requests.value_namespace_prefix = name_space_prefix
                                if(value_path == "stop-control-connection-notifications"):
                                    self.stop_control_connection_notifications = value
                                    self.stop_control_connection_notifications.value_namespace = name_space
                                    self.stop_control_connection_notifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "unknown-packets"):
                                    self.unknown_packets = value
                                    self.unknown_packets.value_namespace = name_space
                                    self.unknown_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "wan-error-notify-packets"):
                                    self.wan_error_notify_packets = value
                                    self.wan_error_notify_packets.value_namespace = name_space
                                    self.wan_error_notify_packets.value_namespace_prefix = name_space_prefix
                                if(value_path == "zero-length-body-packets"):
                                    self.zero_length_body_packets = value
                                    self.zero_length_body_packets.value_namespace = name_space
                                    self.zero_length_body_packets.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.total_drop.is_set or
                                self.total_received.is_set or
                                self.total_retransmit.is_set or
                                self.total_transmit.is_set or
                                (self.drop is not None and self.drop.has_data()) or
                                (self.received is not None and self.received.has_data()) or
                                (self.retransmit is not None and self.retransmit.has_data()) or
                                (self.transmit is not None and self.transmit.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.total_drop.yfilter != YFilter.not_set or
                                self.total_received.yfilter != YFilter.not_set or
                                self.total_retransmit.yfilter != YFilter.not_set or
                                self.total_transmit.yfilter != YFilter.not_set or
                                (self.drop is not None and self.drop.has_operation()) or
                                (self.received is not None and self.received.has_operation()) or
                                (self.retransmit is not None and self.retransmit.has_operation()) or
                                (self.transmit is not None and self.transmit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "global" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.total_drop.is_set or self.total_drop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_drop.get_name_leafdata())
                            if (self.total_received.is_set or self.total_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_received.get_name_leafdata())
                            if (self.total_retransmit.is_set or self.total_retransmit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_retransmit.get_name_leafdata())
                            if (self.total_transmit.is_set or self.total_transmit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_transmit.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "drop"):
                                if (self.drop is None):
                                    self.drop = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Drop()
                                    self.drop.parent = self
                                    self._children_name_map["drop"] = "drop"
                                return self.drop

                            if (child_yang_name == "received"):
                                if (self.received is None):
                                    self.received = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Received()
                                    self.received.parent = self
                                    self._children_name_map["received"] = "received"
                                return self.received

                            if (child_yang_name == "retransmit"):
                                if (self.retransmit is None):
                                    self.retransmit = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Retransmit()
                                    self.retransmit.parent = self
                                    self._children_name_map["retransmit"] = "retransmit"
                                return self.retransmit

                            if (child_yang_name == "transmit"):
                                if (self.transmit is None):
                                    self.transmit = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_.Transmit()
                                    self.transmit.parent = self
                                    self._children_name_map["transmit"] = "transmit"
                                return self.transmit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "drop" or name == "received" or name == "retransmit" or name == "transmit" or name == "total-drop" or name == "total-received" or name == "total-retransmit" or name == "total-transmit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "total-drop"):
                                self.total_drop = value
                                self.total_drop.value_namespace = name_space
                                self.total_drop.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-received"):
                                self.total_received = value
                                self.total_received.value_namespace = name_space
                                self.total_received.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-retransmit"):
                                self.total_retransmit = value
                                self.total_retransmit.value_namespace = name_space
                                self.total_retransmit.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-transmit"):
                                self.total_transmit = value
                                self.total_transmit.value_namespace = name_space
                                self.total_transmit.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.tunnel_id.is_set or
                            (self.brief is not None and self.brief.has_data()) or
                            (self.global_ is not None and self.global_.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set or
                            (self.brief is not None and self.brief.has_operation()) or
                            (self.global_ is not None and self.global_.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel" + "[tunnel-id='" + self.tunnel_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/tunnels/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "brief"):
                            if (self.brief is None):
                                self.brief = L2Tpv2.Counters.Control.Tunnels.Tunnel.Brief()
                                self.brief.parent = self
                                self._children_name_map["brief"] = "brief"
                            return self.brief

                        if (child_yang_name == "global"):
                            if (self.global_ is None):
                                self.global_ = L2Tpv2.Counters.Control.Tunnels.Tunnel.Global_()
                                self.global_.parent = self
                                self._children_name_map["global_"] = "global"
                            return self.global_

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "brief" or name == "global" or name == "tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.tunnel:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.tunnel:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnels" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/control/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "tunnel"):
                        for c in self.tunnel:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = L2Tpv2.Counters.Control.Tunnels.Tunnel()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.tunnel.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "tunnel"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.tunnel_xr is not None and self.tunnel_xr.has_data()) or
                    (self.tunnels is not None and self.tunnels.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.tunnel_xr is not None and self.tunnel_xr.has_operation()) or
                    (self.tunnels is not None and self.tunnels.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "control" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "tunnel-xr"):
                    if (self.tunnel_xr is None):
                        self.tunnel_xr = L2Tpv2.Counters.Control.TunnelXr()
                        self.tunnel_xr.parent = self
                        self._children_name_map["tunnel_xr"] = "tunnel-xr"
                    return self.tunnel_xr

                if (child_yang_name == "tunnels"):
                    if (self.tunnels is None):
                        self.tunnels = L2Tpv2.Counters.Control.Tunnels()
                        self.tunnels.parent = self
                        self._children_name_map["tunnels"] = "tunnels"
                    return self.tunnels

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "tunnel-xr" or name == "tunnels"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.control is not None and self.control.has_data()) or
                (self.forwarding is not None and self.forwarding.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.control is not None and self.control.has_operation()) or
                (self.forwarding is not None and self.forwarding.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "control"):
                if (self.control is None):
                    self.control = L2Tpv2.Counters.Control()
                    self.control.parent = self
                    self._children_name_map["control"] = "control"
                return self.control

            if (child_yang_name == "forwarding"):
                if (self.forwarding is None):
                    self.forwarding = L2Tpv2.Counters.Forwarding()
                    self.forwarding.parent = self
                    self._children_name_map["forwarding"] = "forwarding"
                return self.forwarding

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "control" or name == "forwarding"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Statistics(Entity):
        """
        L2TP v2 statistics information
        
        .. attribute:: average_packet_processing_time
        
        	Average processing time for received packets  (in micro seconds)
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        	**units**\: microsecond
        
        .. attribute:: buffered_packets
        
        	Bufferred packets
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: incoming_dropped_packets
        
        	In coming packets dropped
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: netio_packets
        
        	Packets RX in netio
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: received_out_of_order_packets
        
        	Out of order packets received
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: received_packets
        
        	Number of packets received
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: reorder_deviation_packets
        
        	Re order deviation
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: reorder_packets
        
        	Re order packets
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: sent_packets
        
        	Number of packets sent
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: sessions
        
        	Number of sessions
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: tunnels
        
        	Number of tunnels
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.Statistics, self).__init__()

            self.yang_name = "statistics"
            self.yang_parent_name = "l2tpv2"

            self.average_packet_processing_time = YLeaf(YType.uint32, "average-packet-processing-time")

            self.buffered_packets = YLeaf(YType.uint32, "buffered-packets")

            self.incoming_dropped_packets = YLeaf(YType.uint32, "incoming-dropped-packets")

            self.netio_packets = YLeaf(YType.uint32, "netio-packets")

            self.received_out_of_order_packets = YLeaf(YType.uint32, "received-out-of-order-packets")

            self.received_packets = YLeaf(YType.uint32, "received-packets")

            self.reorder_deviation_packets = YLeaf(YType.uint32, "reorder-deviation-packets")

            self.reorder_packets = YLeaf(YType.uint32, "reorder-packets")

            self.sent_packets = YLeaf(YType.uint32, "sent-packets")

            self.sessions = YLeaf(YType.uint32, "sessions")

            self.tunnels = YLeaf(YType.uint32, "tunnels")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("average_packet_processing_time",
                            "buffered_packets",
                            "incoming_dropped_packets",
                            "netio_packets",
                            "received_out_of_order_packets",
                            "received_packets",
                            "reorder_deviation_packets",
                            "reorder_packets",
                            "sent_packets",
                            "sessions",
                            "tunnels") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tpv2.Statistics, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tpv2.Statistics, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.average_packet_processing_time.is_set or
                self.buffered_packets.is_set or
                self.incoming_dropped_packets.is_set or
                self.netio_packets.is_set or
                self.received_out_of_order_packets.is_set or
                self.received_packets.is_set or
                self.reorder_deviation_packets.is_set or
                self.reorder_packets.is_set or
                self.sent_packets.is_set or
                self.sessions.is_set or
                self.tunnels.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.average_packet_processing_time.yfilter != YFilter.not_set or
                self.buffered_packets.yfilter != YFilter.not_set or
                self.incoming_dropped_packets.yfilter != YFilter.not_set or
                self.netio_packets.yfilter != YFilter.not_set or
                self.received_out_of_order_packets.yfilter != YFilter.not_set or
                self.received_packets.yfilter != YFilter.not_set or
                self.reorder_deviation_packets.yfilter != YFilter.not_set or
                self.reorder_packets.yfilter != YFilter.not_set or
                self.sent_packets.yfilter != YFilter.not_set or
                self.sessions.yfilter != YFilter.not_set or
                self.tunnels.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "statistics" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.average_packet_processing_time.is_set or self.average_packet_processing_time.yfilter != YFilter.not_set):
                leaf_name_data.append(self.average_packet_processing_time.get_name_leafdata())
            if (self.buffered_packets.is_set or self.buffered_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.buffered_packets.get_name_leafdata())
            if (self.incoming_dropped_packets.is_set or self.incoming_dropped_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.incoming_dropped_packets.get_name_leafdata())
            if (self.netio_packets.is_set or self.netio_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.netio_packets.get_name_leafdata())
            if (self.received_out_of_order_packets.is_set or self.received_out_of_order_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.received_out_of_order_packets.get_name_leafdata())
            if (self.received_packets.is_set or self.received_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.received_packets.get_name_leafdata())
            if (self.reorder_deviation_packets.is_set or self.reorder_deviation_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reorder_deviation_packets.get_name_leafdata())
            if (self.reorder_packets.is_set or self.reorder_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reorder_packets.get_name_leafdata())
            if (self.sent_packets.is_set or self.sent_packets.yfilter != YFilter.not_set):
                leaf_name_data.append(self.sent_packets.get_name_leafdata())
            if (self.sessions.is_set or self.sessions.yfilter != YFilter.not_set):
                leaf_name_data.append(self.sessions.get_name_leafdata())
            if (self.tunnels.is_set or self.tunnels.yfilter != YFilter.not_set):
                leaf_name_data.append(self.tunnels.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "average-packet-processing-time" or name == "buffered-packets" or name == "incoming-dropped-packets" or name == "netio-packets" or name == "received-out-of-order-packets" or name == "received-packets" or name == "reorder-deviation-packets" or name == "reorder-packets" or name == "sent-packets" or name == "sessions" or name == "tunnels"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "average-packet-processing-time"):
                self.average_packet_processing_time = value
                self.average_packet_processing_time.value_namespace = name_space
                self.average_packet_processing_time.value_namespace_prefix = name_space_prefix
            if(value_path == "buffered-packets"):
                self.buffered_packets = value
                self.buffered_packets.value_namespace = name_space
                self.buffered_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "incoming-dropped-packets"):
                self.incoming_dropped_packets = value
                self.incoming_dropped_packets.value_namespace = name_space
                self.incoming_dropped_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "netio-packets"):
                self.netio_packets = value
                self.netio_packets.value_namespace = name_space
                self.netio_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "received-out-of-order-packets"):
                self.received_out_of_order_packets = value
                self.received_out_of_order_packets.value_namespace = name_space
                self.received_out_of_order_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "received-packets"):
                self.received_packets = value
                self.received_packets.value_namespace = name_space
                self.received_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "reorder-deviation-packets"):
                self.reorder_deviation_packets = value
                self.reorder_deviation_packets.value_namespace = name_space
                self.reorder_deviation_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "reorder-packets"):
                self.reorder_packets = value
                self.reorder_packets.value_namespace = name_space
                self.reorder_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "sent-packets"):
                self.sent_packets = value
                self.sent_packets.value_namespace = name_space
                self.sent_packets.value_namespace_prefix = name_space_prefix
            if(value_path == "sessions"):
                self.sessions = value
                self.sessions.value_namespace = name_space
                self.sessions.value_namespace_prefix = name_space_prefix
            if(value_path == "tunnels"):
                self.tunnels = value
                self.tunnels.value_namespace = name_space
                self.tunnels.value_namespace_prefix = name_space_prefix


    class Tunnel(Entity):
        """
        L2TPv2 tunnel 
        
        .. attribute:: accounting
        
        	Tunnel accounting counters
        	**type**\:   :py:class:`Accounting <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Tunnel.Accounting>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.Tunnel, self).__init__()

            self.yang_name = "tunnel"
            self.yang_parent_name = "l2tpv2"

            self.accounting = L2Tpv2.Tunnel.Accounting()
            self.accounting.parent = self
            self._children_name_map["accounting"] = "accounting"
            self._children_yang_names.add("accounting")


        class Accounting(Entity):
            """
            Tunnel accounting counters
            
            .. attribute:: statistics
            
            	Tunnel accounting statistics
            	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Tunnel.Accounting.Statistics>`
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.Tunnel.Accounting, self).__init__()

                self.yang_name = "accounting"
                self.yang_parent_name = "tunnel"

                self.statistics = L2Tpv2.Tunnel.Accounting.Statistics()
                self.statistics.parent = self
                self._children_name_map["statistics"] = "statistics"
                self._children_yang_names.add("statistics")


            class Statistics(Entity):
                """
                Tunnel accounting statistics
                
                .. attribute:: current_size
                
                	Current checkpoint size
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: memory_failures
                
                	Memory failures
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: negative_acknowledgement
                
                	Negative acknowledgement
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: positive_acknowledgement
                
                	Positive acknowledgement
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: queue_statistics_size
                
                	Queue statistics size
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: records_checkpointed
                
                	Total records checkpointed
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: records_fail_to_recover
                
                	Records fail to recover
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: records_failed_to_checkpoint
                
                	Records fail to checkpoint
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: records_recovered_from_checkpoint
                
                	Records recovered from checkpoint
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: records_sent_from_queue
                
                	Records sent from queue
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: records_sent_successfully
                
                	Accounting records sent successfully
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: reject
                
                	Accounting reject
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: start
                
                	Accounting start
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: stop
                
                	Accounting stop
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: transport_failures
                
                	Transport failures
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tpv2.Tunnel.Accounting.Statistics, self).__init__()

                    self.yang_name = "statistics"
                    self.yang_parent_name = "accounting"

                    self.current_size = YLeaf(YType.uint32, "current-size")

                    self.memory_failures = YLeaf(YType.uint32, "memory-failures")

                    self.negative_acknowledgement = YLeaf(YType.uint64, "negative-acknowledgement")

                    self.positive_acknowledgement = YLeaf(YType.uint64, "positive-acknowledgement")

                    self.queue_statistics_size = YLeaf(YType.int32, "queue-statistics-size")

                    self.records_checkpointed = YLeaf(YType.uint64, "records-checkpointed")

                    self.records_fail_to_recover = YLeaf(YType.uint32, "records-fail-to-recover")

                    self.records_failed_to_checkpoint = YLeaf(YType.uint64, "records-failed-to-checkpoint")

                    self.records_recovered_from_checkpoint = YLeaf(YType.uint32, "records-recovered-from-checkpoint")

                    self.records_sent_from_queue = YLeaf(YType.uint64, "records-sent-from-queue")

                    self.records_sent_successfully = YLeaf(YType.uint64, "records-sent-successfully")

                    self.reject = YLeaf(YType.uint64, "reject")

                    self.start = YLeaf(YType.uint64, "start")

                    self.stop = YLeaf(YType.uint64, "stop")

                    self.transport_failures = YLeaf(YType.uint64, "transport-failures")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("current_size",
                                    "memory_failures",
                                    "negative_acknowledgement",
                                    "positive_acknowledgement",
                                    "queue_statistics_size",
                                    "records_checkpointed",
                                    "records_fail_to_recover",
                                    "records_failed_to_checkpoint",
                                    "records_recovered_from_checkpoint",
                                    "records_sent_from_queue",
                                    "records_sent_successfully",
                                    "reject",
                                    "start",
                                    "stop",
                                    "transport_failures") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tpv2.Tunnel.Accounting.Statistics, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tpv2.Tunnel.Accounting.Statistics, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.current_size.is_set or
                        self.memory_failures.is_set or
                        self.negative_acknowledgement.is_set or
                        self.positive_acknowledgement.is_set or
                        self.queue_statistics_size.is_set or
                        self.records_checkpointed.is_set or
                        self.records_fail_to_recover.is_set or
                        self.records_failed_to_checkpoint.is_set or
                        self.records_recovered_from_checkpoint.is_set or
                        self.records_sent_from_queue.is_set or
                        self.records_sent_successfully.is_set or
                        self.reject.is_set or
                        self.start.is_set or
                        self.stop.is_set or
                        self.transport_failures.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.current_size.yfilter != YFilter.not_set or
                        self.memory_failures.yfilter != YFilter.not_set or
                        self.negative_acknowledgement.yfilter != YFilter.not_set or
                        self.positive_acknowledgement.yfilter != YFilter.not_set or
                        self.queue_statistics_size.yfilter != YFilter.not_set or
                        self.records_checkpointed.yfilter != YFilter.not_set or
                        self.records_fail_to_recover.yfilter != YFilter.not_set or
                        self.records_failed_to_checkpoint.yfilter != YFilter.not_set or
                        self.records_recovered_from_checkpoint.yfilter != YFilter.not_set or
                        self.records_sent_from_queue.yfilter != YFilter.not_set or
                        self.records_sent_successfully.yfilter != YFilter.not_set or
                        self.reject.yfilter != YFilter.not_set or
                        self.start.yfilter != YFilter.not_set or
                        self.stop.yfilter != YFilter.not_set or
                        self.transport_failures.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "statistics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/tunnel/accounting/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.current_size.is_set or self.current_size.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.current_size.get_name_leafdata())
                    if (self.memory_failures.is_set or self.memory_failures.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.memory_failures.get_name_leafdata())
                    if (self.negative_acknowledgement.is_set or self.negative_acknowledgement.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.negative_acknowledgement.get_name_leafdata())
                    if (self.positive_acknowledgement.is_set or self.positive_acknowledgement.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.positive_acknowledgement.get_name_leafdata())
                    if (self.queue_statistics_size.is_set or self.queue_statistics_size.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.queue_statistics_size.get_name_leafdata())
                    if (self.records_checkpointed.is_set or self.records_checkpointed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.records_checkpointed.get_name_leafdata())
                    if (self.records_fail_to_recover.is_set or self.records_fail_to_recover.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.records_fail_to_recover.get_name_leafdata())
                    if (self.records_failed_to_checkpoint.is_set or self.records_failed_to_checkpoint.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.records_failed_to_checkpoint.get_name_leafdata())
                    if (self.records_recovered_from_checkpoint.is_set or self.records_recovered_from_checkpoint.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.records_recovered_from_checkpoint.get_name_leafdata())
                    if (self.records_sent_from_queue.is_set or self.records_sent_from_queue.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.records_sent_from_queue.get_name_leafdata())
                    if (self.records_sent_successfully.is_set or self.records_sent_successfully.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.records_sent_successfully.get_name_leafdata())
                    if (self.reject.is_set or self.reject.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reject.get_name_leafdata())
                    if (self.start.is_set or self.start.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.start.get_name_leafdata())
                    if (self.stop.is_set or self.stop.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stop.get_name_leafdata())
                    if (self.transport_failures.is_set or self.transport_failures.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.transport_failures.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "current-size" or name == "memory-failures" or name == "negative-acknowledgement" or name == "positive-acknowledgement" or name == "queue-statistics-size" or name == "records-checkpointed" or name == "records-fail-to-recover" or name == "records-failed-to-checkpoint" or name == "records-recovered-from-checkpoint" or name == "records-sent-from-queue" or name == "records-sent-successfully" or name == "reject" or name == "start" or name == "stop" or name == "transport-failures"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "current-size"):
                        self.current_size = value
                        self.current_size.value_namespace = name_space
                        self.current_size.value_namespace_prefix = name_space_prefix
                    if(value_path == "memory-failures"):
                        self.memory_failures = value
                        self.memory_failures.value_namespace = name_space
                        self.memory_failures.value_namespace_prefix = name_space_prefix
                    if(value_path == "negative-acknowledgement"):
                        self.negative_acknowledgement = value
                        self.negative_acknowledgement.value_namespace = name_space
                        self.negative_acknowledgement.value_namespace_prefix = name_space_prefix
                    if(value_path == "positive-acknowledgement"):
                        self.positive_acknowledgement = value
                        self.positive_acknowledgement.value_namespace = name_space
                        self.positive_acknowledgement.value_namespace_prefix = name_space_prefix
                    if(value_path == "queue-statistics-size"):
                        self.queue_statistics_size = value
                        self.queue_statistics_size.value_namespace = name_space
                        self.queue_statistics_size.value_namespace_prefix = name_space_prefix
                    if(value_path == "records-checkpointed"):
                        self.records_checkpointed = value
                        self.records_checkpointed.value_namespace = name_space
                        self.records_checkpointed.value_namespace_prefix = name_space_prefix
                    if(value_path == "records-fail-to-recover"):
                        self.records_fail_to_recover = value
                        self.records_fail_to_recover.value_namespace = name_space
                        self.records_fail_to_recover.value_namespace_prefix = name_space_prefix
                    if(value_path == "records-failed-to-checkpoint"):
                        self.records_failed_to_checkpoint = value
                        self.records_failed_to_checkpoint.value_namespace = name_space
                        self.records_failed_to_checkpoint.value_namespace_prefix = name_space_prefix
                    if(value_path == "records-recovered-from-checkpoint"):
                        self.records_recovered_from_checkpoint = value
                        self.records_recovered_from_checkpoint.value_namespace = name_space
                        self.records_recovered_from_checkpoint.value_namespace_prefix = name_space_prefix
                    if(value_path == "records-sent-from-queue"):
                        self.records_sent_from_queue = value
                        self.records_sent_from_queue.value_namespace = name_space
                        self.records_sent_from_queue.value_namespace_prefix = name_space_prefix
                    if(value_path == "records-sent-successfully"):
                        self.records_sent_successfully = value
                        self.records_sent_successfully.value_namespace = name_space
                        self.records_sent_successfully.value_namespace_prefix = name_space_prefix
                    if(value_path == "reject"):
                        self.reject = value
                        self.reject.value_namespace = name_space
                        self.reject.value_namespace_prefix = name_space_prefix
                    if(value_path == "start"):
                        self.start = value
                        self.start.value_namespace = name_space
                        self.start.value_namespace_prefix = name_space_prefix
                    if(value_path == "stop"):
                        self.stop = value
                        self.stop.value_namespace = name_space
                        self.stop.value_namespace_prefix = name_space_prefix
                    if(value_path == "transport-failures"):
                        self.transport_failures = value
                        self.transport_failures.value_namespace = name_space
                        self.transport_failures.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (self.statistics is not None and self.statistics.has_data())

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.statistics is not None and self.statistics.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "accounting" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/tunnel/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "statistics"):
                    if (self.statistics is None):
                        self.statistics = L2Tpv2.Tunnel.Accounting.Statistics()
                        self.statistics.parent = self
                        self._children_name_map["statistics"] = "statistics"
                    return self.statistics

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "statistics"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.accounting is not None and self.accounting.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.accounting is not None and self.accounting.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnel" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "accounting"):
                if (self.accounting is None):
                    self.accounting = L2Tpv2.Tunnel.Accounting()
                    self.accounting.parent = self
                    self._children_name_map["accounting"] = "accounting"
                return self.accounting

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "accounting"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TunnelConfigurations(Entity):
        """
        List of tunnel IDs
        
        .. attribute:: tunnel_configuration
        
        	L2TP tunnel information
        	**type**\: list of    :py:class:`TunnelConfiguration <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.TunnelConfigurations.TunnelConfiguration>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.TunnelConfigurations, self).__init__()

            self.yang_name = "tunnel-configurations"
            self.yang_parent_name = "l2tpv2"

            self.tunnel_configuration = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tpv2.TunnelConfigurations, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tpv2.TunnelConfigurations, self).__setattr__(name, value)


        class TunnelConfiguration(Entity):
            """
            L2TP tunnel information
            
            .. attribute:: local_tunnel_id  <key>
            
            	Local tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: l2tp_class
            
            	L2Tp class data
            	**type**\:   :py:class:`L2TpClass <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.TunnelConfigurations.TunnelConfiguration.L2TpClass>`
            
            .. attribute:: remote_tunnel_id
            
            	Remote tunnel ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.TunnelConfigurations.TunnelConfiguration, self).__init__()

                self.yang_name = "tunnel-configuration"
                self.yang_parent_name = "tunnel-configurations"

                self.local_tunnel_id = YLeaf(YType.int32, "local-tunnel-id")

                self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                self.l2tp_class = L2Tpv2.TunnelConfigurations.TunnelConfiguration.L2TpClass()
                self.l2tp_class.parent = self
                self._children_name_map["l2tp_class"] = "l2tp-class"
                self._children_yang_names.add("l2tp-class")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("local_tunnel_id",
                                "remote_tunnel_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tpv2.TunnelConfigurations.TunnelConfiguration, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tpv2.TunnelConfigurations.TunnelConfiguration, self).__setattr__(name, value)


            class L2TpClass(Entity):
                """
                L2Tp class data
                
                .. attribute:: accounting_method_list
                
                	Accounting List
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: class_name_xr
                
                	Class name
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: digest_hash
                
                	Hash configured as MD5 or SHA1
                	**type**\:   :py:class:`DigestHash <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.DigestHash>`
                
                .. attribute:: encoded_password
                
                	Encoded password
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: hello_timeout
                
                	Hello timeout value in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: host_name
                
                	Host name
                	**type**\:  str
                
                	**length:** 0..256
                
                .. attribute:: initial_retransmit_maximum_timeout
                
                	Initial timeout maximum in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: initial_retransmit_minimum_timeout
                
                	Initial timeout minimum in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: initial_retransmit_retries
                
                	Initial retransmit retries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: ip_tos
                
                	IP TOS
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: is_authentication_enabled
                
                	True if authentication is enabled
                	**type**\:  bool
                
                .. attribute:: is_congestion_control_enabled
                
                	True if congestion control is enabled
                	**type**\:  bool
                
                .. attribute:: is_digest_check_enabled
                
                	True if digest check is enabled
                	**type**\:  bool
                
                .. attribute:: is_digest_enabled
                
                	True if digest authentication is enabled
                	**type**\:  bool
                
                .. attribute:: is_hidden
                
                	True if class is hidden
                	**type**\:  bool
                
                .. attribute:: is_peer_address_checked
                
                	True if peer address is checked
                	**type**\:  bool
                
                .. attribute:: password
                
                	Password
                	**type**\:  str
                
                	**length:** 0..25
                
                .. attribute:: receive_window_size
                
                	Receive window size
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: retransmit_maximum_timeout
                
                	Retransmit maximum timeout in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: retransmit_minimum_timeout
                
                	Retransmit minimum timeout in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: retransmit_retries
                
                	Retransmit retries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: setup_timeout
                
                	Timeout setup value in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: timeout_no_user
                
                	Timeout no user
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: vrf_name
                
                	VRF name
                	**type**\:  str
                
                	**length:** 0..256
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tpv2.TunnelConfigurations.TunnelConfiguration.L2TpClass, self).__init__()

                    self.yang_name = "l2tp-class"
                    self.yang_parent_name = "tunnel-configuration"

                    self.accounting_method_list = YLeaf(YType.str, "accounting-method-list")

                    self.class_name_xr = YLeaf(YType.str, "class-name-xr")

                    self.digest_hash = YLeaf(YType.enumeration, "digest-hash")

                    self.encoded_password = YLeaf(YType.str, "encoded-password")

                    self.hello_timeout = YLeaf(YType.uint32, "hello-timeout")

                    self.host_name = YLeaf(YType.str, "host-name")

                    self.initial_retransmit_maximum_timeout = YLeaf(YType.uint32, "initial-retransmit-maximum-timeout")

                    self.initial_retransmit_minimum_timeout = YLeaf(YType.uint32, "initial-retransmit-minimum-timeout")

                    self.initial_retransmit_retries = YLeaf(YType.uint32, "initial-retransmit-retries")

                    self.ip_tos = YLeaf(YType.uint8, "ip-tos")

                    self.is_authentication_enabled = YLeaf(YType.boolean, "is-authentication-enabled")

                    self.is_congestion_control_enabled = YLeaf(YType.boolean, "is-congestion-control-enabled")

                    self.is_digest_check_enabled = YLeaf(YType.boolean, "is-digest-check-enabled")

                    self.is_digest_enabled = YLeaf(YType.boolean, "is-digest-enabled")

                    self.is_hidden = YLeaf(YType.boolean, "is-hidden")

                    self.is_peer_address_checked = YLeaf(YType.boolean, "is-peer-address-checked")

                    self.password = YLeaf(YType.str, "password")

                    self.receive_window_size = YLeaf(YType.uint16, "receive-window-size")

                    self.retransmit_maximum_timeout = YLeaf(YType.uint32, "retransmit-maximum-timeout")

                    self.retransmit_minimum_timeout = YLeaf(YType.uint32, "retransmit-minimum-timeout")

                    self.retransmit_retries = YLeaf(YType.uint32, "retransmit-retries")

                    self.setup_timeout = YLeaf(YType.uint32, "setup-timeout")

                    self.timeout_no_user = YLeaf(YType.uint32, "timeout-no-user")

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("accounting_method_list",
                                    "class_name_xr",
                                    "digest_hash",
                                    "encoded_password",
                                    "hello_timeout",
                                    "host_name",
                                    "initial_retransmit_maximum_timeout",
                                    "initial_retransmit_minimum_timeout",
                                    "initial_retransmit_retries",
                                    "ip_tos",
                                    "is_authentication_enabled",
                                    "is_congestion_control_enabled",
                                    "is_digest_check_enabled",
                                    "is_digest_enabled",
                                    "is_hidden",
                                    "is_peer_address_checked",
                                    "password",
                                    "receive_window_size",
                                    "retransmit_maximum_timeout",
                                    "retransmit_minimum_timeout",
                                    "retransmit_retries",
                                    "setup_timeout",
                                    "timeout_no_user",
                                    "vrf_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tpv2.TunnelConfigurations.TunnelConfiguration.L2TpClass, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tpv2.TunnelConfigurations.TunnelConfiguration.L2TpClass, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.accounting_method_list.is_set or
                        self.class_name_xr.is_set or
                        self.digest_hash.is_set or
                        self.encoded_password.is_set or
                        self.hello_timeout.is_set or
                        self.host_name.is_set or
                        self.initial_retransmit_maximum_timeout.is_set or
                        self.initial_retransmit_minimum_timeout.is_set or
                        self.initial_retransmit_retries.is_set or
                        self.ip_tos.is_set or
                        self.is_authentication_enabled.is_set or
                        self.is_congestion_control_enabled.is_set or
                        self.is_digest_check_enabled.is_set or
                        self.is_digest_enabled.is_set or
                        self.is_hidden.is_set or
                        self.is_peer_address_checked.is_set or
                        self.password.is_set or
                        self.receive_window_size.is_set or
                        self.retransmit_maximum_timeout.is_set or
                        self.retransmit_minimum_timeout.is_set or
                        self.retransmit_retries.is_set or
                        self.setup_timeout.is_set or
                        self.timeout_no_user.is_set or
                        self.vrf_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.accounting_method_list.yfilter != YFilter.not_set or
                        self.class_name_xr.yfilter != YFilter.not_set or
                        self.digest_hash.yfilter != YFilter.not_set or
                        self.encoded_password.yfilter != YFilter.not_set or
                        self.hello_timeout.yfilter != YFilter.not_set or
                        self.host_name.yfilter != YFilter.not_set or
                        self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set or
                        self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set or
                        self.initial_retransmit_retries.yfilter != YFilter.not_set or
                        self.ip_tos.yfilter != YFilter.not_set or
                        self.is_authentication_enabled.yfilter != YFilter.not_set or
                        self.is_congestion_control_enabled.yfilter != YFilter.not_set or
                        self.is_digest_check_enabled.yfilter != YFilter.not_set or
                        self.is_digest_enabled.yfilter != YFilter.not_set or
                        self.is_hidden.yfilter != YFilter.not_set or
                        self.is_peer_address_checked.yfilter != YFilter.not_set or
                        self.password.yfilter != YFilter.not_set or
                        self.receive_window_size.yfilter != YFilter.not_set or
                        self.retransmit_maximum_timeout.yfilter != YFilter.not_set or
                        self.retransmit_minimum_timeout.yfilter != YFilter.not_set or
                        self.retransmit_retries.yfilter != YFilter.not_set or
                        self.setup_timeout.yfilter != YFilter.not_set or
                        self.timeout_no_user.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "l2tp-class" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.accounting_method_list.is_set or self.accounting_method_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.accounting_method_list.get_name_leafdata())
                    if (self.class_name_xr.is_set or self.class_name_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.class_name_xr.get_name_leafdata())
                    if (self.digest_hash.is_set or self.digest_hash.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.digest_hash.get_name_leafdata())
                    if (self.encoded_password.is_set or self.encoded_password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.encoded_password.get_name_leafdata())
                    if (self.hello_timeout.is_set or self.hello_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_timeout.get_name_leafdata())
                    if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.host_name.get_name_leafdata())
                    if (self.initial_retransmit_maximum_timeout.is_set or self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.initial_retransmit_maximum_timeout.get_name_leafdata())
                    if (self.initial_retransmit_minimum_timeout.is_set or self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.initial_retransmit_minimum_timeout.get_name_leafdata())
                    if (self.initial_retransmit_retries.is_set or self.initial_retransmit_retries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.initial_retransmit_retries.get_name_leafdata())
                    if (self.ip_tos.is_set or self.ip_tos.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ip_tos.get_name_leafdata())
                    if (self.is_authentication_enabled.is_set or self.is_authentication_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_authentication_enabled.get_name_leafdata())
                    if (self.is_congestion_control_enabled.is_set or self.is_congestion_control_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_congestion_control_enabled.get_name_leafdata())
                    if (self.is_digest_check_enabled.is_set or self.is_digest_check_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_digest_check_enabled.get_name_leafdata())
                    if (self.is_digest_enabled.is_set or self.is_digest_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_digest_enabled.get_name_leafdata())
                    if (self.is_hidden.is_set or self.is_hidden.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_hidden.get_name_leafdata())
                    if (self.is_peer_address_checked.is_set or self.is_peer_address_checked.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_peer_address_checked.get_name_leafdata())
                    if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.password.get_name_leafdata())
                    if (self.receive_window_size.is_set or self.receive_window_size.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.receive_window_size.get_name_leafdata())
                    if (self.retransmit_maximum_timeout.is_set or self.retransmit_maximum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retransmit_maximum_timeout.get_name_leafdata())
                    if (self.retransmit_minimum_timeout.is_set or self.retransmit_minimum_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retransmit_minimum_timeout.get_name_leafdata())
                    if (self.retransmit_retries.is_set or self.retransmit_retries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retransmit_retries.get_name_leafdata())
                    if (self.setup_timeout.is_set or self.setup_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.setup_timeout.get_name_leafdata())
                    if (self.timeout_no_user.is_set or self.timeout_no_user.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.timeout_no_user.get_name_leafdata())
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "accounting-method-list" or name == "class-name-xr" or name == "digest-hash" or name == "encoded-password" or name == "hello-timeout" or name == "host-name" or name == "initial-retransmit-maximum-timeout" or name == "initial-retransmit-minimum-timeout" or name == "initial-retransmit-retries" or name == "ip-tos" or name == "is-authentication-enabled" or name == "is-congestion-control-enabled" or name == "is-digest-check-enabled" or name == "is-digest-enabled" or name == "is-hidden" or name == "is-peer-address-checked" or name == "password" or name == "receive-window-size" or name == "retransmit-maximum-timeout" or name == "retransmit-minimum-timeout" or name == "retransmit-retries" or name == "setup-timeout" or name == "timeout-no-user" or name == "vrf-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "accounting-method-list"):
                        self.accounting_method_list = value
                        self.accounting_method_list.value_namespace = name_space
                        self.accounting_method_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "class-name-xr"):
                        self.class_name_xr = value
                        self.class_name_xr.value_namespace = name_space
                        self.class_name_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "digest-hash"):
                        self.digest_hash = value
                        self.digest_hash.value_namespace = name_space
                        self.digest_hash.value_namespace_prefix = name_space_prefix
                    if(value_path == "encoded-password"):
                        self.encoded_password = value
                        self.encoded_password.value_namespace = name_space
                        self.encoded_password.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-timeout"):
                        self.hello_timeout = value
                        self.hello_timeout.value_namespace = name_space
                        self.hello_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "host-name"):
                        self.host_name = value
                        self.host_name.value_namespace = name_space
                        self.host_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "initial-retransmit-maximum-timeout"):
                        self.initial_retransmit_maximum_timeout = value
                        self.initial_retransmit_maximum_timeout.value_namespace = name_space
                        self.initial_retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "initial-retransmit-minimum-timeout"):
                        self.initial_retransmit_minimum_timeout = value
                        self.initial_retransmit_minimum_timeout.value_namespace = name_space
                        self.initial_retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "initial-retransmit-retries"):
                        self.initial_retransmit_retries = value
                        self.initial_retransmit_retries.value_namespace = name_space
                        self.initial_retransmit_retries.value_namespace_prefix = name_space_prefix
                    if(value_path == "ip-tos"):
                        self.ip_tos = value
                        self.ip_tos.value_namespace = name_space
                        self.ip_tos.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-authentication-enabled"):
                        self.is_authentication_enabled = value
                        self.is_authentication_enabled.value_namespace = name_space
                        self.is_authentication_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-congestion-control-enabled"):
                        self.is_congestion_control_enabled = value
                        self.is_congestion_control_enabled.value_namespace = name_space
                        self.is_congestion_control_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-digest-check-enabled"):
                        self.is_digest_check_enabled = value
                        self.is_digest_check_enabled.value_namespace = name_space
                        self.is_digest_check_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-digest-enabled"):
                        self.is_digest_enabled = value
                        self.is_digest_enabled.value_namespace = name_space
                        self.is_digest_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-hidden"):
                        self.is_hidden = value
                        self.is_hidden.value_namespace = name_space
                        self.is_hidden.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-peer-address-checked"):
                        self.is_peer_address_checked = value
                        self.is_peer_address_checked.value_namespace = name_space
                        self.is_peer_address_checked.value_namespace_prefix = name_space_prefix
                    if(value_path == "password"):
                        self.password = value
                        self.password.value_namespace = name_space
                        self.password.value_namespace_prefix = name_space_prefix
                    if(value_path == "receive-window-size"):
                        self.receive_window_size = value
                        self.receive_window_size.value_namespace = name_space
                        self.receive_window_size.value_namespace_prefix = name_space_prefix
                    if(value_path == "retransmit-maximum-timeout"):
                        self.retransmit_maximum_timeout = value
                        self.retransmit_maximum_timeout.value_namespace = name_space
                        self.retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "retransmit-minimum-timeout"):
                        self.retransmit_minimum_timeout = value
                        self.retransmit_minimum_timeout.value_namespace = name_space
                        self.retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "retransmit-retries"):
                        self.retransmit_retries = value
                        self.retransmit_retries.value_namespace = name_space
                        self.retransmit_retries.value_namespace_prefix = name_space_prefix
                    if(value_path == "setup-timeout"):
                        self.setup_timeout = value
                        self.setup_timeout.value_namespace = name_space
                        self.setup_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "timeout-no-user"):
                        self.timeout_no_user = value
                        self.timeout_no_user.value_namespace = name_space
                        self.timeout_no_user.value_namespace_prefix = name_space_prefix
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.local_tunnel_id.is_set or
                    self.remote_tunnel_id.is_set or
                    (self.l2tp_class is not None and self.l2tp_class.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.local_tunnel_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_id.yfilter != YFilter.not_set or
                    (self.l2tp_class is not None and self.l2tp_class.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel-configuration" + "[local-tunnel-id='" + self.local_tunnel_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/tunnel-configurations/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.local_tunnel_id.is_set or self.local_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_id.get_name_leafdata())
                if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "l2tp-class"):
                    if (self.l2tp_class is None):
                        self.l2tp_class = L2Tpv2.TunnelConfigurations.TunnelConfiguration.L2TpClass()
                        self.l2tp_class.parent = self
                        self._children_name_map["l2tp_class"] = "l2tp-class"
                    return self.l2tp_class

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "l2tp-class" or name == "local-tunnel-id" or name == "remote-tunnel-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "local-tunnel-id"):
                    self.local_tunnel_id = value
                    self.local_tunnel_id.value_namespace = name_space
                    self.local_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-id"):
                    self.remote_tunnel_id = value
                    self.remote_tunnel_id.value_namespace = name_space
                    self.remote_tunnel_id.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel_configuration:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel_configuration:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnel-configurations" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel-configuration"):
                for c in self.tunnel_configuration:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tpv2.TunnelConfigurations.TunnelConfiguration()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel_configuration.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel-configuration"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class CounterHistFail(Entity):
        """
        Failure events leading to disconnection
        
        .. attribute:: pkt_timeout
        
        	timeout events by packet
        	**type**\:  list of int
        
        	**range:** 0..4294967295
        
        .. attribute:: rx_counters
        
        	Receive side counters
        	**type**\:  str
        
        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
        
        .. attribute:: sess_down_tmout
        
        	sesions affected due to timeout
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        .. attribute:: tx_counters
        
        	Send side counters
        	**type**\:  str
        
        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.CounterHistFail, self).__init__()

            self.yang_name = "counter-hist-fail"
            self.yang_parent_name = "l2tpv2"

            self.pkt_timeout = YLeafList(YType.uint32, "pkt-timeout")

            self.rx_counters = YLeaf(YType.str, "rx-counters")

            self.sess_down_tmout = YLeaf(YType.uint32, "sess-down-tmout")

            self.tx_counters = YLeaf(YType.str, "tx-counters")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("pkt_timeout",
                            "rx_counters",
                            "sess_down_tmout",
                            "tx_counters") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tpv2.CounterHistFail, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tpv2.CounterHistFail, self).__setattr__(name, value)

        def has_data(self):
            for leaf in self.pkt_timeout.getYLeafs():
                if (leaf.yfilter != YFilter.not_set):
                    return True
            return (
                self.rx_counters.is_set or
                self.sess_down_tmout.is_set or
                self.tx_counters.is_set)

        def has_operation(self):
            for leaf in self.pkt_timeout.getYLeafs():
                if (leaf.is_set):
                    return True
            return (
                self.yfilter != YFilter.not_set or
                self.pkt_timeout.yfilter != YFilter.not_set or
                self.rx_counters.yfilter != YFilter.not_set or
                self.sess_down_tmout.yfilter != YFilter.not_set or
                self.tx_counters.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "counter-hist-fail" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.rx_counters.is_set or self.rx_counters.yfilter != YFilter.not_set):
                leaf_name_data.append(self.rx_counters.get_name_leafdata())
            if (self.sess_down_tmout.is_set or self.sess_down_tmout.yfilter != YFilter.not_set):
                leaf_name_data.append(self.sess_down_tmout.get_name_leafdata())
            if (self.tx_counters.is_set or self.tx_counters.yfilter != YFilter.not_set):
                leaf_name_data.append(self.tx_counters.get_name_leafdata())

            leaf_name_data.extend(self.pkt_timeout.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "pkt-timeout" or name == "rx-counters" or name == "sess-down-tmout" or name == "tx-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "pkt-timeout"):
                self.pkt_timeout.append(value)
            if(value_path == "rx-counters"):
                self.rx_counters = value
                self.rx_counters.value_namespace = name_space
                self.rx_counters.value_namespace_prefix = name_space_prefix
            if(value_path == "sess-down-tmout"):
                self.sess_down_tmout = value
                self.sess_down_tmout.value_namespace = name_space
                self.sess_down_tmout.value_namespace_prefix = name_space_prefix
            if(value_path == "tx-counters"):
                self.tx_counters = value
                self.tx_counters.value_namespace = name_space
                self.tx_counters.value_namespace_prefix = name_space_prefix


    class Classes(Entity):
        """
        List of L2TP class names
        
        .. attribute:: class_
        
        	L2TP class name
        	**type**\: list of    :py:class:`Class_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Classes.Class_>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.Classes, self).__init__()

            self.yang_name = "classes"
            self.yang_parent_name = "l2tpv2"

            self.class_ = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tpv2.Classes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tpv2.Classes, self).__setattr__(name, value)


        class Class_(Entity):
            """
            L2TP class name
            
            .. attribute:: class_name  <key>
            
            	L2TP class name
            	**type**\:  str
            
            	**length:** 1..31
            
            .. attribute:: accounting_method_list
            
            	Accounting List
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: class_name_xr
            
            	Class name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: digest_hash
            
            	Hash configured as MD5 or SHA1
            	**type**\:   :py:class:`DigestHash <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.DigestHash>`
            
            .. attribute:: encoded_password
            
            	Encoded password
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: hello_timeout
            
            	Hello timeout value in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: host_name
            
            	Host name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: initial_retransmit_maximum_timeout
            
            	Initial timeout maximum in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: initial_retransmit_minimum_timeout
            
            	Initial timeout minimum in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: initial_retransmit_retries
            
            	Initial retransmit retries
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ip_tos
            
            	IP TOS
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: is_authentication_enabled
            
            	True if authentication is enabled
            	**type**\:  bool
            
            .. attribute:: is_congestion_control_enabled
            
            	True if congestion control is enabled
            	**type**\:  bool
            
            .. attribute:: is_digest_check_enabled
            
            	True if digest check is enabled
            	**type**\:  bool
            
            .. attribute:: is_digest_enabled
            
            	True if digest authentication is enabled
            	**type**\:  bool
            
            .. attribute:: is_hidden
            
            	True if class is hidden
            	**type**\:  bool
            
            .. attribute:: is_peer_address_checked
            
            	True if peer address is checked
            	**type**\:  bool
            
            .. attribute:: password
            
            	Password
            	**type**\:  str
            
            	**length:** 0..25
            
            .. attribute:: receive_window_size
            
            	Receive window size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: retransmit_maximum_timeout
            
            	Retransmit maximum timeout in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: retransmit_minimum_timeout
            
            	Retransmit minimum timeout in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: retransmit_retries
            
            	Retransmit retries
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: setup_timeout
            
            	Timeout setup value in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: timeout_no_user
            
            	Timeout no user
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**length:** 0..256
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.Classes.Class_, self).__init__()

                self.yang_name = "class"
                self.yang_parent_name = "classes"

                self.class_name = YLeaf(YType.str, "class-name")

                self.accounting_method_list = YLeaf(YType.str, "accounting-method-list")

                self.class_name_xr = YLeaf(YType.str, "class-name-xr")

                self.digest_hash = YLeaf(YType.enumeration, "digest-hash")

                self.encoded_password = YLeaf(YType.str, "encoded-password")

                self.hello_timeout = YLeaf(YType.uint32, "hello-timeout")

                self.host_name = YLeaf(YType.str, "host-name")

                self.initial_retransmit_maximum_timeout = YLeaf(YType.uint32, "initial-retransmit-maximum-timeout")

                self.initial_retransmit_minimum_timeout = YLeaf(YType.uint32, "initial-retransmit-minimum-timeout")

                self.initial_retransmit_retries = YLeaf(YType.uint32, "initial-retransmit-retries")

                self.ip_tos = YLeaf(YType.uint8, "ip-tos")

                self.is_authentication_enabled = YLeaf(YType.boolean, "is-authentication-enabled")

                self.is_congestion_control_enabled = YLeaf(YType.boolean, "is-congestion-control-enabled")

                self.is_digest_check_enabled = YLeaf(YType.boolean, "is-digest-check-enabled")

                self.is_digest_enabled = YLeaf(YType.boolean, "is-digest-enabled")

                self.is_hidden = YLeaf(YType.boolean, "is-hidden")

                self.is_peer_address_checked = YLeaf(YType.boolean, "is-peer-address-checked")

                self.password = YLeaf(YType.str, "password")

                self.receive_window_size = YLeaf(YType.uint16, "receive-window-size")

                self.retransmit_maximum_timeout = YLeaf(YType.uint32, "retransmit-maximum-timeout")

                self.retransmit_minimum_timeout = YLeaf(YType.uint32, "retransmit-minimum-timeout")

                self.retransmit_retries = YLeaf(YType.uint32, "retransmit-retries")

                self.setup_timeout = YLeaf(YType.uint32, "setup-timeout")

                self.timeout_no_user = YLeaf(YType.uint32, "timeout-no-user")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("class_name",
                                "accounting_method_list",
                                "class_name_xr",
                                "digest_hash",
                                "encoded_password",
                                "hello_timeout",
                                "host_name",
                                "initial_retransmit_maximum_timeout",
                                "initial_retransmit_minimum_timeout",
                                "initial_retransmit_retries",
                                "ip_tos",
                                "is_authentication_enabled",
                                "is_congestion_control_enabled",
                                "is_digest_check_enabled",
                                "is_digest_enabled",
                                "is_hidden",
                                "is_peer_address_checked",
                                "password",
                                "receive_window_size",
                                "retransmit_maximum_timeout",
                                "retransmit_minimum_timeout",
                                "retransmit_retries",
                                "setup_timeout",
                                "timeout_no_user",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tpv2.Classes.Class_, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tpv2.Classes.Class_, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.class_name.is_set or
                    self.accounting_method_list.is_set or
                    self.class_name_xr.is_set or
                    self.digest_hash.is_set or
                    self.encoded_password.is_set or
                    self.hello_timeout.is_set or
                    self.host_name.is_set or
                    self.initial_retransmit_maximum_timeout.is_set or
                    self.initial_retransmit_minimum_timeout.is_set or
                    self.initial_retransmit_retries.is_set or
                    self.ip_tos.is_set or
                    self.is_authentication_enabled.is_set or
                    self.is_congestion_control_enabled.is_set or
                    self.is_digest_check_enabled.is_set or
                    self.is_digest_enabled.is_set or
                    self.is_hidden.is_set or
                    self.is_peer_address_checked.is_set or
                    self.password.is_set or
                    self.receive_window_size.is_set or
                    self.retransmit_maximum_timeout.is_set or
                    self.retransmit_minimum_timeout.is_set or
                    self.retransmit_retries.is_set or
                    self.setup_timeout.is_set or
                    self.timeout_no_user.is_set or
                    self.vrf_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.class_name.yfilter != YFilter.not_set or
                    self.accounting_method_list.yfilter != YFilter.not_set or
                    self.class_name_xr.yfilter != YFilter.not_set or
                    self.digest_hash.yfilter != YFilter.not_set or
                    self.encoded_password.yfilter != YFilter.not_set or
                    self.hello_timeout.yfilter != YFilter.not_set or
                    self.host_name.yfilter != YFilter.not_set or
                    self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set or
                    self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set or
                    self.initial_retransmit_retries.yfilter != YFilter.not_set or
                    self.ip_tos.yfilter != YFilter.not_set or
                    self.is_authentication_enabled.yfilter != YFilter.not_set or
                    self.is_congestion_control_enabled.yfilter != YFilter.not_set or
                    self.is_digest_check_enabled.yfilter != YFilter.not_set or
                    self.is_digest_enabled.yfilter != YFilter.not_set or
                    self.is_hidden.yfilter != YFilter.not_set or
                    self.is_peer_address_checked.yfilter != YFilter.not_set or
                    self.password.yfilter != YFilter.not_set or
                    self.receive_window_size.yfilter != YFilter.not_set or
                    self.retransmit_maximum_timeout.yfilter != YFilter.not_set or
                    self.retransmit_minimum_timeout.yfilter != YFilter.not_set or
                    self.retransmit_retries.yfilter != YFilter.not_set or
                    self.setup_timeout.yfilter != YFilter.not_set or
                    self.timeout_no_user.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "class" + "[class-name='" + self.class_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/classes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.class_name.is_set or self.class_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.class_name.get_name_leafdata())
                if (self.accounting_method_list.is_set or self.accounting_method_list.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.accounting_method_list.get_name_leafdata())
                if (self.class_name_xr.is_set or self.class_name_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.class_name_xr.get_name_leafdata())
                if (self.digest_hash.is_set or self.digest_hash.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.digest_hash.get_name_leafdata())
                if (self.encoded_password.is_set or self.encoded_password.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.encoded_password.get_name_leafdata())
                if (self.hello_timeout.is_set or self.hello_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.hello_timeout.get_name_leafdata())
                if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.host_name.get_name_leafdata())
                if (self.initial_retransmit_maximum_timeout.is_set or self.initial_retransmit_maximum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.initial_retransmit_maximum_timeout.get_name_leafdata())
                if (self.initial_retransmit_minimum_timeout.is_set or self.initial_retransmit_minimum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.initial_retransmit_minimum_timeout.get_name_leafdata())
                if (self.initial_retransmit_retries.is_set or self.initial_retransmit_retries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.initial_retransmit_retries.get_name_leafdata())
                if (self.ip_tos.is_set or self.ip_tos.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ip_tos.get_name_leafdata())
                if (self.is_authentication_enabled.is_set or self.is_authentication_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_authentication_enabled.get_name_leafdata())
                if (self.is_congestion_control_enabled.is_set or self.is_congestion_control_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_congestion_control_enabled.get_name_leafdata())
                if (self.is_digest_check_enabled.is_set or self.is_digest_check_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_digest_check_enabled.get_name_leafdata())
                if (self.is_digest_enabled.is_set or self.is_digest_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_digest_enabled.get_name_leafdata())
                if (self.is_hidden.is_set or self.is_hidden.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_hidden.get_name_leafdata())
                if (self.is_peer_address_checked.is_set or self.is_peer_address_checked.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_peer_address_checked.get_name_leafdata())
                if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.password.get_name_leafdata())
                if (self.receive_window_size.is_set or self.receive_window_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.receive_window_size.get_name_leafdata())
                if (self.retransmit_maximum_timeout.is_set or self.retransmit_maximum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmit_maximum_timeout.get_name_leafdata())
                if (self.retransmit_minimum_timeout.is_set or self.retransmit_minimum_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmit_minimum_timeout.get_name_leafdata())
                if (self.retransmit_retries.is_set or self.retransmit_retries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmit_retries.get_name_leafdata())
                if (self.setup_timeout.is_set or self.setup_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.setup_timeout.get_name_leafdata())
                if (self.timeout_no_user.is_set or self.timeout_no_user.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.timeout_no_user.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "class-name" or name == "accounting-method-list" or name == "class-name-xr" or name == "digest-hash" or name == "encoded-password" or name == "hello-timeout" or name == "host-name" or name == "initial-retransmit-maximum-timeout" or name == "initial-retransmit-minimum-timeout" or name == "initial-retransmit-retries" or name == "ip-tos" or name == "is-authentication-enabled" or name == "is-congestion-control-enabled" or name == "is-digest-check-enabled" or name == "is-digest-enabled" or name == "is-hidden" or name == "is-peer-address-checked" or name == "password" or name == "receive-window-size" or name == "retransmit-maximum-timeout" or name == "retransmit-minimum-timeout" or name == "retransmit-retries" or name == "setup-timeout" or name == "timeout-no-user" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "class-name"):
                    self.class_name = value
                    self.class_name.value_namespace = name_space
                    self.class_name.value_namespace_prefix = name_space_prefix
                if(value_path == "accounting-method-list"):
                    self.accounting_method_list = value
                    self.accounting_method_list.value_namespace = name_space
                    self.accounting_method_list.value_namespace_prefix = name_space_prefix
                if(value_path == "class-name-xr"):
                    self.class_name_xr = value
                    self.class_name_xr.value_namespace = name_space
                    self.class_name_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "digest-hash"):
                    self.digest_hash = value
                    self.digest_hash.value_namespace = name_space
                    self.digest_hash.value_namespace_prefix = name_space_prefix
                if(value_path == "encoded-password"):
                    self.encoded_password = value
                    self.encoded_password.value_namespace = name_space
                    self.encoded_password.value_namespace_prefix = name_space_prefix
                if(value_path == "hello-timeout"):
                    self.hello_timeout = value
                    self.hello_timeout.value_namespace = name_space
                    self.hello_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "host-name"):
                    self.host_name = value
                    self.host_name.value_namespace = name_space
                    self.host_name.value_namespace_prefix = name_space_prefix
                if(value_path == "initial-retransmit-maximum-timeout"):
                    self.initial_retransmit_maximum_timeout = value
                    self.initial_retransmit_maximum_timeout.value_namespace = name_space
                    self.initial_retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "initial-retransmit-minimum-timeout"):
                    self.initial_retransmit_minimum_timeout = value
                    self.initial_retransmit_minimum_timeout.value_namespace = name_space
                    self.initial_retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "initial-retransmit-retries"):
                    self.initial_retransmit_retries = value
                    self.initial_retransmit_retries.value_namespace = name_space
                    self.initial_retransmit_retries.value_namespace_prefix = name_space_prefix
                if(value_path == "ip-tos"):
                    self.ip_tos = value
                    self.ip_tos.value_namespace = name_space
                    self.ip_tos.value_namespace_prefix = name_space_prefix
                if(value_path == "is-authentication-enabled"):
                    self.is_authentication_enabled = value
                    self.is_authentication_enabled.value_namespace = name_space
                    self.is_authentication_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-congestion-control-enabled"):
                    self.is_congestion_control_enabled = value
                    self.is_congestion_control_enabled.value_namespace = name_space
                    self.is_congestion_control_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-digest-check-enabled"):
                    self.is_digest_check_enabled = value
                    self.is_digest_check_enabled.value_namespace = name_space
                    self.is_digest_check_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-digest-enabled"):
                    self.is_digest_enabled = value
                    self.is_digest_enabled.value_namespace = name_space
                    self.is_digest_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-hidden"):
                    self.is_hidden = value
                    self.is_hidden.value_namespace = name_space
                    self.is_hidden.value_namespace_prefix = name_space_prefix
                if(value_path == "is-peer-address-checked"):
                    self.is_peer_address_checked = value
                    self.is_peer_address_checked.value_namespace = name_space
                    self.is_peer_address_checked.value_namespace_prefix = name_space_prefix
                if(value_path == "password"):
                    self.password = value
                    self.password.value_namespace = name_space
                    self.password.value_namespace_prefix = name_space_prefix
                if(value_path == "receive-window-size"):
                    self.receive_window_size = value
                    self.receive_window_size.value_namespace = name_space
                    self.receive_window_size.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-maximum-timeout"):
                    self.retransmit_maximum_timeout = value
                    self.retransmit_maximum_timeout.value_namespace = name_space
                    self.retransmit_maximum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-minimum-timeout"):
                    self.retransmit_minimum_timeout = value
                    self.retransmit_minimum_timeout.value_namespace = name_space
                    self.retransmit_minimum_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-retries"):
                    self.retransmit_retries = value
                    self.retransmit_retries.value_namespace = name_space
                    self.retransmit_retries.value_namespace_prefix = name_space_prefix
                if(value_path == "setup-timeout"):
                    self.setup_timeout = value
                    self.setup_timeout.value_namespace = name_space
                    self.setup_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "timeout-no-user"):
                    self.timeout_no_user = value
                    self.timeout_no_user.value_namespace = name_space
                    self.timeout_no_user.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.class_:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.class_:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "classes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "class"):
                for c in self.class_:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tpv2.Classes.Class_()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.class_.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "class"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Tunnels(Entity):
        """
        List of tunnel IDs
        
        .. attribute:: tunnel
        
        	L2TP tunnel  information
        	**type**\: list of    :py:class:`Tunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Tunnels.Tunnel>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.Tunnels, self).__init__()

            self.yang_name = "tunnels"
            self.yang_parent_name = "l2tpv2"

            self.tunnel = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tpv2.Tunnels, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tpv2.Tunnels, self).__setattr__(name, value)


        class Tunnel(Entity):
            """
            L2TP tunnel  information
            
            .. attribute:: local_tunnel_id  <key>
            
            	Local tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: active_sessions
            
            	Number of active sessions
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: class_name
            
            	L2TP class name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: digest_secrets
            
            	Control message authentication with digest secrets
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: is_congestion_control_enabled
            
            	True if congestion control is enabled else false
            	**type**\:  bool
            
            .. attribute:: is_pmtu_enabled
            
            	True if tunnel PMTU checking is enabled
            	**type**\:  bool
            
            .. attribute:: is_tunnel_up
            
            	True if tunnel is up
            	**type**\:  bool
            
            .. attribute:: local_address
            
            	Local tunnel address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: local_port
            
            	Local port
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: local_tunnel_name
            
            	Local tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: local_window_size
            
            	Local window size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: maximum_retransmission_time
            
            	Maximum retransmission time in seconds
            	**type**\:  int
            
            	**range:** 0..65535
            
            	**units**\: second
            
            .. attribute:: order_queue_size
            
            	Order queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: packet_queue_check
            
            	Current number session packet queue check
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: protocol
            
            	Protocol
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: remote_address
            
            	Remote tunnel address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: remote_port
            
            	Remote port
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: remote_tunnel_id
            
            	Remote tunnel ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_tunnel_name
            
            	Remote tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: remote_window_size
            
            	Remote window size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: resend_maximum_queue_size
            
            	Resend maximum queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: resend_queue_size
            
            	Resend queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: resends
            
            	Total resends
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: retransmission_time
            
            	Retransmission time in seconds
            	**type**\:  int
            
            	**range:** 0..65535
            
            	**units**\: second
            
            .. attribute:: retransmit_time
            
            	Retransmit time distribution in seconds
            	**type**\:  list of int
            
            	**range:** 0..65535
            
            	**units**\: second
            
            .. attribute:: sequence_nr
            
            	Sequence NR
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: sequence_ns
            
            	Sequence NS
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: total_out_of_order_drop_packets
            
            	Total out of order dropped packets
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_out_of_order_reorder_packets
            
            	Total out of order reorder packets
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_peer_authentication_failures
            
            	Number of peer authentication failures
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unsent_maximum_queue_size
            
            	Unsent maximum queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: unsent_queue_size
            
            	Unsent queue size
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: zero_length_body_acknowledgement_sent
            
            	Total zero length body acknowledgement
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.Tunnels.Tunnel, self).__init__()

                self.yang_name = "tunnel"
                self.yang_parent_name = "tunnels"

                self.local_tunnel_id = YLeaf(YType.int32, "local-tunnel-id")

                self.active_sessions = YLeaf(YType.uint32, "active-sessions")

                self.class_name = YLeaf(YType.str, "class-name")

                self.digest_secrets = YLeaf(YType.uint16, "digest-secrets")

                self.is_congestion_control_enabled = YLeaf(YType.boolean, "is-congestion-control-enabled")

                self.is_pmtu_enabled = YLeaf(YType.boolean, "is-pmtu-enabled")

                self.is_tunnel_up = YLeaf(YType.boolean, "is-tunnel-up")

                self.local_address = YLeaf(YType.str, "local-address")

                self.local_port = YLeaf(YType.uint16, "local-port")

                self.local_tunnel_name = YLeaf(YType.str, "local-tunnel-name")

                self.local_window_size = YLeaf(YType.uint16, "local-window-size")

                self.maximum_retransmission_time = YLeaf(YType.uint16, "maximum-retransmission-time")

                self.order_queue_size = YLeaf(YType.uint16, "order-queue-size")

                self.packet_queue_check = YLeaf(YType.uint16, "packet-queue-check")

                self.protocol = YLeaf(YType.uint8, "protocol")

                self.remote_address = YLeaf(YType.str, "remote-address")

                self.remote_port = YLeaf(YType.uint16, "remote-port")

                self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                self.remote_tunnel_name = YLeaf(YType.str, "remote-tunnel-name")

                self.remote_window_size = YLeaf(YType.uint16, "remote-window-size")

                self.resend_maximum_queue_size = YLeaf(YType.uint16, "resend-maximum-queue-size")

                self.resend_queue_size = YLeaf(YType.uint16, "resend-queue-size")

                self.resends = YLeaf(YType.uint32, "resends")

                self.retransmission_time = YLeaf(YType.uint16, "retransmission-time")

                self.retransmit_time = YLeafList(YType.uint16, "retransmit-time")

                self.sequence_nr = YLeaf(YType.uint16, "sequence-nr")

                self.sequence_ns = YLeaf(YType.uint16, "sequence-ns")

                self.total_out_of_order_drop_packets = YLeaf(YType.uint32, "total-out-of-order-drop-packets")

                self.total_out_of_order_reorder_packets = YLeaf(YType.uint32, "total-out-of-order-reorder-packets")

                self.total_peer_authentication_failures = YLeaf(YType.uint32, "total-peer-authentication-failures")

                self.unsent_maximum_queue_size = YLeaf(YType.uint16, "unsent-maximum-queue-size")

                self.unsent_queue_size = YLeaf(YType.uint16, "unsent-queue-size")

                self.zero_length_body_acknowledgement_sent = YLeaf(YType.uint32, "zero-length-body-acknowledgement-sent")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("local_tunnel_id",
                                "active_sessions",
                                "class_name",
                                "digest_secrets",
                                "is_congestion_control_enabled",
                                "is_pmtu_enabled",
                                "is_tunnel_up",
                                "local_address",
                                "local_port",
                                "local_tunnel_name",
                                "local_window_size",
                                "maximum_retransmission_time",
                                "order_queue_size",
                                "packet_queue_check",
                                "protocol",
                                "remote_address",
                                "remote_port",
                                "remote_tunnel_id",
                                "remote_tunnel_name",
                                "remote_window_size",
                                "resend_maximum_queue_size",
                                "resend_queue_size",
                                "resends",
                                "retransmission_time",
                                "retransmit_time",
                                "sequence_nr",
                                "sequence_ns",
                                "total_out_of_order_drop_packets",
                                "total_out_of_order_reorder_packets",
                                "total_peer_authentication_failures",
                                "unsent_maximum_queue_size",
                                "unsent_queue_size",
                                "zero_length_body_acknowledgement_sent") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tpv2.Tunnels.Tunnel, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tpv2.Tunnels.Tunnel, self).__setattr__(name, value)

            def has_data(self):
                for leaf in self.retransmit_time.getYLeafs():
                    if (leaf.yfilter != YFilter.not_set):
                        return True
                return (
                    self.local_tunnel_id.is_set or
                    self.active_sessions.is_set or
                    self.class_name.is_set or
                    self.digest_secrets.is_set or
                    self.is_congestion_control_enabled.is_set or
                    self.is_pmtu_enabled.is_set or
                    self.is_tunnel_up.is_set or
                    self.local_address.is_set or
                    self.local_port.is_set or
                    self.local_tunnel_name.is_set or
                    self.local_window_size.is_set or
                    self.maximum_retransmission_time.is_set or
                    self.order_queue_size.is_set or
                    self.packet_queue_check.is_set or
                    self.protocol.is_set or
                    self.remote_address.is_set or
                    self.remote_port.is_set or
                    self.remote_tunnel_id.is_set or
                    self.remote_tunnel_name.is_set or
                    self.remote_window_size.is_set or
                    self.resend_maximum_queue_size.is_set or
                    self.resend_queue_size.is_set or
                    self.resends.is_set or
                    self.retransmission_time.is_set or
                    self.sequence_nr.is_set or
                    self.sequence_ns.is_set or
                    self.total_out_of_order_drop_packets.is_set or
                    self.total_out_of_order_reorder_packets.is_set or
                    self.total_peer_authentication_failures.is_set or
                    self.unsent_maximum_queue_size.is_set or
                    self.unsent_queue_size.is_set or
                    self.zero_length_body_acknowledgement_sent.is_set)

            def has_operation(self):
                for leaf in self.retransmit_time.getYLeafs():
                    if (leaf.is_set):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.local_tunnel_id.yfilter != YFilter.not_set or
                    self.active_sessions.yfilter != YFilter.not_set or
                    self.class_name.yfilter != YFilter.not_set or
                    self.digest_secrets.yfilter != YFilter.not_set or
                    self.is_congestion_control_enabled.yfilter != YFilter.not_set or
                    self.is_pmtu_enabled.yfilter != YFilter.not_set or
                    self.is_tunnel_up.yfilter != YFilter.not_set or
                    self.local_address.yfilter != YFilter.not_set or
                    self.local_port.yfilter != YFilter.not_set or
                    self.local_tunnel_name.yfilter != YFilter.not_set or
                    self.local_window_size.yfilter != YFilter.not_set or
                    self.maximum_retransmission_time.yfilter != YFilter.not_set or
                    self.order_queue_size.yfilter != YFilter.not_set or
                    self.packet_queue_check.yfilter != YFilter.not_set or
                    self.protocol.yfilter != YFilter.not_set or
                    self.remote_address.yfilter != YFilter.not_set or
                    self.remote_port.yfilter != YFilter.not_set or
                    self.remote_tunnel_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_name.yfilter != YFilter.not_set or
                    self.remote_window_size.yfilter != YFilter.not_set or
                    self.resend_maximum_queue_size.yfilter != YFilter.not_set or
                    self.resend_queue_size.yfilter != YFilter.not_set or
                    self.resends.yfilter != YFilter.not_set or
                    self.retransmission_time.yfilter != YFilter.not_set or
                    self.retransmit_time.yfilter != YFilter.not_set or
                    self.sequence_nr.yfilter != YFilter.not_set or
                    self.sequence_ns.yfilter != YFilter.not_set or
                    self.total_out_of_order_drop_packets.yfilter != YFilter.not_set or
                    self.total_out_of_order_reorder_packets.yfilter != YFilter.not_set or
                    self.total_peer_authentication_failures.yfilter != YFilter.not_set or
                    self.unsent_maximum_queue_size.yfilter != YFilter.not_set or
                    self.unsent_queue_size.yfilter != YFilter.not_set or
                    self.zero_length_body_acknowledgement_sent.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel" + "[local-tunnel-id='" + self.local_tunnel_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/tunnels/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.local_tunnel_id.is_set or self.local_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_id.get_name_leafdata())
                if (self.active_sessions.is_set or self.active_sessions.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.active_sessions.get_name_leafdata())
                if (self.class_name.is_set or self.class_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.class_name.get_name_leafdata())
                if (self.digest_secrets.is_set or self.digest_secrets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.digest_secrets.get_name_leafdata())
                if (self.is_congestion_control_enabled.is_set or self.is_congestion_control_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_congestion_control_enabled.get_name_leafdata())
                if (self.is_pmtu_enabled.is_set or self.is_pmtu_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_pmtu_enabled.get_name_leafdata())
                if (self.is_tunnel_up.is_set or self.is_tunnel_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_tunnel_up.get_name_leafdata())
                if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_address.get_name_leafdata())
                if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_port.get_name_leafdata())
                if (self.local_tunnel_name.is_set or self.local_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_name.get_name_leafdata())
                if (self.local_window_size.is_set or self.local_window_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_window_size.get_name_leafdata())
                if (self.maximum_retransmission_time.is_set or self.maximum_retransmission_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.maximum_retransmission_time.get_name_leafdata())
                if (self.order_queue_size.is_set or self.order_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.order_queue_size.get_name_leafdata())
                if (self.packet_queue_check.is_set or self.packet_queue_check.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.packet_queue_check.get_name_leafdata())
                if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocol.get_name_leafdata())
                if (self.remote_address.is_set or self.remote_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_address.get_name_leafdata())
                if (self.remote_port.is_set or self.remote_port.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_port.get_name_leafdata())
                if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())
                if (self.remote_tunnel_name.is_set or self.remote_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_name.get_name_leafdata())
                if (self.remote_window_size.is_set or self.remote_window_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_window_size.get_name_leafdata())
                if (self.resend_maximum_queue_size.is_set or self.resend_maximum_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.resend_maximum_queue_size.get_name_leafdata())
                if (self.resend_queue_size.is_set or self.resend_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.resend_queue_size.get_name_leafdata())
                if (self.resends.is_set or self.resends.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.resends.get_name_leafdata())
                if (self.retransmission_time.is_set or self.retransmission_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.retransmission_time.get_name_leafdata())
                if (self.sequence_nr.is_set or self.sequence_nr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sequence_nr.get_name_leafdata())
                if (self.sequence_ns.is_set or self.sequence_ns.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sequence_ns.get_name_leafdata())
                if (self.total_out_of_order_drop_packets.is_set or self.total_out_of_order_drop_packets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_out_of_order_drop_packets.get_name_leafdata())
                if (self.total_out_of_order_reorder_packets.is_set or self.total_out_of_order_reorder_packets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_out_of_order_reorder_packets.get_name_leafdata())
                if (self.total_peer_authentication_failures.is_set or self.total_peer_authentication_failures.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_peer_authentication_failures.get_name_leafdata())
                if (self.unsent_maximum_queue_size.is_set or self.unsent_maximum_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unsent_maximum_queue_size.get_name_leafdata())
                if (self.unsent_queue_size.is_set or self.unsent_queue_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unsent_queue_size.get_name_leafdata())
                if (self.zero_length_body_acknowledgement_sent.is_set or self.zero_length_body_acknowledgement_sent.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.zero_length_body_acknowledgement_sent.get_name_leafdata())

                leaf_name_data.extend(self.retransmit_time.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "local-tunnel-id" or name == "active-sessions" or name == "class-name" or name == "digest-secrets" or name == "is-congestion-control-enabled" or name == "is-pmtu-enabled" or name == "is-tunnel-up" or name == "local-address" or name == "local-port" or name == "local-tunnel-name" or name == "local-window-size" or name == "maximum-retransmission-time" or name == "order-queue-size" or name == "packet-queue-check" or name == "protocol" or name == "remote-address" or name == "remote-port" or name == "remote-tunnel-id" or name == "remote-tunnel-name" or name == "remote-window-size" or name == "resend-maximum-queue-size" or name == "resend-queue-size" or name == "resends" or name == "retransmission-time" or name == "retransmit-time" or name == "sequence-nr" or name == "sequence-ns" or name == "total-out-of-order-drop-packets" or name == "total-out-of-order-reorder-packets" or name == "total-peer-authentication-failures" or name == "unsent-maximum-queue-size" or name == "unsent-queue-size" or name == "zero-length-body-acknowledgement-sent"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "local-tunnel-id"):
                    self.local_tunnel_id = value
                    self.local_tunnel_id.value_namespace = name_space
                    self.local_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "active-sessions"):
                    self.active_sessions = value
                    self.active_sessions.value_namespace = name_space
                    self.active_sessions.value_namespace_prefix = name_space_prefix
                if(value_path == "class-name"):
                    self.class_name = value
                    self.class_name.value_namespace = name_space
                    self.class_name.value_namespace_prefix = name_space_prefix
                if(value_path == "digest-secrets"):
                    self.digest_secrets = value
                    self.digest_secrets.value_namespace = name_space
                    self.digest_secrets.value_namespace_prefix = name_space_prefix
                if(value_path == "is-congestion-control-enabled"):
                    self.is_congestion_control_enabled = value
                    self.is_congestion_control_enabled.value_namespace = name_space
                    self.is_congestion_control_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-pmtu-enabled"):
                    self.is_pmtu_enabled = value
                    self.is_pmtu_enabled.value_namespace = name_space
                    self.is_pmtu_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-tunnel-up"):
                    self.is_tunnel_up = value
                    self.is_tunnel_up.value_namespace = name_space
                    self.is_tunnel_up.value_namespace_prefix = name_space_prefix
                if(value_path == "local-address"):
                    self.local_address = value
                    self.local_address.value_namespace = name_space
                    self.local_address.value_namespace_prefix = name_space_prefix
                if(value_path == "local-port"):
                    self.local_port = value
                    self.local_port.value_namespace = name_space
                    self.local_port.value_namespace_prefix = name_space_prefix
                if(value_path == "local-tunnel-name"):
                    self.local_tunnel_name = value
                    self.local_tunnel_name.value_namespace = name_space
                    self.local_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "local-window-size"):
                    self.local_window_size = value
                    self.local_window_size.value_namespace = name_space
                    self.local_window_size.value_namespace_prefix = name_space_prefix
                if(value_path == "maximum-retransmission-time"):
                    self.maximum_retransmission_time = value
                    self.maximum_retransmission_time.value_namespace = name_space
                    self.maximum_retransmission_time.value_namespace_prefix = name_space_prefix
                if(value_path == "order-queue-size"):
                    self.order_queue_size = value
                    self.order_queue_size.value_namespace = name_space
                    self.order_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "packet-queue-check"):
                    self.packet_queue_check = value
                    self.packet_queue_check.value_namespace = name_space
                    self.packet_queue_check.value_namespace_prefix = name_space_prefix
                if(value_path == "protocol"):
                    self.protocol = value
                    self.protocol.value_namespace = name_space
                    self.protocol.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-address"):
                    self.remote_address = value
                    self.remote_address.value_namespace = name_space
                    self.remote_address.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-port"):
                    self.remote_port = value
                    self.remote_port.value_namespace = name_space
                    self.remote_port.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-id"):
                    self.remote_tunnel_id = value
                    self.remote_tunnel_id.value_namespace = name_space
                    self.remote_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-name"):
                    self.remote_tunnel_name = value
                    self.remote_tunnel_name.value_namespace = name_space
                    self.remote_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-window-size"):
                    self.remote_window_size = value
                    self.remote_window_size.value_namespace = name_space
                    self.remote_window_size.value_namespace_prefix = name_space_prefix
                if(value_path == "resend-maximum-queue-size"):
                    self.resend_maximum_queue_size = value
                    self.resend_maximum_queue_size.value_namespace = name_space
                    self.resend_maximum_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "resend-queue-size"):
                    self.resend_queue_size = value
                    self.resend_queue_size.value_namespace = name_space
                    self.resend_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "resends"):
                    self.resends = value
                    self.resends.value_namespace = name_space
                    self.resends.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmission-time"):
                    self.retransmission_time = value
                    self.retransmission_time.value_namespace = name_space
                    self.retransmission_time.value_namespace_prefix = name_space_prefix
                if(value_path == "retransmit-time"):
                    self.retransmit_time.append(value)
                if(value_path == "sequence-nr"):
                    self.sequence_nr = value
                    self.sequence_nr.value_namespace = name_space
                    self.sequence_nr.value_namespace_prefix = name_space_prefix
                if(value_path == "sequence-ns"):
                    self.sequence_ns = value
                    self.sequence_ns.value_namespace = name_space
                    self.sequence_ns.value_namespace_prefix = name_space_prefix
                if(value_path == "total-out-of-order-drop-packets"):
                    self.total_out_of_order_drop_packets = value
                    self.total_out_of_order_drop_packets.value_namespace = name_space
                    self.total_out_of_order_drop_packets.value_namespace_prefix = name_space_prefix
                if(value_path == "total-out-of-order-reorder-packets"):
                    self.total_out_of_order_reorder_packets = value
                    self.total_out_of_order_reorder_packets.value_namespace = name_space
                    self.total_out_of_order_reorder_packets.value_namespace_prefix = name_space_prefix
                if(value_path == "total-peer-authentication-failures"):
                    self.total_peer_authentication_failures = value
                    self.total_peer_authentication_failures.value_namespace = name_space
                    self.total_peer_authentication_failures.value_namespace_prefix = name_space_prefix
                if(value_path == "unsent-maximum-queue-size"):
                    self.unsent_maximum_queue_size = value
                    self.unsent_maximum_queue_size.value_namespace = name_space
                    self.unsent_maximum_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "unsent-queue-size"):
                    self.unsent_queue_size = value
                    self.unsent_queue_size.value_namespace = name_space
                    self.unsent_queue_size.value_namespace_prefix = name_space_prefix
                if(value_path == "zero-length-body-acknowledgement-sent"):
                    self.zero_length_body_acknowledgement_sent = value
                    self.zero_length_body_acknowledgement_sent.value_namespace = name_space
                    self.zero_length_body_acknowledgement_sent.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.tunnel:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.tunnel:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "tunnels" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnel"):
                for c in self.tunnel:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tpv2.Tunnels.Tunnel()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.tunnel.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnel"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Sessions(Entity):
        """
        List of session IDs
        
        .. attribute:: session
        
        	L2TP information for a particular session
        	**type**\: list of    :py:class:`Session <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Sessions.Session>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.Sessions, self).__init__()

            self.yang_name = "sessions"
            self.yang_parent_name = "l2tpv2"

            self.session = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Tpv2.Sessions, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Tpv2.Sessions, self).__setattr__(name, value)


        class Session(Entity):
            """
            L2TP information for a particular session
            
            .. attribute:: local_tunnel_id  <key>
            
            	Local tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: local_session_id  <key>
            
            	Local session ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: call_serial_number
            
            	Call serial number
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_name
            
            	Interface name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: is_conditional_debug_enabled
            
            	True if conditional debugging is enabled
            	**type**\:  bool
            
            .. attribute:: is_sequencing_on
            
            	True if session sequence is on
            	**type**\:  bool
            
            .. attribute:: is_session_locally_initiated
            
            	True if session initiated locally
            	**type**\:  bool
            
            .. attribute:: is_session_manual
            
            	True if session is manual
            	**type**\:  bool
            
            .. attribute:: is_session_state_established
            
            	True if session state is established
            	**type**\:  bool
            
            .. attribute:: is_session_up
            
            	True if session is up
            	**type**\:  bool
            
            .. attribute:: is_udp_checksum_enabled
            
            	True if UDP checksum enabled
            	**type**\:  bool
            
            .. attribute:: l2tp_sh_sess_tie_breaker
            
            	l2tp sh sess tie breaker
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            .. attribute:: l2tp_sh_sess_tie_breaker_enabled
            
            	l2tp sh sess tie breaker enabled
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: l2tp_sh_sess_udp_lport
            
            	l2tp sh sess udp lport
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: l2tp_sh_sess_udp_rport
            
            	l2tp sh sess udp rport
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: local_ip_address
            
            	Local session IP address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: local_tunnel_name
            
            	Local tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: protocol
            
            	Protocol
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: remote_ip_address
            
            	Remote session IP address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: remote_session_id
            
            	Remote session ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_tunnel_id
            
            	Remote tunnel ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_tunnel_name
            
            	Remote tunnel name
            	**type**\:  str
            
            	**length:** 0..256
            
            .. attribute:: session_application_data
            
            	Session application data
            	**type**\:   :py:class:`SessionApplicationData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Sessions.Session.SessionApplicationData>`
            
            .. attribute:: unique_id
            
            	Unique ID
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.Sessions.Session, self).__init__()

                self.yang_name = "session"
                self.yang_parent_name = "sessions"

                self.local_tunnel_id = YLeaf(YType.int32, "local-tunnel-id")

                self.local_session_id = YLeaf(YType.int32, "local-session-id")

                self.call_serial_number = YLeaf(YType.uint32, "call-serial-number")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.is_conditional_debug_enabled = YLeaf(YType.boolean, "is-conditional-debug-enabled")

                self.is_sequencing_on = YLeaf(YType.boolean, "is-sequencing-on")

                self.is_session_locally_initiated = YLeaf(YType.boolean, "is-session-locally-initiated")

                self.is_session_manual = YLeaf(YType.boolean, "is-session-manual")

                self.is_session_state_established = YLeaf(YType.boolean, "is-session-state-established")

                self.is_session_up = YLeaf(YType.boolean, "is-session-up")

                self.is_udp_checksum_enabled = YLeaf(YType.boolean, "is-udp-checksum-enabled")

                self.l2tp_sh_sess_tie_breaker = YLeaf(YType.uint64, "l2tp-sh-sess-tie-breaker")

                self.l2tp_sh_sess_tie_breaker_enabled = YLeaf(YType.uint8, "l2tp-sh-sess-tie-breaker-enabled")

                self.l2tp_sh_sess_udp_lport = YLeaf(YType.uint16, "l2tp-sh-sess-udp-lport")

                self.l2tp_sh_sess_udp_rport = YLeaf(YType.uint16, "l2tp-sh-sess-udp-rport")

                self.local_ip_address = YLeaf(YType.str, "local-ip-address")

                self.local_tunnel_name = YLeaf(YType.str, "local-tunnel-name")

                self.protocol = YLeaf(YType.uint8, "protocol")

                self.remote_ip_address = YLeaf(YType.str, "remote-ip-address")

                self.remote_session_id = YLeaf(YType.uint32, "remote-session-id")

                self.remote_tunnel_id = YLeaf(YType.uint32, "remote-tunnel-id")

                self.remote_tunnel_name = YLeaf(YType.str, "remote-tunnel-name")

                self.unique_id = YLeaf(YType.uint32, "unique-id")

                self.session_application_data = L2Tpv2.Sessions.Session.SessionApplicationData()
                self.session_application_data.parent = self
                self._children_name_map["session_application_data"] = "session-application-data"
                self._children_yang_names.add("session-application-data")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("local_tunnel_id",
                                "local_session_id",
                                "call_serial_number",
                                "interface_name",
                                "is_conditional_debug_enabled",
                                "is_sequencing_on",
                                "is_session_locally_initiated",
                                "is_session_manual",
                                "is_session_state_established",
                                "is_session_up",
                                "is_udp_checksum_enabled",
                                "l2tp_sh_sess_tie_breaker",
                                "l2tp_sh_sess_tie_breaker_enabled",
                                "l2tp_sh_sess_udp_lport",
                                "l2tp_sh_sess_udp_rport",
                                "local_ip_address",
                                "local_tunnel_name",
                                "protocol",
                                "remote_ip_address",
                                "remote_session_id",
                                "remote_tunnel_id",
                                "remote_tunnel_name",
                                "unique_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tpv2.Sessions.Session, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tpv2.Sessions.Session, self).__setattr__(name, value)


            class SessionApplicationData(Entity):
                """
                Session application data
                
                .. attribute:: l2tp_sh_sess_app_type
                
                	l2tp sh sess app type
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: vpdn
                
                	VPDN data
                	**type**\:   :py:class:`Vpdn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Sessions.Session.SessionApplicationData.Vpdn>`
                
                .. attribute:: xconnect
                
                	Xconnect data
                	**type**\:   :py:class:`Xconnect <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Sessions.Session.SessionApplicationData.Xconnect>`
                
                

                """

                _prefix = 'tunnel-l2tun-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Tpv2.Sessions.Session.SessionApplicationData, self).__init__()

                    self.yang_name = "session-application-data"
                    self.yang_parent_name = "session"

                    self.l2tp_sh_sess_app_type = YLeaf(YType.uint32, "l2tp-sh-sess-app-type")

                    self.vpdn = L2Tpv2.Sessions.Session.SessionApplicationData.Vpdn()
                    self.vpdn.parent = self
                    self._children_name_map["vpdn"] = "vpdn"
                    self._children_yang_names.add("vpdn")

                    self.xconnect = L2Tpv2.Sessions.Session.SessionApplicationData.Xconnect()
                    self.xconnect.parent = self
                    self._children_name_map["xconnect"] = "xconnect"
                    self._children_yang_names.add("xconnect")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("l2tp_sh_sess_app_type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Tpv2.Sessions.Session.SessionApplicationData, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Tpv2.Sessions.Session.SessionApplicationData, self).__setattr__(name, value)


                class Xconnect(Entity):
                    """
                    Xconnect data
                    
                    .. attribute:: circuit_name
                    
                    	Circuit name
                    	**type**\:  str
                    
                    .. attribute:: ipv6_protocol_tunneling
                    
                    	IPv6ProtocolTunneling
                    	**type**\:  bool
                    
                    .. attribute:: is_circuit_state_up
                    
                    	True if circuit state is up
                    	**type**\:  bool
                    
                    .. attribute:: is_local_circuit_state_up
                    
                    	True if local circuit state is up
                    	**type**\:  bool
                    
                    .. attribute:: is_remote_circuit_state_up
                    
                    	True if remote circuit state is up
                    	**type**\:  bool
                    
                    .. attribute:: sessionvc_id
                    
                    	Session VC ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tpv2.Sessions.Session.SessionApplicationData.Xconnect, self).__init__()

                        self.yang_name = "xconnect"
                        self.yang_parent_name = "session-application-data"

                        self.circuit_name = YLeaf(YType.str, "circuit-name")

                        self.ipv6_protocol_tunneling = YLeaf(YType.boolean, "ipv6-protocol-tunneling")

                        self.is_circuit_state_up = YLeaf(YType.boolean, "is-circuit-state-up")

                        self.is_local_circuit_state_up = YLeaf(YType.boolean, "is-local-circuit-state-up")

                        self.is_remote_circuit_state_up = YLeaf(YType.boolean, "is-remote-circuit-state-up")

                        self.sessionvc_id = YLeaf(YType.uint32, "sessionvc-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("circuit_name",
                                        "ipv6_protocol_tunneling",
                                        "is_circuit_state_up",
                                        "is_local_circuit_state_up",
                                        "is_remote_circuit_state_up",
                                        "sessionvc_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tpv2.Sessions.Session.SessionApplicationData.Xconnect, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tpv2.Sessions.Session.SessionApplicationData.Xconnect, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.circuit_name.is_set or
                            self.ipv6_protocol_tunneling.is_set or
                            self.is_circuit_state_up.is_set or
                            self.is_local_circuit_state_up.is_set or
                            self.is_remote_circuit_state_up.is_set or
                            self.sessionvc_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.circuit_name.yfilter != YFilter.not_set or
                            self.ipv6_protocol_tunneling.yfilter != YFilter.not_set or
                            self.is_circuit_state_up.yfilter != YFilter.not_set or
                            self.is_local_circuit_state_up.yfilter != YFilter.not_set or
                            self.is_remote_circuit_state_up.yfilter != YFilter.not_set or
                            self.sessionvc_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "xconnect" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.circuit_name.is_set or self.circuit_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.circuit_name.get_name_leafdata())
                        if (self.ipv6_protocol_tunneling.is_set or self.ipv6_protocol_tunneling.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6_protocol_tunneling.get_name_leafdata())
                        if (self.is_circuit_state_up.is_set or self.is_circuit_state_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_circuit_state_up.get_name_leafdata())
                        if (self.is_local_circuit_state_up.is_set or self.is_local_circuit_state_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_local_circuit_state_up.get_name_leafdata())
                        if (self.is_remote_circuit_state_up.is_set or self.is_remote_circuit_state_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_remote_circuit_state_up.get_name_leafdata())
                        if (self.sessionvc_id.is_set or self.sessionvc_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sessionvc_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "circuit-name" or name == "ipv6-protocol-tunneling" or name == "is-circuit-state-up" or name == "is-local-circuit-state-up" or name == "is-remote-circuit-state-up" or name == "sessionvc-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "circuit-name"):
                            self.circuit_name = value
                            self.circuit_name.value_namespace = name_space
                            self.circuit_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6-protocol-tunneling"):
                            self.ipv6_protocol_tunneling = value
                            self.ipv6_protocol_tunneling.value_namespace = name_space
                            self.ipv6_protocol_tunneling.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-circuit-state-up"):
                            self.is_circuit_state_up = value
                            self.is_circuit_state_up.value_namespace = name_space
                            self.is_circuit_state_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-local-circuit-state-up"):
                            self.is_local_circuit_state_up = value
                            self.is_local_circuit_state_up.value_namespace = name_space
                            self.is_local_circuit_state_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-remote-circuit-state-up"):
                            self.is_remote_circuit_state_up = value
                            self.is_remote_circuit_state_up.value_namespace = name_space
                            self.is_remote_circuit_state_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "sessionvc-id"):
                            self.sessionvc_id = value
                            self.sessionvc_id.value_namespace = name_space
                            self.sessionvc_id.value_namespace_prefix = name_space_prefix


                class Vpdn(Entity):
                    """
                    VPDN data
                    
                    .. attribute:: interface_name
                    
                    	Interface name
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: username
                    
                    	Session username
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'tunnel-l2tun-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Tpv2.Sessions.Session.SessionApplicationData.Vpdn, self).__init__()

                        self.yang_name = "vpdn"
                        self.yang_parent_name = "session-application-data"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.username = YLeaf(YType.str, "username")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name",
                                        "username") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Tpv2.Sessions.Session.SessionApplicationData.Vpdn, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Tpv2.Sessions.Session.SessionApplicationData.Vpdn, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            self.username.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.username.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "vpdn" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.username.is_set or self.username.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.username.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface-name" or name == "username"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "username"):
                            self.username = value
                            self.username.value_namespace = name_space
                            self.username.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.l2tp_sh_sess_app_type.is_set or
                        (self.vpdn is not None and self.vpdn.has_data()) or
                        (self.xconnect is not None and self.xconnect.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.l2tp_sh_sess_app_type.yfilter != YFilter.not_set or
                        (self.vpdn is not None and self.vpdn.has_operation()) or
                        (self.xconnect is not None and self.xconnect.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-application-data" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.l2tp_sh_sess_app_type.is_set or self.l2tp_sh_sess_app_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.l2tp_sh_sess_app_type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "vpdn"):
                        if (self.vpdn is None):
                            self.vpdn = L2Tpv2.Sessions.Session.SessionApplicationData.Vpdn()
                            self.vpdn.parent = self
                            self._children_name_map["vpdn"] = "vpdn"
                        return self.vpdn

                    if (child_yang_name == "xconnect"):
                        if (self.xconnect is None):
                            self.xconnect = L2Tpv2.Sessions.Session.SessionApplicationData.Xconnect()
                            self.xconnect.parent = self
                            self._children_name_map["xconnect"] = "xconnect"
                        return self.xconnect

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vpdn" or name == "xconnect" or name == "l2tp-sh-sess-app-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "l2tp-sh-sess-app-type"):
                        self.l2tp_sh_sess_app_type = value
                        self.l2tp_sh_sess_app_type.value_namespace = name_space
                        self.l2tp_sh_sess_app_type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.local_tunnel_id.is_set or
                    self.local_session_id.is_set or
                    self.call_serial_number.is_set or
                    self.interface_name.is_set or
                    self.is_conditional_debug_enabled.is_set or
                    self.is_sequencing_on.is_set or
                    self.is_session_locally_initiated.is_set or
                    self.is_session_manual.is_set or
                    self.is_session_state_established.is_set or
                    self.is_session_up.is_set or
                    self.is_udp_checksum_enabled.is_set or
                    self.l2tp_sh_sess_tie_breaker.is_set or
                    self.l2tp_sh_sess_tie_breaker_enabled.is_set or
                    self.l2tp_sh_sess_udp_lport.is_set or
                    self.l2tp_sh_sess_udp_rport.is_set or
                    self.local_ip_address.is_set or
                    self.local_tunnel_name.is_set or
                    self.protocol.is_set or
                    self.remote_ip_address.is_set or
                    self.remote_session_id.is_set or
                    self.remote_tunnel_id.is_set or
                    self.remote_tunnel_name.is_set or
                    self.unique_id.is_set or
                    (self.session_application_data is not None and self.session_application_data.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.local_tunnel_id.yfilter != YFilter.not_set or
                    self.local_session_id.yfilter != YFilter.not_set or
                    self.call_serial_number.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.is_conditional_debug_enabled.yfilter != YFilter.not_set or
                    self.is_sequencing_on.yfilter != YFilter.not_set or
                    self.is_session_locally_initiated.yfilter != YFilter.not_set or
                    self.is_session_manual.yfilter != YFilter.not_set or
                    self.is_session_state_established.yfilter != YFilter.not_set or
                    self.is_session_up.yfilter != YFilter.not_set or
                    self.is_udp_checksum_enabled.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_tie_breaker.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_tie_breaker_enabled.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_udp_lport.yfilter != YFilter.not_set or
                    self.l2tp_sh_sess_udp_rport.yfilter != YFilter.not_set or
                    self.local_ip_address.yfilter != YFilter.not_set or
                    self.local_tunnel_name.yfilter != YFilter.not_set or
                    self.protocol.yfilter != YFilter.not_set or
                    self.remote_ip_address.yfilter != YFilter.not_set or
                    self.remote_session_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_id.yfilter != YFilter.not_set or
                    self.remote_tunnel_name.yfilter != YFilter.not_set or
                    self.unique_id.yfilter != YFilter.not_set or
                    (self.session_application_data is not None and self.session_application_data.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session" + "[local-tunnel-id='" + self.local_tunnel_id.get() + "']" + "[local-session-id='" + self.local_session_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/sessions/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.local_tunnel_id.is_set or self.local_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_id.get_name_leafdata())
                if (self.local_session_id.is_set or self.local_session_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_session_id.get_name_leafdata())
                if (self.call_serial_number.is_set or self.call_serial_number.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.call_serial_number.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.is_conditional_debug_enabled.is_set or self.is_conditional_debug_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_conditional_debug_enabled.get_name_leafdata())
                if (self.is_sequencing_on.is_set or self.is_sequencing_on.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_sequencing_on.get_name_leafdata())
                if (self.is_session_locally_initiated.is_set or self.is_session_locally_initiated.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_locally_initiated.get_name_leafdata())
                if (self.is_session_manual.is_set or self.is_session_manual.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_manual.get_name_leafdata())
                if (self.is_session_state_established.is_set or self.is_session_state_established.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_state_established.get_name_leafdata())
                if (self.is_session_up.is_set or self.is_session_up.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_session_up.get_name_leafdata())
                if (self.is_udp_checksum_enabled.is_set or self.is_udp_checksum_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_udp_checksum_enabled.get_name_leafdata())
                if (self.l2tp_sh_sess_tie_breaker.is_set or self.l2tp_sh_sess_tie_breaker.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_tie_breaker.get_name_leafdata())
                if (self.l2tp_sh_sess_tie_breaker_enabled.is_set or self.l2tp_sh_sess_tie_breaker_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_tie_breaker_enabled.get_name_leafdata())
                if (self.l2tp_sh_sess_udp_lport.is_set or self.l2tp_sh_sess_udp_lport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_udp_lport.get_name_leafdata())
                if (self.l2tp_sh_sess_udp_rport.is_set or self.l2tp_sh_sess_udp_rport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2tp_sh_sess_udp_rport.get_name_leafdata())
                if (self.local_ip_address.is_set or self.local_ip_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ip_address.get_name_leafdata())
                if (self.local_tunnel_name.is_set or self.local_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_tunnel_name.get_name_leafdata())
                if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocol.get_name_leafdata())
                if (self.remote_ip_address.is_set or self.remote_ip_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ip_address.get_name_leafdata())
                if (self.remote_session_id.is_set or self.remote_session_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_session_id.get_name_leafdata())
                if (self.remote_tunnel_id.is_set or self.remote_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_id.get_name_leafdata())
                if (self.remote_tunnel_name.is_set or self.remote_tunnel_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_tunnel_name.get_name_leafdata())
                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-application-data"):
                    if (self.session_application_data is None):
                        self.session_application_data = L2Tpv2.Sessions.Session.SessionApplicationData()
                        self.session_application_data.parent = self
                        self._children_name_map["session_application_data"] = "session-application-data"
                    return self.session_application_data

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-application-data" or name == "local-tunnel-id" or name == "local-session-id" or name == "call-serial-number" or name == "interface-name" or name == "is-conditional-debug-enabled" or name == "is-sequencing-on" or name == "is-session-locally-initiated" or name == "is-session-manual" or name == "is-session-state-established" or name == "is-session-up" or name == "is-udp-checksum-enabled" or name == "l2tp-sh-sess-tie-breaker" or name == "l2tp-sh-sess-tie-breaker-enabled" or name == "l2tp-sh-sess-udp-lport" or name == "l2tp-sh-sess-udp-rport" or name == "local-ip-address" or name == "local-tunnel-name" or name == "protocol" or name == "remote-ip-address" or name == "remote-session-id" or name == "remote-tunnel-id" or name == "remote-tunnel-name" or name == "unique-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "local-tunnel-id"):
                    self.local_tunnel_id = value
                    self.local_tunnel_id.value_namespace = name_space
                    self.local_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "local-session-id"):
                    self.local_session_id = value
                    self.local_session_id.value_namespace = name_space
                    self.local_session_id.value_namespace_prefix = name_space_prefix
                if(value_path == "call-serial-number"):
                    self.call_serial_number = value
                    self.call_serial_number.value_namespace = name_space
                    self.call_serial_number.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "is-conditional-debug-enabled"):
                    self.is_conditional_debug_enabled = value
                    self.is_conditional_debug_enabled.value_namespace = name_space
                    self.is_conditional_debug_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-sequencing-on"):
                    self.is_sequencing_on = value
                    self.is_sequencing_on.value_namespace = name_space
                    self.is_sequencing_on.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-locally-initiated"):
                    self.is_session_locally_initiated = value
                    self.is_session_locally_initiated.value_namespace = name_space
                    self.is_session_locally_initiated.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-manual"):
                    self.is_session_manual = value
                    self.is_session_manual.value_namespace = name_space
                    self.is_session_manual.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-state-established"):
                    self.is_session_state_established = value
                    self.is_session_state_established.value_namespace = name_space
                    self.is_session_state_established.value_namespace_prefix = name_space_prefix
                if(value_path == "is-session-up"):
                    self.is_session_up = value
                    self.is_session_up.value_namespace = name_space
                    self.is_session_up.value_namespace_prefix = name_space_prefix
                if(value_path == "is-udp-checksum-enabled"):
                    self.is_udp_checksum_enabled = value
                    self.is_udp_checksum_enabled.value_namespace = name_space
                    self.is_udp_checksum_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-tie-breaker"):
                    self.l2tp_sh_sess_tie_breaker = value
                    self.l2tp_sh_sess_tie_breaker.value_namespace = name_space
                    self.l2tp_sh_sess_tie_breaker.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-tie-breaker-enabled"):
                    self.l2tp_sh_sess_tie_breaker_enabled = value
                    self.l2tp_sh_sess_tie_breaker_enabled.value_namespace = name_space
                    self.l2tp_sh_sess_tie_breaker_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-udp-lport"):
                    self.l2tp_sh_sess_udp_lport = value
                    self.l2tp_sh_sess_udp_lport.value_namespace = name_space
                    self.l2tp_sh_sess_udp_lport.value_namespace_prefix = name_space_prefix
                if(value_path == "l2tp-sh-sess-udp-rport"):
                    self.l2tp_sh_sess_udp_rport = value
                    self.l2tp_sh_sess_udp_rport.value_namespace = name_space
                    self.l2tp_sh_sess_udp_rport.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ip-address"):
                    self.local_ip_address = value
                    self.local_ip_address.value_namespace = name_space
                    self.local_ip_address.value_namespace_prefix = name_space_prefix
                if(value_path == "local-tunnel-name"):
                    self.local_tunnel_name = value
                    self.local_tunnel_name.value_namespace = name_space
                    self.local_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "protocol"):
                    self.protocol = value
                    self.protocol.value_namespace = name_space
                    self.protocol.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ip-address"):
                    self.remote_ip_address = value
                    self.remote_ip_address.value_namespace = name_space
                    self.remote_ip_address.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-session-id"):
                    self.remote_session_id = value
                    self.remote_session_id.value_namespace = name_space
                    self.remote_session_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-id"):
                    self.remote_tunnel_id = value
                    self.remote_tunnel_id.value_namespace = name_space
                    self.remote_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-tunnel-name"):
                    self.remote_tunnel_name = value
                    self.remote_tunnel_name.value_namespace = name_space
                    self.remote_tunnel_name.value_namespace_prefix = name_space_prefix
                if(value_path == "unique-id"):
                    self.unique_id = value
                    self.unique_id.value_namespace = name_space
                    self.unique_id.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.session:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.session:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "sessions" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session"):
                for c in self.session:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = L2Tpv2.Sessions.Session()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.session.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Session(Entity):
        """
        L2TP control messages counters
        
        .. attribute:: unavailable
        
        	L2TP session unavailable  information
        	**type**\:   :py:class:`Unavailable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_tunnel_l2tun_oper.L2Tpv2.Session.Unavailable>`
        
        

        """

        _prefix = 'tunnel-l2tun-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Tpv2.Session, self).__init__()

            self.yang_name = "session"
            self.yang_parent_name = "l2tpv2"

            self.unavailable = L2Tpv2.Session.Unavailable()
            self.unavailable.parent = self
            self._children_name_map["unavailable"] = "unavailable"
            self._children_yang_names.add("unavailable")


        class Unavailable(Entity):
            """
            L2TP session unavailable  information
            
            .. attribute:: sessions_on_hold
            
            	Number of session ID in hold database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'tunnel-l2tun-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Tpv2.Session.Unavailable, self).__init__()

                self.yang_name = "unavailable"
                self.yang_parent_name = "session"

                self.sessions_on_hold = YLeaf(YType.uint32, "sessions-on-hold")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("sessions_on_hold") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Tpv2.Session.Unavailable, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Tpv2.Session.Unavailable, self).__setattr__(name, value)

            def has_data(self):
                return self.sessions_on_hold.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.sessions_on_hold.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "unavailable" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/session/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.sessions_on_hold.is_set or self.sessions_on_hold.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sessions_on_hold.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "sessions-on-hold"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "sessions-on-hold"):
                    self.sessions_on_hold = value
                    self.sessions_on_hold.value_namespace = name_space
                    self.sessions_on_hold.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.unavailable is not None and self.unavailable.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.unavailable is not None and self.unavailable.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "session" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "unavailable"):
                if (self.unavailable is None):
                    self.unavailable = L2Tpv2.Session.Unavailable()
                    self.unavailable.parent = self
                    self._children_name_map["unavailable"] = "unavailable"
                return self.unavailable

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "unavailable"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.classes is not None and self.classes.has_data()) or
            (self.counter_hist_fail is not None and self.counter_hist_fail.has_data()) or
            (self.counters is not None and self.counters.has_data()) or
            (self.session is not None and self.session.has_data()) or
            (self.sessions is not None and self.sessions.has_data()) or
            (self.statistics is not None and self.statistics.has_data()) or
            (self.tunnel is not None and self.tunnel.has_data()) or
            (self.tunnel_configurations is not None and self.tunnel_configurations.has_data()) or
            (self.tunnels is not None and self.tunnels.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.classes is not None and self.classes.has_operation()) or
            (self.counter_hist_fail is not None and self.counter_hist_fail.has_operation()) or
            (self.counters is not None and self.counters.has_operation()) or
            (self.session is not None and self.session.has_operation()) or
            (self.sessions is not None and self.sessions.has_operation()) or
            (self.statistics is not None and self.statistics.has_operation()) or
            (self.tunnel is not None and self.tunnel.has_operation()) or
            (self.tunnel_configurations is not None and self.tunnel_configurations.has_operation()) or
            (self.tunnels is not None and self.tunnels.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-tunnel-l2tun-oper:l2tpv2" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "classes"):
            if (self.classes is None):
                self.classes = L2Tpv2.Classes()
                self.classes.parent = self
                self._children_name_map["classes"] = "classes"
            return self.classes

        if (child_yang_name == "counter-hist-fail"):
            if (self.counter_hist_fail is None):
                self.counter_hist_fail = L2Tpv2.CounterHistFail()
                self.counter_hist_fail.parent = self
                self._children_name_map["counter_hist_fail"] = "counter-hist-fail"
            return self.counter_hist_fail

        if (child_yang_name == "counters"):
            if (self.counters is None):
                self.counters = L2Tpv2.Counters()
                self.counters.parent = self
                self._children_name_map["counters"] = "counters"
            return self.counters

        if (child_yang_name == "session"):
            if (self.session is None):
                self.session = L2Tpv2.Session()
                self.session.parent = self
                self._children_name_map["session"] = "session"
            return self.session

        if (child_yang_name == "sessions"):
            if (self.sessions is None):
                self.sessions = L2Tpv2.Sessions()
                self.sessions.parent = self
                self._children_name_map["sessions"] = "sessions"
            return self.sessions

        if (child_yang_name == "statistics"):
            if (self.statistics is None):
                self.statistics = L2Tpv2.Statistics()
                self.statistics.parent = self
                self._children_name_map["statistics"] = "statistics"
            return self.statistics

        if (child_yang_name == "tunnel"):
            if (self.tunnel is None):
                self.tunnel = L2Tpv2.Tunnel()
                self.tunnel.parent = self
                self._children_name_map["tunnel"] = "tunnel"
            return self.tunnel

        if (child_yang_name == "tunnel-configurations"):
            if (self.tunnel_configurations is None):
                self.tunnel_configurations = L2Tpv2.TunnelConfigurations()
                self.tunnel_configurations.parent = self
                self._children_name_map["tunnel_configurations"] = "tunnel-configurations"
            return self.tunnel_configurations

        if (child_yang_name == "tunnels"):
            if (self.tunnels is None):
                self.tunnels = L2Tpv2.Tunnels()
                self.tunnels.parent = self
                self._children_name_map["tunnels"] = "tunnels"
            return self.tunnels

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "classes" or name == "counter-hist-fail" or name == "counters" or name == "session" or name == "sessions" or name == "statistics" or name == "tunnel" or name == "tunnel-configurations" or name == "tunnels"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = L2Tpv2()
        return self._top_entity

