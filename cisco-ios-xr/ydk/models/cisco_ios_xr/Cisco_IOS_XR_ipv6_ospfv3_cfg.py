""" Cisco_IOS_XR_ipv6_ospfv3_cfg 

This module contains a collection of YANG definitions
for Cisco IOS\-XR ipv6\-ospfv3 package configuration.

This module contains definitions
for the following management objects\:
  ospfv3\: OSPFv3 configuration

This YANG module augments the
  Cisco\-IOS\-XR\-snmp\-agent\-cfg
module with configuration data.

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class Ospfv3AddressFamily(Enum):
    """
    Ospfv3AddressFamily

    Ospfv3 address family

    .. data:: ipv6 = 1

    	IPv6 address family

    """

    ipv6 = Enum.YLeaf(1, "ipv6")


class Ospfv3Authentication(Enum):
    """
    Ospfv3Authentication

    Ospfv3 authentication

    .. data:: md5 = 1

    	MD5 algorithm

    .. data:: sha1 = 2

    	SHA1 algorithm

    """

    md5 = Enum.YLeaf(1, "md5")

    sha1 = Enum.YLeaf(2, "sha1")


class Ospfv3AuthenticationType2(Enum):
    """
    Ospfv3AuthenticationType2

    Ospfv3 authentication type2

    .. data:: null = 0

    	NULL authentication

    .. data:: md5 = 1

    	MD5 algorithm

    .. data:: sha1 = 2

    	SHA1 algorithm

    """

    null = Enum.YLeaf(0, "null")

    md5 = Enum.YLeaf(1, "md5")

    sha1 = Enum.YLeaf(2, "sha1")


class Ospfv3BfdEnableMode(Enum):
    """
    Ospfv3BfdEnableMode

    Ospfv3bfd enable mode

    .. data:: disable = 0

    	Disable Mode - Prevent inheritance

    .. data:: default = 1

    	Default Mode - Default BFD behavior

    .. data:: strict = 2

    	Strict Mode - Hold down adj until BFD sesion up

    """

    disable = Enum.YLeaf(0, "disable")

    default = Enum.YLeaf(1, "default")

    strict = Enum.YLeaf(2, "strict")


class Ospfv3DomainId(Enum):
    """
    Ospfv3DomainId

    Ospfv3 domain id

    .. data:: type0005 = 5

    	Type 0x0005

    .. data:: type0105 = 261

    	Type 0x0105

    .. data:: type0205 = 517

    	Type 0x0205

    .. data:: type8005 = 32773

    	Type 0x8005

    """

    type0005 = Enum.YLeaf(5, "type0005")

    type0105 = Enum.YLeaf(261, "type0105")

    type0205 = Enum.YLeaf(517, "type0205")

    type8005 = Enum.YLeaf(32773, "type8005")


class Ospfv3EigrpRoute(Enum):
    """
    Ospfv3EigrpRoute

    Ospfv3 eigrp route

    .. data:: internal = 16384

    	EIGRP internal routes

    .. data:: external = 32768

    	EIGRP external routes

    """

    internal = Enum.YLeaf(16384, "internal")

    external = Enum.YLeaf(32768, "external")


class Ospfv3EncryptionAlgorithm(Enum):
    """
    Ospfv3EncryptionAlgorithm

    Ospfv3 encryption algorithm

    .. data:: null = 0

    	Use NULL encryption

    .. data:: des = 1

    	Use the DES algorithm

    .. data:: Y_3des = 2

    	Use the triple DES algorithm

    .. data:: aes = 3

    	Use the AES algorithm

    .. data:: aes192 = 4

    	Use the 192-bit AES algorithm

    .. data:: aes256 = 5

    	Use the 256-bit AES algorithm

    """

    null = Enum.YLeaf(0, "null")

    des = Enum.YLeaf(1, "des")

    Y_3des = Enum.YLeaf(2, "3des")

    aes = Enum.YLeaf(3, "aes")

    aes192 = Enum.YLeaf(4, "aes192")

    aes256 = Enum.YLeaf(5, "aes256")


class Ospfv3ExternalRoute(Enum):
    """
    Ospfv3ExternalRoute

    Ospfv3 external route

    .. data:: external1 = 8

    	External type 1 routes

    .. data:: external2 = 16

    	External type 2 routes

    .. data:: external = 24

    	External (type 1 and 2) routes

    """

    external1 = Enum.YLeaf(8, "external1")

    external2 = Enum.YLeaf(16, "external2")

    external = Enum.YLeaf(24, "external")


class Ospfv3FastReroute(Enum):
    """
    Ospfv3FastReroute

    Ospfv3 fast reroute

    .. data:: none = 0

    	Disable

    .. data:: per_link = 1

    	Per link

    .. data:: per_prefix = 2

    	Per prefix

    """

    none = Enum.YLeaf(0, "none")

    per_link = Enum.YLeaf(1, "per-link")

    per_prefix = Enum.YLeaf(2, "per-prefix")


class Ospfv3FastReroutePriority(Enum):
    """
    Ospfv3FastReroutePriority

    Ospfv3 fast reroute priority

    .. data:: critical = 0

    	Critical

    .. data:: high = 1

    	High

    .. data:: medium = 2

    	Medium

    .. data:: low = 3

    	Low

    """

    critical = Enum.YLeaf(0, "critical")

    high = Enum.YLeaf(1, "high")

    medium = Enum.YLeaf(2, "medium")

    low = Enum.YLeaf(3, "low")


class Ospfv3FastRerouteTiebreakers(Enum):
    """
    Ospfv3FastRerouteTiebreakers

    Ospfv3 fast reroute tiebreakers

    .. data:: downstream = 0

    	Downstream

    .. data:: line_card_disjoint = 1

    	LC Disjoint

    .. data:: lowest_metric = 2

    	Lowest metric

    .. data:: node_protect = 3

    	Node protection

    .. data:: primary_path = 4

    	Primary path

    .. data:: secondary_path = 5

    	Secondar path

    .. data:: srlg_disjoint = 6

    	SRLG

    """

    downstream = Enum.YLeaf(0, "downstream")

    line_card_disjoint = Enum.YLeaf(1, "line-card-disjoint")

    lowest_metric = Enum.YLeaf(2, "lowest-metric")

    node_protect = Enum.YLeaf(3, "node-protect")

    primary_path = Enum.YLeaf(4, "primary-path")

    secondary_path = Enum.YLeaf(5, "secondary-path")

    srlg_disjoint = Enum.YLeaf(6, "srlg-disjoint")


class Ospfv3InternalRoute(Enum):
    """
    Ospfv3InternalRoute

    Ospfv3 internal route

    .. data:: internal = 6

    	OSPFv3 internal routes

    """

    internal = Enum.YLeaf(6, "internal")


class Ospfv3IsisRoute(Enum):
    """
    Ospfv3IsisRoute

    Ospfv3isis route

    .. data:: level1 = 64

    	IS-IS level-1 routes

    .. data:: level2 = 128

    	IS-IS level-2 routes

    .. data:: level1_and2 = 192

    	IS-IS level-1 and level-2 routes

    """

    level1 = Enum.YLeaf(64, "level1")

    level2 = Enum.YLeaf(128, "level2")

    level1_and2 = Enum.YLeaf(192, "level1-and2")


class Ospfv3LogAdj(Enum):
    """
    Ospfv3LogAdj

    Ospfv3 log adj

    .. data:: suppress = 0

    	No output

    .. data:: brief = 1

    	Limited output

    .. data:: detail = 2

    	Verbose output

    """

    suppress = Enum.YLeaf(0, "suppress")

    brief = Enum.YLeaf(1, "brief")

    detail = Enum.YLeaf(2, "detail")


class Ospfv3Metric(Enum):
    """
    Ospfv3Metric

    Ospfv3 metric

    .. data:: type1 = 1

    	OSPFv3 external type 1 metrics

    .. data:: type2 = 2

    	OSPFv3 external type 2 metrics

    """

    type1 = Enum.YLeaf(1, "type1")

    type2 = Enum.YLeaf(2, "type2")


class Ospfv3Network(Enum):
    """
    Ospfv3Network

    Ospfv3 network

    .. data:: broadcast = 1

    	Broadcast multi-access network

    .. data:: non_broadcast = 2

    	Non-broadcast multi-access network

    .. data:: point_to_point = 3

    	Point-to-point network

    .. data:: point_to_multipoint = 4

    	Point-to-multipoint network

    .. data:: non_broadcast_point_to_multipoint = 5

    	Non-broadcast point-to-multipoint network

    """

    broadcast = Enum.YLeaf(1, "broadcast")

    non_broadcast = Enum.YLeaf(2, "non-broadcast")

    point_to_point = Enum.YLeaf(3, "point-to-point")

    point_to_multipoint = Enum.YLeaf(4, "point-to-multipoint")

    non_broadcast_point_to_multipoint = Enum.YLeaf(5, "non-broadcast-point-to-multipoint")


class Ospfv3Nsr(Enum):
    """
    Ospfv3Nsr

    Ospfv3nsr

    .. data:: true = 1

    	Enable non-stop routing

    .. data:: false = 2

    	Disable non-stop routing

    """

    true = Enum.YLeaf(1, "true")

    false = Enum.YLeaf(2, "false")


class Ospfv3NssaExternalRoute(Enum):
    """
    Ospfv3NssaExternalRoute

    Ospfv3nssa external route

    .. data:: external1 = 4096

    	NSSA external type 1 routes

    .. data:: external2 = 8192

    	NSSA external type 2 routes

    .. data:: external = 12288

    	NSSA external (type 1 and 2) routes

    """

    external1 = Enum.YLeaf(4096, "external1")

    external2 = Enum.YLeaf(8192, "external2")

    external = Enum.YLeaf(12288, "external")


class Ospfv3Protocol(Enum):
    """
    Ospfv3Protocol

    Ospfv3 protocol

    .. data:: all = 0

    	All

    .. data:: connected = 1

    	Connected

    .. data:: static = 3

    	Static

    .. data:: bgp = 4

    	BGP

    .. data:: isis = 6

    	ISIS

    .. data:: ospfv3 = 7

    	OSPFv3

    .. data:: eigrp = 8

    	EIGRP

    """

    all = Enum.YLeaf(0, "all")

    connected = Enum.YLeaf(1, "connected")

    static = Enum.YLeaf(3, "static")

    bgp = Enum.YLeaf(4, "bgp")

    isis = Enum.YLeaf(6, "isis")

    ospfv3 = Enum.YLeaf(7, "ospfv3")

    eigrp = Enum.YLeaf(8, "eigrp")


class Ospfv3ProtocolType2(Enum):
    """
    Ospfv3ProtocolType2

    Ospfv3 protocol type2

    .. data:: connected = 1

    	Connected

    .. data:: static = 3

    	Static

    .. data:: bgp = 4

    	BGP

    .. data:: isis = 6

    	ISIS

    .. data:: ospfv3 = 7

    	OSPFv3

    .. data:: eigrp = 8

    	EIGRP

    .. data:: subscriber = 9

    	Subscriber

    .. data:: application = 10

    	Application

    .. data:: mobile = 11

    	Mobile

    """

    connected = Enum.YLeaf(1, "connected")

    static = Enum.YLeaf(3, "static")

    bgp = Enum.YLeaf(4, "bgp")

    isis = Enum.YLeaf(6, "isis")

    ospfv3 = Enum.YLeaf(7, "ospfv3")

    eigrp = Enum.YLeaf(8, "eigrp")

    subscriber = Enum.YLeaf(9, "subscriber")

    application = Enum.YLeaf(10, "application")

    mobile = Enum.YLeaf(11, "mobile")


class Ospfv3SubsequentAddressFamily(Enum):
    """
    Ospfv3SubsequentAddressFamily

    Ospfv3 subsequent address family

    .. data:: unicast = 1

    	Unicast subsequent address family

    """

    unicast = Enum.YLeaf(1, "unicast")


class TraceBufSize(Enum):
    """
    TraceBufSize

    Trace buf size

    .. data:: disable = 0

    	Disable trace

    .. data:: one = 256

    	trace buffer size 256

    .. data:: two = 512

    	trace buffer size 512

    .. data:: three = 1024

    	trace buffer size 1024

    .. data:: four = 2048

    	trace buffer size 2048

    .. data:: five = 4096

    	trace buffer size 4096

    .. data:: six = 8192

    	trace buffer size 8192

    .. data:: seven = 16384

    	trace buffer size 16384

    .. data:: eight = 32768

    	trace buffer size 32768

    .. data:: nine = 65536

    	trace buffer size 65536

    """

    disable = Enum.YLeaf(0, "disable")

    one = Enum.YLeaf(256, "one")

    two = Enum.YLeaf(512, "two")

    three = Enum.YLeaf(1024, "three")

    four = Enum.YLeaf(2048, "four")

    five = Enum.YLeaf(4096, "five")

    six = Enum.YLeaf(8192, "six")

    seven = Enum.YLeaf(16384, "seven")

    eight = Enum.YLeaf(32768, "eight")

    nine = Enum.YLeaf(65536, "nine")



class Ospfv3(Entity):
    """
    OSPFv3 configuration
    
    .. attribute:: dns_name_lookup
    
    	Enable OSPFv3 router IDs as DNS names
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: processes
    
    	OSPFv3 processes
    	**type**\:   :py:class:`Processes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes>`
    
    

    """

    _prefix = 'ipv6-ospfv3-cfg'
    _revision = '2015-11-09'

    def __init__(self):
        super(Ospfv3, self).__init__()
        self._top_entity = None

        self.yang_name = "ospfv3"
        self.yang_parent_name = "Cisco-IOS-XR-ipv6-ospfv3-cfg"

        self.dns_name_lookup = YLeaf(YType.empty, "dns-name-lookup")

        self.processes = Ospfv3.Processes()
        self.processes.parent = self
        self._children_name_map["processes"] = "processes"
        self._children_yang_names.add("processes")

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in ("dns_name_lookup") and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(Ospfv3, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(Ospfv3, self).__setattr__(name, value)


    class Processes(Entity):
        """
        OSPFv3 processes
        
        .. attribute:: process
        
        	An OSPFv3 process
        	**type**\: list of    :py:class:`Process <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process>`
        
        

        """

        _prefix = 'ipv6-ospfv3-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Ospfv3.Processes, self).__init__()

            self.yang_name = "processes"
            self.yang_parent_name = "ospfv3"

            self.process = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Ospfv3.Processes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Ospfv3.Processes, self).__setattr__(name, value)


        class Process(Entity):
            """
            An OSPFv3 process
            
            .. attribute:: process_name  <key>
            
            	OSPFv3 process name
            	**type**\:  str
            
            	**length:** 1..32
            
            .. attribute:: af
            
            	Address Family (AF)
            	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Af>`
            
            	**presence node**\: True
            
            .. attribute:: default_vrf
            
            	Default VRF related configuration
            	**type**\:   :py:class:`DefaultVrf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf>`
            
            .. attribute:: enable
            
            	Enable OSPFv3
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: nsr
            
            	Enable non\-stop routing
            	**type**\:   :py:class:`Ospfv3Nsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Nsr>`
            
            	**default value**\: true
            
            .. attribute:: protocol_shutdown
            
            	Enable protocol shutdown
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: trace_bufs
            
            	Configuration to change size of trace buffer
            	**type**\:   :py:class:`TraceBufs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.TraceBufs>`
            
            .. attribute:: vrfs
            
            	VRF related configuration
            	**type**\:   :py:class:`Vrfs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs>`
            
            

            """

            _prefix = 'ipv6-ospfv3-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Ospfv3.Processes.Process, self).__init__()

                self.yang_name = "process"
                self.yang_parent_name = "processes"

                self.process_name = YLeaf(YType.str, "process-name")

                self.enable = YLeaf(YType.empty, "enable")

                self.nsr = YLeaf(YType.enumeration, "nsr")

                self.protocol_shutdown = YLeaf(YType.empty, "protocol-shutdown")

                self.af = None
                self._children_name_map["af"] = "af"
                self._children_yang_names.add("af")

                self.default_vrf = Ospfv3.Processes.Process.DefaultVrf()
                self.default_vrf.parent = self
                self._children_name_map["default_vrf"] = "default-vrf"
                self._children_yang_names.add("default-vrf")

                self.trace_bufs = Ospfv3.Processes.Process.TraceBufs()
                self.trace_bufs.parent = self
                self._children_name_map["trace_bufs"] = "trace-bufs"
                self._children_yang_names.add("trace-bufs")

                self.vrfs = Ospfv3.Processes.Process.Vrfs()
                self.vrfs.parent = self
                self._children_name_map["vrfs"] = "vrfs"
                self._children_yang_names.add("vrfs")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("process_name",
                                "enable",
                                "nsr",
                                "protocol_shutdown") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Ospfv3.Processes.Process, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Ospfv3.Processes.Process, self).__setattr__(name, value)


            class DefaultVrf(Entity):
                """
                Default VRF related configuration
                
                .. attribute:: area_addresses
                
                	Area configuration
                	**type**\:   :py:class:`AreaAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses>`
                
                .. attribute:: authentication
                
                	Authenticate OSPFv3 packets
                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Authentication>`
                
                .. attribute:: auto_cost
                
                	Calculate interface cost according to bandwidth
                	**type**\:   :py:class:`AutoCost <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AutoCost>`
                
                	**presence node**\: True
                
                .. attribute:: bfd
                
                	Configure BFD parameters
                	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Bfd>`
                
                .. attribute:: cost
                
                	Interface cost
                	**type**\:  int
                
                	**range:** 1..65535
                
                .. attribute:: database_filter
                
                	Database filter
                	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter>`
                
                .. attribute:: dead_interval
                
                	Interval after which a neighbor is declared dead (in seconds)
                	**type**\:  int
                
                	**range:** 1..65535
                
                	**units**\: second
                
                .. attribute:: default_information
                
                	Control distribution of default information
                	**type**\:   :py:class:`DefaultInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DefaultInformation>`
                
                .. attribute:: default_metric
                
                	Set metric of redistributed routes
                	**type**\:  int
                
                	**range:** 1..16777214
                
                .. attribute:: demand_circuit
                
                	Enable/disable demand circuit operation
                	**type**\:  bool
                
                .. attribute:: distance
                
                	Define an administrative distance
                	**type**\:   :py:class:`Distance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Distance>`
                
                .. attribute:: distribute_list
                
                	Filter prefixes to/from RIB
                	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DistributeList>`
                
                .. attribute:: distribute_list_out
                
                	Filter prefixes from RIB 
                	**type**\:   :py:class:`DistributeListOut <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DistributeListOut>`
                
                .. attribute:: encryption
                
                	Encrypt and authenticate OSPFv3 packets
                	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Encryption>`
                
                .. attribute:: fast_reroute
                
                	Fast\-reroute instance scoped parameters
                	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.FastReroute>`
                
                .. attribute:: flood_reduction
                
                	Enable/disable flood reduction
                	**type**\:  bool
                
                .. attribute:: graceful_restart
                
                	Graceful restart configuration
                	**type**\:   :py:class:`GracefulRestart <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.GracefulRestart>`
                
                .. attribute:: hello_interval
                
                	Time between HELLO packets
                	**type**\:  int
                
                	**range:** 1..65535
                
                	**units**\: second
                
                .. attribute:: ignore
                
                	Do not complain about a specified event
                	**type**\:   :py:class:`Ignore <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Ignore>`
                
                .. attribute:: instance
                
                	Instance ID
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: ldp_sync
                
                	Enable/Disable MPLS LDP sync
                	**type**\:  bool
                
                .. attribute:: log_adjacency_changes
                
                	Log changes in adjacency state
                	**type**\:   :py:class:`Ospfv3LogAdj <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3LogAdj>`
                
                .. attribute:: maximum
                
                	Set OSPFv3 limits
                	**type**\:   :py:class:`Maximum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Maximum>`
                
                .. attribute:: mtu_ignore
                
                	Enable/disable ignoring of MTU in DBD packets
                	**type**\:  bool
                
                .. attribute:: network
                
                	Specify network type
                	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                
                .. attribute:: packet_size
                
                	Limit size of OSPFv3 packets
                	**type**\:  int
                
                	**range:** 256..10000
                
                .. attribute:: passive
                
                	Enable/disable routing updates on an interface
                	**type**\:  bool
                
                .. attribute:: prefix_suppression
                
                	Enable/disable prefix suppression on an interface
                	**type**\:  bool
                
                .. attribute:: priority
                
                	Specify router priority
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: process_scope
                
                	Process scope configuration
                	**type**\:   :py:class:`ProcessScope <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope>`
                
                .. attribute:: redistributes
                
                	Redistribute information from another routing protocol
                	**type**\:   :py:class:`Redistributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Redistributes>`
                
                .. attribute:: retransmit_interval
                
                	Specify the transmit interval in seconds
                	**type**\:  int
                
                	**range:** 1..65535
                
                	**units**\: second
                
                .. attribute:: router_id
                
                	Specify the router ID for this OSPFv3 process in IPv4 address format
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: snmp
                
                	SNMP configuration
                	**type**\:   :py:class:`Snmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Snmp>`
                
                .. attribute:: spf_prefix_priority_disable
                
                	SPF prefix prioritization disabled
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: spf_prefix_priority_policy
                
                	Route policy for SPF prefix prioritization
                	**type**\:  str
                
                .. attribute:: stub_router
                
                	Stub router configuration
                	**type**\:   :py:class:`StubRouter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.StubRouter>`
                
                .. attribute:: summary_prefixes
                
                	Summarize redistributed routes matching prefix/length
                	**type**\:   :py:class:`SummaryPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes>`
                
                .. attribute:: timers
                
                	Adjust routing timers
                	**type**\:   :py:class:`Timers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Timers>`
                
                .. attribute:: transmit_delay
                
                	Specify the transmit delay in seconds
                	**type**\:  int
                
                	**range:** 1..65535
                
                	**units**\: second
                
                

                """

                _prefix = 'ipv6-ospfv3-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Ospfv3.Processes.Process.DefaultVrf, self).__init__()

                    self.yang_name = "default-vrf"
                    self.yang_parent_name = "process"

                    self.cost = YLeaf(YType.uint32, "cost")

                    self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                    self.default_metric = YLeaf(YType.uint32, "default-metric")

                    self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                    self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                    self.instance = YLeaf(YType.uint32, "instance")

                    self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                    self.log_adjacency_changes = YLeaf(YType.enumeration, "log-adjacency-changes")

                    self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                    self.network = YLeaf(YType.enumeration, "network")

                    self.packet_size = YLeaf(YType.uint32, "packet-size")

                    self.passive = YLeaf(YType.boolean, "passive")

                    self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                    self.priority = YLeaf(YType.uint32, "priority")

                    self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                    self.router_id = YLeaf(YType.str, "router-id")

                    self.spf_prefix_priority_disable = YLeaf(YType.empty, "spf-prefix-priority-disable")

                    self.spf_prefix_priority_policy = YLeaf(YType.str, "spf-prefix-priority-policy")

                    self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                    self.area_addresses = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses()
                    self.area_addresses.parent = self
                    self._children_name_map["area_addresses"] = "area-addresses"
                    self._children_yang_names.add("area-addresses")

                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.Authentication()
                    self.authentication.parent = self
                    self._children_name_map["authentication"] = "authentication"
                    self._children_yang_names.add("authentication")

                    self.auto_cost = None
                    self._children_name_map["auto_cost"] = "auto-cost"
                    self._children_yang_names.add("auto-cost")

                    self.bfd = Ospfv3.Processes.Process.DefaultVrf.Bfd()
                    self.bfd.parent = self
                    self._children_name_map["bfd"] = "bfd"
                    self._children_yang_names.add("bfd")

                    self.database_filter = Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter()
                    self.database_filter.parent = self
                    self._children_name_map["database_filter"] = "database-filter"
                    self._children_yang_names.add("database-filter")

                    self.default_information = Ospfv3.Processes.Process.DefaultVrf.DefaultInformation()
                    self.default_information.parent = self
                    self._children_name_map["default_information"] = "default-information"
                    self._children_yang_names.add("default-information")

                    self.distance = Ospfv3.Processes.Process.DefaultVrf.Distance()
                    self.distance.parent = self
                    self._children_name_map["distance"] = "distance"
                    self._children_yang_names.add("distance")

                    self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.DistributeList()
                    self.distribute_list.parent = self
                    self._children_name_map["distribute_list"] = "distribute-list"
                    self._children_yang_names.add("distribute-list")

                    self.distribute_list_out = Ospfv3.Processes.Process.DefaultVrf.DistributeListOut()
                    self.distribute_list_out.parent = self
                    self._children_name_map["distribute_list_out"] = "distribute-list-out"
                    self._children_yang_names.add("distribute-list-out")

                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.Encryption()
                    self.encryption.parent = self
                    self._children_name_map["encryption"] = "encryption"
                    self._children_yang_names.add("encryption")

                    self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.FastReroute()
                    self.fast_reroute.parent = self
                    self._children_name_map["fast_reroute"] = "fast-reroute"
                    self._children_yang_names.add("fast-reroute")

                    self.graceful_restart = Ospfv3.Processes.Process.DefaultVrf.GracefulRestart()
                    self.graceful_restart.parent = self
                    self._children_name_map["graceful_restart"] = "graceful-restart"
                    self._children_yang_names.add("graceful-restart")

                    self.ignore = Ospfv3.Processes.Process.DefaultVrf.Ignore()
                    self.ignore.parent = self
                    self._children_name_map["ignore"] = "ignore"
                    self._children_yang_names.add("ignore")

                    self.maximum = Ospfv3.Processes.Process.DefaultVrf.Maximum()
                    self.maximum.parent = self
                    self._children_name_map["maximum"] = "maximum"
                    self._children_yang_names.add("maximum")

                    self.process_scope = Ospfv3.Processes.Process.DefaultVrf.ProcessScope()
                    self.process_scope.parent = self
                    self._children_name_map["process_scope"] = "process-scope"
                    self._children_yang_names.add("process-scope")

                    self.redistributes = Ospfv3.Processes.Process.DefaultVrf.Redistributes()
                    self.redistributes.parent = self
                    self._children_name_map["redistributes"] = "redistributes"
                    self._children_yang_names.add("redistributes")

                    self.snmp = Ospfv3.Processes.Process.DefaultVrf.Snmp()
                    self.snmp.parent = self
                    self._children_name_map["snmp"] = "snmp"
                    self._children_yang_names.add("snmp")

                    self.stub_router = Ospfv3.Processes.Process.DefaultVrf.StubRouter()
                    self.stub_router.parent = self
                    self._children_name_map["stub_router"] = "stub-router"
                    self._children_yang_names.add("stub-router")

                    self.summary_prefixes = Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes()
                    self.summary_prefixes.parent = self
                    self._children_name_map["summary_prefixes"] = "summary-prefixes"
                    self._children_yang_names.add("summary-prefixes")

                    self.timers = Ospfv3.Processes.Process.DefaultVrf.Timers()
                    self.timers.parent = self
                    self._children_name_map["timers"] = "timers"
                    self._children_yang_names.add("timers")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("cost",
                                    "dead_interval",
                                    "default_metric",
                                    "demand_circuit",
                                    "flood_reduction",
                                    "hello_interval",
                                    "instance",
                                    "ldp_sync",
                                    "log_adjacency_changes",
                                    "mtu_ignore",
                                    "network",
                                    "packet_size",
                                    "passive",
                                    "prefix_suppression",
                                    "priority",
                                    "retransmit_interval",
                                    "router_id",
                                    "spf_prefix_priority_disable",
                                    "spf_prefix_priority_policy",
                                    "transmit_delay") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Ospfv3.Processes.Process.DefaultVrf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Ospfv3.Processes.Process.DefaultVrf, self).__setattr__(name, value)


                class AreaAddresses(Entity):
                    """
                    Area configuration
                    
                    .. attribute:: area_address
                    
                    	Configuration for a particular area
                    	**type**\: list of    :py:class:`AreaAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress>`
                    
                    .. attribute:: area_area_id
                    
                    	Configuration for a particular area
                    	**type**\: list of    :py:class:`AreaAreaId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses, self).__init__()

                        self.yang_name = "area-addresses"
                        self.yang_parent_name = "default-vrf"

                        self.area_address = YList(self)
                        self.area_area_id = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses, self).__setattr__(name, value)


                    class AreaAddress(Entity):
                        """
                        Configuration for a particular area
                        
                        .. attribute:: address  <key>
                        
                        	Area ID if in IP address format
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: area_scope
                        
                        	Area Scope Configuration
                        	**type**\:   :py:class:`AreaScope <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope>`
                        
                        .. attribute:: authentication
                        
                        	Authenticate OSPFv3 packets
                        	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Authentication>`
                        
                        .. attribute:: bfd
                        
                        	Configure BFD parameters
                        	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Bfd>`
                        
                        .. attribute:: cost
                        
                        	Interface cost
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        .. attribute:: database_filter
                        
                        	Database filter
                        	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter>`
                        
                        .. attribute:: dead_interval
                        
                        	Interval after which a neighbor is declared dead (in seconds)
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: default_cost
                        
                        	Set the summary default\-cost of a NSSA/stub area
                        	**type**\:  int
                        
                        	**range:** 0..16777215
                        
                        .. attribute:: demand_circuit
                        
                        	Enable/disable demand circuit operation
                        	**type**\:  bool
                        
                        .. attribute:: distribute_list
                        
                        	Filter prefixes to/from RIB
                        	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList>`
                        
                        .. attribute:: enable
                        
                        	Enable OSPFv3 area
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: encryption
                        
                        	Encrypt and authenticate OSPFv3 packets
                        	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Encryption>`
                        
                        .. attribute:: flood_reduction
                        
                        	Enable/disable flood reduction
                        	**type**\:  bool
                        
                        .. attribute:: hello_interval
                        
                        	Time between HELLO packets
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: instance
                        
                        	Instance ID
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: interfaces
                        
                        	OSPFv3 interfaces
                        	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces>`
                        
                        .. attribute:: ldp_sync
                        
                        	Enable/Disable MPLS LDP sync
                        	**type**\:  bool
                        
                        .. attribute:: mtu_ignore
                        
                        	Enable/disable ignoring of MTU in DBD packets
                        	**type**\:  bool
                        
                        .. attribute:: network
                        
                        	Specify network type
                        	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                        
                        .. attribute:: nssa
                        
                        	Specify area as a NSSA area.  Allowed only in non\-backbone areas
                        	**type**\:   :py:class:`Nssa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Nssa>`
                        
                        .. attribute:: packet_size
                        
                        	Limit size of OSPFv3 packets
                        	**type**\:  int
                        
                        	**range:** 256..10000
                        
                        .. attribute:: passive
                        
                        	Enable/disable routing updates on an interface
                        	**type**\:  bool
                        
                        .. attribute:: prefix_suppression
                        
                        	Enable/disable prefix suppression on an interface
                        	**type**\:  bool
                        
                        .. attribute:: priority
                        
                        	Specify router priority
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ranges
                        
                        	Range configuration
                        	**type**\:   :py:class:`Ranges <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges>`
                        
                        .. attribute:: retransmit_interval
                        
                        	Specify the transmit interval in seconds
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: sham_links
                        
                        	Sham Link sub\-mode
                        	**type**\:   :py:class:`ShamLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks>`
                        
                        .. attribute:: stub
                        
                        	Specify area as a stub area.  Allowed only in non\-backbone areas
                        	**type**\:  bool
                        
                        .. attribute:: transmit_delay
                        
                        	Specify the transmit delay in seconds
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: virtual_links
                        
                        	Virtual link sub\-mode
                        	**type**\:   :py:class:`VirtualLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress, self).__init__()

                            self.yang_name = "area-address"
                            self.yang_parent_name = "area-addresses"

                            self.address = YLeaf(YType.str, "address")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                            self.default_cost = YLeaf(YType.uint32, "default-cost")

                            self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                            self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                            self.instance = YLeaf(YType.uint32, "instance")

                            self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                            self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                            self.network = YLeaf(YType.enumeration, "network")

                            self.packet_size = YLeaf(YType.uint32, "packet-size")

                            self.passive = YLeaf(YType.boolean, "passive")

                            self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                            self.priority = YLeaf(YType.uint32, "priority")

                            self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                            self.stub = YLeaf(YType.boolean, "stub")

                            self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                            self.area_scope = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope()
                            self.area_scope.parent = self
                            self._children_name_map["area_scope"] = "area-scope"
                            self._children_yang_names.add("area-scope")

                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Authentication()
                            self.authentication.parent = self
                            self._children_name_map["authentication"] = "authentication"
                            self._children_yang_names.add("authentication")

                            self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Bfd()
                            self.bfd.parent = self
                            self._children_name_map["bfd"] = "bfd"
                            self._children_yang_names.add("bfd")

                            self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter()
                            self.database_filter.parent = self
                            self._children_name_map["database_filter"] = "database-filter"
                            self._children_yang_names.add("database-filter")

                            self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList()
                            self.distribute_list.parent = self
                            self._children_name_map["distribute_list"] = "distribute-list"
                            self._children_yang_names.add("distribute-list")

                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Encryption()
                            self.encryption.parent = self
                            self._children_name_map["encryption"] = "encryption"
                            self._children_yang_names.add("encryption")

                            self.interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces()
                            self.interfaces.parent = self
                            self._children_name_map["interfaces"] = "interfaces"
                            self._children_yang_names.add("interfaces")

                            self.nssa = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Nssa()
                            self.nssa.parent = self
                            self._children_name_map["nssa"] = "nssa"
                            self._children_yang_names.add("nssa")

                            self.ranges = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges()
                            self.ranges.parent = self
                            self._children_name_map["ranges"] = "ranges"
                            self._children_yang_names.add("ranges")

                            self.sham_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks()
                            self.sham_links.parent = self
                            self._children_name_map["sham_links"] = "sham-links"
                            self._children_yang_names.add("sham-links")

                            self.virtual_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks()
                            self.virtual_links.parent = self
                            self._children_name_map["virtual_links"] = "virtual-links"
                            self._children_yang_names.add("virtual-links")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "cost",
                                            "dead_interval",
                                            "default_cost",
                                            "demand_circuit",
                                            "enable",
                                            "flood_reduction",
                                            "hello_interval",
                                            "instance",
                                            "ldp_sync",
                                            "mtu_ignore",
                                            "network",
                                            "packet_size",
                                            "passive",
                                            "prefix_suppression",
                                            "priority",
                                            "retransmit_interval",
                                            "stub",
                                            "transmit_delay") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress, self).__setattr__(name, value)


                        class Authentication(Entity):
                            """
                            Authenticate OSPFv3 packets
                            
                            .. attribute:: algorithm
                            
                            	Use the MD5 or SHA1 algorithm
                            	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                            
                            .. attribute:: enable
                            
                            	Authenticate packets
                            	**type**\:  bool
                            
                            .. attribute:: password
                            
                            	Specify MD5 or SHA1 password
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            .. attribute:: spi
                            
                            	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                            	**type**\:  int
                            
                            	**range:** 256..4294967295
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Authentication, self).__init__()

                                self.yang_name = "authentication"
                                self.yang_parent_name = "area-address"

                                self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.password = YLeaf(YType.str, "password")

                                self.spi = YLeaf(YType.uint32, "spi")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("algorithm",
                                                "enable",
                                                "password",
                                                "spi") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Authentication, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Authentication, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.algorithm.is_set or
                                    self.enable.is_set or
                                    self.password.is_set or
                                    self.spi.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.algorithm.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.password.yfilter != YFilter.not_set or
                                    self.spi.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "authentication" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.algorithm.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.password.get_name_leafdata())
                                if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.spi.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "algorithm"):
                                    self.algorithm = value
                                    self.algorithm.value_namespace = name_space
                                    self.algorithm.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "password"):
                                    self.password = value
                                    self.password.value_namespace = name_space
                                    self.password.value_namespace_prefix = name_space_prefix
                                if(value_path == "spi"):
                                    self.spi = value
                                    self.spi.value_namespace = name_space
                                    self.spi.value_namespace_prefix = name_space_prefix


                        class Bfd(Entity):
                            """
                            Configure BFD parameters
                            
                            .. attribute:: detection_multiplier
                            
                            	Detect multiplier
                            	**type**\:  int
                            
                            	**range:** 2..50
                            
                            .. attribute:: fast_detect_mode
                            
                            	Enable or disable BFD fast detection
                            	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                            
                            .. attribute:: interval
                            
                            	Hello interval in milli\-seconds
                            	**type**\:  int
                            
                            	**range:** 3..30000
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Bfd, self).__init__()

                                self.yang_name = "bfd"
                                self.yang_parent_name = "area-address"

                                self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("detection_multiplier",
                                                "fast_detect_mode",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Bfd, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Bfd, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.detection_multiplier.is_set or
                                    self.fast_detect_mode.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.detection_multiplier.yfilter != YFilter.not_set or
                                    self.fast_detect_mode.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bfd" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "detection-multiplier"):
                                    self.detection_multiplier = value
                                    self.detection_multiplier.value_namespace = name_space
                                    self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                if(value_path == "fast-detect-mode"):
                                    self.fast_detect_mode = value
                                    self.fast_detect_mode.value_namespace = name_space
                                    self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix


                        class Ranges(Entity):
                            """
                            Range configuration
                            
                            .. attribute:: range
                            
                            	Summarize inter\-area routes matching prefix/length
                            	**type**\: list of    :py:class:`Range <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges.Range>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges, self).__init__()

                                self.yang_name = "ranges"
                                self.yang_parent_name = "area-address"

                                self.range = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges, self).__setattr__(name, value)


                            class Range(Entity):
                                """
                                Summarize inter\-area routes matching
                                prefix/length
                                
                                .. attribute:: prefix  <key>
                                
                                	IPv6 prefix format
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: prefix_length  <key>
                                
                                	IPV6 prefix length
                                	**type**\:  int
                                
                                	**range:** 0..128
                                
                                .. attribute:: cost
                                
                                	Specified metric for this range
                                	**type**\:  int
                                
                                	**range:** 1..16777214
                                
                                .. attribute:: not_advertise
                                
                                	Do not advertise address range
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges.Range, self).__init__()

                                    self.yang_name = "range"
                                    self.yang_parent_name = "ranges"

                                    self.prefix = YLeaf(YType.str, "prefix")

                                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                    self.cost = YLeaf(YType.uint32, "cost")

                                    self.not_advertise = YLeaf(YType.boolean, "not-advertise")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix",
                                                    "prefix_length",
                                                    "cost",
                                                    "not_advertise") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges.Range, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges.Range, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.prefix.is_set or
                                        self.prefix_length.is_set or
                                        self.cost.is_set or
                                        self.not_advertise.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix.yfilter != YFilter.not_set or
                                        self.prefix_length.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.not_advertise.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "range" + "[prefix='" + self.prefix.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.not_advertise.is_set or self.not_advertise.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.not_advertise.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix" or name == "prefix-length" or name == "cost" or name == "not-advertise"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix"):
                                        self.prefix = value
                                        self.prefix.value_namespace = name_space
                                        self.prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-length"):
                                        self.prefix_length = value
                                        self.prefix_length.value_namespace = name_space
                                        self.prefix_length.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "not-advertise"):
                                        self.not_advertise = value
                                        self.not_advertise.value_namespace = name_space
                                        self.not_advertise.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.range:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.range:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ranges" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "range"):
                                    for c in self.range:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges.Range()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.range.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "range"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Encryption(Entity):
                            """
                            Encrypt and authenticate OSPFv3 packets
                            
                            .. attribute:: authentication_algorithm
                            
                            	Use the NULL, MD5 or SHA1 algorithm
                            	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                            
                            .. attribute:: authentication_password
                            
                            	Specify MD5 or SHA1 password
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            .. attribute:: enable
                            
                            	Authenticate packets
                            	**type**\:  bool
                            
                            .. attribute:: encryption_algorithm
                            
                            	Specify the encryption algorithm
                            	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                            
                            .. attribute:: encryption_password
                            
                            	Encryption password
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            .. attribute:: spi
                            
                            	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                            	**type**\:  int
                            
                            	**range:** 256..4294967295
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Encryption, self).__init__()

                                self.yang_name = "encryption"
                                self.yang_parent_name = "area-address"

                                self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                self.authentication_password = YLeaf(YType.str, "authentication-password")

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                self.encryption_password = YLeaf(YType.str, "encryption-password")

                                self.spi = YLeaf(YType.uint32, "spi")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("authentication_algorithm",
                                                "authentication_password",
                                                "enable",
                                                "encryption_algorithm",
                                                "encryption_password",
                                                "spi") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Encryption, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Encryption, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.authentication_algorithm.is_set or
                                    self.authentication_password.is_set or
                                    self.enable.is_set or
                                    self.encryption_algorithm.is_set or
                                    self.encryption_password.is_set or
                                    self.spi.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.authentication_algorithm.yfilter != YFilter.not_set or
                                    self.authentication_password.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.encryption_algorithm.yfilter != YFilter.not_set or
                                    self.encryption_password.yfilter != YFilter.not_set or
                                    self.spi.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "encryption" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.spi.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "authentication-algorithm"):
                                    self.authentication_algorithm = value
                                    self.authentication_algorithm.value_namespace = name_space
                                    self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                if(value_path == "authentication-password"):
                                    self.authentication_password = value
                                    self.authentication_password.value_namespace = name_space
                                    self.authentication_password.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "encryption-algorithm"):
                                    self.encryption_algorithm = value
                                    self.encryption_algorithm.value_namespace = name_space
                                    self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                if(value_path == "encryption-password"):
                                    self.encryption_password = value
                                    self.encryption_password.value_namespace = name_space
                                    self.encryption_password.value_namespace_prefix = name_space_prefix
                                if(value_path == "spi"):
                                    self.spi = value
                                    self.spi.value_namespace = name_space
                                    self.spi.value_namespace_prefix = name_space_prefix


                        class Nssa(Entity):
                            """
                            Specify area as a NSSA area.  Allowed only in
                            non\-backbone areas
                            
                            .. attribute:: default_info_originate
                            
                            	Originate Type 7 default into NSSA area
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: metric
                            
                            	Only valid with DefaultInfoOriginate
                            	**type**\:  int
                            
                            	**range:** 0..16777214
                            
                            .. attribute:: metric_type
                            
                            	Only valid with DefaultInfoOriginate
                            	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                            
                            .. attribute:: no_redistribution
                            
                            	No redistribution into this NSSA area
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: no_summary
                            
                            	Do not send summary LSA into NSSA
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Nssa, self).__init__()

                                self.yang_name = "nssa"
                                self.yang_parent_name = "area-address"

                                self.default_info_originate = YLeaf(YType.boolean, "default-info-originate")

                                self.metric = YLeaf(YType.uint32, "metric")

                                self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                self.no_redistribution = YLeaf(YType.boolean, "no-redistribution")

                                self.no_summary = YLeaf(YType.empty, "no-summary")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_info_originate",
                                                "metric",
                                                "metric_type",
                                                "no_redistribution",
                                                "no_summary") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Nssa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Nssa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.default_info_originate.is_set or
                                    self.metric.is_set or
                                    self.metric_type.is_set or
                                    self.no_redistribution.is_set or
                                    self.no_summary.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_info_originate.yfilter != YFilter.not_set or
                                    self.metric.yfilter != YFilter.not_set or
                                    self.metric_type.yfilter != YFilter.not_set or
                                    self.no_redistribution.yfilter != YFilter.not_set or
                                    self.no_summary.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "nssa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_info_originate.is_set or self.default_info_originate.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_info_originate.get_name_leafdata())
                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric.get_name_leafdata())
                                if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric_type.get_name_leafdata())
                                if (self.no_redistribution.is_set or self.no_redistribution.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.no_redistribution.get_name_leafdata())
                                if (self.no_summary.is_set or self.no_summary.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.no_summary.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-info-originate" or name == "metric" or name == "metric-type" or name == "no-redistribution" or name == "no-summary"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-info-originate"):
                                    self.default_info_originate = value
                                    self.default_info_originate.value_namespace = name_space
                                    self.default_info_originate.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric"):
                                    self.metric = value
                                    self.metric.value_namespace = name_space
                                    self.metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric-type"):
                                    self.metric_type = value
                                    self.metric_type.value_namespace = name_space
                                    self.metric_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "no-redistribution"):
                                    self.no_redistribution = value
                                    self.no_redistribution.value_namespace = name_space
                                    self.no_redistribution.value_namespace_prefix = name_space_prefix
                                if(value_path == "no-summary"):
                                    self.no_summary = value
                                    self.no_summary.value_namespace = name_space
                                    self.no_summary.value_namespace_prefix = name_space_prefix


                        class DatabaseFilter(Entity):
                            """
                            Database filter
                            
                            .. attribute:: all
                            
                            	All
                            	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter.All>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter, self).__init__()

                                self.yang_name = "database-filter"
                                self.yang_parent_name = "area-address"

                                self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter.All()
                                self.all.parent = self
                                self._children_name_map["all"] = "all"
                                self._children_yang_names.add("all")


                            class All(Entity):
                                """
                                All
                                
                                .. attribute:: out
                                
                                	Enable or disable database\-filter
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter.All, self).__init__()

                                    self.yang_name = "all"
                                    self.yang_parent_name = "database-filter"

                                    self.out = YLeaf(YType.boolean, "out")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("out") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter.All, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter.All, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.out.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.out.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "all" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.out.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "out"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "out"):
                                        self.out = value
                                        self.out.value_namespace = name_space
                                        self.out.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (self.all is not None and self.all.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.all is not None and self.all.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "database-filter" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "all"):
                                    if (self.all is None):
                                        self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter.All()
                                        self.all.parent = self
                                        self._children_name_map["all"] = "all"
                                    return self.all

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "all"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class DistributeList(Entity):
                            """
                            Filter prefixes to/from RIB
                            
                            .. attribute:: in_
                            
                            	Filter prefixes installed to RIB
                            	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList.In_>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList, self).__init__()

                                self.yang_name = "distribute-list"
                                self.yang_parent_name = "area-address"

                                self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList.In_()
                                self.in_.parent = self
                                self._children_name_map["in_"] = "in"
                                self._children_yang_names.add("in")


                            class In_(Entity):
                                """
                                Filter prefixes installed to RIB
                                
                                .. attribute:: prefix_list
                                
                                	Filter prefixes based on an IPv6 prefix\-list
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList.In_, self).__init__()

                                    self.yang_name = "in"
                                    self.yang_parent_name = "distribute-list"

                                    self.prefix_list = YLeaf(YType.str, "prefix-list")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix_list") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList.In_, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList.In_, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.prefix_list.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix_list.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "in" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix-list"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix-list"):
                                        self.prefix_list = value
                                        self.prefix_list.value_namespace = name_space
                                        self.prefix_list.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (self.in_ is not None and self.in_.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.in_ is not None and self.in_.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "distribute-list" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "in"):
                                    if (self.in_ is None):
                                        self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList.In_()
                                        self.in_.parent = self
                                        self._children_name_map["in_"] = "in"
                                    return self.in_

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "in"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Interfaces(Entity):
                            """
                            OSPFv3 interfaces
                            
                            .. attribute:: interface
                            
                            	OSPFv3 interface
                            	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces, self).__init__()

                                self.yang_name = "interfaces"
                                self.yang_parent_name = "area-address"

                                self.interface = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces, self).__setattr__(name, value)


                            class Interface(Entity):
                                """
                                OSPFv3 interface
                                
                                .. attribute:: interface_name  <key>
                                
                                	Interface to configure
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: authentication
                                
                                	Authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication>`
                                
                                .. attribute:: bfd
                                
                                	Configure BFD parameters
                                	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd>`
                                
                                .. attribute:: cost
                                
                                	Interface cost
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: database_filter
                                
                                	Database filter
                                	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter>`
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead (in seconds)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: demand_circuit
                                
                                	Enable/disable demand circuit operation
                                	**type**\:  bool
                                
                                .. attribute:: distribute_list
                                
                                	Filter prefixes to/from RIB
                                	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList>`
                                
                                .. attribute:: enable
                                
                                	Enable OSPFv3 interface
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: encryption
                                
                                	Encrypt and authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption>`
                                
                                .. attribute:: fast_reroute
                                
                                	Fast\-reroute configuration
                                	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute>`
                                
                                .. attribute:: flood_reduction
                                
                                	Enable/disable flood reduction
                                	**type**\:  bool
                                
                                .. attribute:: hello_interval
                                
                                	Time between HELLO packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: instance
                                
                                	Instance ID
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: ldp_sync
                                
                                	Enable/Disable MPLS LDP sync
                                	**type**\:  bool
                                
                                .. attribute:: mtu_ignore
                                
                                	Enable/disable ignoring of MTU in DBD packets
                                	**type**\:  bool
                                
                                .. attribute:: neighbors
                                
                                	Specify a neighbor router
                                	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors>`
                                
                                .. attribute:: network
                                
                                	Specify network type
                                	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                                
                                .. attribute:: packet_size
                                
                                	Limit size of OSPFv3 packets
                                	**type**\:  int
                                
                                	**range:** 256..10000
                                
                                .. attribute:: passive
                                
                                	Enable/disable routing updates on an interface
                                	**type**\:  bool
                                
                                .. attribute:: prefix_suppression
                                
                                	Enable/disable prefix suppression on an interface
                                	**type**\:  bool
                                
                                .. attribute:: priority
                                
                                	Specify router priority
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: retransmit_interval
                                
                                	Specify the transmit interval in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: transmit_delay
                                
                                	Specify the transmit delay in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface, self).__init__()

                                    self.yang_name = "interface"
                                    self.yang_parent_name = "interfaces"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.cost = YLeaf(YType.uint32, "cost")

                                    self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                    self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                    self.instance = YLeaf(YType.uint32, "instance")

                                    self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                                    self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                    self.network = YLeaf(YType.enumeration, "network")

                                    self.packet_size = YLeaf(YType.uint32, "packet-size")

                                    self.passive = YLeaf(YType.boolean, "passive")

                                    self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                    self.priority = YLeaf(YType.uint32, "priority")

                                    self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd()
                                    self.bfd.parent = self
                                    self._children_name_map["bfd"] = "bfd"
                                    self._children_yang_names.add("bfd")

                                    self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter()
                                    self.database_filter.parent = self
                                    self._children_name_map["database_filter"] = "database-filter"
                                    self._children_yang_names.add("database-filter")

                                    self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList()
                                    self.distribute_list.parent = self
                                    self._children_name_map["distribute_list"] = "distribute-list"
                                    self._children_yang_names.add("distribute-list")

                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                    self._children_yang_names.add("encryption")

                                    self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                    self._children_yang_names.add("fast-reroute")

                                    self.neighbors = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors()
                                    self.neighbors.parent = self
                                    self._children_name_map["neighbors"] = "neighbors"
                                    self._children_yang_names.add("neighbors")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name",
                                                    "cost",
                                                    "dead_interval",
                                                    "demand_circuit",
                                                    "enable",
                                                    "flood_reduction",
                                                    "hello_interval",
                                                    "instance",
                                                    "ldp_sync",
                                                    "mtu_ignore",
                                                    "network",
                                                    "packet_size",
                                                    "passive",
                                                    "prefix_suppression",
                                                    "priority",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface, self).__setattr__(name, value)


                                class Authentication(Entity):
                                    """
                                    Authenticate OSPFv3 packets
                                    
                                    .. attribute:: algorithm
                                    
                                    	Use the MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "interface"

                                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.password = YLeaf(YType.str, "password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("algorithm",
                                                        "enable",
                                                        "password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.algorithm.is_set or
                                            self.enable.is_set or
                                            self.password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.algorithm.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "algorithm"):
                                            self.algorithm = value
                                            self.algorithm.value_namespace = name_space
                                            self.algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "password"):
                                            self.password = value
                                            self.password.value_namespace = name_space
                                            self.password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Neighbors(Entity):
                                    """
                                    Specify a neighbor router
                                    
                                    .. attribute:: neighbor
                                    
                                    	IPv6 address
                                    	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors, self).__init__()

                                        self.yang_name = "neighbors"
                                        self.yang_parent_name = "interface"

                                        self.neighbor = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors, self).__setattr__(name, value)


                                    class Neighbor(Entity):
                                        """
                                        IPv6 address
                                        
                                        .. attribute:: neighbor_address  <key>
                                        
                                        	IPV6 address
                                        	**type**\:  str
                                        
                                        	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                        
                                        .. attribute:: cost
                                        
                                        	OSPFv3 cost for point\-to\-multipoint neighbor
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: database_filter
                                        
                                        	Filter OSPFv3 LSA during synchronization and flooding for point\-to\-multipoint neighbor
                                        	**type**\:  bool
                                        
                                        .. attribute:: poll_interval
                                        
                                        	OSPFv3 dead\-router polling interval (in seconds)
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**units**\: second
                                        
                                        .. attribute:: priority
                                        
                                        	OSPFv3 priority of non\-broadcast neighbor
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: zone
                                        
                                        	Zone
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor, self).__init__()

                                            self.yang_name = "neighbor"
                                            self.yang_parent_name = "neighbors"

                                            self.neighbor_address = YLeaf(YType.str, "neighbor-address")

                                            self.cost = YLeaf(YType.uint32, "cost")

                                            self.database_filter = YLeaf(YType.boolean, "database-filter")

                                            self.poll_interval = YLeaf(YType.uint32, "poll-interval")

                                            self.priority = YLeaf(YType.uint32, "priority")

                                            self.zone = YLeaf(YType.str, "zone")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("neighbor_address",
                                                            "cost",
                                                            "database_filter",
                                                            "poll_interval",
                                                            "priority",
                                                            "zone") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.neighbor_address.is_set or
                                                self.cost.is_set or
                                                self.database_filter.is_set or
                                                self.poll_interval.is_set or
                                                self.priority.is_set or
                                                self.zone.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.neighbor_address.yfilter != YFilter.not_set or
                                                self.cost.yfilter != YFilter.not_set or
                                                self.database_filter.yfilter != YFilter.not_set or
                                                self.poll_interval.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set or
                                                self.zone.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "neighbor" + "[neighbor-address='" + self.neighbor_address.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.neighbor_address.is_set or self.neighbor_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.neighbor_address.get_name_leafdata())
                                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.cost.get_name_leafdata())
                                            if (self.database_filter.is_set or self.database_filter.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.database_filter.get_name_leafdata())
                                            if (self.poll_interval.is_set or self.poll_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.poll_interval.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())
                                            if (self.zone.is_set or self.zone.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.zone.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "neighbor-address" or name == "cost" or name == "database-filter" or name == "poll-interval" or name == "priority" or name == "zone"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "neighbor-address"):
                                                self.neighbor_address = value
                                                self.neighbor_address.value_namespace = name_space
                                                self.neighbor_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "cost"):
                                                self.cost = value
                                                self.cost.value_namespace = name_space
                                                self.cost.value_namespace_prefix = name_space_prefix
                                            if(value_path == "database-filter"):
                                                self.database_filter = value
                                                self.database_filter.value_namespace = name_space
                                                self.database_filter.value_namespace_prefix = name_space_prefix
                                            if(value_path == "poll-interval"):
                                                self.poll_interval = value
                                                self.poll_interval.value_namespace = name_space
                                                self.poll_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "zone"):
                                                self.zone = value
                                                self.zone.value_namespace = name_space
                                                self.zone.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.neighbor:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.neighbor:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "neighbors" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "neighbor"):
                                            for c in self.neighbor:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.neighbor.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "neighbor"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class Encryption(Entity):
                                    """
                                    Encrypt and authenticate OSPFv3 packets
                                    
                                    .. attribute:: authentication_algorithm
                                    
                                    	Use the NULL, MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                    
                                    .. attribute:: authentication_password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: encryption_algorithm
                                    
                                    	Specify the encryption algorithm
                                    	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                    
                                    .. attribute:: encryption_password
                                    
                                    	Encryption password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption, self).__init__()

                                        self.yang_name = "encryption"
                                        self.yang_parent_name = "interface"

                                        self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                        self.authentication_password = YLeaf(YType.str, "authentication-password")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                        self.encryption_password = YLeaf(YType.str, "encryption-password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("authentication_algorithm",
                                                        "authentication_password",
                                                        "enable",
                                                        "encryption_algorithm",
                                                        "encryption_password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.authentication_algorithm.is_set or
                                            self.authentication_password.is_set or
                                            self.enable.is_set or
                                            self.encryption_algorithm.is_set or
                                            self.encryption_password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.authentication_algorithm.yfilter != YFilter.not_set or
                                            self.authentication_password.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.encryption_algorithm.yfilter != YFilter.not_set or
                                            self.encryption_password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "encryption" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                        if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                        if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "authentication-algorithm"):
                                            self.authentication_algorithm = value
                                            self.authentication_algorithm.value_namespace = name_space
                                            self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "authentication-password"):
                                            self.authentication_password = value
                                            self.authentication_password.value_namespace = name_space
                                            self.authentication_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-algorithm"):
                                            self.encryption_algorithm = value
                                            self.encryption_algorithm.value_namespace = name_space
                                            self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-password"):
                                            self.encryption_password = value
                                            self.encryption_password.value_namespace = name_space
                                            self.encryption_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Bfd(Entity):
                                    """
                                    Configure BFD parameters
                                    
                                    .. attribute:: detection_multiplier
                                    
                                    	Detect multiplier
                                    	**type**\:  int
                                    
                                    	**range:** 2..50
                                    
                                    .. attribute:: fast_detect_mode
                                    
                                    	Enable or disable BFD fast detection
                                    	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                                    
                                    .. attribute:: interval
                                    
                                    	Hello interval in milli\-seconds
                                    	**type**\:  int
                                    
                                    	**range:** 3..30000
                                    
                                    	**units**\: millisecond
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd, self).__init__()

                                        self.yang_name = "bfd"
                                        self.yang_parent_name = "interface"

                                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                        self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                        self.interval = YLeaf(YType.uint32, "interval")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("detection_multiplier",
                                                        "fast_detect_mode",
                                                        "interval") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.detection_multiplier.is_set or
                                            self.fast_detect_mode.is_set or
                                            self.interval.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.detection_multiplier.yfilter != YFilter.not_set or
                                            self.fast_detect_mode.yfilter != YFilter.not_set or
                                            self.interval.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bfd" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                        if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interval.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "detection-multiplier"):
                                            self.detection_multiplier = value
                                            self.detection_multiplier.value_namespace = name_space
                                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fast-detect-mode"):
                                            self.fast_detect_mode = value
                                            self.fast_detect_mode.value_namespace = name_space
                                            self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                        if(value_path == "interval"):
                                            self.interval = value
                                            self.interval.value_namespace = name_space
                                            self.interval.value_namespace_prefix = name_space_prefix


                                class DatabaseFilter(Entity):
                                    """
                                    Database filter
                                    
                                    .. attribute:: all
                                    
                                    	All
                                    	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter, self).__init__()

                                        self.yang_name = "database-filter"
                                        self.yang_parent_name = "interface"

                                        self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All()
                                        self.all.parent = self
                                        self._children_name_map["all"] = "all"
                                        self._children_yang_names.add("all")


                                    class All(Entity):
                                        """
                                        All
                                        
                                        .. attribute:: out
                                        
                                        	Enable or disable database\-filter
                                        	**type**\:  bool
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All, self).__init__()

                                            self.yang_name = "all"
                                            self.yang_parent_name = "database-filter"

                                            self.out = YLeaf(YType.boolean, "out")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("out") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.out.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.out.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "all" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.out.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "out"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "out"):
                                                self.out = value
                                                self.out.value_namespace = name_space
                                                self.out.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.all is not None and self.all.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.all is not None and self.all.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "database-filter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "all"):
                                            if (self.all is None):
                                                self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All()
                                                self.all.parent = self
                                                self._children_name_map["all"] = "all"
                                            return self.all

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "all"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class DistributeList(Entity):
                                    """
                                    Filter prefixes to/from RIB
                                    
                                    .. attribute:: in_
                                    
                                    	Filter prefixes installed to RIB
                                    	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList, self).__init__()

                                        self.yang_name = "distribute-list"
                                        self.yang_parent_name = "interface"

                                        self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_()
                                        self.in_.parent = self
                                        self._children_name_map["in_"] = "in"
                                        self._children_yang_names.add("in")


                                    class In_(Entity):
                                        """
                                        Filter prefixes installed to RIB
                                        
                                        .. attribute:: prefix_list
                                        
                                        	Filter prefixes based on an IPv6 prefix\-list
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_, self).__init__()

                                            self.yang_name = "in"
                                            self.yang_parent_name = "distribute-list"

                                            self.prefix_list = YLeaf(YType.str, "prefix-list")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("prefix_list") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.prefix_list.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.prefix_list.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "in" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "prefix-list"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "prefix-list"):
                                                self.prefix_list = value
                                                self.prefix_list.value_namespace = name_space
                                                self.prefix_list.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.in_ is not None and self.in_.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.in_ is not None and self.in_.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "distribute-list" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "in"):
                                            if (self.in_ is None):
                                                self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_()
                                                self.in_.parent = self
                                                self._children_name_map["in_"] = "in"
                                            return self.in_

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "in"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class FastReroute(Entity):
                                    """
                                    Fast\-reroute configuration
                                    
                                    .. attribute:: fast_reroute_enable
                                    
                                    	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                    	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                    
                                    .. attribute:: per_link
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink>`
                                    
                                    .. attribute:: per_prefix
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute, self).__init__()

                                        self.yang_name = "fast-reroute"
                                        self.yang_parent_name = "interface"

                                        self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                        self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink()
                                        self.per_link.parent = self
                                        self._children_name_map["per_link"] = "per-link"
                                        self._children_yang_names.add("per-link")

                                        self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix()
                                        self.per_prefix.parent = self
                                        self._children_name_map["per_prefix"] = "per-prefix"
                                        self._children_yang_names.add("per-prefix")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_enable") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute, self).__setattr__(name, value)


                                    class PerLink(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink, self).__init__()

                                            self.yang_name = "per-link"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-link" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                    class PerPrefix(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix, self).__init__()

                                            self.yang_name = "per-prefix"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-prefix" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_enable.is_set or
                                            (self.per_link is not None and self.per_link.has_data()) or
                                            (self.per_prefix is not None and self.per_prefix.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_enable.yfilter != YFilter.not_set or
                                            (self.per_link is not None and self.per_link.has_operation()) or
                                            (self.per_prefix is not None and self.per_prefix.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fast-reroute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "per-link"):
                                            if (self.per_link is None):
                                                self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink()
                                                self.per_link.parent = self
                                                self._children_name_map["per_link"] = "per-link"
                                            return self.per_link

                                        if (child_yang_name == "per-prefix"):
                                            if (self.per_prefix is None):
                                                self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix()
                                                self.per_prefix.parent = self
                                                self._children_name_map["per_prefix"] = "per-prefix"
                                            return self.per_prefix

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-enable"):
                                            self.fast_reroute_enable = value
                                            self.fast_reroute_enable.value_namespace = name_space
                                            self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.interface_name.is_set or
                                        self.cost.is_set or
                                        self.dead_interval.is_set or
                                        self.demand_circuit.is_set or
                                        self.enable.is_set or
                                        self.flood_reduction.is_set or
                                        self.hello_interval.is_set or
                                        self.instance.is_set or
                                        self.ldp_sync.is_set or
                                        self.mtu_ignore.is_set or
                                        self.network.is_set or
                                        self.packet_size.is_set or
                                        self.passive.is_set or
                                        self.prefix_suppression.is_set or
                                        self.priority.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.bfd is not None and self.bfd.has_data()) or
                                        (self.database_filter is not None and self.database_filter.has_data()) or
                                        (self.distribute_list is not None and self.distribute_list.has_data()) or
                                        (self.encryption is not None and self.encryption.has_data()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                                        (self.neighbors is not None and self.neighbors.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.demand_circuit.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.flood_reduction.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.instance.yfilter != YFilter.not_set or
                                        self.ldp_sync.yfilter != YFilter.not_set or
                                        self.mtu_ignore.yfilter != YFilter.not_set or
                                        self.network.yfilter != YFilter.not_set or
                                        self.packet_size.yfilter != YFilter.not_set or
                                        self.passive.yfilter != YFilter.not_set or
                                        self.prefix_suppression.yfilter != YFilter.not_set or
                                        self.priority.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.bfd is not None and self.bfd.has_operation()) or
                                        (self.database_filter is not None and self.database_filter.has_operation()) or
                                        (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                        (self.encryption is not None and self.encryption.has_operation()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                                        (self.neighbors is not None and self.neighbors.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.instance.get_name_leafdata())
                                    if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                                    if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                    if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.network.get_name_leafdata())
                                    if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.packet_size.get_name_leafdata())
                                    if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.passive.get_name_leafdata())
                                    if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                    if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.priority.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "bfd"):
                                        if (self.bfd is None):
                                            self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd()
                                            self.bfd.parent = self
                                            self._children_name_map["bfd"] = "bfd"
                                        return self.bfd

                                    if (child_yang_name == "database-filter"):
                                        if (self.database_filter is None):
                                            self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter()
                                            self.database_filter.parent = self
                                            self._children_name_map["database_filter"] = "database-filter"
                                        return self.database_filter

                                    if (child_yang_name == "distribute-list"):
                                        if (self.distribute_list is None):
                                            self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList()
                                            self.distribute_list.parent = self
                                            self._children_name_map["distribute_list"] = "distribute-list"
                                        return self.distribute_list

                                    if (child_yang_name == "encryption"):
                                        if (self.encryption is None):
                                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption()
                                            self.encryption.parent = self
                                            self._children_name_map["encryption"] = "encryption"
                                        return self.encryption

                                    if (child_yang_name == "fast-reroute"):
                                        if (self.fast_reroute is None):
                                            self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute()
                                            self.fast_reroute.parent = self
                                            self._children_name_map["fast_reroute"] = "fast-reroute"
                                        return self.fast_reroute

                                    if (child_yang_name == "neighbors"):
                                        if (self.neighbors is None):
                                            self.neighbors = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors()
                                            self.neighbors.parent = self
                                            self._children_name_map["neighbors"] = "neighbors"
                                        return self.neighbors

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "fast-reroute" or name == "neighbors" or name == "interface-name" or name == "cost" or name == "dead-interval" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "demand-circuit"):
                                        self.demand_circuit = value
                                        self.demand_circuit.value_namespace = name_space
                                        self.demand_circuit.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "flood-reduction"):
                                        self.flood_reduction = value
                                        self.flood_reduction.value_namespace = name_space
                                        self.flood_reduction.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "instance"):
                                        self.instance = value
                                        self.instance.value_namespace = name_space
                                        self.instance.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ldp-sync"):
                                        self.ldp_sync = value
                                        self.ldp_sync.value_namespace = name_space
                                        self.ldp_sync.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mtu-ignore"):
                                        self.mtu_ignore = value
                                        self.mtu_ignore.value_namespace = name_space
                                        self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                    if(value_path == "network"):
                                        self.network = value
                                        self.network.value_namespace = name_space
                                        self.network.value_namespace_prefix = name_space_prefix
                                    if(value_path == "packet-size"):
                                        self.packet_size = value
                                        self.packet_size.value_namespace = name_space
                                        self.packet_size.value_namespace_prefix = name_space_prefix
                                    if(value_path == "passive"):
                                        self.passive = value
                                        self.passive.value_namespace = name_space
                                        self.passive.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-suppression"):
                                        self.prefix_suppression = value
                                        self.prefix_suppression.value_namespace = name_space
                                        self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                    if(value_path == "priority"):
                                        self.priority = value
                                        self.priority.value_namespace = name_space
                                        self.priority.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.interface:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.interface:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interfaces" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "interface"):
                                    for c in self.interface:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces.Interface()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.interface.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class AreaScope(Entity):
                            """
                            Area Scope Configuration
                            
                            .. attribute:: fast_reroute
                            
                            	Fast\-reroute configuration
                            	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope, self).__init__()

                                self.yang_name = "area-scope"
                                self.yang_parent_name = "area-address"

                                self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute()
                                self.fast_reroute.parent = self
                                self._children_name_map["fast_reroute"] = "fast-reroute"
                                self._children_yang_names.add("fast-reroute")


                            class FastReroute(Entity):
                                """
                                Fast\-reroute configuration
                                
                                .. attribute:: fast_reroute_enable
                                
                                	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                
                                .. attribute:: per_link
                                
                                	Fast\-reroute per\-link configuration
                                	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink>`
                                
                                .. attribute:: per_prefix
                                
                                	Fast\-reroute per\-link configuration
                                	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute, self).__init__()

                                    self.yang_name = "fast-reroute"
                                    self.yang_parent_name = "area-scope"

                                    self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                    self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink()
                                    self.per_link.parent = self
                                    self._children_name_map["per_link"] = "per-link"
                                    self._children_yang_names.add("per-link")

                                    self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix()
                                    self.per_prefix.parent = self
                                    self._children_name_map["per_prefix"] = "per-prefix"
                                    self._children_yang_names.add("per-prefix")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fast_reroute_enable") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute, self).__setattr__(name, value)


                                class PerLink(Entity):
                                    """
                                    Fast\-reroute per\-link configuration
                                    
                                    .. attribute:: candidate_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                    	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces>`
                                    
                                    .. attribute:: exclude_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                    	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces>`
                                    
                                    .. attribute:: fast_reroute_use_candidate_only
                                    
                                    	Use only interfaces on the candidate list as a backup path
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink, self).__init__()

                                        self.yang_name = "per-link"
                                        self.yang_parent_name = "fast-reroute"

                                        self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                        self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                        self.candidate_interfaces.parent = self
                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                        self._children_yang_names.add("candidate-interfaces")

                                        self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                        self._children_yang_names.add("exclude-interfaces")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)


                                    class CandidateInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix candidate
                                        interface configuration
                                        
                                        .. attribute:: candidate_interface
                                        
                                        	Candidate backup interface
                                        	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                            self.yang_name = "candidate-interfaces"
                                            self.yang_parent_name = "per-link"

                                            self.candidate_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                        class CandidateInterface(Entity):
                                            """
                                            Candidate backup interface
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                self.yang_name = "candidate-interface"
                                                self.yang_parent_name = "candidate-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.candidate_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.candidate_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "candidate-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interface"):
                                                for c in self.candidate_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.candidate_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class ExcludeInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix exclude
                                        interface configuration
                                        
                                        .. attribute:: exclude_interface
                                        
                                        	Exclude an interface from becoming a backup
                                        	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                            self.yang_name = "exclude-interfaces"
                                            self.yang_parent_name = "per-link"

                                            self.exclude_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                        class ExcludeInterface(Entity):
                                            """
                                            Exclude an interface from becoming a backup
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                self.yang_name = "exclude-interface"
                                                self.yang_parent_name = "exclude-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.exclude_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.exclude_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "exclude-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "exclude-interface"):
                                                for c in self.exclude_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.exclude_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "exclude-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_use_candidate_only.is_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "per-link" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "candidate-interfaces"):
                                            if (self.candidate_interfaces is None):
                                                self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            return self.candidate_interfaces

                                        if (child_yang_name == "exclude-interfaces"):
                                            if (self.exclude_interfaces is None):
                                                self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            return self.exclude_interfaces

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-use-candidate-only"):
                                            self.fast_reroute_use_candidate_only = value
                                            self.fast_reroute_use_candidate_only.value_namespace = name_space
                                            self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                class PerPrefix(Entity):
                                    """
                                    Fast\-reroute per\-link configuration
                                    
                                    .. attribute:: candidate_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                    	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces>`
                                    
                                    .. attribute:: exclude_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                    	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces>`
                                    
                                    .. attribute:: fast_reroute_use_candidate_only
                                    
                                    	Use only interfaces on the candidate list as a backup path
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix, self).__init__()

                                        self.yang_name = "per-prefix"
                                        self.yang_parent_name = "fast-reroute"

                                        self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                        self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                        self.candidate_interfaces.parent = self
                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                        self._children_yang_names.add("candidate-interfaces")

                                        self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                        self._children_yang_names.add("exclude-interfaces")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)


                                    class CandidateInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix candidate
                                        interface configuration
                                        
                                        .. attribute:: candidate_interface
                                        
                                        	Candidate backup interface
                                        	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                            self.yang_name = "candidate-interfaces"
                                            self.yang_parent_name = "per-prefix"

                                            self.candidate_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                        class CandidateInterface(Entity):
                                            """
                                            Candidate backup interface
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                self.yang_name = "candidate-interface"
                                                self.yang_parent_name = "candidate-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.candidate_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.candidate_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "candidate-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interface"):
                                                for c in self.candidate_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.candidate_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class ExcludeInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix exclude
                                        interface configuration
                                        
                                        .. attribute:: exclude_interface
                                        
                                        	Exclude an interface from becoming a backup
                                        	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                            self.yang_name = "exclude-interfaces"
                                            self.yang_parent_name = "per-prefix"

                                            self.exclude_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                        class ExcludeInterface(Entity):
                                            """
                                            Exclude an interface from becoming a backup
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                self.yang_name = "exclude-interface"
                                                self.yang_parent_name = "exclude-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.exclude_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.exclude_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "exclude-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "exclude-interface"):
                                                for c in self.exclude_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.exclude_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "exclude-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_use_candidate_only.is_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "per-prefix" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "candidate-interfaces"):
                                            if (self.candidate_interfaces is None):
                                                self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            return self.candidate_interfaces

                                        if (child_yang_name == "exclude-interfaces"):
                                            if (self.exclude_interfaces is None):
                                                self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            return self.exclude_interfaces

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-use-candidate-only"):
                                            self.fast_reroute_use_candidate_only = value
                                            self.fast_reroute_use_candidate_only.value_namespace = name_space
                                            self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.fast_reroute_enable.is_set or
                                        (self.per_link is not None and self.per_link.has_data()) or
                                        (self.per_prefix is not None and self.per_prefix.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fast_reroute_enable.yfilter != YFilter.not_set or
                                        (self.per_link is not None and self.per_link.has_operation()) or
                                        (self.per_prefix is not None and self.per_prefix.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fast-reroute" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "per-link"):
                                        if (self.per_link is None):
                                            self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink()
                                            self.per_link.parent = self
                                            self._children_name_map["per_link"] = "per-link"
                                        return self.per_link

                                    if (child_yang_name == "per-prefix"):
                                        if (self.per_prefix is None):
                                            self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix()
                                            self.per_prefix.parent = self
                                            self._children_name_map["per_prefix"] = "per-prefix"
                                        return self.per_prefix

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fast-reroute-enable"):
                                        self.fast_reroute_enable = value
                                        self.fast_reroute_enable.value_namespace = name_space
                                        self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (self.fast_reroute is not None and self.fast_reroute.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.fast_reroute is not None and self.fast_reroute.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "area-scope" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fast-reroute"):
                                    if (self.fast_reroute is None):
                                        self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope.FastReroute()
                                        self.fast_reroute.parent = self
                                        self._children_name_map["fast_reroute"] = "fast-reroute"
                                    return self.fast_reroute

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fast-reroute"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class ShamLinks(Entity):
                            """
                            Sham Link sub\-mode
                            
                            .. attribute:: sham_link
                            
                            	ShamLink local and remote endpoints
                            	**type**\: list of    :py:class:`ShamLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks, self).__init__()

                                self.yang_name = "sham-links"
                                self.yang_parent_name = "area-address"

                                self.sham_link = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks, self).__setattr__(name, value)


                            class ShamLink(Entity):
                                """
                                ShamLink local and remote endpoints
                                
                                .. attribute:: source_address  <key>
                                
                                	Local sham\-link endpoint
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: destination_address  <key>
                                
                                	Remote sham\-link endpoint
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: authentication
                                
                                	Authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication>`
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead (in seconds)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: enable
                                
                                	Enable sham link
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: encryption
                                
                                	Encrypt and authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption>`
                                
                                .. attribute:: hello_interval
                                
                                	Time between HELLO packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: retransmit_interval
                                
                                	Specify the transmit interval in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: transmit_delay
                                
                                	Specify the transmit delay in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink, self).__init__()

                                    self.yang_name = "sham-link"
                                    self.yang_parent_name = "sham-links"

                                    self.source_address = YLeaf(YType.str, "source-address")

                                    self.destination_address = YLeaf(YType.str, "destination-address")

                                    self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                    self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                    self._children_yang_names.add("encryption")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("source_address",
                                                    "destination_address",
                                                    "dead_interval",
                                                    "enable",
                                                    "hello_interval",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink, self).__setattr__(name, value)


                                class Authentication(Entity):
                                    """
                                    Authenticate OSPFv3 packets
                                    
                                    .. attribute:: algorithm
                                    
                                    	Use the MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "sham-link"

                                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.password = YLeaf(YType.str, "password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("algorithm",
                                                        "enable",
                                                        "password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.algorithm.is_set or
                                            self.enable.is_set or
                                            self.password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.algorithm.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "algorithm"):
                                            self.algorithm = value
                                            self.algorithm.value_namespace = name_space
                                            self.algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "password"):
                                            self.password = value
                                            self.password.value_namespace = name_space
                                            self.password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Encryption(Entity):
                                    """
                                    Encrypt and authenticate OSPFv3 packets
                                    
                                    .. attribute:: authentication_algorithm
                                    
                                    	Use the NULL, MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                    
                                    .. attribute:: authentication_password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: encryption_algorithm
                                    
                                    	Specify the encryption algorithm
                                    	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                    
                                    .. attribute:: encryption_password
                                    
                                    	Encryption password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption, self).__init__()

                                        self.yang_name = "encryption"
                                        self.yang_parent_name = "sham-link"

                                        self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                        self.authentication_password = YLeaf(YType.str, "authentication-password")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                        self.encryption_password = YLeaf(YType.str, "encryption-password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("authentication_algorithm",
                                                        "authentication_password",
                                                        "enable",
                                                        "encryption_algorithm",
                                                        "encryption_password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.authentication_algorithm.is_set or
                                            self.authentication_password.is_set or
                                            self.enable.is_set or
                                            self.encryption_algorithm.is_set or
                                            self.encryption_password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.authentication_algorithm.yfilter != YFilter.not_set or
                                            self.authentication_password.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.encryption_algorithm.yfilter != YFilter.not_set or
                                            self.encryption_password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "encryption" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                        if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                        if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "authentication-algorithm"):
                                            self.authentication_algorithm = value
                                            self.authentication_algorithm.value_namespace = name_space
                                            self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "authentication-password"):
                                            self.authentication_password = value
                                            self.authentication_password.value_namespace = name_space
                                            self.authentication_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-algorithm"):
                                            self.encryption_algorithm = value
                                            self.encryption_algorithm.value_namespace = name_space
                                            self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-password"):
                                            self.encryption_password = value
                                            self.encryption_password.value_namespace = name_space
                                            self.encryption_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.source_address.is_set or
                                        self.destination_address.is_set or
                                        self.dead_interval.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.encryption is not None and self.encryption.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.source_address.yfilter != YFilter.not_set or
                                        self.destination_address.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.encryption is not None and self.encryption.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sham-link" + "[source-address='" + self.source_address.get() + "']" + "[destination-address='" + self.destination_address.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source_address.get_name_leafdata())
                                    if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.destination_address.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "encryption"):
                                        if (self.encryption is None):
                                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption()
                                            self.encryption.parent = self
                                            self._children_name_map["encryption"] = "encryption"
                                        return self.encryption

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "encryption" or name == "source-address" or name == "destination-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "source-address"):
                                        self.source_address = value
                                        self.source_address.value_namespace = name_space
                                        self.source_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "destination-address"):
                                        self.destination_address = value
                                        self.destination_address.value_namespace = name_space
                                        self.destination_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sham_link:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.sham_link:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "sham-links" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sham-link"):
                                    for c in self.sham_link:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sham_link.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sham-link"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class VirtualLinks(Entity):
                            """
                            Virtual link sub\-mode
                            
                            .. attribute:: virtual_link
                            
                            	Router ID of virtual link neighbor
                            	**type**\: list of    :py:class:`VirtualLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks, self).__init__()

                                self.yang_name = "virtual-links"
                                self.yang_parent_name = "area-address"

                                self.virtual_link = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks, self).__setattr__(name, value)


                            class VirtualLink(Entity):
                                """
                                Router ID of virtual link neighbor
                                
                                .. attribute:: virtual_link_address  <key>
                                
                                	Router ID of virtual link neighbor
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: authentication
                                
                                	Authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication>`
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead (in seconds)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: enable
                                
                                	Enabled virtual link
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: encryption
                                
                                	Encrypt and authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption>`
                                
                                .. attribute:: hello_interval
                                
                                	Time between HELLO packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: retransmit_interval
                                
                                	Specify the transmit interval in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: transmit_delay
                                
                                	Specify the transmit delay in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink, self).__init__()

                                    self.yang_name = "virtual-link"
                                    self.yang_parent_name = "virtual-links"

                                    self.virtual_link_address = YLeaf(YType.str, "virtual-link-address")

                                    self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                    self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                    self._children_yang_names.add("encryption")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("virtual_link_address",
                                                    "dead_interval",
                                                    "enable",
                                                    "hello_interval",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink, self).__setattr__(name, value)


                                class Authentication(Entity):
                                    """
                                    Authenticate OSPFv3 packets
                                    
                                    .. attribute:: algorithm
                                    
                                    	Use the MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "virtual-link"

                                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.password = YLeaf(YType.str, "password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("algorithm",
                                                        "enable",
                                                        "password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.algorithm.is_set or
                                            self.enable.is_set or
                                            self.password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.algorithm.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "algorithm"):
                                            self.algorithm = value
                                            self.algorithm.value_namespace = name_space
                                            self.algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "password"):
                                            self.password = value
                                            self.password.value_namespace = name_space
                                            self.password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Encryption(Entity):
                                    """
                                    Encrypt and authenticate OSPFv3 packets
                                    
                                    .. attribute:: authentication_algorithm
                                    
                                    	Use the NULL, MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                    
                                    .. attribute:: authentication_password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: encryption_algorithm
                                    
                                    	Specify the encryption algorithm
                                    	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                    
                                    .. attribute:: encryption_password
                                    
                                    	Encryption password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption, self).__init__()

                                        self.yang_name = "encryption"
                                        self.yang_parent_name = "virtual-link"

                                        self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                        self.authentication_password = YLeaf(YType.str, "authentication-password")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                        self.encryption_password = YLeaf(YType.str, "encryption-password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("authentication_algorithm",
                                                        "authentication_password",
                                                        "enable",
                                                        "encryption_algorithm",
                                                        "encryption_password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.authentication_algorithm.is_set or
                                            self.authentication_password.is_set or
                                            self.enable.is_set or
                                            self.encryption_algorithm.is_set or
                                            self.encryption_password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.authentication_algorithm.yfilter != YFilter.not_set or
                                            self.authentication_password.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.encryption_algorithm.yfilter != YFilter.not_set or
                                            self.encryption_password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "encryption" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                        if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                        if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "authentication-algorithm"):
                                            self.authentication_algorithm = value
                                            self.authentication_algorithm.value_namespace = name_space
                                            self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "authentication-password"):
                                            self.authentication_password = value
                                            self.authentication_password.value_namespace = name_space
                                            self.authentication_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-algorithm"):
                                            self.encryption_algorithm = value
                                            self.encryption_algorithm.value_namespace = name_space
                                            self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-password"):
                                            self.encryption_password = value
                                            self.encryption_password.value_namespace = name_space
                                            self.encryption_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.virtual_link_address.is_set or
                                        self.dead_interval.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.encryption is not None and self.encryption.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.virtual_link_address.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.encryption is not None and self.encryption.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "virtual-link" + "[virtual-link-address='" + self.virtual_link_address.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.virtual_link_address.is_set or self.virtual_link_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.virtual_link_address.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "encryption"):
                                        if (self.encryption is None):
                                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption()
                                            self.encryption.parent = self
                                            self._children_name_map["encryption"] = "encryption"
                                        return self.encryption

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "encryption" or name == "virtual-link-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "virtual-link-address"):
                                        self.virtual_link_address = value
                                        self.virtual_link_address.value_namespace = name_space
                                        self.virtual_link_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.virtual_link:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.virtual_link:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "virtual-links" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "virtual-link"):
                                    for c in self.virtual_link:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.virtual_link.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "virtual-link"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.cost.is_set or
                                self.dead_interval.is_set or
                                self.default_cost.is_set or
                                self.demand_circuit.is_set or
                                self.enable.is_set or
                                self.flood_reduction.is_set or
                                self.hello_interval.is_set or
                                self.instance.is_set or
                                self.ldp_sync.is_set or
                                self.mtu_ignore.is_set or
                                self.network.is_set or
                                self.packet_size.is_set or
                                self.passive.is_set or
                                self.prefix_suppression.is_set or
                                self.priority.is_set or
                                self.retransmit_interval.is_set or
                                self.stub.is_set or
                                self.transmit_delay.is_set or
                                (self.area_scope is not None and self.area_scope.has_data()) or
                                (self.authentication is not None and self.authentication.has_data()) or
                                (self.bfd is not None and self.bfd.has_data()) or
                                (self.database_filter is not None and self.database_filter.has_data()) or
                                (self.distribute_list is not None and self.distribute_list.has_data()) or
                                (self.encryption is not None and self.encryption.has_data()) or
                                (self.interfaces is not None and self.interfaces.has_data()) or
                                (self.nssa is not None and self.nssa.has_data()) or
                                (self.ranges is not None and self.ranges.has_data()) or
                                (self.sham_links is not None and self.sham_links.has_data()) or
                                (self.virtual_links is not None and self.virtual_links.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.dead_interval.yfilter != YFilter.not_set or
                                self.default_cost.yfilter != YFilter.not_set or
                                self.demand_circuit.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.flood_reduction.yfilter != YFilter.not_set or
                                self.hello_interval.yfilter != YFilter.not_set or
                                self.instance.yfilter != YFilter.not_set or
                                self.ldp_sync.yfilter != YFilter.not_set or
                                self.mtu_ignore.yfilter != YFilter.not_set or
                                self.network.yfilter != YFilter.not_set or
                                self.packet_size.yfilter != YFilter.not_set or
                                self.passive.yfilter != YFilter.not_set or
                                self.prefix_suppression.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.retransmit_interval.yfilter != YFilter.not_set or
                                self.stub.yfilter != YFilter.not_set or
                                self.transmit_delay.yfilter != YFilter.not_set or
                                (self.area_scope is not None and self.area_scope.has_operation()) or
                                (self.authentication is not None and self.authentication.has_operation()) or
                                (self.bfd is not None and self.bfd.has_operation()) or
                                (self.database_filter is not None and self.database_filter.has_operation()) or
                                (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                (self.encryption is not None and self.encryption.has_operation()) or
                                (self.interfaces is not None and self.interfaces.has_operation()) or
                                (self.nssa is not None and self.nssa.has_operation()) or
                                (self.ranges is not None and self.ranges.has_operation()) or
                                (self.sham_links is not None and self.sham_links.has_operation()) or
                                (self.virtual_links is not None and self.virtual_links.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "area-address" + "[address='" + self.address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dead_interval.get_name_leafdata())
                            if (self.default_cost.is_set or self.default_cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_cost.get_name_leafdata())
                            if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                            if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_interval.get_name_leafdata())
                            if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance.get_name_leafdata())
                            if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                            if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                            if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.network.get_name_leafdata())
                            if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.packet_size.get_name_leafdata())
                            if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passive.get_name_leafdata())
                            if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                            if (self.stub.is_set or self.stub.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stub.get_name_leafdata())
                            if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "area-scope"):
                                if (self.area_scope is None):
                                    self.area_scope = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.AreaScope()
                                    self.area_scope.parent = self
                                    self._children_name_map["area_scope"] = "area-scope"
                                return self.area_scope

                            if (child_yang_name == "authentication"):
                                if (self.authentication is None):
                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                return self.authentication

                            if (child_yang_name == "bfd"):
                                if (self.bfd is None):
                                    self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Bfd()
                                    self.bfd.parent = self
                                    self._children_name_map["bfd"] = "bfd"
                                return self.bfd

                            if (child_yang_name == "database-filter"):
                                if (self.database_filter is None):
                                    self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DatabaseFilter()
                                    self.database_filter.parent = self
                                    self._children_name_map["database_filter"] = "database-filter"
                                return self.database_filter

                            if (child_yang_name == "distribute-list"):
                                if (self.distribute_list is None):
                                    self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.DistributeList()
                                    self.distribute_list.parent = self
                                    self._children_name_map["distribute_list"] = "distribute-list"
                                return self.distribute_list

                            if (child_yang_name == "encryption"):
                                if (self.encryption is None):
                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                return self.encryption

                            if (child_yang_name == "interfaces"):
                                if (self.interfaces is None):
                                    self.interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Interfaces()
                                    self.interfaces.parent = self
                                    self._children_name_map["interfaces"] = "interfaces"
                                return self.interfaces

                            if (child_yang_name == "nssa"):
                                if (self.nssa is None):
                                    self.nssa = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Nssa()
                                    self.nssa.parent = self
                                    self._children_name_map["nssa"] = "nssa"
                                return self.nssa

                            if (child_yang_name == "ranges"):
                                if (self.ranges is None):
                                    self.ranges = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.Ranges()
                                    self.ranges.parent = self
                                    self._children_name_map["ranges"] = "ranges"
                                return self.ranges

                            if (child_yang_name == "sham-links"):
                                if (self.sham_links is None):
                                    self.sham_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.ShamLinks()
                                    self.sham_links.parent = self
                                    self._children_name_map["sham_links"] = "sham-links"
                                return self.sham_links

                            if (child_yang_name == "virtual-links"):
                                if (self.virtual_links is None):
                                    self.virtual_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress.VirtualLinks()
                                    self.virtual_links.parent = self
                                    self._children_name_map["virtual_links"] = "virtual-links"
                                return self.virtual_links

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "area-scope" or name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "interfaces" or name == "nssa" or name == "ranges" or name == "sham-links" or name == "virtual-links" or name == "address" or name == "cost" or name == "dead-interval" or name == "default-cost" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "stub" or name == "transmit-delay"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "dead-interval"):
                                self.dead_interval = value
                                self.dead_interval.value_namespace = name_space
                                self.dead_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "default-cost"):
                                self.default_cost = value
                                self.default_cost.value_namespace = name_space
                                self.default_cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "demand-circuit"):
                                self.demand_circuit = value
                                self.demand_circuit.value_namespace = name_space
                                self.demand_circuit.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "flood-reduction"):
                                self.flood_reduction = value
                                self.flood_reduction.value_namespace = name_space
                                self.flood_reduction.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-interval"):
                                self.hello_interval = value
                                self.hello_interval.value_namespace = name_space
                                self.hello_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance"):
                                self.instance = value
                                self.instance.value_namespace = name_space
                                self.instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldp-sync"):
                                self.ldp_sync = value
                                self.ldp_sync.value_namespace = name_space
                                self.ldp_sync.value_namespace_prefix = name_space_prefix
                            if(value_path == "mtu-ignore"):
                                self.mtu_ignore = value
                                self.mtu_ignore.value_namespace = name_space
                                self.mtu_ignore.value_namespace_prefix = name_space_prefix
                            if(value_path == "network"):
                                self.network = value
                                self.network.value_namespace = name_space
                                self.network.value_namespace_prefix = name_space_prefix
                            if(value_path == "packet-size"):
                                self.packet_size = value
                                self.packet_size.value_namespace = name_space
                                self.packet_size.value_namespace_prefix = name_space_prefix
                            if(value_path == "passive"):
                                self.passive = value
                                self.passive.value_namespace = name_space
                                self.passive.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-suppression"):
                                self.prefix_suppression = value
                                self.prefix_suppression.value_namespace = name_space
                                self.prefix_suppression.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "retransmit-interval"):
                                self.retransmit_interval = value
                                self.retransmit_interval.value_namespace = name_space
                                self.retransmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "stub"):
                                self.stub = value
                                self.stub.value_namespace = name_space
                                self.stub.value_namespace_prefix = name_space_prefix
                            if(value_path == "transmit-delay"):
                                self.transmit_delay = value
                                self.transmit_delay.value_namespace = name_space
                                self.transmit_delay.value_namespace_prefix = name_space_prefix


                    class AreaAreaId(Entity):
                        """
                        Configuration for a particular area
                        
                        .. attribute:: area_id  <key>
                        
                        	Area ID if in integer format
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: area_scope
                        
                        	Area Scope Configuration
                        	**type**\:   :py:class:`AreaScope <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope>`
                        
                        .. attribute:: authentication
                        
                        	Authenticate OSPFv3 packets
                        	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Authentication>`
                        
                        .. attribute:: bfd
                        
                        	Configure BFD parameters
                        	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Bfd>`
                        
                        .. attribute:: cost
                        
                        	Interface cost
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        .. attribute:: database_filter
                        
                        	Database filter
                        	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter>`
                        
                        .. attribute:: dead_interval
                        
                        	Interval after which a neighbor is declared dead (in seconds)
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: default_cost
                        
                        	Set the summary default\-cost of a NSSA/stub area
                        	**type**\:  int
                        
                        	**range:** 0..16777215
                        
                        .. attribute:: demand_circuit
                        
                        	Enable/disable demand circuit operation
                        	**type**\:  bool
                        
                        .. attribute:: distribute_list
                        
                        	Filter prefixes to/from RIB
                        	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList>`
                        
                        .. attribute:: enable
                        
                        	Enable OSPFv3 area
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: encryption
                        
                        	Encrypt and authenticate OSPFv3 packets
                        	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Encryption>`
                        
                        .. attribute:: flood_reduction
                        
                        	Enable/disable flood reduction
                        	**type**\:  bool
                        
                        .. attribute:: hello_interval
                        
                        	Time between HELLO packets
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: instance
                        
                        	Instance ID
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: interfaces
                        
                        	OSPFv3 interfaces
                        	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces>`
                        
                        .. attribute:: ldp_sync
                        
                        	Enable/Disable MPLS LDP sync
                        	**type**\:  bool
                        
                        .. attribute:: mtu_ignore
                        
                        	Enable/disable ignoring of MTU in DBD packets
                        	**type**\:  bool
                        
                        .. attribute:: network
                        
                        	Specify network type
                        	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                        
                        .. attribute:: nssa
                        
                        	Specify area as a NSSA area.  Allowed only in non\-backbone areas
                        	**type**\:   :py:class:`Nssa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Nssa>`
                        
                        .. attribute:: packet_size
                        
                        	Limit size of OSPFv3 packets
                        	**type**\:  int
                        
                        	**range:** 256..10000
                        
                        .. attribute:: passive
                        
                        	Enable/disable routing updates on an interface
                        	**type**\:  bool
                        
                        .. attribute:: prefix_suppression
                        
                        	Enable/disable prefix suppression on an interface
                        	**type**\:  bool
                        
                        .. attribute:: priority
                        
                        	Specify router priority
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ranges
                        
                        	Range configuration
                        	**type**\:   :py:class:`Ranges <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges>`
                        
                        .. attribute:: retransmit_interval
                        
                        	Specify the transmit interval in seconds
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: sham_links
                        
                        	Sham Link sub\-mode
                        	**type**\:   :py:class:`ShamLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks>`
                        
                        .. attribute:: stub
                        
                        	Specify area as a stub area.  Allowed only in non\-backbone areas
                        	**type**\:  bool
                        
                        .. attribute:: transmit_delay
                        
                        	Specify the transmit delay in seconds
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**units**\: second
                        
                        .. attribute:: virtual_links
                        
                        	Virtual link sub\-mode
                        	**type**\:   :py:class:`VirtualLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId, self).__init__()

                            self.yang_name = "area-area-id"
                            self.yang_parent_name = "area-addresses"

                            self.area_id = YLeaf(YType.int32, "area-id")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                            self.default_cost = YLeaf(YType.uint32, "default-cost")

                            self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                            self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                            self.instance = YLeaf(YType.uint32, "instance")

                            self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                            self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                            self.network = YLeaf(YType.enumeration, "network")

                            self.packet_size = YLeaf(YType.uint32, "packet-size")

                            self.passive = YLeaf(YType.boolean, "passive")

                            self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                            self.priority = YLeaf(YType.uint32, "priority")

                            self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                            self.stub = YLeaf(YType.boolean, "stub")

                            self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                            self.area_scope = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope()
                            self.area_scope.parent = self
                            self._children_name_map["area_scope"] = "area-scope"
                            self._children_yang_names.add("area-scope")

                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Authentication()
                            self.authentication.parent = self
                            self._children_name_map["authentication"] = "authentication"
                            self._children_yang_names.add("authentication")

                            self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Bfd()
                            self.bfd.parent = self
                            self._children_name_map["bfd"] = "bfd"
                            self._children_yang_names.add("bfd")

                            self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter()
                            self.database_filter.parent = self
                            self._children_name_map["database_filter"] = "database-filter"
                            self._children_yang_names.add("database-filter")

                            self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList()
                            self.distribute_list.parent = self
                            self._children_name_map["distribute_list"] = "distribute-list"
                            self._children_yang_names.add("distribute-list")

                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Encryption()
                            self.encryption.parent = self
                            self._children_name_map["encryption"] = "encryption"
                            self._children_yang_names.add("encryption")

                            self.interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces()
                            self.interfaces.parent = self
                            self._children_name_map["interfaces"] = "interfaces"
                            self._children_yang_names.add("interfaces")

                            self.nssa = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Nssa()
                            self.nssa.parent = self
                            self._children_name_map["nssa"] = "nssa"
                            self._children_yang_names.add("nssa")

                            self.ranges = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges()
                            self.ranges.parent = self
                            self._children_name_map["ranges"] = "ranges"
                            self._children_yang_names.add("ranges")

                            self.sham_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks()
                            self.sham_links.parent = self
                            self._children_name_map["sham_links"] = "sham-links"
                            self._children_yang_names.add("sham-links")

                            self.virtual_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks()
                            self.virtual_links.parent = self
                            self._children_name_map["virtual_links"] = "virtual-links"
                            self._children_yang_names.add("virtual-links")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("area_id",
                                            "cost",
                                            "dead_interval",
                                            "default_cost",
                                            "demand_circuit",
                                            "enable",
                                            "flood_reduction",
                                            "hello_interval",
                                            "instance",
                                            "ldp_sync",
                                            "mtu_ignore",
                                            "network",
                                            "packet_size",
                                            "passive",
                                            "prefix_suppression",
                                            "priority",
                                            "retransmit_interval",
                                            "stub",
                                            "transmit_delay") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId, self).__setattr__(name, value)


                        class Authentication(Entity):
                            """
                            Authenticate OSPFv3 packets
                            
                            .. attribute:: algorithm
                            
                            	Use the MD5 or SHA1 algorithm
                            	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                            
                            .. attribute:: enable
                            
                            	Authenticate packets
                            	**type**\:  bool
                            
                            .. attribute:: password
                            
                            	Specify MD5 or SHA1 password
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            .. attribute:: spi
                            
                            	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                            	**type**\:  int
                            
                            	**range:** 256..4294967295
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Authentication, self).__init__()

                                self.yang_name = "authentication"
                                self.yang_parent_name = "area-area-id"

                                self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.password = YLeaf(YType.str, "password")

                                self.spi = YLeaf(YType.uint32, "spi")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("algorithm",
                                                "enable",
                                                "password",
                                                "spi") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Authentication, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Authentication, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.algorithm.is_set or
                                    self.enable.is_set or
                                    self.password.is_set or
                                    self.spi.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.algorithm.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.password.yfilter != YFilter.not_set or
                                    self.spi.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "authentication" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.algorithm.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.password.get_name_leafdata())
                                if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.spi.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "algorithm"):
                                    self.algorithm = value
                                    self.algorithm.value_namespace = name_space
                                    self.algorithm.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "password"):
                                    self.password = value
                                    self.password.value_namespace = name_space
                                    self.password.value_namespace_prefix = name_space_prefix
                                if(value_path == "spi"):
                                    self.spi = value
                                    self.spi.value_namespace = name_space
                                    self.spi.value_namespace_prefix = name_space_prefix


                        class Bfd(Entity):
                            """
                            Configure BFD parameters
                            
                            .. attribute:: detection_multiplier
                            
                            	Detect multiplier
                            	**type**\:  int
                            
                            	**range:** 2..50
                            
                            .. attribute:: fast_detect_mode
                            
                            	Enable or disable BFD fast detection
                            	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                            
                            .. attribute:: interval
                            
                            	Hello interval in milli\-seconds
                            	**type**\:  int
                            
                            	**range:** 3..30000
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Bfd, self).__init__()

                                self.yang_name = "bfd"
                                self.yang_parent_name = "area-area-id"

                                self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("detection_multiplier",
                                                "fast_detect_mode",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Bfd, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Bfd, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.detection_multiplier.is_set or
                                    self.fast_detect_mode.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.detection_multiplier.yfilter != YFilter.not_set or
                                    self.fast_detect_mode.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bfd" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "detection-multiplier"):
                                    self.detection_multiplier = value
                                    self.detection_multiplier.value_namespace = name_space
                                    self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                if(value_path == "fast-detect-mode"):
                                    self.fast_detect_mode = value
                                    self.fast_detect_mode.value_namespace = name_space
                                    self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix


                        class Ranges(Entity):
                            """
                            Range configuration
                            
                            .. attribute:: range
                            
                            	Summarize inter\-area routes matching prefix/length
                            	**type**\: list of    :py:class:`Range <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges.Range>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges, self).__init__()

                                self.yang_name = "ranges"
                                self.yang_parent_name = "area-area-id"

                                self.range = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges, self).__setattr__(name, value)


                            class Range(Entity):
                                """
                                Summarize inter\-area routes matching
                                prefix/length
                                
                                .. attribute:: prefix  <key>
                                
                                	IPv6 prefix format
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: prefix_length  <key>
                                
                                	IPV6 prefix length
                                	**type**\:  int
                                
                                	**range:** 0..128
                                
                                .. attribute:: cost
                                
                                	Specified metric for this range
                                	**type**\:  int
                                
                                	**range:** 1..16777214
                                
                                .. attribute:: not_advertise
                                
                                	Do not advertise address range
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges.Range, self).__init__()

                                    self.yang_name = "range"
                                    self.yang_parent_name = "ranges"

                                    self.prefix = YLeaf(YType.str, "prefix")

                                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                    self.cost = YLeaf(YType.uint32, "cost")

                                    self.not_advertise = YLeaf(YType.boolean, "not-advertise")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix",
                                                    "prefix_length",
                                                    "cost",
                                                    "not_advertise") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges.Range, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges.Range, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.prefix.is_set or
                                        self.prefix_length.is_set or
                                        self.cost.is_set or
                                        self.not_advertise.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix.yfilter != YFilter.not_set or
                                        self.prefix_length.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.not_advertise.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "range" + "[prefix='" + self.prefix.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.not_advertise.is_set or self.not_advertise.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.not_advertise.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix" or name == "prefix-length" or name == "cost" or name == "not-advertise"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix"):
                                        self.prefix = value
                                        self.prefix.value_namespace = name_space
                                        self.prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-length"):
                                        self.prefix_length = value
                                        self.prefix_length.value_namespace = name_space
                                        self.prefix_length.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "not-advertise"):
                                        self.not_advertise = value
                                        self.not_advertise.value_namespace = name_space
                                        self.not_advertise.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.range:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.range:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ranges" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "range"):
                                    for c in self.range:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges.Range()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.range.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "range"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Encryption(Entity):
                            """
                            Encrypt and authenticate OSPFv3 packets
                            
                            .. attribute:: authentication_algorithm
                            
                            	Use the NULL, MD5 or SHA1 algorithm
                            	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                            
                            .. attribute:: authentication_password
                            
                            	Specify MD5 or SHA1 password
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            .. attribute:: enable
                            
                            	Authenticate packets
                            	**type**\:  bool
                            
                            .. attribute:: encryption_algorithm
                            
                            	Specify the encryption algorithm
                            	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                            
                            .. attribute:: encryption_password
                            
                            	Encryption password
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            .. attribute:: spi
                            
                            	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                            	**type**\:  int
                            
                            	**range:** 256..4294967295
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Encryption, self).__init__()

                                self.yang_name = "encryption"
                                self.yang_parent_name = "area-area-id"

                                self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                self.authentication_password = YLeaf(YType.str, "authentication-password")

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                self.encryption_password = YLeaf(YType.str, "encryption-password")

                                self.spi = YLeaf(YType.uint32, "spi")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("authentication_algorithm",
                                                "authentication_password",
                                                "enable",
                                                "encryption_algorithm",
                                                "encryption_password",
                                                "spi") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Encryption, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Encryption, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.authentication_algorithm.is_set or
                                    self.authentication_password.is_set or
                                    self.enable.is_set or
                                    self.encryption_algorithm.is_set or
                                    self.encryption_password.is_set or
                                    self.spi.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.authentication_algorithm.yfilter != YFilter.not_set or
                                    self.authentication_password.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.encryption_algorithm.yfilter != YFilter.not_set or
                                    self.encryption_password.yfilter != YFilter.not_set or
                                    self.spi.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "encryption" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.spi.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "authentication-algorithm"):
                                    self.authentication_algorithm = value
                                    self.authentication_algorithm.value_namespace = name_space
                                    self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                if(value_path == "authentication-password"):
                                    self.authentication_password = value
                                    self.authentication_password.value_namespace = name_space
                                    self.authentication_password.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "encryption-algorithm"):
                                    self.encryption_algorithm = value
                                    self.encryption_algorithm.value_namespace = name_space
                                    self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                if(value_path == "encryption-password"):
                                    self.encryption_password = value
                                    self.encryption_password.value_namespace = name_space
                                    self.encryption_password.value_namespace_prefix = name_space_prefix
                                if(value_path == "spi"):
                                    self.spi = value
                                    self.spi.value_namespace = name_space
                                    self.spi.value_namespace_prefix = name_space_prefix


                        class Nssa(Entity):
                            """
                            Specify area as a NSSA area.  Allowed only in
                            non\-backbone areas
                            
                            .. attribute:: default_info_originate
                            
                            	Originate Type 7 default into NSSA area
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: metric
                            
                            	Only valid with DefaultInfoOriginate
                            	**type**\:  int
                            
                            	**range:** 0..16777214
                            
                            .. attribute:: metric_type
                            
                            	Only valid with DefaultInfoOriginate
                            	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                            
                            .. attribute:: no_redistribution
                            
                            	No redistribution into this NSSA area
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: no_summary
                            
                            	Do not send summary LSA into NSSA
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Nssa, self).__init__()

                                self.yang_name = "nssa"
                                self.yang_parent_name = "area-area-id"

                                self.default_info_originate = YLeaf(YType.boolean, "default-info-originate")

                                self.metric = YLeaf(YType.uint32, "metric")

                                self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                self.no_redistribution = YLeaf(YType.boolean, "no-redistribution")

                                self.no_summary = YLeaf(YType.empty, "no-summary")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_info_originate",
                                                "metric",
                                                "metric_type",
                                                "no_redistribution",
                                                "no_summary") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Nssa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Nssa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.default_info_originate.is_set or
                                    self.metric.is_set or
                                    self.metric_type.is_set or
                                    self.no_redistribution.is_set or
                                    self.no_summary.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_info_originate.yfilter != YFilter.not_set or
                                    self.metric.yfilter != YFilter.not_set or
                                    self.metric_type.yfilter != YFilter.not_set or
                                    self.no_redistribution.yfilter != YFilter.not_set or
                                    self.no_summary.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "nssa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_info_originate.is_set or self.default_info_originate.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_info_originate.get_name_leafdata())
                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric.get_name_leafdata())
                                if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric_type.get_name_leafdata())
                                if (self.no_redistribution.is_set or self.no_redistribution.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.no_redistribution.get_name_leafdata())
                                if (self.no_summary.is_set or self.no_summary.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.no_summary.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-info-originate" or name == "metric" or name == "metric-type" or name == "no-redistribution" or name == "no-summary"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-info-originate"):
                                    self.default_info_originate = value
                                    self.default_info_originate.value_namespace = name_space
                                    self.default_info_originate.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric"):
                                    self.metric = value
                                    self.metric.value_namespace = name_space
                                    self.metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric-type"):
                                    self.metric_type = value
                                    self.metric_type.value_namespace = name_space
                                    self.metric_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "no-redistribution"):
                                    self.no_redistribution = value
                                    self.no_redistribution.value_namespace = name_space
                                    self.no_redistribution.value_namespace_prefix = name_space_prefix
                                if(value_path == "no-summary"):
                                    self.no_summary = value
                                    self.no_summary.value_namespace = name_space
                                    self.no_summary.value_namespace_prefix = name_space_prefix


                        class DatabaseFilter(Entity):
                            """
                            Database filter
                            
                            .. attribute:: all
                            
                            	All
                            	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter.All>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter, self).__init__()

                                self.yang_name = "database-filter"
                                self.yang_parent_name = "area-area-id"

                                self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter.All()
                                self.all.parent = self
                                self._children_name_map["all"] = "all"
                                self._children_yang_names.add("all")


                            class All(Entity):
                                """
                                All
                                
                                .. attribute:: out
                                
                                	Enable or disable database\-filter
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter.All, self).__init__()

                                    self.yang_name = "all"
                                    self.yang_parent_name = "database-filter"

                                    self.out = YLeaf(YType.boolean, "out")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("out") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter.All, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter.All, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.out.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.out.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "all" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.out.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "out"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "out"):
                                        self.out = value
                                        self.out.value_namespace = name_space
                                        self.out.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (self.all is not None and self.all.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.all is not None and self.all.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "database-filter" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "all"):
                                    if (self.all is None):
                                        self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter.All()
                                        self.all.parent = self
                                        self._children_name_map["all"] = "all"
                                    return self.all

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "all"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class DistributeList(Entity):
                            """
                            Filter prefixes to/from RIB
                            
                            .. attribute:: in_
                            
                            	Filter prefixes installed to RIB
                            	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList.In_>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList, self).__init__()

                                self.yang_name = "distribute-list"
                                self.yang_parent_name = "area-area-id"

                                self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList.In_()
                                self.in_.parent = self
                                self._children_name_map["in_"] = "in"
                                self._children_yang_names.add("in")


                            class In_(Entity):
                                """
                                Filter prefixes installed to RIB
                                
                                .. attribute:: prefix_list
                                
                                	Filter prefixes based on an IPv6 prefix\-list
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList.In_, self).__init__()

                                    self.yang_name = "in"
                                    self.yang_parent_name = "distribute-list"

                                    self.prefix_list = YLeaf(YType.str, "prefix-list")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix_list") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList.In_, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList.In_, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.prefix_list.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix_list.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "in" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix-list"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix-list"):
                                        self.prefix_list = value
                                        self.prefix_list.value_namespace = name_space
                                        self.prefix_list.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (self.in_ is not None and self.in_.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.in_ is not None and self.in_.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "distribute-list" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "in"):
                                    if (self.in_ is None):
                                        self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList.In_()
                                        self.in_.parent = self
                                        self._children_name_map["in_"] = "in"
                                    return self.in_

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "in"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Interfaces(Entity):
                            """
                            OSPFv3 interfaces
                            
                            .. attribute:: interface
                            
                            	OSPFv3 interface
                            	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces, self).__init__()

                                self.yang_name = "interfaces"
                                self.yang_parent_name = "area-area-id"

                                self.interface = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces, self).__setattr__(name, value)


                            class Interface(Entity):
                                """
                                OSPFv3 interface
                                
                                .. attribute:: interface_name  <key>
                                
                                	Interface to configure
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: authentication
                                
                                	Authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication>`
                                
                                .. attribute:: bfd
                                
                                	Configure BFD parameters
                                	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd>`
                                
                                .. attribute:: cost
                                
                                	Interface cost
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: database_filter
                                
                                	Database filter
                                	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter>`
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead (in seconds)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: demand_circuit
                                
                                	Enable/disable demand circuit operation
                                	**type**\:  bool
                                
                                .. attribute:: distribute_list
                                
                                	Filter prefixes to/from RIB
                                	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList>`
                                
                                .. attribute:: enable
                                
                                	Enable OSPFv3 interface
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: encryption
                                
                                	Encrypt and authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption>`
                                
                                .. attribute:: fast_reroute
                                
                                	Fast\-reroute configuration
                                	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute>`
                                
                                .. attribute:: flood_reduction
                                
                                	Enable/disable flood reduction
                                	**type**\:  bool
                                
                                .. attribute:: hello_interval
                                
                                	Time between HELLO packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: instance
                                
                                	Instance ID
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: ldp_sync
                                
                                	Enable/Disable MPLS LDP sync
                                	**type**\:  bool
                                
                                .. attribute:: mtu_ignore
                                
                                	Enable/disable ignoring of MTU in DBD packets
                                	**type**\:  bool
                                
                                .. attribute:: neighbors
                                
                                	Specify a neighbor router
                                	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors>`
                                
                                .. attribute:: network
                                
                                	Specify network type
                                	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                                
                                .. attribute:: packet_size
                                
                                	Limit size of OSPFv3 packets
                                	**type**\:  int
                                
                                	**range:** 256..10000
                                
                                .. attribute:: passive
                                
                                	Enable/disable routing updates on an interface
                                	**type**\:  bool
                                
                                .. attribute:: prefix_suppression
                                
                                	Enable/disable prefix suppression on an interface
                                	**type**\:  bool
                                
                                .. attribute:: priority
                                
                                	Specify router priority
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: retransmit_interval
                                
                                	Specify the transmit interval in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: transmit_delay
                                
                                	Specify the transmit delay in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface, self).__init__()

                                    self.yang_name = "interface"
                                    self.yang_parent_name = "interfaces"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.cost = YLeaf(YType.uint32, "cost")

                                    self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                    self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                    self.instance = YLeaf(YType.uint32, "instance")

                                    self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                                    self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                    self.network = YLeaf(YType.enumeration, "network")

                                    self.packet_size = YLeaf(YType.uint32, "packet-size")

                                    self.passive = YLeaf(YType.boolean, "passive")

                                    self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                    self.priority = YLeaf(YType.uint32, "priority")

                                    self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd()
                                    self.bfd.parent = self
                                    self._children_name_map["bfd"] = "bfd"
                                    self._children_yang_names.add("bfd")

                                    self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter()
                                    self.database_filter.parent = self
                                    self._children_name_map["database_filter"] = "database-filter"
                                    self._children_yang_names.add("database-filter")

                                    self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList()
                                    self.distribute_list.parent = self
                                    self._children_name_map["distribute_list"] = "distribute-list"
                                    self._children_yang_names.add("distribute-list")

                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                    self._children_yang_names.add("encryption")

                                    self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                    self._children_yang_names.add("fast-reroute")

                                    self.neighbors = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors()
                                    self.neighbors.parent = self
                                    self._children_name_map["neighbors"] = "neighbors"
                                    self._children_yang_names.add("neighbors")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name",
                                                    "cost",
                                                    "dead_interval",
                                                    "demand_circuit",
                                                    "enable",
                                                    "flood_reduction",
                                                    "hello_interval",
                                                    "instance",
                                                    "ldp_sync",
                                                    "mtu_ignore",
                                                    "network",
                                                    "packet_size",
                                                    "passive",
                                                    "prefix_suppression",
                                                    "priority",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface, self).__setattr__(name, value)


                                class Authentication(Entity):
                                    """
                                    Authenticate OSPFv3 packets
                                    
                                    .. attribute:: algorithm
                                    
                                    	Use the MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "interface"

                                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.password = YLeaf(YType.str, "password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("algorithm",
                                                        "enable",
                                                        "password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.algorithm.is_set or
                                            self.enable.is_set or
                                            self.password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.algorithm.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "algorithm"):
                                            self.algorithm = value
                                            self.algorithm.value_namespace = name_space
                                            self.algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "password"):
                                            self.password = value
                                            self.password.value_namespace = name_space
                                            self.password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Neighbors(Entity):
                                    """
                                    Specify a neighbor router
                                    
                                    .. attribute:: neighbor
                                    
                                    	IPv6 address
                                    	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors, self).__init__()

                                        self.yang_name = "neighbors"
                                        self.yang_parent_name = "interface"

                                        self.neighbor = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors, self).__setattr__(name, value)


                                    class Neighbor(Entity):
                                        """
                                        IPv6 address
                                        
                                        .. attribute:: neighbor_address  <key>
                                        
                                        	IPV6 address
                                        	**type**\:  str
                                        
                                        	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                        
                                        .. attribute:: cost
                                        
                                        	OSPFv3 cost for point\-to\-multipoint neighbor
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: database_filter
                                        
                                        	Filter OSPFv3 LSA during synchronization and flooding for point\-to\-multipoint neighbor
                                        	**type**\:  bool
                                        
                                        .. attribute:: poll_interval
                                        
                                        	OSPFv3 dead\-router polling interval (in seconds)
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**units**\: second
                                        
                                        .. attribute:: priority
                                        
                                        	OSPFv3 priority of non\-broadcast neighbor
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: zone
                                        
                                        	Zone
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor, self).__init__()

                                            self.yang_name = "neighbor"
                                            self.yang_parent_name = "neighbors"

                                            self.neighbor_address = YLeaf(YType.str, "neighbor-address")

                                            self.cost = YLeaf(YType.uint32, "cost")

                                            self.database_filter = YLeaf(YType.boolean, "database-filter")

                                            self.poll_interval = YLeaf(YType.uint32, "poll-interval")

                                            self.priority = YLeaf(YType.uint32, "priority")

                                            self.zone = YLeaf(YType.str, "zone")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("neighbor_address",
                                                            "cost",
                                                            "database_filter",
                                                            "poll_interval",
                                                            "priority",
                                                            "zone") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.neighbor_address.is_set or
                                                self.cost.is_set or
                                                self.database_filter.is_set or
                                                self.poll_interval.is_set or
                                                self.priority.is_set or
                                                self.zone.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.neighbor_address.yfilter != YFilter.not_set or
                                                self.cost.yfilter != YFilter.not_set or
                                                self.database_filter.yfilter != YFilter.not_set or
                                                self.poll_interval.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set or
                                                self.zone.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "neighbor" + "[neighbor-address='" + self.neighbor_address.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.neighbor_address.is_set or self.neighbor_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.neighbor_address.get_name_leafdata())
                                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.cost.get_name_leafdata())
                                            if (self.database_filter.is_set or self.database_filter.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.database_filter.get_name_leafdata())
                                            if (self.poll_interval.is_set or self.poll_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.poll_interval.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())
                                            if (self.zone.is_set or self.zone.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.zone.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "neighbor-address" or name == "cost" or name == "database-filter" or name == "poll-interval" or name == "priority" or name == "zone"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "neighbor-address"):
                                                self.neighbor_address = value
                                                self.neighbor_address.value_namespace = name_space
                                                self.neighbor_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "cost"):
                                                self.cost = value
                                                self.cost.value_namespace = name_space
                                                self.cost.value_namespace_prefix = name_space_prefix
                                            if(value_path == "database-filter"):
                                                self.database_filter = value
                                                self.database_filter.value_namespace = name_space
                                                self.database_filter.value_namespace_prefix = name_space_prefix
                                            if(value_path == "poll-interval"):
                                                self.poll_interval = value
                                                self.poll_interval.value_namespace = name_space
                                                self.poll_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "zone"):
                                                self.zone = value
                                                self.zone.value_namespace = name_space
                                                self.zone.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.neighbor:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.neighbor:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "neighbors" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "neighbor"):
                                            for c in self.neighbor:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.neighbor.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "neighbor"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class Encryption(Entity):
                                    """
                                    Encrypt and authenticate OSPFv3 packets
                                    
                                    .. attribute:: authentication_algorithm
                                    
                                    	Use the NULL, MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                    
                                    .. attribute:: authentication_password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: encryption_algorithm
                                    
                                    	Specify the encryption algorithm
                                    	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                    
                                    .. attribute:: encryption_password
                                    
                                    	Encryption password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption, self).__init__()

                                        self.yang_name = "encryption"
                                        self.yang_parent_name = "interface"

                                        self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                        self.authentication_password = YLeaf(YType.str, "authentication-password")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                        self.encryption_password = YLeaf(YType.str, "encryption-password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("authentication_algorithm",
                                                        "authentication_password",
                                                        "enable",
                                                        "encryption_algorithm",
                                                        "encryption_password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.authentication_algorithm.is_set or
                                            self.authentication_password.is_set or
                                            self.enable.is_set or
                                            self.encryption_algorithm.is_set or
                                            self.encryption_password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.authentication_algorithm.yfilter != YFilter.not_set or
                                            self.authentication_password.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.encryption_algorithm.yfilter != YFilter.not_set or
                                            self.encryption_password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "encryption" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                        if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                        if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "authentication-algorithm"):
                                            self.authentication_algorithm = value
                                            self.authentication_algorithm.value_namespace = name_space
                                            self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "authentication-password"):
                                            self.authentication_password = value
                                            self.authentication_password.value_namespace = name_space
                                            self.authentication_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-algorithm"):
                                            self.encryption_algorithm = value
                                            self.encryption_algorithm.value_namespace = name_space
                                            self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-password"):
                                            self.encryption_password = value
                                            self.encryption_password.value_namespace = name_space
                                            self.encryption_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Bfd(Entity):
                                    """
                                    Configure BFD parameters
                                    
                                    .. attribute:: detection_multiplier
                                    
                                    	Detect multiplier
                                    	**type**\:  int
                                    
                                    	**range:** 2..50
                                    
                                    .. attribute:: fast_detect_mode
                                    
                                    	Enable or disable BFD fast detection
                                    	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                                    
                                    .. attribute:: interval
                                    
                                    	Hello interval in milli\-seconds
                                    	**type**\:  int
                                    
                                    	**range:** 3..30000
                                    
                                    	**units**\: millisecond
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd, self).__init__()

                                        self.yang_name = "bfd"
                                        self.yang_parent_name = "interface"

                                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                        self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                        self.interval = YLeaf(YType.uint32, "interval")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("detection_multiplier",
                                                        "fast_detect_mode",
                                                        "interval") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.detection_multiplier.is_set or
                                            self.fast_detect_mode.is_set or
                                            self.interval.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.detection_multiplier.yfilter != YFilter.not_set or
                                            self.fast_detect_mode.yfilter != YFilter.not_set or
                                            self.interval.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bfd" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                        if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interval.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "detection-multiplier"):
                                            self.detection_multiplier = value
                                            self.detection_multiplier.value_namespace = name_space
                                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fast-detect-mode"):
                                            self.fast_detect_mode = value
                                            self.fast_detect_mode.value_namespace = name_space
                                            self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                        if(value_path == "interval"):
                                            self.interval = value
                                            self.interval.value_namespace = name_space
                                            self.interval.value_namespace_prefix = name_space_prefix


                                class DatabaseFilter(Entity):
                                    """
                                    Database filter
                                    
                                    .. attribute:: all
                                    
                                    	All
                                    	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter, self).__init__()

                                        self.yang_name = "database-filter"
                                        self.yang_parent_name = "interface"

                                        self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All()
                                        self.all.parent = self
                                        self._children_name_map["all"] = "all"
                                        self._children_yang_names.add("all")


                                    class All(Entity):
                                        """
                                        All
                                        
                                        .. attribute:: out
                                        
                                        	Enable or disable database\-filter
                                        	**type**\:  bool
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All, self).__init__()

                                            self.yang_name = "all"
                                            self.yang_parent_name = "database-filter"

                                            self.out = YLeaf(YType.boolean, "out")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("out") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.out.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.out.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "all" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.out.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "out"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "out"):
                                                self.out = value
                                                self.out.value_namespace = name_space
                                                self.out.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.all is not None and self.all.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.all is not None and self.all.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "database-filter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "all"):
                                            if (self.all is None):
                                                self.all = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All()
                                                self.all.parent = self
                                                self._children_name_map["all"] = "all"
                                            return self.all

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "all"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class DistributeList(Entity):
                                    """
                                    Filter prefixes to/from RIB
                                    
                                    .. attribute:: in_
                                    
                                    	Filter prefixes installed to RIB
                                    	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList, self).__init__()

                                        self.yang_name = "distribute-list"
                                        self.yang_parent_name = "interface"

                                        self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_()
                                        self.in_.parent = self
                                        self._children_name_map["in_"] = "in"
                                        self._children_yang_names.add("in")


                                    class In_(Entity):
                                        """
                                        Filter prefixes installed to RIB
                                        
                                        .. attribute:: prefix_list
                                        
                                        	Filter prefixes based on an IPv6 prefix\-list
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_, self).__init__()

                                            self.yang_name = "in"
                                            self.yang_parent_name = "distribute-list"

                                            self.prefix_list = YLeaf(YType.str, "prefix-list")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("prefix_list") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.prefix_list.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.prefix_list.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "in" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "prefix-list"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "prefix-list"):
                                                self.prefix_list = value
                                                self.prefix_list.value_namespace = name_space
                                                self.prefix_list.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.in_ is not None and self.in_.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.in_ is not None and self.in_.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "distribute-list" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "in"):
                                            if (self.in_ is None):
                                                self.in_ = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_()
                                                self.in_.parent = self
                                                self._children_name_map["in_"] = "in"
                                            return self.in_

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "in"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class FastReroute(Entity):
                                    """
                                    Fast\-reroute configuration
                                    
                                    .. attribute:: fast_reroute_enable
                                    
                                    	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                    	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                    
                                    .. attribute:: per_link
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink>`
                                    
                                    .. attribute:: per_prefix
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute, self).__init__()

                                        self.yang_name = "fast-reroute"
                                        self.yang_parent_name = "interface"

                                        self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                        self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink()
                                        self.per_link.parent = self
                                        self._children_name_map["per_link"] = "per-link"
                                        self._children_yang_names.add("per-link")

                                        self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix()
                                        self.per_prefix.parent = self
                                        self._children_name_map["per_prefix"] = "per-prefix"
                                        self._children_yang_names.add("per-prefix")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_enable") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute, self).__setattr__(name, value)


                                    class PerLink(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink, self).__init__()

                                            self.yang_name = "per-link"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-link" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                    class PerPrefix(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix, self).__init__()

                                            self.yang_name = "per-prefix"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-prefix" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_enable.is_set or
                                            (self.per_link is not None and self.per_link.has_data()) or
                                            (self.per_prefix is not None and self.per_prefix.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_enable.yfilter != YFilter.not_set or
                                            (self.per_link is not None and self.per_link.has_operation()) or
                                            (self.per_prefix is not None and self.per_prefix.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fast-reroute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "per-link"):
                                            if (self.per_link is None):
                                                self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink()
                                                self.per_link.parent = self
                                                self._children_name_map["per_link"] = "per-link"
                                            return self.per_link

                                        if (child_yang_name == "per-prefix"):
                                            if (self.per_prefix is None):
                                                self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix()
                                                self.per_prefix.parent = self
                                                self._children_name_map["per_prefix"] = "per-prefix"
                                            return self.per_prefix

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-enable"):
                                            self.fast_reroute_enable = value
                                            self.fast_reroute_enable.value_namespace = name_space
                                            self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.interface_name.is_set or
                                        self.cost.is_set or
                                        self.dead_interval.is_set or
                                        self.demand_circuit.is_set or
                                        self.enable.is_set or
                                        self.flood_reduction.is_set or
                                        self.hello_interval.is_set or
                                        self.instance.is_set or
                                        self.ldp_sync.is_set or
                                        self.mtu_ignore.is_set or
                                        self.network.is_set or
                                        self.packet_size.is_set or
                                        self.passive.is_set or
                                        self.prefix_suppression.is_set or
                                        self.priority.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.bfd is not None and self.bfd.has_data()) or
                                        (self.database_filter is not None and self.database_filter.has_data()) or
                                        (self.distribute_list is not None and self.distribute_list.has_data()) or
                                        (self.encryption is not None and self.encryption.has_data()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                                        (self.neighbors is not None and self.neighbors.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.demand_circuit.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.flood_reduction.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.instance.yfilter != YFilter.not_set or
                                        self.ldp_sync.yfilter != YFilter.not_set or
                                        self.mtu_ignore.yfilter != YFilter.not_set or
                                        self.network.yfilter != YFilter.not_set or
                                        self.packet_size.yfilter != YFilter.not_set or
                                        self.passive.yfilter != YFilter.not_set or
                                        self.prefix_suppression.yfilter != YFilter.not_set or
                                        self.priority.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.bfd is not None and self.bfd.has_operation()) or
                                        (self.database_filter is not None and self.database_filter.has_operation()) or
                                        (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                        (self.encryption is not None and self.encryption.has_operation()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                                        (self.neighbors is not None and self.neighbors.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.instance.get_name_leafdata())
                                    if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                                    if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                    if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.network.get_name_leafdata())
                                    if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.packet_size.get_name_leafdata())
                                    if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.passive.get_name_leafdata())
                                    if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                    if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.priority.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "bfd"):
                                        if (self.bfd is None):
                                            self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd()
                                            self.bfd.parent = self
                                            self._children_name_map["bfd"] = "bfd"
                                        return self.bfd

                                    if (child_yang_name == "database-filter"):
                                        if (self.database_filter is None):
                                            self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter()
                                            self.database_filter.parent = self
                                            self._children_name_map["database_filter"] = "database-filter"
                                        return self.database_filter

                                    if (child_yang_name == "distribute-list"):
                                        if (self.distribute_list is None):
                                            self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList()
                                            self.distribute_list.parent = self
                                            self._children_name_map["distribute_list"] = "distribute-list"
                                        return self.distribute_list

                                    if (child_yang_name == "encryption"):
                                        if (self.encryption is None):
                                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption()
                                            self.encryption.parent = self
                                            self._children_name_map["encryption"] = "encryption"
                                        return self.encryption

                                    if (child_yang_name == "fast-reroute"):
                                        if (self.fast_reroute is None):
                                            self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute()
                                            self.fast_reroute.parent = self
                                            self._children_name_map["fast_reroute"] = "fast-reroute"
                                        return self.fast_reroute

                                    if (child_yang_name == "neighbors"):
                                        if (self.neighbors is None):
                                            self.neighbors = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors()
                                            self.neighbors.parent = self
                                            self._children_name_map["neighbors"] = "neighbors"
                                        return self.neighbors

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "fast-reroute" or name == "neighbors" or name == "interface-name" or name == "cost" or name == "dead-interval" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "demand-circuit"):
                                        self.demand_circuit = value
                                        self.demand_circuit.value_namespace = name_space
                                        self.demand_circuit.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "flood-reduction"):
                                        self.flood_reduction = value
                                        self.flood_reduction.value_namespace = name_space
                                        self.flood_reduction.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "instance"):
                                        self.instance = value
                                        self.instance.value_namespace = name_space
                                        self.instance.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ldp-sync"):
                                        self.ldp_sync = value
                                        self.ldp_sync.value_namespace = name_space
                                        self.ldp_sync.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mtu-ignore"):
                                        self.mtu_ignore = value
                                        self.mtu_ignore.value_namespace = name_space
                                        self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                    if(value_path == "network"):
                                        self.network = value
                                        self.network.value_namespace = name_space
                                        self.network.value_namespace_prefix = name_space_prefix
                                    if(value_path == "packet-size"):
                                        self.packet_size = value
                                        self.packet_size.value_namespace = name_space
                                        self.packet_size.value_namespace_prefix = name_space_prefix
                                    if(value_path == "passive"):
                                        self.passive = value
                                        self.passive.value_namespace = name_space
                                        self.passive.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-suppression"):
                                        self.prefix_suppression = value
                                        self.prefix_suppression.value_namespace = name_space
                                        self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                    if(value_path == "priority"):
                                        self.priority = value
                                        self.priority.value_namespace = name_space
                                        self.priority.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.interface:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.interface:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interfaces" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "interface"):
                                    for c in self.interface:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces.Interface()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.interface.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class AreaScope(Entity):
                            """
                            Area Scope Configuration
                            
                            .. attribute:: fast_reroute
                            
                            	Fast\-reroute configuration
                            	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope, self).__init__()

                                self.yang_name = "area-scope"
                                self.yang_parent_name = "area-area-id"

                                self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute()
                                self.fast_reroute.parent = self
                                self._children_name_map["fast_reroute"] = "fast-reroute"
                                self._children_yang_names.add("fast-reroute")


                            class FastReroute(Entity):
                                """
                                Fast\-reroute configuration
                                
                                .. attribute:: fast_reroute_enable
                                
                                	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                
                                .. attribute:: per_link
                                
                                	Fast\-reroute per\-link configuration
                                	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink>`
                                
                                .. attribute:: per_prefix
                                
                                	Fast\-reroute per\-link configuration
                                	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute, self).__init__()

                                    self.yang_name = "fast-reroute"
                                    self.yang_parent_name = "area-scope"

                                    self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                    self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink()
                                    self.per_link.parent = self
                                    self._children_name_map["per_link"] = "per-link"
                                    self._children_yang_names.add("per-link")

                                    self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix()
                                    self.per_prefix.parent = self
                                    self._children_name_map["per_prefix"] = "per-prefix"
                                    self._children_yang_names.add("per-prefix")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fast_reroute_enable") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute, self).__setattr__(name, value)


                                class PerLink(Entity):
                                    """
                                    Fast\-reroute per\-link configuration
                                    
                                    .. attribute:: candidate_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                    	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces>`
                                    
                                    .. attribute:: exclude_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                    	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces>`
                                    
                                    .. attribute:: fast_reroute_use_candidate_only
                                    
                                    	Use only interfaces on the candidate list as a backup path
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink, self).__init__()

                                        self.yang_name = "per-link"
                                        self.yang_parent_name = "fast-reroute"

                                        self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                        self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                        self.candidate_interfaces.parent = self
                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                        self._children_yang_names.add("candidate-interfaces")

                                        self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                        self._children_yang_names.add("exclude-interfaces")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)


                                    class CandidateInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix candidate
                                        interface configuration
                                        
                                        .. attribute:: candidate_interface
                                        
                                        	Candidate backup interface
                                        	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                            self.yang_name = "candidate-interfaces"
                                            self.yang_parent_name = "per-link"

                                            self.candidate_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                        class CandidateInterface(Entity):
                                            """
                                            Candidate backup interface
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                self.yang_name = "candidate-interface"
                                                self.yang_parent_name = "candidate-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.candidate_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.candidate_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "candidate-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interface"):
                                                for c in self.candidate_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.candidate_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class ExcludeInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix exclude
                                        interface configuration
                                        
                                        .. attribute:: exclude_interface
                                        
                                        	Exclude an interface from becoming a backup
                                        	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                            self.yang_name = "exclude-interfaces"
                                            self.yang_parent_name = "per-link"

                                            self.exclude_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                        class ExcludeInterface(Entity):
                                            """
                                            Exclude an interface from becoming a backup
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                self.yang_name = "exclude-interface"
                                                self.yang_parent_name = "exclude-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.exclude_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.exclude_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "exclude-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "exclude-interface"):
                                                for c in self.exclude_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.exclude_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "exclude-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_use_candidate_only.is_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "per-link" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "candidate-interfaces"):
                                            if (self.candidate_interfaces is None):
                                                self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            return self.candidate_interfaces

                                        if (child_yang_name == "exclude-interfaces"):
                                            if (self.exclude_interfaces is None):
                                                self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            return self.exclude_interfaces

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-use-candidate-only"):
                                            self.fast_reroute_use_candidate_only = value
                                            self.fast_reroute_use_candidate_only.value_namespace = name_space
                                            self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                class PerPrefix(Entity):
                                    """
                                    Fast\-reroute per\-link configuration
                                    
                                    .. attribute:: candidate_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                    	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces>`
                                    
                                    .. attribute:: exclude_interfaces
                                    
                                    	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                    	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces>`
                                    
                                    .. attribute:: fast_reroute_use_candidate_only
                                    
                                    	Use only interfaces on the candidate list as a backup path
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix, self).__init__()

                                        self.yang_name = "per-prefix"
                                        self.yang_parent_name = "fast-reroute"

                                        self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                        self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                        self.candidate_interfaces.parent = self
                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                        self._children_yang_names.add("candidate-interfaces")

                                        self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                        self._children_yang_names.add("exclude-interfaces")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)


                                    class CandidateInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix candidate
                                        interface configuration
                                        
                                        .. attribute:: candidate_interface
                                        
                                        	Candidate backup interface
                                        	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                            self.yang_name = "candidate-interfaces"
                                            self.yang_parent_name = "per-prefix"

                                            self.candidate_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                        class CandidateInterface(Entity):
                                            """
                                            Candidate backup interface
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                self.yang_name = "candidate-interface"
                                                self.yang_parent_name = "candidate-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.candidate_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.candidate_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "candidate-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interface"):
                                                for c in self.candidate_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.candidate_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class ExcludeInterfaces(Entity):
                                        """
                                        Fast\-reroute per\-link/per\-prefix exclude
                                        interface configuration
                                        
                                        .. attribute:: exclude_interface
                                        
                                        	Exclude an interface from becoming a backup
                                        	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                            self.yang_name = "exclude-interfaces"
                                            self.yang_parent_name = "per-prefix"

                                            self.exclude_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                        class ExcludeInterface(Entity):
                                            """
                                            Exclude an interface from becoming a backup
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                self.yang_name = "exclude-interface"
                                                self.yang_parent_name = "exclude-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.interface_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.exclude_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.exclude_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "exclude-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "exclude-interface"):
                                                for c in self.exclude_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.exclude_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "exclude-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_use_candidate_only.is_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                            (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                            (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "per-prefix" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "candidate-interfaces"):
                                            if (self.candidate_interfaces is None):
                                                self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            return self.candidate_interfaces

                                        if (child_yang_name == "exclude-interfaces"):
                                            if (self.exclude_interfaces is None):
                                                self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            return self.exclude_interfaces

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-use-candidate-only"):
                                            self.fast_reroute_use_candidate_only = value
                                            self.fast_reroute_use_candidate_only.value_namespace = name_space
                                            self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.fast_reroute_enable.is_set or
                                        (self.per_link is not None and self.per_link.has_data()) or
                                        (self.per_prefix is not None and self.per_prefix.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fast_reroute_enable.yfilter != YFilter.not_set or
                                        (self.per_link is not None and self.per_link.has_operation()) or
                                        (self.per_prefix is not None and self.per_prefix.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fast-reroute" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "per-link"):
                                        if (self.per_link is None):
                                            self.per_link = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink()
                                            self.per_link.parent = self
                                            self._children_name_map["per_link"] = "per-link"
                                        return self.per_link

                                    if (child_yang_name == "per-prefix"):
                                        if (self.per_prefix is None):
                                            self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix()
                                            self.per_prefix.parent = self
                                            self._children_name_map["per_prefix"] = "per-prefix"
                                        return self.per_prefix

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fast-reroute-enable"):
                                        self.fast_reroute_enable = value
                                        self.fast_reroute_enable.value_namespace = name_space
                                        self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (self.fast_reroute is not None and self.fast_reroute.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.fast_reroute is not None and self.fast_reroute.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "area-scope" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fast-reroute"):
                                    if (self.fast_reroute is None):
                                        self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute()
                                        self.fast_reroute.parent = self
                                        self._children_name_map["fast_reroute"] = "fast-reroute"
                                    return self.fast_reroute

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fast-reroute"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class ShamLinks(Entity):
                            """
                            Sham Link sub\-mode
                            
                            .. attribute:: sham_link
                            
                            	ShamLink local and remote endpoints
                            	**type**\: list of    :py:class:`ShamLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks, self).__init__()

                                self.yang_name = "sham-links"
                                self.yang_parent_name = "area-area-id"

                                self.sham_link = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks, self).__setattr__(name, value)


                            class ShamLink(Entity):
                                """
                                ShamLink local and remote endpoints
                                
                                .. attribute:: source_address  <key>
                                
                                	Local sham\-link endpoint
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: destination_address  <key>
                                
                                	Remote sham\-link endpoint
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: authentication
                                
                                	Authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication>`
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead (in seconds)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: enable
                                
                                	Enable sham link
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: encryption
                                
                                	Encrypt and authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption>`
                                
                                .. attribute:: hello_interval
                                
                                	Time between HELLO packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: retransmit_interval
                                
                                	Specify the transmit interval in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: transmit_delay
                                
                                	Specify the transmit delay in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink, self).__init__()

                                    self.yang_name = "sham-link"
                                    self.yang_parent_name = "sham-links"

                                    self.source_address = YLeaf(YType.str, "source-address")

                                    self.destination_address = YLeaf(YType.str, "destination-address")

                                    self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                    self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                    self._children_yang_names.add("encryption")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("source_address",
                                                    "destination_address",
                                                    "dead_interval",
                                                    "enable",
                                                    "hello_interval",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink, self).__setattr__(name, value)


                                class Authentication(Entity):
                                    """
                                    Authenticate OSPFv3 packets
                                    
                                    .. attribute:: algorithm
                                    
                                    	Use the MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "sham-link"

                                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.password = YLeaf(YType.str, "password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("algorithm",
                                                        "enable",
                                                        "password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.algorithm.is_set or
                                            self.enable.is_set or
                                            self.password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.algorithm.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "algorithm"):
                                            self.algorithm = value
                                            self.algorithm.value_namespace = name_space
                                            self.algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "password"):
                                            self.password = value
                                            self.password.value_namespace = name_space
                                            self.password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Encryption(Entity):
                                    """
                                    Encrypt and authenticate OSPFv3 packets
                                    
                                    .. attribute:: authentication_algorithm
                                    
                                    	Use the NULL, MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                    
                                    .. attribute:: authentication_password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: encryption_algorithm
                                    
                                    	Specify the encryption algorithm
                                    	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                    
                                    .. attribute:: encryption_password
                                    
                                    	Encryption password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption, self).__init__()

                                        self.yang_name = "encryption"
                                        self.yang_parent_name = "sham-link"

                                        self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                        self.authentication_password = YLeaf(YType.str, "authentication-password")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                        self.encryption_password = YLeaf(YType.str, "encryption-password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("authentication_algorithm",
                                                        "authentication_password",
                                                        "enable",
                                                        "encryption_algorithm",
                                                        "encryption_password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.authentication_algorithm.is_set or
                                            self.authentication_password.is_set or
                                            self.enable.is_set or
                                            self.encryption_algorithm.is_set or
                                            self.encryption_password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.authentication_algorithm.yfilter != YFilter.not_set or
                                            self.authentication_password.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.encryption_algorithm.yfilter != YFilter.not_set or
                                            self.encryption_password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "encryption" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                        if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                        if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "authentication-algorithm"):
                                            self.authentication_algorithm = value
                                            self.authentication_algorithm.value_namespace = name_space
                                            self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "authentication-password"):
                                            self.authentication_password = value
                                            self.authentication_password.value_namespace = name_space
                                            self.authentication_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-algorithm"):
                                            self.encryption_algorithm = value
                                            self.encryption_algorithm.value_namespace = name_space
                                            self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-password"):
                                            self.encryption_password = value
                                            self.encryption_password.value_namespace = name_space
                                            self.encryption_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.source_address.is_set or
                                        self.destination_address.is_set or
                                        self.dead_interval.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.encryption is not None and self.encryption.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.source_address.yfilter != YFilter.not_set or
                                        self.destination_address.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.encryption is not None and self.encryption.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sham-link" + "[source-address='" + self.source_address.get() + "']" + "[destination-address='" + self.destination_address.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source_address.get_name_leafdata())
                                    if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.destination_address.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "encryption"):
                                        if (self.encryption is None):
                                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption()
                                            self.encryption.parent = self
                                            self._children_name_map["encryption"] = "encryption"
                                        return self.encryption

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "encryption" or name == "source-address" or name == "destination-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "source-address"):
                                        self.source_address = value
                                        self.source_address.value_namespace = name_space
                                        self.source_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "destination-address"):
                                        self.destination_address = value
                                        self.destination_address.value_namespace = name_space
                                        self.destination_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sham_link:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.sham_link:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "sham-links" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sham-link"):
                                    for c in self.sham_link:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sham_link.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sham-link"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class VirtualLinks(Entity):
                            """
                            Virtual link sub\-mode
                            
                            .. attribute:: virtual_link
                            
                            	Router ID of virtual link neighbor
                            	**type**\: list of    :py:class:`VirtualLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks, self).__init__()

                                self.yang_name = "virtual-links"
                                self.yang_parent_name = "area-area-id"

                                self.virtual_link = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks, self).__setattr__(name, value)


                            class VirtualLink(Entity):
                                """
                                Router ID of virtual link neighbor
                                
                                .. attribute:: virtual_link_address  <key>
                                
                                	Router ID of virtual link neighbor
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: authentication
                                
                                	Authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication>`
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead (in seconds)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: enable
                                
                                	Enabled virtual link
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: encryption
                                
                                	Encrypt and authenticate OSPFv3 packets
                                	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption>`
                                
                                .. attribute:: hello_interval
                                
                                	Time between HELLO packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: retransmit_interval
                                
                                	Specify the transmit interval in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                .. attribute:: transmit_delay
                                
                                	Specify the transmit delay in seconds
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink, self).__init__()

                                    self.yang_name = "virtual-link"
                                    self.yang_parent_name = "virtual-links"

                                    self.virtual_link_address = YLeaf(YType.str, "virtual-link-address")

                                    self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                    self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                    self._children_yang_names.add("encryption")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("virtual_link_address",
                                                    "dead_interval",
                                                    "enable",
                                                    "hello_interval",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink, self).__setattr__(name, value)


                                class Authentication(Entity):
                                    """
                                    Authenticate OSPFv3 packets
                                    
                                    .. attribute:: algorithm
                                    
                                    	Use the MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "virtual-link"

                                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.password = YLeaf(YType.str, "password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("algorithm",
                                                        "enable",
                                                        "password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.algorithm.is_set or
                                            self.enable.is_set or
                                            self.password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.algorithm.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "algorithm"):
                                            self.algorithm = value
                                            self.algorithm.value_namespace = name_space
                                            self.algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "password"):
                                            self.password = value
                                            self.password.value_namespace = name_space
                                            self.password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix


                                class Encryption(Entity):
                                    """
                                    Encrypt and authenticate OSPFv3 packets
                                    
                                    .. attribute:: authentication_algorithm
                                    
                                    	Use the NULL, MD5 or SHA1 algorithm
                                    	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                    
                                    .. attribute:: authentication_password
                                    
                                    	Specify MD5 or SHA1 password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: enable
                                    
                                    	Authenticate packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: encryption_algorithm
                                    
                                    	Specify the encryption algorithm
                                    	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                    
                                    .. attribute:: encryption_password
                                    
                                    	Encryption password
                                    	**type**\:  str
                                    
                                    	**pattern:** (!.+)\|([^!].+)
                                    
                                    .. attribute:: spi
                                    
                                    	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                    	**type**\:  int
                                    
                                    	**range:** 256..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption, self).__init__()

                                        self.yang_name = "encryption"
                                        self.yang_parent_name = "virtual-link"

                                        self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                        self.authentication_password = YLeaf(YType.str, "authentication-password")

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                        self.encryption_password = YLeaf(YType.str, "encryption-password")

                                        self.spi = YLeaf(YType.uint32, "spi")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("authentication_algorithm",
                                                        "authentication_password",
                                                        "enable",
                                                        "encryption_algorithm",
                                                        "encryption_password",
                                                        "spi") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.authentication_algorithm.is_set or
                                            self.authentication_password.is_set or
                                            self.enable.is_set or
                                            self.encryption_algorithm.is_set or
                                            self.encryption_password.is_set or
                                            self.spi.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.authentication_algorithm.yfilter != YFilter.not_set or
                                            self.authentication_password.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.encryption_algorithm.yfilter != YFilter.not_set or
                                            self.encryption_password.yfilter != YFilter.not_set or
                                            self.spi.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "encryption" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                        if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                        if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.spi.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "authentication-algorithm"):
                                            self.authentication_algorithm = value
                                            self.authentication_algorithm.value_namespace = name_space
                                            self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "authentication-password"):
                                            self.authentication_password = value
                                            self.authentication_password.value_namespace = name_space
                                            self.authentication_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-algorithm"):
                                            self.encryption_algorithm = value
                                            self.encryption_algorithm.value_namespace = name_space
                                            self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                        if(value_path == "encryption-password"):
                                            self.encryption_password = value
                                            self.encryption_password.value_namespace = name_space
                                            self.encryption_password.value_namespace_prefix = name_space_prefix
                                        if(value_path == "spi"):
                                            self.spi = value
                                            self.spi.value_namespace = name_space
                                            self.spi.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.virtual_link_address.is_set or
                                        self.dead_interval.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.encryption is not None and self.encryption.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.virtual_link_address.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.encryption is not None and self.encryption.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "virtual-link" + "[virtual-link-address='" + self.virtual_link_address.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.virtual_link_address.is_set or self.virtual_link_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.virtual_link_address.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "encryption"):
                                        if (self.encryption is None):
                                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption()
                                            self.encryption.parent = self
                                            self._children_name_map["encryption"] = "encryption"
                                        return self.encryption

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "encryption" or name == "virtual-link-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "virtual-link-address"):
                                        self.virtual_link_address = value
                                        self.virtual_link_address.value_namespace = name_space
                                        self.virtual_link_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.virtual_link:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.virtual_link:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "virtual-links" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "virtual-link"):
                                    for c in self.virtual_link:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.virtual_link.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "virtual-link"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.area_id.is_set or
                                self.cost.is_set or
                                self.dead_interval.is_set or
                                self.default_cost.is_set or
                                self.demand_circuit.is_set or
                                self.enable.is_set or
                                self.flood_reduction.is_set or
                                self.hello_interval.is_set or
                                self.instance.is_set or
                                self.ldp_sync.is_set or
                                self.mtu_ignore.is_set or
                                self.network.is_set or
                                self.packet_size.is_set or
                                self.passive.is_set or
                                self.prefix_suppression.is_set or
                                self.priority.is_set or
                                self.retransmit_interval.is_set or
                                self.stub.is_set or
                                self.transmit_delay.is_set or
                                (self.area_scope is not None and self.area_scope.has_data()) or
                                (self.authentication is not None and self.authentication.has_data()) or
                                (self.bfd is not None and self.bfd.has_data()) or
                                (self.database_filter is not None and self.database_filter.has_data()) or
                                (self.distribute_list is not None and self.distribute_list.has_data()) or
                                (self.encryption is not None and self.encryption.has_data()) or
                                (self.interfaces is not None and self.interfaces.has_data()) or
                                (self.nssa is not None and self.nssa.has_data()) or
                                (self.ranges is not None and self.ranges.has_data()) or
                                (self.sham_links is not None and self.sham_links.has_data()) or
                                (self.virtual_links is not None and self.virtual_links.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.area_id.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.dead_interval.yfilter != YFilter.not_set or
                                self.default_cost.yfilter != YFilter.not_set or
                                self.demand_circuit.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.flood_reduction.yfilter != YFilter.not_set or
                                self.hello_interval.yfilter != YFilter.not_set or
                                self.instance.yfilter != YFilter.not_set or
                                self.ldp_sync.yfilter != YFilter.not_set or
                                self.mtu_ignore.yfilter != YFilter.not_set or
                                self.network.yfilter != YFilter.not_set or
                                self.packet_size.yfilter != YFilter.not_set or
                                self.passive.yfilter != YFilter.not_set or
                                self.prefix_suppression.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.retransmit_interval.yfilter != YFilter.not_set or
                                self.stub.yfilter != YFilter.not_set or
                                self.transmit_delay.yfilter != YFilter.not_set or
                                (self.area_scope is not None and self.area_scope.has_operation()) or
                                (self.authentication is not None and self.authentication.has_operation()) or
                                (self.bfd is not None and self.bfd.has_operation()) or
                                (self.database_filter is not None and self.database_filter.has_operation()) or
                                (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                (self.encryption is not None and self.encryption.has_operation()) or
                                (self.interfaces is not None and self.interfaces.has_operation()) or
                                (self.nssa is not None and self.nssa.has_operation()) or
                                (self.ranges is not None and self.ranges.has_operation()) or
                                (self.sham_links is not None and self.sham_links.has_operation()) or
                                (self.virtual_links is not None and self.virtual_links.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "area-area-id" + "[area-id='" + self.area_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.area_id.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dead_interval.get_name_leafdata())
                            if (self.default_cost.is_set or self.default_cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_cost.get_name_leafdata())
                            if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                            if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_interval.get_name_leafdata())
                            if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance.get_name_leafdata())
                            if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                            if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                            if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.network.get_name_leafdata())
                            if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.packet_size.get_name_leafdata())
                            if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.passive.get_name_leafdata())
                            if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                            if (self.stub.is_set or self.stub.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stub.get_name_leafdata())
                            if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "area-scope"):
                                if (self.area_scope is None):
                                    self.area_scope = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.AreaScope()
                                    self.area_scope.parent = self
                                    self._children_name_map["area_scope"] = "area-scope"
                                return self.area_scope

                            if (child_yang_name == "authentication"):
                                if (self.authentication is None):
                                    self.authentication = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                return self.authentication

                            if (child_yang_name == "bfd"):
                                if (self.bfd is None):
                                    self.bfd = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Bfd()
                                    self.bfd.parent = self
                                    self._children_name_map["bfd"] = "bfd"
                                return self.bfd

                            if (child_yang_name == "database-filter"):
                                if (self.database_filter is None):
                                    self.database_filter = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DatabaseFilter()
                                    self.database_filter.parent = self
                                    self._children_name_map["database_filter"] = "database-filter"
                                return self.database_filter

                            if (child_yang_name == "distribute-list"):
                                if (self.distribute_list is None):
                                    self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.DistributeList()
                                    self.distribute_list.parent = self
                                    self._children_name_map["distribute_list"] = "distribute-list"
                                return self.distribute_list

                            if (child_yang_name == "encryption"):
                                if (self.encryption is None):
                                    self.encryption = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Encryption()
                                    self.encryption.parent = self
                                    self._children_name_map["encryption"] = "encryption"
                                return self.encryption

                            if (child_yang_name == "interfaces"):
                                if (self.interfaces is None):
                                    self.interfaces = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Interfaces()
                                    self.interfaces.parent = self
                                    self._children_name_map["interfaces"] = "interfaces"
                                return self.interfaces

                            if (child_yang_name == "nssa"):
                                if (self.nssa is None):
                                    self.nssa = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Nssa()
                                    self.nssa.parent = self
                                    self._children_name_map["nssa"] = "nssa"
                                return self.nssa

                            if (child_yang_name == "ranges"):
                                if (self.ranges is None):
                                    self.ranges = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.Ranges()
                                    self.ranges.parent = self
                                    self._children_name_map["ranges"] = "ranges"
                                return self.ranges

                            if (child_yang_name == "sham-links"):
                                if (self.sham_links is None):
                                    self.sham_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.ShamLinks()
                                    self.sham_links.parent = self
                                    self._children_name_map["sham_links"] = "sham-links"
                                return self.sham_links

                            if (child_yang_name == "virtual-links"):
                                if (self.virtual_links is None):
                                    self.virtual_links = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId.VirtualLinks()
                                    self.virtual_links.parent = self
                                    self._children_name_map["virtual_links"] = "virtual-links"
                                return self.virtual_links

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "area-scope" or name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "interfaces" or name == "nssa" or name == "ranges" or name == "sham-links" or name == "virtual-links" or name == "area-id" or name == "cost" or name == "dead-interval" or name == "default-cost" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "stub" or name == "transmit-delay"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "area-id"):
                                self.area_id = value
                                self.area_id.value_namespace = name_space
                                self.area_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "dead-interval"):
                                self.dead_interval = value
                                self.dead_interval.value_namespace = name_space
                                self.dead_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "default-cost"):
                                self.default_cost = value
                                self.default_cost.value_namespace = name_space
                                self.default_cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "demand-circuit"):
                                self.demand_circuit = value
                                self.demand_circuit.value_namespace = name_space
                                self.demand_circuit.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "flood-reduction"):
                                self.flood_reduction = value
                                self.flood_reduction.value_namespace = name_space
                                self.flood_reduction.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-interval"):
                                self.hello_interval = value
                                self.hello_interval.value_namespace = name_space
                                self.hello_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance"):
                                self.instance = value
                                self.instance.value_namespace = name_space
                                self.instance.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldp-sync"):
                                self.ldp_sync = value
                                self.ldp_sync.value_namespace = name_space
                                self.ldp_sync.value_namespace_prefix = name_space_prefix
                            if(value_path == "mtu-ignore"):
                                self.mtu_ignore = value
                                self.mtu_ignore.value_namespace = name_space
                                self.mtu_ignore.value_namespace_prefix = name_space_prefix
                            if(value_path == "network"):
                                self.network = value
                                self.network.value_namespace = name_space
                                self.network.value_namespace_prefix = name_space_prefix
                            if(value_path == "packet-size"):
                                self.packet_size = value
                                self.packet_size.value_namespace = name_space
                                self.packet_size.value_namespace_prefix = name_space_prefix
                            if(value_path == "passive"):
                                self.passive = value
                                self.passive.value_namespace = name_space
                                self.passive.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-suppression"):
                                self.prefix_suppression = value
                                self.prefix_suppression.value_namespace = name_space
                                self.prefix_suppression.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "retransmit-interval"):
                                self.retransmit_interval = value
                                self.retransmit_interval.value_namespace = name_space
                                self.retransmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "stub"):
                                self.stub = value
                                self.stub.value_namespace = name_space
                                self.stub.value_namespace_prefix = name_space_prefix
                            if(value_path == "transmit-delay"):
                                self.transmit_delay = value
                                self.transmit_delay.value_namespace = name_space
                                self.transmit_delay.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.area_address:
                            if (c.has_data()):
                                return True
                        for c in self.area_area_id:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.area_address:
                            if (c.has_operation()):
                                return True
                        for c in self.area_area_id:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "area-addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "area-address"):
                            for c in self.area_address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAddress()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.area_address.append(c)
                            return c

                        if (child_yang_name == "area-area-id"):
                            for c in self.area_area_id:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses.AreaAreaId()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.area_area_id.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "area-address" or name == "area-area-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Timers(Entity):
                    """
                    Adjust routing timers
                    
                    .. attribute:: lsa_timers
                    
                    	LSA timers
                    	**type**\:   :py:class:`LsaTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Timers.LsaTimers>`
                    
                    .. attribute:: pacing
                    
                    	Pacing timers
                    	**type**\:   :py:class:`Pacing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Timers.Pacing>`
                    
                    .. attribute:: throttle
                    
                    	Throttle timers
                    	**type**\:   :py:class:`Throttle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Timers, self).__init__()

                        self.yang_name = "timers"
                        self.yang_parent_name = "default-vrf"

                        self.lsa_timers = Ospfv3.Processes.Process.DefaultVrf.Timers.LsaTimers()
                        self.lsa_timers.parent = self
                        self._children_name_map["lsa_timers"] = "lsa-timers"
                        self._children_yang_names.add("lsa-timers")

                        self.pacing = Ospfv3.Processes.Process.DefaultVrf.Timers.Pacing()
                        self.pacing.parent = self
                        self._children_name_map["pacing"] = "pacing"
                        self._children_yang_names.add("pacing")

                        self.throttle = Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle()
                        self.throttle.parent = self
                        self._children_name_map["throttle"] = "throttle"
                        self._children_yang_names.add("throttle")


                    class Pacing(Entity):
                        """
                        Pacing timers
                        
                        .. attribute:: flood
                        
                        	The minimum interval in milliseconds to pace limit flooding on interface
                        	**type**\:  int
                        
                        	**range:** 5..100
                        
                        	**units**\: millisecond
                        
                        .. attribute:: lsa_group
                        
                        	Interval in seconds at which LSAs are grouped and refreshed, checksummed, or aged
                        	**type**\:  int
                        
                        	**range:** 10..1800
                        
                        	**units**\: second
                        
                        .. attribute:: retransmission
                        
                        	The minimum interval in msec between neighbor retransmissions
                        	**type**\:  int
                        
                        	**range:** 5..100
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Timers.Pacing, self).__init__()

                            self.yang_name = "pacing"
                            self.yang_parent_name = "timers"

                            self.flood = YLeaf(YType.uint32, "flood")

                            self.lsa_group = YLeaf(YType.uint32, "lsa-group")

                            self.retransmission = YLeaf(YType.uint32, "retransmission")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("flood",
                                            "lsa_group",
                                            "retransmission") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.Timers.Pacing, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.Timers.Pacing, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.flood.is_set or
                                self.lsa_group.is_set or
                                self.retransmission.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.flood.yfilter != YFilter.not_set or
                                self.lsa_group.yfilter != YFilter.not_set or
                                self.retransmission.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "pacing" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.flood.is_set or self.flood.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.flood.get_name_leafdata())
                            if (self.lsa_group.is_set or self.lsa_group.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lsa_group.get_name_leafdata())
                            if (self.retransmission.is_set or self.retransmission.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.retransmission.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "flood" or name == "lsa-group" or name == "retransmission"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "flood"):
                                self.flood = value
                                self.flood.value_namespace = name_space
                                self.flood.value_namespace_prefix = name_space_prefix
                            if(value_path == "lsa-group"):
                                self.lsa_group = value
                                self.lsa_group.value_namespace = name_space
                                self.lsa_group.value_namespace_prefix = name_space_prefix
                            if(value_path == "retransmission"):
                                self.retransmission = value
                                self.retransmission.value_namespace = name_space
                                self.retransmission.value_namespace_prefix = name_space_prefix


                    class LsaTimers(Entity):
                        """
                        LSA timers
                        
                        .. attribute:: arrival
                        
                        	The minimum interval in milliseconds between accepting the same LSA
                        	**type**\:  int
                        
                        	**range:** 0..60000
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Timers.LsaTimers, self).__init__()

                            self.yang_name = "lsa-timers"
                            self.yang_parent_name = "timers"

                            self.arrival = YLeaf(YType.uint32, "arrival")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("arrival") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.Timers.LsaTimers, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.Timers.LsaTimers, self).__setattr__(name, value)

                        def has_data(self):
                            return self.arrival.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.arrival.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "lsa-timers" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.arrival.is_set or self.arrival.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.arrival.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "arrival"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "arrival"):
                                self.arrival = value
                                self.arrival.value_namespace = name_space
                                self.arrival.value_namespace_prefix = name_space_prefix


                    class Throttle(Entity):
                        """
                        Throttle timers
                        
                        .. attribute:: lsa
                        
                        	LSA throttle timers for all types of OSPF LSAs
                        	**type**\:   :py:class:`Lsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Lsa>`
                        
                        .. attribute:: spf
                        
                        	SPF throttle timers
                        	**type**\:   :py:class:`Spf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Spf>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle, self).__init__()

                            self.yang_name = "throttle"
                            self.yang_parent_name = "timers"

                            self.lsa = Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Lsa()
                            self.lsa.parent = self
                            self._children_name_map["lsa"] = "lsa"
                            self._children_yang_names.add("lsa")

                            self.spf = Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Spf()
                            self.spf.parent = self
                            self._children_name_map["spf"] = "spf"
                            self._children_yang_names.add("spf")


                        class Lsa(Entity):
                            """
                            LSA throttle timers for all types of OSPF LSAs
                            
                            .. attribute:: first_delay
                            
                            	Delay to generate first occurrence of LSA in milliseconds
                            	**type**\:  int
                            
                            	**range:** 0..600000
                            
                            	**units**\: millisecond
                            
                            .. attribute:: maximum_delay
                            
                            	Maximum delay between originating the same LSA in milliseconds
                            	**type**\:  int
                            
                            	**range:** 1..600000
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_delay
                            
                            	Minimum delay between originating the same LSA in milliseconds
                            	**type**\:  int
                            
                            	**range:** 1..600000
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Lsa, self).__init__()

                                self.yang_name = "lsa"
                                self.yang_parent_name = "throttle"

                                self.first_delay = YLeaf(YType.uint32, "first-delay")

                                self.maximum_delay = YLeaf(YType.uint32, "maximum-delay")

                                self.minimum_delay = YLeaf(YType.uint32, "minimum-delay")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("first_delay",
                                                "maximum_delay",
                                                "minimum_delay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Lsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Lsa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.first_delay.is_set or
                                    self.maximum_delay.is_set or
                                    self.minimum_delay.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.first_delay.yfilter != YFilter.not_set or
                                    self.maximum_delay.yfilter != YFilter.not_set or
                                    self.minimum_delay.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.first_delay.is_set or self.first_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.first_delay.get_name_leafdata())
                                if (self.maximum_delay.is_set or self.maximum_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_delay.get_name_leafdata())
                                if (self.minimum_delay.is_set or self.minimum_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_delay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "first-delay" or name == "maximum-delay" or name == "minimum-delay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "first-delay"):
                                    self.first_delay = value
                                    self.first_delay.value_namespace = name_space
                                    self.first_delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-delay"):
                                    self.maximum_delay = value
                                    self.maximum_delay.value_namespace = name_space
                                    self.maximum_delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-delay"):
                                    self.minimum_delay = value
                                    self.minimum_delay.value_namespace = name_space
                                    self.minimum_delay.value_namespace_prefix = name_space_prefix


                        class Spf(Entity):
                            """
                            SPF throttle timers
                            
                            .. attribute:: first_delay
                            
                            	Initial delay between receiving a change and starting SPF in ms
                            	**type**\:  int
                            
                            	**range:** 1..600000
                            
                            .. attribute:: maximum_delay
                            
                            	Maximum wait time between consecutive SPF calculations in ms
                            	**type**\:  int
                            
                            	**range:** 1..600000
                            
                            .. attribute:: minimum_delay
                            
                            	Minimum hold time between consecutive SPF calculations in ms
                            	**type**\:  int
                            
                            	**range:** 1..600000
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Spf, self).__init__()

                                self.yang_name = "spf"
                                self.yang_parent_name = "throttle"

                                self.first_delay = YLeaf(YType.uint32, "first-delay")

                                self.maximum_delay = YLeaf(YType.uint32, "maximum-delay")

                                self.minimum_delay = YLeaf(YType.uint32, "minimum-delay")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("first_delay",
                                                "maximum_delay",
                                                "minimum_delay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Spf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Spf, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.first_delay.is_set or
                                    self.maximum_delay.is_set or
                                    self.minimum_delay.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.first_delay.yfilter != YFilter.not_set or
                                    self.maximum_delay.yfilter != YFilter.not_set or
                                    self.minimum_delay.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.first_delay.is_set or self.first_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.first_delay.get_name_leafdata())
                                if (self.maximum_delay.is_set or self.maximum_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_delay.get_name_leafdata())
                                if (self.minimum_delay.is_set or self.minimum_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_delay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "first-delay" or name == "maximum-delay" or name == "minimum-delay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "first-delay"):
                                    self.first_delay = value
                                    self.first_delay.value_namespace = name_space
                                    self.first_delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-delay"):
                                    self.maximum_delay = value
                                    self.maximum_delay.value_namespace = name_space
                                    self.maximum_delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-delay"):
                                    self.minimum_delay = value
                                    self.minimum_delay.value_namespace = name_space
                                    self.minimum_delay.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.lsa is not None and self.lsa.has_data()) or
                                (self.spf is not None and self.spf.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.lsa is not None and self.lsa.has_operation()) or
                                (self.spf is not None and self.spf.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "throttle" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsa"):
                                if (self.lsa is None):
                                    self.lsa = Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Lsa()
                                    self.lsa.parent = self
                                    self._children_name_map["lsa"] = "lsa"
                                return self.lsa

                            if (child_yang_name == "spf"):
                                if (self.spf is None):
                                    self.spf = Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle.Spf()
                                    self.spf.parent = self
                                    self._children_name_map["spf"] = "spf"
                                return self.spf

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsa" or name == "spf"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.lsa_timers is not None and self.lsa_timers.has_data()) or
                            (self.pacing is not None and self.pacing.has_data()) or
                            (self.throttle is not None and self.throttle.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.lsa_timers is not None and self.lsa_timers.has_operation()) or
                            (self.pacing is not None and self.pacing.has_operation()) or
                            (self.throttle is not None and self.throttle.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "timers" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "lsa-timers"):
                            if (self.lsa_timers is None):
                                self.lsa_timers = Ospfv3.Processes.Process.DefaultVrf.Timers.LsaTimers()
                                self.lsa_timers.parent = self
                                self._children_name_map["lsa_timers"] = "lsa-timers"
                            return self.lsa_timers

                        if (child_yang_name == "pacing"):
                            if (self.pacing is None):
                                self.pacing = Ospfv3.Processes.Process.DefaultVrf.Timers.Pacing()
                                self.pacing.parent = self
                                self._children_name_map["pacing"] = "pacing"
                            return self.pacing

                        if (child_yang_name == "throttle"):
                            if (self.throttle is None):
                                self.throttle = Ospfv3.Processes.Process.DefaultVrf.Timers.Throttle()
                                self.throttle.parent = self
                                self._children_name_map["throttle"] = "throttle"
                            return self.throttle

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "lsa-timers" or name == "pacing" or name == "throttle"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SummaryPrefixes(Entity):
                    """
                    Summarize redistributed routes matching
                    prefix/length
                    
                    .. attribute:: summary_prefix
                    
                    	IPv6 address
                    	**type**\: list of    :py:class:`SummaryPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes.SummaryPrefix>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes, self).__init__()

                        self.yang_name = "summary-prefixes"
                        self.yang_parent_name = "default-vrf"

                        self.summary_prefix = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes, self).__setattr__(name, value)


                    class SummaryPrefix(Entity):
                        """
                        IPv6 address
                        
                        .. attribute:: prefix  <key>
                        
                        	IPv6 prefix string format
                        	**type**\:  str
                        
                        	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                        
                        .. attribute:: prefix_length  <key>
                        
                        	IPV6 prefix length
                        	**type**\:  int
                        
                        	**range:** 0..128
                        
                        .. attribute:: not_advertise
                        
                        	Suppress routes matching prefix/length
                        	**type**\:  bool
                        
                        .. attribute:: tag
                        
                        	Tag
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes.SummaryPrefix, self).__init__()

                            self.yang_name = "summary-prefix"
                            self.yang_parent_name = "summary-prefixes"

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            self.not_advertise = YLeaf(YType.boolean, "not-advertise")

                            self.tag = YLeaf(YType.uint32, "tag")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("prefix",
                                            "prefix_length",
                                            "not_advertise",
                                            "tag") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.prefix.is_set or
                                self.prefix_length.is_set or
                                self.not_advertise.is_set or
                                self.tag.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_length.yfilter != YFilter.not_set or
                                self.not_advertise.yfilter != YFilter.not_set or
                                self.tag.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "summary-prefix" + "[prefix='" + self.prefix.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_length.get_name_leafdata())
                            if (self.not_advertise.is_set or self.not_advertise.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.not_advertise.get_name_leafdata())
                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tag.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix" or name == "prefix-length" or name == "not-advertise" or name == "tag"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-length"):
                                self.prefix_length = value
                                self.prefix_length.value_namespace = name_space
                                self.prefix_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "not-advertise"):
                                self.not_advertise = value
                                self.not_advertise.value_namespace = name_space
                                self.not_advertise.value_namespace_prefix = name_space_prefix
                            if(value_path == "tag"):
                                self.tag = value
                                self.tag.value_namespace = name_space
                                self.tag.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.summary_prefix:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.summary_prefix:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "summary-prefixes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "summary-prefix"):
                            for c in self.summary_prefix:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes.SummaryPrefix()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.summary_prefix.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "summary-prefix"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Snmp(Entity):
                    """
                    SNMP configuration
                    
                    .. attribute:: context
                    
                    	SNMP context configuration
                    	**type**\:  str
                    
                    .. attribute:: trap_rate_limit
                    
                    	SNMP trap rate configuration
                    	**type**\:   :py:class:`TrapRateLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Snmp.TrapRateLimit>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Snmp, self).__init__()

                        self.yang_name = "snmp"
                        self.yang_parent_name = "default-vrf"

                        self.context = YLeaf(YType.str, "context")

                        self.trap_rate_limit = Ospfv3.Processes.Process.DefaultVrf.Snmp.TrapRateLimit()
                        self.trap_rate_limit.parent = self
                        self._children_name_map["trap_rate_limit"] = "trap-rate-limit"
                        self._children_yang_names.add("trap-rate-limit")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("context") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.Snmp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.Snmp, self).__setattr__(name, value)


                    class TrapRateLimit(Entity):
                        """
                        SNMP trap rate configuration
                        
                        .. attribute:: max_window_traps
                        
                        	Max number of traps sent in window time
                        	**type**\:  int
                        
                        	**range:** 0..300
                        
                        .. attribute:: window_size
                        
                        	Trap rate limit sliding window size
                        	**type**\:  int
                        
                        	**range:** 2..60
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Snmp.TrapRateLimit, self).__init__()

                            self.yang_name = "trap-rate-limit"
                            self.yang_parent_name = "snmp"

                            self.max_window_traps = YLeaf(YType.uint32, "max-window-traps")

                            self.window_size = YLeaf(YType.uint32, "window-size")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("max_window_traps",
                                            "window_size") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.Snmp.TrapRateLimit, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.Snmp.TrapRateLimit, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.max_window_traps.is_set or
                                self.window_size.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.max_window_traps.yfilter != YFilter.not_set or
                                self.window_size.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "trap-rate-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.max_window_traps.is_set or self.max_window_traps.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.max_window_traps.get_name_leafdata())
                            if (self.window_size.is_set or self.window_size.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.window_size.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "max-window-traps" or name == "window-size"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "max-window-traps"):
                                self.max_window_traps = value
                                self.max_window_traps.value_namespace = name_space
                                self.max_window_traps.value_namespace_prefix = name_space_prefix
                            if(value_path == "window-size"):
                                self.window_size = value
                                self.window_size.value_namespace = name_space
                                self.window_size.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.context.is_set or
                            (self.trap_rate_limit is not None and self.trap_rate_limit.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.context.yfilter != YFilter.not_set or
                            (self.trap_rate_limit is not None and self.trap_rate_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "snmp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.context.is_set or self.context.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.context.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "trap-rate-limit"):
                            if (self.trap_rate_limit is None):
                                self.trap_rate_limit = Ospfv3.Processes.Process.DefaultVrf.Snmp.TrapRateLimit()
                                self.trap_rate_limit.parent = self
                                self._children_name_map["trap_rate_limit"] = "trap-rate-limit"
                            return self.trap_rate_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "trap-rate-limit" or name == "context"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "context"):
                            self.context = value
                            self.context.value_namespace = name_space
                            self.context.value_namespace_prefix = name_space_prefix


                class FastReroute(Entity):
                    """
                    Fast\-reroute instance scoped parameters
                    
                    .. attribute:: per_link
                    
                    	Fast\-reroute per\-link global configuration
                    	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerLink>`
                    
                    .. attribute:: per_prefix
                    
                    	Fast\-reroute per\-prefix global configuration
                    	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.FastReroute, self).__init__()

                        self.yang_name = "fast-reroute"
                        self.yang_parent_name = "default-vrf"

                        self.per_link = Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerLink()
                        self.per_link.parent = self
                        self._children_name_map["per_link"] = "per-link"
                        self._children_yang_names.add("per-link")

                        self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix()
                        self.per_prefix.parent = self
                        self._children_name_map["per_prefix"] = "per-prefix"
                        self._children_yang_names.add("per-prefix")


                    class PerLink(Entity):
                        """
                        Fast\-reroute per\-link global configuration
                        
                        .. attribute:: priority
                        
                        	Fast\-reroute per\-link/per\-prefix priority\-limit command
                        	**type**\:   :py:class:`Ospfv3FastReroutePriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroutePriority>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerLink, self).__init__()

                            self.yang_name = "per-link"
                            self.yang_parent_name = "fast-reroute"

                            self.priority = YLeaf(YType.enumeration, "priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerLink, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerLink, self).__setattr__(name, value)

                        def has_data(self):
                            return self.priority.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "per-link" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix


                    class PerPrefix(Entity):
                        """
                        Fast\-reroute per\-prefix global configuration
                        
                        .. attribute:: load_sharing_disable
                        
                        	Disable load sharing between multiple backups
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: priority
                        
                        	Fast\-reroute per\-link/per\-prefix priority\-limit command
                        	**type**\:   :py:class:`Ospfv3FastReroutePriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroutePriority>`
                        
                        .. attribute:: tiebreakers
                        
                        	Fast\-reroute tiebreakers configurations
                        	**type**\:   :py:class:`Tiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix, self).__init__()

                            self.yang_name = "per-prefix"
                            self.yang_parent_name = "fast-reroute"

                            self.load_sharing_disable = YLeaf(YType.empty, "load-sharing-disable")

                            self.priority = YLeaf(YType.enumeration, "priority")

                            self.tiebreakers = Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers()
                            self.tiebreakers.parent = self
                            self._children_name_map["tiebreakers"] = "tiebreakers"
                            self._children_yang_names.add("tiebreakers")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("load_sharing_disable",
                                            "priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix, self).__setattr__(name, value)


                        class Tiebreakers(Entity):
                            """
                            Fast\-reroute tiebreakers configurations
                            
                            .. attribute:: tiebreaker
                            
                            	Fast\-reroute tiebreakers configuration
                            	**type**\: list of    :py:class:`Tiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers, self).__init__()

                                self.yang_name = "tiebreakers"
                                self.yang_parent_name = "per-prefix"

                                self.tiebreaker = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers, self).__setattr__(name, value)


                            class Tiebreaker(Entity):
                                """
                                Fast\-reroute tiebreakers configuration
                                
                                .. attribute:: tiebreaker_type  <key>
                                
                                	Tiebreaker type
                                	**type**\:   :py:class:`Ospfv3FastRerouteTiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastRerouteTiebreakers>`
                                
                                .. attribute:: tiebreaker_index
                                
                                	Index value for a tiebreaker
                                	**type**\:  int
                                
                                	**range:** 1..255
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker, self).__init__()

                                    self.yang_name = "tiebreaker"
                                    self.yang_parent_name = "tiebreakers"

                                    self.tiebreaker_type = YLeaf(YType.enumeration, "tiebreaker-type")

                                    self.tiebreaker_index = YLeaf(YType.uint32, "tiebreaker-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("tiebreaker_type",
                                                    "tiebreaker_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.tiebreaker_type.is_set or
                                        self.tiebreaker_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.tiebreaker_type.yfilter != YFilter.not_set or
                                        self.tiebreaker_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "tiebreaker" + "[tiebreaker-type='" + self.tiebreaker_type.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.tiebreaker_type.is_set or self.tiebreaker_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tiebreaker_type.get_name_leafdata())
                                    if (self.tiebreaker_index.is_set or self.tiebreaker_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tiebreaker_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "tiebreaker-type" or name == "tiebreaker-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "tiebreaker-type"):
                                        self.tiebreaker_type = value
                                        self.tiebreaker_type.value_namespace = name_space
                                        self.tiebreaker_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tiebreaker-index"):
                                        self.tiebreaker_index = value
                                        self.tiebreaker_index.value_namespace = name_space
                                        self.tiebreaker_index.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.tiebreaker:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.tiebreaker:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "tiebreakers" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "tiebreaker"):
                                    for c in self.tiebreaker:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.tiebreaker.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "tiebreaker"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.load_sharing_disable.is_set or
                                self.priority.is_set or
                                (self.tiebreakers is not None and self.tiebreakers.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.load_sharing_disable.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                (self.tiebreakers is not None and self.tiebreakers.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "per-prefix" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.load_sharing_disable.is_set or self.load_sharing_disable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.load_sharing_disable.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "tiebreakers"):
                                if (self.tiebreakers is None):
                                    self.tiebreakers = Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix.Tiebreakers()
                                    self.tiebreakers.parent = self
                                    self._children_name_map["tiebreakers"] = "tiebreakers"
                                return self.tiebreakers

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "tiebreakers" or name == "load-sharing-disable" or name == "priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "load-sharing-disable"):
                                self.load_sharing_disable = value
                                self.load_sharing_disable.value_namespace = name_space
                                self.load_sharing_disable.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.per_link is not None and self.per_link.has_data()) or
                            (self.per_prefix is not None and self.per_prefix.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.per_link is not None and self.per_link.has_operation()) or
                            (self.per_prefix is not None and self.per_prefix.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "fast-reroute" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "per-link"):
                            if (self.per_link is None):
                                self.per_link = Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerLink()
                                self.per_link.parent = self
                                self._children_name_map["per_link"] = "per-link"
                            return self.per_link

                        if (child_yang_name == "per-prefix"):
                            if (self.per_prefix is None):
                                self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.FastReroute.PerPrefix()
                                self.per_prefix.parent = self
                                self._children_name_map["per_prefix"] = "per-prefix"
                            return self.per_prefix

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "per-link" or name == "per-prefix"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Distance(Entity):
                    """
                    Define an administrative distance
                    
                    .. attribute:: administrative
                    
                    	Define an administrative distance
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    .. attribute:: ospfv3
                    
                    	OSPFv3 administrative distance
                    	**type**\:   :py:class:`Ospfv3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Distance.Ospfv3>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Distance, self).__init__()

                        self.yang_name = "distance"
                        self.yang_parent_name = "default-vrf"

                        self.administrative = YLeaf(YType.uint32, "administrative")

                        self.ospfv3 = Ospfv3.Processes.Process.DefaultVrf.Distance.Ospfv3()
                        self.ospfv3.parent = self
                        self._children_name_map["ospfv3"] = "ospfv3"
                        self._children_yang_names.add("ospfv3")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("administrative") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.Distance, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.Distance, self).__setattr__(name, value)


                    class Ospfv3(Entity):
                        """
                        OSPFv3 administrative distance
                        
                        .. attribute:: external
                        
                        	Distance for external type 5 and type 7 routes
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        .. attribute:: inter_area
                        
                        	Distance for inter\-area routes
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        .. attribute:: intra_area
                        
                        	Distance for intra\-area routes
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Distance.Ospfv3, self).__init__()

                            self.yang_name = "ospfv3"
                            self.yang_parent_name = "distance"

                            self.external = YLeaf(YType.uint32, "external")

                            self.inter_area = YLeaf(YType.uint32, "inter-area")

                            self.intra_area = YLeaf(YType.uint32, "intra-area")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("external",
                                            "inter_area",
                                            "intra_area") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.Distance.Ospfv3, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.Distance.Ospfv3, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.external.is_set or
                                self.inter_area.is_set or
                                self.intra_area.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.external.yfilter != YFilter.not_set or
                                self.inter_area.yfilter != YFilter.not_set or
                                self.intra_area.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ospfv3" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.external.is_set or self.external.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.external.get_name_leafdata())
                            if (self.inter_area.is_set or self.inter_area.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.inter_area.get_name_leafdata())
                            if (self.intra_area.is_set or self.intra_area.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.intra_area.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "external" or name == "inter-area" or name == "intra-area"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "external"):
                                self.external = value
                                self.external.value_namespace = name_space
                                self.external.value_namespace_prefix = name_space_prefix
                            if(value_path == "inter-area"):
                                self.inter_area = value
                                self.inter_area.value_namespace = name_space
                                self.inter_area.value_namespace_prefix = name_space_prefix
                            if(value_path == "intra-area"):
                                self.intra_area = value
                                self.intra_area.value_namespace = name_space
                                self.intra_area.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.administrative.is_set or
                            (self.ospfv3 is not None and self.ospfv3.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.administrative.yfilter != YFilter.not_set or
                            (self.ospfv3 is not None and self.ospfv3.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "distance" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.administrative.is_set or self.administrative.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.administrative.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ospfv3"):
                            if (self.ospfv3 is None):
                                self.ospfv3 = Ospfv3.Processes.Process.DefaultVrf.Distance.Ospfv3()
                                self.ospfv3.parent = self
                                self._children_name_map["ospfv3"] = "ospfv3"
                            return self.ospfv3

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ospfv3" or name == "administrative"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "administrative"):
                            self.administrative = value
                            self.administrative.value_namespace = name_space
                            self.administrative.value_namespace_prefix = name_space_prefix


                class Maximum(Entity):
                    """
                    Set OSPFv3 limits
                    
                    .. attribute:: interfaces
                    
                    	Specify maximum number of interfaces
                    	**type**\:  int
                    
                    	**range:** 1..4294967295
                    
                    .. attribute:: paths
                    
                    	Specify maximum number of paths per route
                    	**type**\:  int
                    
                    	**range:** 1..64
                    
                    .. attribute:: redistributed_prefixes
                    
                    	Limit number of redistributed prefixes
                    	**type**\:   :py:class:`RedistributedPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Maximum.RedistributedPrefixes>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Maximum, self).__init__()

                        self.yang_name = "maximum"
                        self.yang_parent_name = "default-vrf"

                        self.interfaces = YLeaf(YType.uint32, "interfaces")

                        self.paths = YLeaf(YType.uint32, "paths")

                        self.redistributed_prefixes = Ospfv3.Processes.Process.DefaultVrf.Maximum.RedistributedPrefixes()
                        self.redistributed_prefixes.parent = self
                        self._children_name_map["redistributed_prefixes"] = "redistributed-prefixes"
                        self._children_yang_names.add("redistributed-prefixes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interfaces",
                                        "paths") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.Maximum, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.Maximum, self).__setattr__(name, value)


                    class RedistributedPrefixes(Entity):
                        """
                        Limit number of redistributed prefixes
                        
                        .. attribute:: prefixes
                        
                        	Maximum number of prefixes redistributed to protocol
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: threshold
                        
                        	Threshold value (%) at which to generate a warning message
                        	**type**\:  int
                        
                        	**range:** 1..100
                        
                        .. attribute:: warning_only
                        
                        	Only give warning message when limit is exceeded
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Maximum.RedistributedPrefixes, self).__init__()

                            self.yang_name = "redistributed-prefixes"
                            self.yang_parent_name = "maximum"

                            self.prefixes = YLeaf(YType.uint32, "prefixes")

                            self.threshold = YLeaf(YType.uint32, "threshold")

                            self.warning_only = YLeaf(YType.empty, "warning-only")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("prefixes",
                                            "threshold",
                                            "warning_only") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.Maximum.RedistributedPrefixes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.Maximum.RedistributedPrefixes, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.prefixes.is_set or
                                self.threshold.is_set or
                                self.warning_only.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.prefixes.yfilter != YFilter.not_set or
                                self.threshold.yfilter != YFilter.not_set or
                                self.warning_only.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "redistributed-prefixes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.prefixes.is_set or self.prefixes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefixes.get_name_leafdata())
                            if (self.threshold.is_set or self.threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold.get_name_leafdata())
                            if (self.warning_only.is_set or self.warning_only.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_only.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefixes" or name == "threshold" or name == "warning-only"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "prefixes"):
                                self.prefixes = value
                                self.prefixes.value_namespace = name_space
                                self.prefixes.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold"):
                                self.threshold = value
                                self.threshold.value_namespace = name_space
                                self.threshold.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-only"):
                                self.warning_only = value
                                self.warning_only.value_namespace = name_space
                                self.warning_only.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.interfaces.is_set or
                            self.paths.is_set or
                            (self.redistributed_prefixes is not None and self.redistributed_prefixes.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interfaces.yfilter != YFilter.not_set or
                            self.paths.yfilter != YFilter.not_set or
                            (self.redistributed_prefixes is not None and self.redistributed_prefixes.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "maximum" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interfaces.is_set or self.interfaces.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interfaces.get_name_leafdata())
                        if (self.paths.is_set or self.paths.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.paths.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "redistributed-prefixes"):
                            if (self.redistributed_prefixes is None):
                                self.redistributed_prefixes = Ospfv3.Processes.Process.DefaultVrf.Maximum.RedistributedPrefixes()
                                self.redistributed_prefixes.parent = self
                                self._children_name_map["redistributed_prefixes"] = "redistributed-prefixes"
                            return self.redistributed_prefixes

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "redistributed-prefixes" or name == "interfaces" or name == "paths"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interfaces"):
                            self.interfaces = value
                            self.interfaces.value_namespace = name_space
                            self.interfaces.value_namespace_prefix = name_space_prefix
                        if(value_path == "paths"):
                            self.paths = value
                            self.paths.value_namespace = name_space
                            self.paths.value_namespace_prefix = name_space_prefix


                class Redistributes(Entity):
                    """
                    Redistribute information from another routing
                    protocol
                    
                    .. attribute:: redistribute
                    
                    	Redistribute information from another routing protocol
                    	**type**\: list of    :py:class:`Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Redistributes, self).__init__()

                        self.yang_name = "redistributes"
                        self.yang_parent_name = "default-vrf"

                        self.redistribute = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.Redistributes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.Redistributes, self).__setattr__(name, value)


                    class Redistribute(Entity):
                        """
                        Redistribute information from another routing
                        protocol
                        
                        .. attribute:: protocol_name  <key>
                        
                        	Protocol
                        	**type**\:   :py:class:`Ospfv3ProtocolType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ProtocolType2>`
                        
                        .. attribute:: bgp
                        
                        	bgp
                        	**type**\: list of    :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Bgp>`
                        
                        .. attribute:: connected_or_static_or_subscriber_or_mobile
                        
                        	connected or static or subscriber or mobile
                        	**type**\:   :py:class:`ConnectedOrStaticOrSubscriberOrMobile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: eigrp
                        
                        	eigrp
                        	**type**\: list of    :py:class:`Eigrp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Eigrp>`
                        
                        .. attribute:: ospfv3_or_isis_or_application
                        
                        	ospfv3 or isis or application
                        	**type**\: list of    :py:class:`Ospfv3OrIsisOrApplication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute, self).__init__()

                            self.yang_name = "redistribute"
                            self.yang_parent_name = "redistributes"

                            self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                            self.connected_or_static_or_subscriber_or_mobile = None
                            self._children_name_map["connected_or_static_or_subscriber_or_mobile"] = "connected-or-static-or-subscriber-or-mobile"
                            self._children_yang_names.add("connected-or-static-or-subscriber-or-mobile")

                            self.bgp = YList(self)
                            self.eigrp = YList(self)
                            self.ospfv3_or_isis_or_application = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("protocol_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute, self).__setattr__(name, value)


                        class ConnectedOrStaticOrSubscriberOrMobile(Entity):
                            """
                            connected or static or subscriber or mobile
                            
                            .. attribute:: default_metric
                            
                            	OSPFv3 default metric
                            	**type**\:  int
                            
                            	**range:** 0..16777214
                            
                            .. attribute:: eigrp_route_type
                            
                            	EIGRP route type
                            	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                            
                            .. attribute:: external_route_type
                            
                            	Redistribute OSPFv3 external routes
                            	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                            
                            .. attribute:: internal_route_type
                            
                            	Redistribute OSPFv3 routes
                            	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                            
                            .. attribute:: isis_route_type
                            
                            	ISIS route type
                            	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                            
                            .. attribute:: metric_type
                            
                            	OSPFv3 exterior metric type for redistributed routes
                            	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                            
                            .. attribute:: nssa_external_route_type
                            
                            	Redistribute OSPFv3 NSSA external routes
                            	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                            
                            .. attribute:: preserve_med
                            
                            	Preserve (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: preserve_med_info
                            
                            	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: redistribute_route
                            
                            	Redistribution of OSPFv3 routes
                            	**type**\:  bool
                            
                            .. attribute:: route_policy_name
                            
                            	Route policy to redistribution
                            	**type**\:  str
                            
                            .. attribute:: tag
                            
                            	Tag for routes redistributed into OSPFv3
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile, self).__init__()

                                self.yang_name = "connected-or-static-or-subscriber-or-mobile"
                                self.yang_parent_name = "redistribute"
                                self.is_presence_container = True

                                self.default_metric = YLeaf(YType.uint32, "default-metric")

                                self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                self.tag = YLeaf(YType.int32, "tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_metric",
                                                "eigrp_route_type",
                                                "external_route_type",
                                                "internal_route_type",
                                                "isis_route_type",
                                                "metric_type",
                                                "nssa_external_route_type",
                                                "preserve_med",
                                                "preserve_med_info",
                                                "redistribute_route",
                                                "route_policy_name",
                                                "tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.default_metric.is_set or
                                    self.eigrp_route_type.is_set or
                                    self.external_route_type.is_set or
                                    self.internal_route_type.is_set or
                                    self.isis_route_type.is_set or
                                    self.metric_type.is_set or
                                    self.nssa_external_route_type.is_set or
                                    self.preserve_med.is_set or
                                    self.preserve_med_info.is_set or
                                    self.redistribute_route.is_set or
                                    self.route_policy_name.is_set or
                                    self.tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_metric.yfilter != YFilter.not_set or
                                    self.eigrp_route_type.yfilter != YFilter.not_set or
                                    self.external_route_type.yfilter != YFilter.not_set or
                                    self.internal_route_type.yfilter != YFilter.not_set or
                                    self.isis_route_type.yfilter != YFilter.not_set or
                                    self.metric_type.yfilter != YFilter.not_set or
                                    self.nssa_external_route_type.yfilter != YFilter.not_set or
                                    self.preserve_med.yfilter != YFilter.not_set or
                                    self.preserve_med_info.yfilter != YFilter.not_set or
                                    self.redistribute_route.yfilter != YFilter.not_set or
                                    self.route_policy_name.yfilter != YFilter.not_set or
                                    self.tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "connected-or-static-or-subscriber-or-mobile" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_metric.get_name_leafdata())
                                if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric_type.get_name_leafdata())
                                if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-metric"):
                                    self.default_metric = value
                                    self.default_metric.value_namespace = name_space
                                    self.default_metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "eigrp-route-type"):
                                    self.eigrp_route_type = value
                                    self.eigrp_route_type.value_namespace = name_space
                                    self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-route-type"):
                                    self.external_route_type = value
                                    self.external_route_type.value_namespace = name_space
                                    self.external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal-route-type"):
                                    self.internal_route_type = value
                                    self.internal_route_type.value_namespace = name_space
                                    self.internal_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "isis-route-type"):
                                    self.isis_route_type = value
                                    self.isis_route_type.value_namespace = name_space
                                    self.isis_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric-type"):
                                    self.metric_type = value
                                    self.metric_type.value_namespace = name_space
                                    self.metric_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "nssa-external-route-type"):
                                    self.nssa_external_route_type = value
                                    self.nssa_external_route_type.value_namespace = name_space
                                    self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med"):
                                    self.preserve_med = value
                                    self.preserve_med.value_namespace = name_space
                                    self.preserve_med.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med-info"):
                                    self.preserve_med_info = value
                                    self.preserve_med_info.value_namespace = name_space
                                    self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "redistribute-route"):
                                    self.redistribute_route = value
                                    self.redistribute_route.value_namespace = name_space
                                    self.redistribute_route.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-policy-name"):
                                    self.route_policy_name = value
                                    self.route_policy_name.value_namespace = name_space
                                    self.route_policy_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "tag"):
                                    self.tag = value
                                    self.tag.value_namespace = name_space
                                    self.tag.value_namespace_prefix = name_space_prefix


                        class Bgp(Entity):
                            """
                            bgp
                            
                            .. attribute:: as_xx  <key>
                            
                            	4\-byte AS number in asdot (X.Y) format \- first half (X)
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: as_yy  <key>
                            
                            	4\-byte AS number in asdot (X.Y) format \- second half (Y), or 2\-byte AS number, or 4\-byte AS number in asplain format
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: default_metric
                            
                            	OSPFv3 default metric
                            	**type**\:  int
                            
                            	**range:** 0..16777214
                            
                            .. attribute:: eigrp_route_type
                            
                            	EIGRP route type
                            	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                            
                            .. attribute:: external_route_type
                            
                            	Redistribute OSPFv3 external routes
                            	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                            
                            .. attribute:: internal_route_type
                            
                            	Redistribute OSPFv3 routes
                            	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                            
                            .. attribute:: isis_route_type
                            
                            	ISIS route type
                            	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                            
                            .. attribute:: metric_type
                            
                            	OSPFv3 exterior metric type for redistributed routes
                            	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                            
                            .. attribute:: nssa_external_route_type
                            
                            	Redistribute OSPFv3 NSSA external routes
                            	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                            
                            .. attribute:: preserve_med
                            
                            	Preserve (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: preserve_med_info
                            
                            	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: redistribute_route
                            
                            	Redistribution of OSPFv3 routes
                            	**type**\:  bool
                            
                            .. attribute:: route_policy_name
                            
                            	Route policy to redistribution
                            	**type**\:  str
                            
                            .. attribute:: tag
                            
                            	Tag for routes redistributed into OSPFv3
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Bgp, self).__init__()

                                self.yang_name = "bgp"
                                self.yang_parent_name = "redistribute"

                                self.as_xx = YLeaf(YType.uint32, "as-xx")

                                self.as_yy = YLeaf(YType.uint32, "as-yy")

                                self.default_metric = YLeaf(YType.uint32, "default-metric")

                                self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                self.tag = YLeaf(YType.int32, "tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("as_xx",
                                                "as_yy",
                                                "default_metric",
                                                "eigrp_route_type",
                                                "external_route_type",
                                                "internal_route_type",
                                                "isis_route_type",
                                                "metric_type",
                                                "nssa_external_route_type",
                                                "preserve_med",
                                                "preserve_med_info",
                                                "redistribute_route",
                                                "route_policy_name",
                                                "tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Bgp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Bgp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.as_xx.is_set or
                                    self.as_yy.is_set or
                                    self.default_metric.is_set or
                                    self.eigrp_route_type.is_set or
                                    self.external_route_type.is_set or
                                    self.internal_route_type.is_set or
                                    self.isis_route_type.is_set or
                                    self.metric_type.is_set or
                                    self.nssa_external_route_type.is_set or
                                    self.preserve_med.is_set or
                                    self.preserve_med_info.is_set or
                                    self.redistribute_route.is_set or
                                    self.route_policy_name.is_set or
                                    self.tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.as_xx.yfilter != YFilter.not_set or
                                    self.as_yy.yfilter != YFilter.not_set or
                                    self.default_metric.yfilter != YFilter.not_set or
                                    self.eigrp_route_type.yfilter != YFilter.not_set or
                                    self.external_route_type.yfilter != YFilter.not_set or
                                    self.internal_route_type.yfilter != YFilter.not_set or
                                    self.isis_route_type.yfilter != YFilter.not_set or
                                    self.metric_type.yfilter != YFilter.not_set or
                                    self.nssa_external_route_type.yfilter != YFilter.not_set or
                                    self.preserve_med.yfilter != YFilter.not_set or
                                    self.preserve_med_info.yfilter != YFilter.not_set or
                                    self.redistribute_route.yfilter != YFilter.not_set or
                                    self.route_policy_name.yfilter != YFilter.not_set or
                                    self.tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp" + "[as-xx='" + self.as_xx.get() + "']" + "[as-yy='" + self.as_yy.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_xx.get_name_leafdata())
                                if (self.as_yy.is_set or self.as_yy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_yy.get_name_leafdata())
                                if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_metric.get_name_leafdata())
                                if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric_type.get_name_leafdata())
                                if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "as-xx" or name == "as-yy" or name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "as-xx"):
                                    self.as_xx = value
                                    self.as_xx.value_namespace = name_space
                                    self.as_xx.value_namespace_prefix = name_space_prefix
                                if(value_path == "as-yy"):
                                    self.as_yy = value
                                    self.as_yy.value_namespace = name_space
                                    self.as_yy.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-metric"):
                                    self.default_metric = value
                                    self.default_metric.value_namespace = name_space
                                    self.default_metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "eigrp-route-type"):
                                    self.eigrp_route_type = value
                                    self.eigrp_route_type.value_namespace = name_space
                                    self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-route-type"):
                                    self.external_route_type = value
                                    self.external_route_type.value_namespace = name_space
                                    self.external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal-route-type"):
                                    self.internal_route_type = value
                                    self.internal_route_type.value_namespace = name_space
                                    self.internal_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "isis-route-type"):
                                    self.isis_route_type = value
                                    self.isis_route_type.value_namespace = name_space
                                    self.isis_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric-type"):
                                    self.metric_type = value
                                    self.metric_type.value_namespace = name_space
                                    self.metric_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "nssa-external-route-type"):
                                    self.nssa_external_route_type = value
                                    self.nssa_external_route_type.value_namespace = name_space
                                    self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med"):
                                    self.preserve_med = value
                                    self.preserve_med.value_namespace = name_space
                                    self.preserve_med.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med-info"):
                                    self.preserve_med_info = value
                                    self.preserve_med_info.value_namespace = name_space
                                    self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "redistribute-route"):
                                    self.redistribute_route = value
                                    self.redistribute_route.value_namespace = name_space
                                    self.redistribute_route.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-policy-name"):
                                    self.route_policy_name = value
                                    self.route_policy_name.value_namespace = name_space
                                    self.route_policy_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "tag"):
                                    self.tag = value
                                    self.tag.value_namespace = name_space
                                    self.tag.value_namespace_prefix = name_space_prefix


                        class Ospfv3OrIsisOrApplication(Entity):
                            """
                            ospfv3 or isis or application
                            
                            .. attribute:: process_name  <key>
                            
                            	ISIS process name if protocol is ISIS, or OSPFv3 process name if protocol is OSPFv3
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: default_metric
                            
                            	OSPFv3 default metric
                            	**type**\:  int
                            
                            	**range:** 0..16777214
                            
                            .. attribute:: eigrp_route_type
                            
                            	EIGRP route type
                            	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                            
                            .. attribute:: external_route_type
                            
                            	Redistribute OSPFv3 external routes
                            	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                            
                            .. attribute:: internal_route_type
                            
                            	Redistribute OSPFv3 routes
                            	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                            
                            .. attribute:: isis_route_type
                            
                            	ISIS route type
                            	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                            
                            .. attribute:: metric_type
                            
                            	OSPFv3 exterior metric type for redistributed routes
                            	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                            
                            .. attribute:: nssa_external_route_type
                            
                            	Redistribute OSPFv3 NSSA external routes
                            	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                            
                            .. attribute:: preserve_med
                            
                            	Preserve (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: preserve_med_info
                            
                            	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: redistribute_route
                            
                            	Redistribution of OSPFv3 routes
                            	**type**\:  bool
                            
                            .. attribute:: route_policy_name
                            
                            	Route policy to redistribution
                            	**type**\:  str
                            
                            .. attribute:: tag
                            
                            	Tag for routes redistributed into OSPFv3
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication, self).__init__()

                                self.yang_name = "ospfv3-or-isis-or-application"
                                self.yang_parent_name = "redistribute"

                                self.process_name = YLeaf(YType.str, "process-name")

                                self.default_metric = YLeaf(YType.uint32, "default-metric")

                                self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                self.tag = YLeaf(YType.int32, "tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("process_name",
                                                "default_metric",
                                                "eigrp_route_type",
                                                "external_route_type",
                                                "internal_route_type",
                                                "isis_route_type",
                                                "metric_type",
                                                "nssa_external_route_type",
                                                "preserve_med",
                                                "preserve_med_info",
                                                "redistribute_route",
                                                "route_policy_name",
                                                "tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.process_name.is_set or
                                    self.default_metric.is_set or
                                    self.eigrp_route_type.is_set or
                                    self.external_route_type.is_set or
                                    self.internal_route_type.is_set or
                                    self.isis_route_type.is_set or
                                    self.metric_type.is_set or
                                    self.nssa_external_route_type.is_set or
                                    self.preserve_med.is_set or
                                    self.preserve_med_info.is_set or
                                    self.redistribute_route.is_set or
                                    self.route_policy_name.is_set or
                                    self.tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.process_name.yfilter != YFilter.not_set or
                                    self.default_metric.yfilter != YFilter.not_set or
                                    self.eigrp_route_type.yfilter != YFilter.not_set or
                                    self.external_route_type.yfilter != YFilter.not_set or
                                    self.internal_route_type.yfilter != YFilter.not_set or
                                    self.isis_route_type.yfilter != YFilter.not_set or
                                    self.metric_type.yfilter != YFilter.not_set or
                                    self.nssa_external_route_type.yfilter != YFilter.not_set or
                                    self.preserve_med.yfilter != YFilter.not_set or
                                    self.preserve_med_info.yfilter != YFilter.not_set or
                                    self.redistribute_route.yfilter != YFilter.not_set or
                                    self.route_policy_name.yfilter != YFilter.not_set or
                                    self.tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospfv3-or-isis-or-application" + "[process-name='" + self.process_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.process_name.get_name_leafdata())
                                if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_metric.get_name_leafdata())
                                if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric_type.get_name_leafdata())
                                if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "process-name" or name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "process-name"):
                                    self.process_name = value
                                    self.process_name.value_namespace = name_space
                                    self.process_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-metric"):
                                    self.default_metric = value
                                    self.default_metric.value_namespace = name_space
                                    self.default_metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "eigrp-route-type"):
                                    self.eigrp_route_type = value
                                    self.eigrp_route_type.value_namespace = name_space
                                    self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-route-type"):
                                    self.external_route_type = value
                                    self.external_route_type.value_namespace = name_space
                                    self.external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal-route-type"):
                                    self.internal_route_type = value
                                    self.internal_route_type.value_namespace = name_space
                                    self.internal_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "isis-route-type"):
                                    self.isis_route_type = value
                                    self.isis_route_type.value_namespace = name_space
                                    self.isis_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric-type"):
                                    self.metric_type = value
                                    self.metric_type.value_namespace = name_space
                                    self.metric_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "nssa-external-route-type"):
                                    self.nssa_external_route_type = value
                                    self.nssa_external_route_type.value_namespace = name_space
                                    self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med"):
                                    self.preserve_med = value
                                    self.preserve_med.value_namespace = name_space
                                    self.preserve_med.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med-info"):
                                    self.preserve_med_info = value
                                    self.preserve_med_info.value_namespace = name_space
                                    self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "redistribute-route"):
                                    self.redistribute_route = value
                                    self.redistribute_route.value_namespace = name_space
                                    self.redistribute_route.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-policy-name"):
                                    self.route_policy_name = value
                                    self.route_policy_name.value_namespace = name_space
                                    self.route_policy_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "tag"):
                                    self.tag = value
                                    self.tag.value_namespace = name_space
                                    self.tag.value_namespace_prefix = name_space_prefix


                        class Eigrp(Entity):
                            """
                            eigrp
                            
                            .. attribute:: as_xx  <key>
                            
                            	4\-byte AS number in asdot (X.Y) format \- first half (X)
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: default_metric
                            
                            	OSPFv3 default metric
                            	**type**\:  int
                            
                            	**range:** 0..16777214
                            
                            .. attribute:: eigrp_route_type
                            
                            	EIGRP route type
                            	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                            
                            .. attribute:: external_route_type
                            
                            	Redistribute OSPFv3 external routes
                            	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                            
                            .. attribute:: internal_route_type
                            
                            	Redistribute OSPFv3 routes
                            	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                            
                            .. attribute:: isis_route_type
                            
                            	ISIS route type
                            	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                            
                            .. attribute:: metric_type
                            
                            	OSPFv3 exterior metric type for redistributed routes
                            	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                            
                            .. attribute:: nssa_external_route_type
                            
                            	Redistribute OSPFv3 NSSA external routes
                            	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                            
                            .. attribute:: preserve_med
                            
                            	Preserve (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: preserve_med_info
                            
                            	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: redistribute_route
                            
                            	Redistribution of OSPFv3 routes
                            	**type**\:  bool
                            
                            .. attribute:: route_policy_name
                            
                            	Route policy to redistribution
                            	**type**\:  str
                            
                            .. attribute:: tag
                            
                            	Tag for routes redistributed into OSPFv3
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Eigrp, self).__init__()

                                self.yang_name = "eigrp"
                                self.yang_parent_name = "redistribute"

                                self.as_xx = YLeaf(YType.uint32, "as-xx")

                                self.default_metric = YLeaf(YType.uint32, "default-metric")

                                self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                self.tag = YLeaf(YType.int32, "tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("as_xx",
                                                "default_metric",
                                                "eigrp_route_type",
                                                "external_route_type",
                                                "internal_route_type",
                                                "isis_route_type",
                                                "metric_type",
                                                "nssa_external_route_type",
                                                "preserve_med",
                                                "preserve_med_info",
                                                "redistribute_route",
                                                "route_policy_name",
                                                "tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Eigrp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Eigrp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.as_xx.is_set or
                                    self.default_metric.is_set or
                                    self.eigrp_route_type.is_set or
                                    self.external_route_type.is_set or
                                    self.internal_route_type.is_set or
                                    self.isis_route_type.is_set or
                                    self.metric_type.is_set or
                                    self.nssa_external_route_type.is_set or
                                    self.preserve_med.is_set or
                                    self.preserve_med_info.is_set or
                                    self.redistribute_route.is_set or
                                    self.route_policy_name.is_set or
                                    self.tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.as_xx.yfilter != YFilter.not_set or
                                    self.default_metric.yfilter != YFilter.not_set or
                                    self.eigrp_route_type.yfilter != YFilter.not_set or
                                    self.external_route_type.yfilter != YFilter.not_set or
                                    self.internal_route_type.yfilter != YFilter.not_set or
                                    self.isis_route_type.yfilter != YFilter.not_set or
                                    self.metric_type.yfilter != YFilter.not_set or
                                    self.nssa_external_route_type.yfilter != YFilter.not_set or
                                    self.preserve_med.yfilter != YFilter.not_set or
                                    self.preserve_med_info.yfilter != YFilter.not_set or
                                    self.redistribute_route.yfilter != YFilter.not_set or
                                    self.route_policy_name.yfilter != YFilter.not_set or
                                    self.tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "eigrp" + "[as-xx='" + self.as_xx.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_xx.get_name_leafdata())
                                if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_metric.get_name_leafdata())
                                if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric_type.get_name_leafdata())
                                if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "as-xx" or name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "as-xx"):
                                    self.as_xx = value
                                    self.as_xx.value_namespace = name_space
                                    self.as_xx.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-metric"):
                                    self.default_metric = value
                                    self.default_metric.value_namespace = name_space
                                    self.default_metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "eigrp-route-type"):
                                    self.eigrp_route_type = value
                                    self.eigrp_route_type.value_namespace = name_space
                                    self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-route-type"):
                                    self.external_route_type = value
                                    self.external_route_type.value_namespace = name_space
                                    self.external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal-route-type"):
                                    self.internal_route_type = value
                                    self.internal_route_type.value_namespace = name_space
                                    self.internal_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "isis-route-type"):
                                    self.isis_route_type = value
                                    self.isis_route_type.value_namespace = name_space
                                    self.isis_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric-type"):
                                    self.metric_type = value
                                    self.metric_type.value_namespace = name_space
                                    self.metric_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "nssa-external-route-type"):
                                    self.nssa_external_route_type = value
                                    self.nssa_external_route_type.value_namespace = name_space
                                    self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med"):
                                    self.preserve_med = value
                                    self.preserve_med.value_namespace = name_space
                                    self.preserve_med.value_namespace_prefix = name_space_prefix
                                if(value_path == "preserve-med-info"):
                                    self.preserve_med_info = value
                                    self.preserve_med_info.value_namespace = name_space
                                    self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "redistribute-route"):
                                    self.redistribute_route = value
                                    self.redistribute_route.value_namespace = name_space
                                    self.redistribute_route.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-policy-name"):
                                    self.route_policy_name = value
                                    self.route_policy_name.value_namespace = name_space
                                    self.route_policy_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "tag"):
                                    self.tag = value
                                    self.tag.value_namespace = name_space
                                    self.tag.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.bgp:
                                if (c.has_data()):
                                    return True
                            for c in self.eigrp:
                                if (c.has_data()):
                                    return True
                            for c in self.ospfv3_or_isis_or_application:
                                if (c.has_data()):
                                    return True
                            return (
                                self.protocol_name.is_set or
                                (self.connected_or_static_or_subscriber_or_mobile is not None))

                        def has_operation(self):
                            for c in self.bgp:
                                if (c.has_operation()):
                                    return True
                            for c in self.eigrp:
                                if (c.has_operation()):
                                    return True
                            for c in self.ospfv3_or_isis_or_application:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.protocol_name.yfilter != YFilter.not_set or
                                (self.connected_or_static_or_subscriber_or_mobile is not None and self.connected_or_static_or_subscriber_or_mobile.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "redistribute" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protocol_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp"):
                                for c in self.bgp:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Bgp()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.bgp.append(c)
                                return c

                            if (child_yang_name == "connected-or-static-or-subscriber-or-mobile"):
                                if (self.connected_or_static_or_subscriber_or_mobile is None):
                                    self.connected_or_static_or_subscriber_or_mobile = Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile()
                                    self.connected_or_static_or_subscriber_or_mobile.parent = self
                                    self._children_name_map["connected_or_static_or_subscriber_or_mobile"] = "connected-or-static-or-subscriber-or-mobile"
                                return self.connected_or_static_or_subscriber_or_mobile

                            if (child_yang_name == "eigrp"):
                                for c in self.eigrp:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Eigrp()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.eigrp.append(c)
                                return c

                            if (child_yang_name == "ospfv3-or-isis-or-application"):
                                for c in self.ospfv3_or_isis_or_application:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.ospfv3_or_isis_or_application.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp" or name == "connected-or-static-or-subscriber-or-mobile" or name == "eigrp" or name == "ospfv3-or-isis-or-application" or name == "protocol-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "protocol-name"):
                                self.protocol_name = value
                                self.protocol_name.value_namespace = name_space
                                self.protocol_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.redistribute:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.redistribute:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "redistributes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "redistribute"):
                            for c in self.redistribute:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Ospfv3.Processes.Process.DefaultVrf.Redistributes.Redistribute()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.redistribute.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "redistribute"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ignore(Entity):
                    """
                    Do not complain about a specified event
                    
                    .. attribute:: lsa
                    
                    	Do not complain upon receiving LSA of the specified type
                    	**type**\:   :py:class:`Lsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.Ignore.Lsa>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Ignore, self).__init__()

                        self.yang_name = "ignore"
                        self.yang_parent_name = "default-vrf"

                        self.lsa = Ospfv3.Processes.Process.DefaultVrf.Ignore.Lsa()
                        self.lsa.parent = self
                        self._children_name_map["lsa"] = "lsa"
                        self._children_yang_names.add("lsa")


                    class Lsa(Entity):
                        """
                        Do not complain upon receiving LSA of the
                        specified type
                        
                        .. attribute:: mospf
                        
                        	Enable ignore of MOSPF type 6 LSA
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.Ignore.Lsa, self).__init__()

                            self.yang_name = "lsa"
                            self.yang_parent_name = "ignore"

                            self.mospf = YLeaf(YType.empty, "mospf")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("mospf") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.Ignore.Lsa, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.Ignore.Lsa, self).__setattr__(name, value)

                        def has_data(self):
                            return self.mospf.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.mospf.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "lsa" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.mospf.is_set or self.mospf.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mospf.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mospf"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "mospf"):
                                self.mospf = value
                                self.mospf.value_namespace = name_space
                                self.mospf.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.lsa is not None and self.lsa.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.lsa is not None and self.lsa.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ignore" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "lsa"):
                            if (self.lsa is None):
                                self.lsa = Ospfv3.Processes.Process.DefaultVrf.Ignore.Lsa()
                                self.lsa.parent = self
                                self._children_name_map["lsa"] = "lsa"
                            return self.lsa

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "lsa"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class DistributeListOut(Entity):
                    """
                    Filter prefixes from RIB 
                    
                    .. attribute:: distribute_outs
                    
                    	Filter generated type\-5 LSAs
                    	**type**\:   :py:class:`DistributeOuts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut, self).__init__()

                        self.yang_name = "distribute-list-out"
                        self.yang_parent_name = "default-vrf"

                        self.distribute_outs = Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts()
                        self.distribute_outs.parent = self
                        self._children_name_map["distribute_outs"] = "distribute-outs"
                        self._children_yang_names.add("distribute-outs")


                    class DistributeOuts(Entity):
                        """
                        Filter generated type\-5 LSAs
                        
                        .. attribute:: distribute_out
                        
                        	Filter generated type\-5 LSAs
                        	**type**\: list of    :py:class:`DistributeOut <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts, self).__init__()

                            self.yang_name = "distribute-outs"
                            self.yang_parent_name = "distribute-list-out"

                            self.distribute_out = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts, self).__setattr__(name, value)


                        class DistributeOut(Entity):
                            """
                            Filter generated type\-5 LSAs
                            
                            .. attribute:: protocol_name  <key>
                            
                            	none
                            	**type**\:   :py:class:`Ospfv3Protocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Protocol>`
                            
                            .. attribute:: as_yy_and_as_xx_and_process_name
                            
                            	keys\: as\-yy, as\-xx, process\-name
                            	**type**\: list of    :py:class:`AsYyAndAsXxAndProcessName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut, self).__init__()

                                self.yang_name = "distribute-out"
                                self.yang_parent_name = "distribute-outs"

                                self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                                self.as_yy_and_as_xx_and_process_name = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("protocol_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut, self).__setattr__(name, value)


                            class AsYyAndAsXxAndProcessName(Entity):
                                """
                                keys\: as\-yy, as\-xx, process\-name
                                
                                .. attribute:: as_yy  <key>
                                
                                	4\-byte AS number in asdot (X.Y) format \- second half (Y), or 2\-byte AS number, or 4\-byte AS number in asplain format
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: as_xx  <key>
                                
                                	4\-byte AS number in asdot (X.Y) format \- first half (X)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: process_name  <key>
                                
                                	If ISIS or OSPFv3, specify the instance name
                                	**type**\:  str
                                
                                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                
                                .. attribute:: prefix_list
                                
                                	Prefix\-list name
                                	**type**\:  str
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName, self).__init__()

                                    self.yang_name = "as-yy-and-as-xx-and-process-name"
                                    self.yang_parent_name = "distribute-out"

                                    self.as_yy = YLeaf(YType.uint32, "as-yy")

                                    self.as_xx = YLeaf(YType.uint32, "as-xx")

                                    self.process_name = YLeaf(YType.str, "process-name")

                                    self.prefix_list = YLeaf(YType.str, "prefix-list")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("as_yy",
                                                    "as_xx",
                                                    "process_name",
                                                    "prefix_list") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.as_yy.is_set or
                                        self.as_xx.is_set or
                                        self.process_name.is_set or
                                        self.prefix_list.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.as_yy.yfilter != YFilter.not_set or
                                        self.as_xx.yfilter != YFilter.not_set or
                                        self.process_name.yfilter != YFilter.not_set or
                                        self.prefix_list.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "as-yy-and-as-xx-and-process-name" + "[as-yy='" + self.as_yy.get() + "']" + "[as-xx='" + self.as_xx.get() + "']" + "[process-name='" + self.process_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.as_yy.is_set or self.as_yy.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.as_yy.get_name_leafdata())
                                    if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.as_xx.get_name_leafdata())
                                    if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.process_name.get_name_leafdata())
                                    if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "as-yy" or name == "as-xx" or name == "process-name" or name == "prefix-list"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "as-yy"):
                                        self.as_yy = value
                                        self.as_yy.value_namespace = name_space
                                        self.as_yy.value_namespace_prefix = name_space_prefix
                                    if(value_path == "as-xx"):
                                        self.as_xx = value
                                        self.as_xx.value_namespace = name_space
                                        self.as_xx.value_namespace_prefix = name_space_prefix
                                    if(value_path == "process-name"):
                                        self.process_name = value
                                        self.process_name.value_namespace = name_space
                                        self.process_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-list"):
                                        self.prefix_list = value
                                        self.prefix_list.value_namespace = name_space
                                        self.prefix_list.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.as_yy_and_as_xx_and_process_name:
                                    if (c.has_data()):
                                        return True
                                return self.protocol_name.is_set

                            def has_operation(self):
                                for c in self.as_yy_and_as_xx_and_process_name:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.protocol_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "distribute-out" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protocol_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "as-yy-and-as-xx-and-process-name"):
                                    for c in self.as_yy_and_as_xx_and_process_name:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.as_yy_and_as_xx_and_process_name.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "as-yy-and-as-xx-and-process-name" or name == "protocol-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "protocol-name"):
                                    self.protocol_name = value
                                    self.protocol_name.value_namespace = name_space
                                    self.protocol_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.distribute_out:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.distribute_out:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "distribute-outs" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "distribute-out"):
                                for c in self.distribute_out:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts.DistributeOut()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.distribute_out.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "distribute-out"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.distribute_outs is not None and self.distribute_outs.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.distribute_outs is not None and self.distribute_outs.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "distribute-list-out" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "distribute-outs"):
                            if (self.distribute_outs is None):
                                self.distribute_outs = Ospfv3.Processes.Process.DefaultVrf.DistributeListOut.DistributeOuts()
                                self.distribute_outs.parent = self
                                self._children_name_map["distribute_outs"] = "distribute-outs"
                            return self.distribute_outs

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "distribute-outs"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class DistributeList(Entity):
                    """
                    Filter prefixes to/from RIB
                    
                    .. attribute:: in_
                    
                    	Filter prefixes installed to RIB
                    	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DistributeList.In_>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.DistributeList, self).__init__()

                        self.yang_name = "distribute-list"
                        self.yang_parent_name = "default-vrf"

                        self.in_ = Ospfv3.Processes.Process.DefaultVrf.DistributeList.In_()
                        self.in_.parent = self
                        self._children_name_map["in_"] = "in"
                        self._children_yang_names.add("in")


                    class In_(Entity):
                        """
                        Filter prefixes installed to RIB
                        
                        .. attribute:: prefix_list
                        
                        	Filter prefixes based on an IPv6 prefix\-list
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.DistributeList.In_, self).__init__()

                            self.yang_name = "in"
                            self.yang_parent_name = "distribute-list"

                            self.prefix_list = YLeaf(YType.str, "prefix-list")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("prefix_list") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.DistributeList.In_, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.DistributeList.In_, self).__setattr__(name, value)

                        def has_data(self):
                            return self.prefix_list.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.prefix_list.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "in" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_list.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-list"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "prefix-list"):
                                self.prefix_list = value
                                self.prefix_list.value_namespace = name_space
                                self.prefix_list.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.in_ is not None and self.in_.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.in_ is not None and self.in_.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "distribute-list" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "in"):
                            if (self.in_ is None):
                                self.in_ = Ospfv3.Processes.Process.DefaultVrf.DistributeList.In_()
                                self.in_.parent = self
                                self._children_name_map["in_"] = "in"
                            return self.in_

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "in"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class StubRouter(Entity):
                    """
                    Stub router configuration
                    
                    .. attribute:: max_metric
                    
                    	Stub router max\-metric configuration
                    	**type**\:   :py:class:`MaxMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric>`
                    
                    .. attribute:: rbit
                    
                    	Stub router R\-bit configuration
                    	**type**\:   :py:class:`Rbit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit>`
                    
                    .. attribute:: v6bit
                    
                    	Stub router V6\-bit configuration
                    	**type**\:   :py:class:`V6Bit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.StubRouter, self).__init__()

                        self.yang_name = "stub-router"
                        self.yang_parent_name = "default-vrf"

                        self.max_metric = Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric()
                        self.max_metric.parent = self
                        self._children_name_map["max_metric"] = "max-metric"
                        self._children_yang_names.add("max-metric")

                        self.rbit = Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit()
                        self.rbit.parent = self
                        self._children_name_map["rbit"] = "rbit"
                        self._children_yang_names.add("rbit")

                        self.v6bit = Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit()
                        self.v6bit.parent = self
                        self._children_name_map["v6bit"] = "v6bit"
                        self._children_yang_names.add("v6bit")


                    class Rbit(Entity):
                        """
                        Stub router R\-bit configuration
                        
                        .. attribute:: always
                        
                        	Unconditionally enter stub router operational state
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: enable
                        
                        	Enabled stub router configuration mode
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: external_lsa
                        
                        	Advertise external LSAs with modified metric in stub router mode
                        	**type**\:  int
                        
                        	**range:** 1..16777214
                        
                        	**default value**\: 16711680
                        
                        .. attribute:: include_stub
                        
                        	Advertise stub links with maximum metric in stub router mode
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: on_proc_migration
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: on_proc_restart
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: on_startup
                        
                        	Enter stub router operational state on startup
                        	**type**\:   :py:class:`OnStartup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit.OnStartup>`
                        
                        .. attribute:: on_switchover
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: summary_lsa
                        
                        	Advertise summary LSAs with modified metric in stub router mode
                        	**type**\:  int
                        
                        	**range:** 1..16777214
                        
                        	**default value**\: 16711680
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit, self).__init__()

                            self.yang_name = "rbit"
                            self.yang_parent_name = "stub-router"

                            self.always = YLeaf(YType.empty, "always")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.external_lsa = YLeaf(YType.uint32, "external-lsa")

                            self.include_stub = YLeaf(YType.empty, "include-stub")

                            self.on_proc_migration = YLeaf(YType.uint32, "on-proc-migration")

                            self.on_proc_restart = YLeaf(YType.uint32, "on-proc-restart")

                            self.on_switchover = YLeaf(YType.uint32, "on-switchover")

                            self.summary_lsa = YLeaf(YType.uint32, "summary-lsa")

                            self.on_startup = Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit.OnStartup()
                            self.on_startup.parent = self
                            self._children_name_map["on_startup"] = "on-startup"
                            self._children_yang_names.add("on-startup")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("always",
                                            "enable",
                                            "external_lsa",
                                            "include_stub",
                                            "on_proc_migration",
                                            "on_proc_restart",
                                            "on_switchover",
                                            "summary_lsa") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit, self).__setattr__(name, value)


                        class OnStartup(Entity):
                            """
                            Enter stub router operational state on startup
                            
                            .. attribute:: wait_for_bgp
                            
                            	Wait until BGP converges (only applicable to default VRF)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: wait_time
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit.OnStartup, self).__init__()

                                self.yang_name = "on-startup"
                                self.yang_parent_name = "rbit"

                                self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                self.wait_time = YLeaf(YType.uint32, "wait-time")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("wait_for_bgp",
                                                "wait_time") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit.OnStartup, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit.OnStartup, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.wait_for_bgp.is_set or
                                    self.wait_time.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.wait_for_bgp.yfilter != YFilter.not_set or
                                    self.wait_time.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "on-startup" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())
                                if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_time.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "wait-for-bgp" or name == "wait-time"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "wait-for-bgp"):
                                    self.wait_for_bgp = value
                                    self.wait_for_bgp.value_namespace = name_space
                                    self.wait_for_bgp.value_namespace_prefix = name_space_prefix
                                if(value_path == "wait-time"):
                                    self.wait_time = value
                                    self.wait_time.value_namespace = name_space
                                    self.wait_time.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.always.is_set or
                                self.enable.is_set or
                                self.external_lsa.is_set or
                                self.include_stub.is_set or
                                self.on_proc_migration.is_set or
                                self.on_proc_restart.is_set or
                                self.on_switchover.is_set or
                                self.summary_lsa.is_set or
                                (self.on_startup is not None and self.on_startup.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.always.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.external_lsa.yfilter != YFilter.not_set or
                                self.include_stub.yfilter != YFilter.not_set or
                                self.on_proc_migration.yfilter != YFilter.not_set or
                                self.on_proc_restart.yfilter != YFilter.not_set or
                                self.on_switchover.yfilter != YFilter.not_set or
                                self.summary_lsa.yfilter != YFilter.not_set or
                                (self.on_startup is not None and self.on_startup.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rbit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.always.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                            if (self.on_proc_migration.is_set or self.on_proc_migration.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_proc_migration.get_name_leafdata())
                            if (self.on_proc_restart.is_set or self.on_proc_restart.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_proc_restart.get_name_leafdata())
                            if (self.on_switchover.is_set or self.on_switchover.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_switchover.get_name_leafdata())
                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "on-startup"):
                                if (self.on_startup is None):
                                    self.on_startup = Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit.OnStartup()
                                    self.on_startup.parent = self
                                    self._children_name_map["on_startup"] = "on-startup"
                                return self.on_startup

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "on-startup" or name == "always" or name == "enable" or name == "external-lsa" or name == "include-stub" or name == "on-proc-migration" or name == "on-proc-restart" or name == "on-switchover" or name == "summary-lsa"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "always"):
                                self.always = value
                                self.always.value_namespace = name_space
                                self.always.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "external-lsa"):
                                self.external_lsa = value
                                self.external_lsa.value_namespace = name_space
                                self.external_lsa.value_namespace_prefix = name_space_prefix
                            if(value_path == "include-stub"):
                                self.include_stub = value
                                self.include_stub.value_namespace = name_space
                                self.include_stub.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-proc-migration"):
                                self.on_proc_migration = value
                                self.on_proc_migration.value_namespace = name_space
                                self.on_proc_migration.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-proc-restart"):
                                self.on_proc_restart = value
                                self.on_proc_restart.value_namespace = name_space
                                self.on_proc_restart.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-switchover"):
                                self.on_switchover = value
                                self.on_switchover.value_namespace = name_space
                                self.on_switchover.value_namespace_prefix = name_space_prefix
                            if(value_path == "summary-lsa"):
                                self.summary_lsa = value
                                self.summary_lsa.value_namespace = name_space
                                self.summary_lsa.value_namespace_prefix = name_space_prefix


                    class V6Bit(Entity):
                        """
                        Stub router V6\-bit configuration
                        
                        .. attribute:: always
                        
                        	Unconditionally enter stub router operational state
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: enable
                        
                        	Enabled stub router configuration mode
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: external_lsa
                        
                        	Advertise external LSAs with modified metric in stub router mode
                        	**type**\:  int
                        
                        	**range:** 1..16777214
                        
                        	**default value**\: 16711680
                        
                        .. attribute:: include_stub
                        
                        	Advertise stub links with maximum metric in stub router mode
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: on_proc_migration
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: on_proc_restart
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: on_startup
                        
                        	Enter stub router operational state on startup
                        	**type**\:   :py:class:`OnStartup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit.OnStartup>`
                        
                        .. attribute:: on_switchover
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: summary_lsa
                        
                        	Advertise summary LSAs with modified metric in stub router mode
                        	**type**\:  int
                        
                        	**range:** 1..16777214
                        
                        	**default value**\: 16711680
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit, self).__init__()

                            self.yang_name = "v6bit"
                            self.yang_parent_name = "stub-router"

                            self.always = YLeaf(YType.empty, "always")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.external_lsa = YLeaf(YType.uint32, "external-lsa")

                            self.include_stub = YLeaf(YType.empty, "include-stub")

                            self.on_proc_migration = YLeaf(YType.uint32, "on-proc-migration")

                            self.on_proc_restart = YLeaf(YType.uint32, "on-proc-restart")

                            self.on_switchover = YLeaf(YType.uint32, "on-switchover")

                            self.summary_lsa = YLeaf(YType.uint32, "summary-lsa")

                            self.on_startup = Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit.OnStartup()
                            self.on_startup.parent = self
                            self._children_name_map["on_startup"] = "on-startup"
                            self._children_yang_names.add("on-startup")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("always",
                                            "enable",
                                            "external_lsa",
                                            "include_stub",
                                            "on_proc_migration",
                                            "on_proc_restart",
                                            "on_switchover",
                                            "summary_lsa") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit, self).__setattr__(name, value)


                        class OnStartup(Entity):
                            """
                            Enter stub router operational state on startup
                            
                            .. attribute:: wait_for_bgp
                            
                            	Wait until BGP converges (only applicable to default VRF)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: wait_time
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit.OnStartup, self).__init__()

                                self.yang_name = "on-startup"
                                self.yang_parent_name = "v6bit"

                                self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                self.wait_time = YLeaf(YType.uint32, "wait-time")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("wait_for_bgp",
                                                "wait_time") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit.OnStartup, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit.OnStartup, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.wait_for_bgp.is_set or
                                    self.wait_time.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.wait_for_bgp.yfilter != YFilter.not_set or
                                    self.wait_time.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "on-startup" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())
                                if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_time.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "wait-for-bgp" or name == "wait-time"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "wait-for-bgp"):
                                    self.wait_for_bgp = value
                                    self.wait_for_bgp.value_namespace = name_space
                                    self.wait_for_bgp.value_namespace_prefix = name_space_prefix
                                if(value_path == "wait-time"):
                                    self.wait_time = value
                                    self.wait_time.value_namespace = name_space
                                    self.wait_time.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.always.is_set or
                                self.enable.is_set or
                                self.external_lsa.is_set or
                                self.include_stub.is_set or
                                self.on_proc_migration.is_set or
                                self.on_proc_restart.is_set or
                                self.on_switchover.is_set or
                                self.summary_lsa.is_set or
                                (self.on_startup is not None and self.on_startup.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.always.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.external_lsa.yfilter != YFilter.not_set or
                                self.include_stub.yfilter != YFilter.not_set or
                                self.on_proc_migration.yfilter != YFilter.not_set or
                                self.on_proc_restart.yfilter != YFilter.not_set or
                                self.on_switchover.yfilter != YFilter.not_set or
                                self.summary_lsa.yfilter != YFilter.not_set or
                                (self.on_startup is not None and self.on_startup.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "v6bit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.always.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                            if (self.on_proc_migration.is_set or self.on_proc_migration.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_proc_migration.get_name_leafdata())
                            if (self.on_proc_restart.is_set or self.on_proc_restart.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_proc_restart.get_name_leafdata())
                            if (self.on_switchover.is_set or self.on_switchover.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_switchover.get_name_leafdata())
                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "on-startup"):
                                if (self.on_startup is None):
                                    self.on_startup = Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit.OnStartup()
                                    self.on_startup.parent = self
                                    self._children_name_map["on_startup"] = "on-startup"
                                return self.on_startup

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "on-startup" or name == "always" or name == "enable" or name == "external-lsa" or name == "include-stub" or name == "on-proc-migration" or name == "on-proc-restart" or name == "on-switchover" or name == "summary-lsa"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "always"):
                                self.always = value
                                self.always.value_namespace = name_space
                                self.always.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "external-lsa"):
                                self.external_lsa = value
                                self.external_lsa.value_namespace = name_space
                                self.external_lsa.value_namespace_prefix = name_space_prefix
                            if(value_path == "include-stub"):
                                self.include_stub = value
                                self.include_stub.value_namespace = name_space
                                self.include_stub.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-proc-migration"):
                                self.on_proc_migration = value
                                self.on_proc_migration.value_namespace = name_space
                                self.on_proc_migration.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-proc-restart"):
                                self.on_proc_restart = value
                                self.on_proc_restart.value_namespace = name_space
                                self.on_proc_restart.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-switchover"):
                                self.on_switchover = value
                                self.on_switchover.value_namespace = name_space
                                self.on_switchover.value_namespace_prefix = name_space_prefix
                            if(value_path == "summary-lsa"):
                                self.summary_lsa = value
                                self.summary_lsa.value_namespace = name_space
                                self.summary_lsa.value_namespace_prefix = name_space_prefix


                    class MaxMetric(Entity):
                        """
                        Stub router max\-metric configuration
                        
                        .. attribute:: always
                        
                        	Unconditionally enter stub router operational state
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: enable
                        
                        	Enabled stub router configuration mode
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: external_lsa
                        
                        	Advertise external LSAs with modified metric in stub router mode
                        	**type**\:  int
                        
                        	**range:** 1..16777214
                        
                        	**default value**\: 16711680
                        
                        .. attribute:: include_stub
                        
                        	Advertise stub links with maximum metric in stub router mode
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: on_proc_migration
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: on_proc_restart
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: on_startup
                        
                        	Enter stub router operational state on startup
                        	**type**\:   :py:class:`OnStartup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric.OnStartup>`
                        
                        .. attribute:: on_switchover
                        
                        	Time (in seconds) to stay in stub router operational state
                        	**type**\:  int
                        
                        	**range:** 5..86400
                        
                        	**units**\: second
                        
                        .. attribute:: summary_lsa
                        
                        	Advertise summary LSAs with modified metric in stub router mode
                        	**type**\:  int
                        
                        	**range:** 1..16777214
                        
                        	**default value**\: 16711680
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric, self).__init__()

                            self.yang_name = "max-metric"
                            self.yang_parent_name = "stub-router"

                            self.always = YLeaf(YType.empty, "always")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.external_lsa = YLeaf(YType.uint32, "external-lsa")

                            self.include_stub = YLeaf(YType.empty, "include-stub")

                            self.on_proc_migration = YLeaf(YType.uint32, "on-proc-migration")

                            self.on_proc_restart = YLeaf(YType.uint32, "on-proc-restart")

                            self.on_switchover = YLeaf(YType.uint32, "on-switchover")

                            self.summary_lsa = YLeaf(YType.uint32, "summary-lsa")

                            self.on_startup = Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric.OnStartup()
                            self.on_startup.parent = self
                            self._children_name_map["on_startup"] = "on-startup"
                            self._children_yang_names.add("on-startup")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("always",
                                            "enable",
                                            "external_lsa",
                                            "include_stub",
                                            "on_proc_migration",
                                            "on_proc_restart",
                                            "on_switchover",
                                            "summary_lsa") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric, self).__setattr__(name, value)


                        class OnStartup(Entity):
                            """
                            Enter stub router operational state on startup
                            
                            .. attribute:: wait_for_bgp
                            
                            	Wait until BGP converges (only applicable to default VRF)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: wait_time
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric.OnStartup, self).__init__()

                                self.yang_name = "on-startup"
                                self.yang_parent_name = "max-metric"

                                self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                self.wait_time = YLeaf(YType.uint32, "wait-time")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("wait_for_bgp",
                                                "wait_time") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric.OnStartup, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric.OnStartup, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.wait_for_bgp.is_set or
                                    self.wait_time.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.wait_for_bgp.yfilter != YFilter.not_set or
                                    self.wait_time.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "on-startup" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())
                                if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_time.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "wait-for-bgp" or name == "wait-time"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "wait-for-bgp"):
                                    self.wait_for_bgp = value
                                    self.wait_for_bgp.value_namespace = name_space
                                    self.wait_for_bgp.value_namespace_prefix = name_space_prefix
                                if(value_path == "wait-time"):
                                    self.wait_time = value
                                    self.wait_time.value_namespace = name_space
                                    self.wait_time.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.always.is_set or
                                self.enable.is_set or
                                self.external_lsa.is_set or
                                self.include_stub.is_set or
                                self.on_proc_migration.is_set or
                                self.on_proc_restart.is_set or
                                self.on_switchover.is_set or
                                self.summary_lsa.is_set or
                                (self.on_startup is not None and self.on_startup.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.always.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.external_lsa.yfilter != YFilter.not_set or
                                self.include_stub.yfilter != YFilter.not_set or
                                self.on_proc_migration.yfilter != YFilter.not_set or
                                self.on_proc_restart.yfilter != YFilter.not_set or
                                self.on_switchover.yfilter != YFilter.not_set or
                                self.summary_lsa.yfilter != YFilter.not_set or
                                (self.on_startup is not None and self.on_startup.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "max-metric" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.always.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                            if (self.on_proc_migration.is_set or self.on_proc_migration.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_proc_migration.get_name_leafdata())
                            if (self.on_proc_restart.is_set or self.on_proc_restart.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_proc_restart.get_name_leafdata())
                            if (self.on_switchover.is_set or self.on_switchover.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.on_switchover.get_name_leafdata())
                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "on-startup"):
                                if (self.on_startup is None):
                                    self.on_startup = Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric.OnStartup()
                                    self.on_startup.parent = self
                                    self._children_name_map["on_startup"] = "on-startup"
                                return self.on_startup

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "on-startup" or name == "always" or name == "enable" or name == "external-lsa" or name == "include-stub" or name == "on-proc-migration" or name == "on-proc-restart" or name == "on-switchover" or name == "summary-lsa"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "always"):
                                self.always = value
                                self.always.value_namespace = name_space
                                self.always.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "external-lsa"):
                                self.external_lsa = value
                                self.external_lsa.value_namespace = name_space
                                self.external_lsa.value_namespace_prefix = name_space_prefix
                            if(value_path == "include-stub"):
                                self.include_stub = value
                                self.include_stub.value_namespace = name_space
                                self.include_stub.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-proc-migration"):
                                self.on_proc_migration = value
                                self.on_proc_migration.value_namespace = name_space
                                self.on_proc_migration.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-proc-restart"):
                                self.on_proc_restart = value
                                self.on_proc_restart.value_namespace = name_space
                                self.on_proc_restart.value_namespace_prefix = name_space_prefix
                            if(value_path == "on-switchover"):
                                self.on_switchover = value
                                self.on_switchover.value_namespace = name_space
                                self.on_switchover.value_namespace_prefix = name_space_prefix
                            if(value_path == "summary-lsa"):
                                self.summary_lsa = value
                                self.summary_lsa.value_namespace = name_space
                                self.summary_lsa.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.max_metric is not None and self.max_metric.has_data()) or
                            (self.rbit is not None and self.rbit.has_data()) or
                            (self.v6bit is not None and self.v6bit.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.max_metric is not None and self.max_metric.has_operation()) or
                            (self.rbit is not None and self.rbit.has_operation()) or
                            (self.v6bit is not None and self.v6bit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "stub-router" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "max-metric"):
                            if (self.max_metric is None):
                                self.max_metric = Ospfv3.Processes.Process.DefaultVrf.StubRouter.MaxMetric()
                                self.max_metric.parent = self
                                self._children_name_map["max_metric"] = "max-metric"
                            return self.max_metric

                        if (child_yang_name == "rbit"):
                            if (self.rbit is None):
                                self.rbit = Ospfv3.Processes.Process.DefaultVrf.StubRouter.Rbit()
                                self.rbit.parent = self
                                self._children_name_map["rbit"] = "rbit"
                            return self.rbit

                        if (child_yang_name == "v6bit"):
                            if (self.v6bit is None):
                                self.v6bit = Ospfv3.Processes.Process.DefaultVrf.StubRouter.V6Bit()
                                self.v6bit.parent = self
                                self._children_name_map["v6bit"] = "v6bit"
                            return self.v6bit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "max-metric" or name == "rbit" or name == "v6bit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Bfd(Entity):
                    """
                    Configure BFD parameters
                    
                    .. attribute:: detection_multiplier
                    
                    	Detect multiplier
                    	**type**\:  int
                    
                    	**range:** 2..50
                    
                    .. attribute:: fast_detect_mode
                    
                    	Enable or disable BFD fast detection
                    	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                    
                    .. attribute:: interval
                    
                    	Hello interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 3..30000
                    
                    	**units**\: millisecond
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Bfd, self).__init__()

                        self.yang_name = "bfd"
                        self.yang_parent_name = "default-vrf"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                        self.interval = YLeaf(YType.uint32, "interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "fast_detect_mode",
                                        "interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.Bfd, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.Bfd, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.fast_detect_mode.is_set or
                            self.interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.fast_detect_mode.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bfd" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "fast-detect-mode"):
                            self.fast_detect_mode = value
                            self.fast_detect_mode.value_namespace = name_space
                            self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix


                class DatabaseFilter(Entity):
                    """
                    Database filter
                    
                    .. attribute:: all
                    
                    	All
                    	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter.All>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter, self).__init__()

                        self.yang_name = "database-filter"
                        self.yang_parent_name = "default-vrf"

                        self.all = Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter.All()
                        self.all.parent = self
                        self._children_name_map["all"] = "all"
                        self._children_yang_names.add("all")


                    class All(Entity):
                        """
                        All
                        
                        .. attribute:: out
                        
                        	Enable out
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter.All, self).__init__()

                            self.yang_name = "all"
                            self.yang_parent_name = "database-filter"

                            self.out = YLeaf(YType.empty, "out")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("out") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter.All, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter.All, self).__setattr__(name, value)

                        def has_data(self):
                            return self.out.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.out.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "all" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "out"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "out"):
                                self.out = value
                                self.out.value_namespace = name_space
                                self.out.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.all is not None and self.all.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.all is not None and self.all.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "database-filter" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "all"):
                            if (self.all is None):
                                self.all = Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter.All()
                                self.all.parent = self
                                self._children_name_map["all"] = "all"
                            return self.all

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "all"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Authentication(Entity):
                    """
                    Authenticate OSPFv3 packets
                    
                    .. attribute:: algorithm
                    
                    	Use the MD5 or SHA1 algorithm
                    	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                    
                    .. attribute:: enable
                    
                    	Authenticate packets
                    	**type**\:  bool
                    
                    .. attribute:: password
                    
                    	Specify MD5 or SHA1 password
                    	**type**\:  str
                    
                    	**pattern:** (!.+)\|([^!].+)
                    
                    .. attribute:: spi
                    
                    	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                    	**type**\:  int
                    
                    	**range:** 256..4294967295
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Authentication, self).__init__()

                        self.yang_name = "authentication"
                        self.yang_parent_name = "default-vrf"

                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                        self.enable = YLeaf(YType.boolean, "enable")

                        self.password = YLeaf(YType.str, "password")

                        self.spi = YLeaf(YType.uint32, "spi")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("algorithm",
                                        "enable",
                                        "password",
                                        "spi") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.Authentication, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.Authentication, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.algorithm.is_set or
                            self.enable.is_set or
                            self.password.is_set or
                            self.spi.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.algorithm.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.password.yfilter != YFilter.not_set or
                            self.spi.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "authentication" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.password.get_name_leafdata())
                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.spi.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "algorithm"):
                            self.algorithm = value
                            self.algorithm.value_namespace = name_space
                            self.algorithm.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "password"):
                            self.password = value
                            self.password.value_namespace = name_space
                            self.password.value_namespace_prefix = name_space_prefix
                        if(value_path == "spi"):
                            self.spi = value
                            self.spi.value_namespace = name_space
                            self.spi.value_namespace_prefix = name_space_prefix


                class GracefulRestart(Entity):
                    """
                    Graceful restart configuration
                    
                    .. attribute:: enable
                    
                    	Enable graceful restart
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: helper
                    
                    	Disable router's helper support
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: interval
                    
                    	Minimum interval between graceful restarts (seconds)
                    	**type**\:  int
                    
                    	**range:** 90..3600
                    
                    	**units**\: second
                    
                    .. attribute:: lifetime
                    
                    	Maximum route lifetime following restart (seconds)
                    	**type**\:  int
                    
                    	**range:** 90..1800
                    
                    	**units**\: second
                    
                    .. attribute:: strict_lsa_checking
                    
                    	Terminate graceful restart helper mode if LSA changed
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.GracefulRestart, self).__init__()

                        self.yang_name = "graceful-restart"
                        self.yang_parent_name = "default-vrf"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.helper = YLeaf(YType.empty, "helper")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.lifetime = YLeaf(YType.uint32, "lifetime")

                        self.strict_lsa_checking = YLeaf(YType.empty, "strict-lsa-checking")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "helper",
                                        "interval",
                                        "lifetime",
                                        "strict_lsa_checking") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.GracefulRestart, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.GracefulRestart, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.helper.is_set or
                            self.interval.is_set or
                            self.lifetime.is_set or
                            self.strict_lsa_checking.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.helper.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.lifetime.yfilter != YFilter.not_set or
                            self.strict_lsa_checking.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "graceful-restart" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.helper.is_set or self.helper.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.helper.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.lifetime.is_set or self.lifetime.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lifetime.get_name_leafdata())
                        if (self.strict_lsa_checking.is_set or self.strict_lsa_checking.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.strict_lsa_checking.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "helper" or name == "interval" or name == "lifetime" or name == "strict-lsa-checking"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "helper"):
                            self.helper = value
                            self.helper.value_namespace = name_space
                            self.helper.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "lifetime"):
                            self.lifetime = value
                            self.lifetime.value_namespace = name_space
                            self.lifetime.value_namespace_prefix = name_space_prefix
                        if(value_path == "strict-lsa-checking"):
                            self.strict_lsa_checking = value
                            self.strict_lsa_checking.value_namespace = name_space
                            self.strict_lsa_checking.value_namespace_prefix = name_space_prefix


                class DefaultInformation(Entity):
                    """
                    Control distribution of default information
                    
                    .. attribute:: originate
                    
                    	Distribute a default route
                    	**type**\:   :py:class:`Originate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.DefaultInformation.Originate>`
                    
                    	**presence node**\: True
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.DefaultInformation, self).__init__()

                        self.yang_name = "default-information"
                        self.yang_parent_name = "default-vrf"

                        self.originate = None
                        self._children_name_map["originate"] = "originate"
                        self._children_yang_names.add("originate")


                    class Originate(Entity):
                        """
                        Distribute a default route
                        
                        .. attribute:: always
                        
                        	Always advertise default route
                        	**type**\:  bool
                        
                        	**mandatory**\: True
                        
                        .. attribute:: metric
                        
                        	OSPFv3 default metric
                        	**type**\:  int
                        
                        	**range:** 0..16777214
                        
                        .. attribute:: metric_type
                        
                        	OSPFv3 metric type for default routes
                        	**type**\:  int
                        
                        	**range:** 1..2
                        
                        .. attribute:: route_policy_name
                        
                        	Route policy to default\-information origination
                        	**type**\:  str
                        
                        .. attribute:: tag
                        
                        	Tag for default route
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.DefaultInformation.Originate, self).__init__()

                            self.yang_name = "originate"
                            self.yang_parent_name = "default-information"
                            self.is_presence_container = True

                            self.always = YLeaf(YType.boolean, "always")

                            self.metric = YLeaf(YType.uint32, "metric")

                            self.metric_type = YLeaf(YType.uint32, "metric-type")

                            self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                            self.tag = YLeaf(YType.int32, "tag")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("always",
                                            "metric",
                                            "metric_type",
                                            "route_policy_name",
                                            "tag") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.DefaultInformation.Originate, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.DefaultInformation.Originate, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.always.is_set or
                                self.metric.is_set or
                                self.metric_type.is_set or
                                self.route_policy_name.is_set or
                                self.tag.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.always.yfilter != YFilter.not_set or
                                self.metric.yfilter != YFilter.not_set or
                                self.metric_type.yfilter != YFilter.not_set or
                                self.route_policy_name.yfilter != YFilter.not_set or
                                self.tag.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "originate" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.always.get_name_leafdata())
                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.metric.get_name_leafdata())
                            if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.metric_type.get_name_leafdata())
                            if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tag.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "always" or name == "metric" or name == "metric-type" or name == "route-policy-name" or name == "tag"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "always"):
                                self.always = value
                                self.always.value_namespace = name_space
                                self.always.value_namespace_prefix = name_space_prefix
                            if(value_path == "metric"):
                                self.metric = value
                                self.metric.value_namespace = name_space
                                self.metric.value_namespace_prefix = name_space_prefix
                            if(value_path == "metric-type"):
                                self.metric_type = value
                                self.metric_type.value_namespace = name_space
                                self.metric_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-policy-name"):
                                self.route_policy_name = value
                                self.route_policy_name.value_namespace = name_space
                                self.route_policy_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "tag"):
                                self.tag = value
                                self.tag.value_namespace = name_space
                                self.tag.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.originate is not None)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.originate is not None and self.originate.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "default-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "originate"):
                            if (self.originate is None):
                                self.originate = Ospfv3.Processes.Process.DefaultVrf.DefaultInformation.Originate()
                                self.originate.parent = self
                                self._children_name_map["originate"] = "originate"
                            return self.originate

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "originate"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class ProcessScope(Entity):
                    """
                    Process scope configuration
                    
                    .. attribute:: fast_reroute
                    
                    	Fast\-reroute configuration
                    	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute>`
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope, self).__init__()

                        self.yang_name = "process-scope"
                        self.yang_parent_name = "default-vrf"

                        self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute()
                        self.fast_reroute.parent = self
                        self._children_name_map["fast_reroute"] = "fast-reroute"
                        self._children_yang_names.add("fast-reroute")


                    class FastReroute(Entity):
                        """
                        Fast\-reroute configuration
                        
                        .. attribute:: fast_reroute_enable
                        
                        	Enable/Disable Fast\-reroute per\-link or per\-prefix
                        	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                        
                        .. attribute:: per_link
                        
                        	Fast\-reroute per\-link configuration
                        	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink>`
                        
                        .. attribute:: per_prefix
                        
                        	Fast\-reroute per\-link configuration
                        	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute, self).__init__()

                            self.yang_name = "fast-reroute"
                            self.yang_parent_name = "process-scope"

                            self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                            self.per_link = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink()
                            self.per_link.parent = self
                            self._children_name_map["per_link"] = "per-link"
                            self._children_yang_names.add("per-link")

                            self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix()
                            self.per_prefix.parent = self
                            self._children_name_map["per_prefix"] = "per-prefix"
                            self._children_yang_names.add("per-prefix")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("fast_reroute_enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute, self).__setattr__(name, value)


                        class PerLink(Entity):
                            """
                            Fast\-reroute per\-link configuration
                            
                            .. attribute:: candidate_interfaces
                            
                            	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                            	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces>`
                            
                            .. attribute:: exclude_interfaces
                            
                            	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces>`
                            
                            .. attribute:: fast_reroute_use_candidate_only
                            
                            	Use only interfaces on the candidate list as a backup path
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink, self).__init__()

                                self.yang_name = "per-link"
                                self.yang_parent_name = "fast-reroute"

                                self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces()
                                self.candidate_interfaces.parent = self
                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                self._children_yang_names.add("candidate-interfaces")

                                self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces()
                                self.exclude_interfaces.parent = self
                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                self._children_yang_names.add("exclude-interfaces")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink, self).__setattr__(name, value)


                            class CandidateInterfaces(Entity):
                                """
                                Fast\-reroute per\-link/per\-prefix candidate
                                interface configuration
                                
                                .. attribute:: candidate_interface
                                
                                	Candidate backup interface
                                	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                    self.yang_name = "candidate-interfaces"
                                    self.yang_parent_name = "per-link"

                                    self.candidate_interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                class CandidateInterface(Entity):
                                    """
                                    Candidate backup interface
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Interface
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                        self.yang_name = "candidate-interface"
                                        self.yang_parent_name = "candidate-interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.interface_name.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.candidate_interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.candidate_interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "candidate-interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "candidate-interface"):
                                        for c in self.candidate_interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.candidate_interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "candidate-interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class ExcludeInterfaces(Entity):
                                """
                                Fast\-reroute per\-link/per\-prefix exclude
                                interface configuration
                                
                                .. attribute:: exclude_interface
                                
                                	Exclude an interface from becoming a backup
                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                    self.yang_name = "exclude-interfaces"
                                    self.yang_parent_name = "per-link"

                                    self.exclude_interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                class ExcludeInterface(Entity):
                                    """
                                    Exclude an interface from becoming a backup
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Interface
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                        self.yang_name = "exclude-interface"
                                        self.yang_parent_name = "exclude-interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.interface_name.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.exclude_interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.exclude_interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exclude-interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "exclude-interface"):
                                        for c in self.exclude_interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.exclude_interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.fast_reroute_use_candidate_only.is_set or
                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "per-link" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "candidate-interfaces"):
                                    if (self.candidate_interfaces is None):
                                        self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces()
                                        self.candidate_interfaces.parent = self
                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                    return self.candidate_interfaces

                                if (child_yang_name == "exclude-interfaces"):
                                    if (self.exclude_interfaces is None):
                                        self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                    return self.exclude_interfaces

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fast-reroute-use-candidate-only"):
                                    self.fast_reroute_use_candidate_only = value
                                    self.fast_reroute_use_candidate_only.value_namespace = name_space
                                    self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                        class PerPrefix(Entity):
                            """
                            Fast\-reroute per\-link configuration
                            
                            .. attribute:: candidate_interfaces
                            
                            	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                            	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces>`
                            
                            .. attribute:: exclude_interfaces
                            
                            	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces>`
                            
                            .. attribute:: fast_reroute_use_candidate_only
                            
                            	Use only interfaces on the candidate list as a backup path
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix, self).__init__()

                                self.yang_name = "per-prefix"
                                self.yang_parent_name = "fast-reroute"

                                self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces()
                                self.candidate_interfaces.parent = self
                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                self._children_yang_names.add("candidate-interfaces")

                                self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                self.exclude_interfaces.parent = self
                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                self._children_yang_names.add("exclude-interfaces")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix, self).__setattr__(name, value)


                            class CandidateInterfaces(Entity):
                                """
                                Fast\-reroute per\-link/per\-prefix candidate
                                interface configuration
                                
                                .. attribute:: candidate_interface
                                
                                	Candidate backup interface
                                	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                    self.yang_name = "candidate-interfaces"
                                    self.yang_parent_name = "per-prefix"

                                    self.candidate_interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                class CandidateInterface(Entity):
                                    """
                                    Candidate backup interface
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Interface
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                        self.yang_name = "candidate-interface"
                                        self.yang_parent_name = "candidate-interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.interface_name.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.candidate_interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.candidate_interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "candidate-interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "candidate-interface"):
                                        for c in self.candidate_interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.candidate_interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "candidate-interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class ExcludeInterfaces(Entity):
                                """
                                Fast\-reroute per\-link/per\-prefix exclude
                                interface configuration
                                
                                .. attribute:: exclude_interface
                                
                                	Exclude an interface from becoming a backup
                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                    self.yang_name = "exclude-interfaces"
                                    self.yang_parent_name = "per-prefix"

                                    self.exclude_interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                class ExcludeInterface(Entity):
                                    """
                                    Exclude an interface from becoming a backup
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Interface
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                        self.yang_name = "exclude-interface"
                                        self.yang_parent_name = "exclude-interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.interface_name.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.exclude_interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.exclude_interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exclude-interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "exclude-interface"):
                                        for c in self.exclude_interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.exclude_interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.fast_reroute_use_candidate_only.is_set or
                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "per-prefix" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "candidate-interfaces"):
                                    if (self.candidate_interfaces is None):
                                        self.candidate_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces()
                                        self.candidate_interfaces.parent = self
                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                    return self.candidate_interfaces

                                if (child_yang_name == "exclude-interfaces"):
                                    if (self.exclude_interfaces is None):
                                        self.exclude_interfaces = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                    return self.exclude_interfaces

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fast-reroute-use-candidate-only"):
                                    self.fast_reroute_use_candidate_only = value
                                    self.fast_reroute_use_candidate_only.value_namespace = name_space
                                    self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.fast_reroute_enable.is_set or
                                (self.per_link is not None and self.per_link.has_data()) or
                                (self.per_prefix is not None and self.per_prefix.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.fast_reroute_enable.yfilter != YFilter.not_set or
                                (self.per_link is not None and self.per_link.has_operation()) or
                                (self.per_prefix is not None and self.per_prefix.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "fast-reroute" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "per-link"):
                                if (self.per_link is None):
                                    self.per_link = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerLink()
                                    self.per_link.parent = self
                                    self._children_name_map["per_link"] = "per-link"
                                return self.per_link

                            if (child_yang_name == "per-prefix"):
                                if (self.per_prefix is None):
                                    self.per_prefix = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute.PerPrefix()
                                    self.per_prefix.parent = self
                                    self._children_name_map["per_prefix"] = "per-prefix"
                                return self.per_prefix

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "fast-reroute-enable"):
                                self.fast_reroute_enable = value
                                self.fast_reroute_enable.value_namespace = name_space
                                self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.fast_reroute is not None and self.fast_reroute.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.fast_reroute is not None and self.fast_reroute.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "process-scope" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "fast-reroute"):
                            if (self.fast_reroute is None):
                                self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.ProcessScope.FastReroute()
                                self.fast_reroute.parent = self
                                self._children_name_map["fast_reroute"] = "fast-reroute"
                            return self.fast_reroute

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "fast-reroute"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Encryption(Entity):
                    """
                    Encrypt and authenticate OSPFv3 packets
                    
                    .. attribute:: authentication_algorithm
                    
                    	Use the NULL, MD5 or SHA1 algorithm
                    	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                    
                    .. attribute:: authentication_password
                    
                    	Specify MD5 or SHA1 password
                    	**type**\:  str
                    
                    	**pattern:** (!.+)\|([^!].+)
                    
                    .. attribute:: enable
                    
                    	Authenticate packets
                    	**type**\:  bool
                    
                    .. attribute:: encryption_algorithm
                    
                    	Specify the encryption algorithm
                    	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                    
                    .. attribute:: encryption_password
                    
                    	Encryption password
                    	**type**\:  str
                    
                    	**pattern:** (!.+)\|([^!].+)
                    
                    .. attribute:: spi
                    
                    	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                    	**type**\:  int
                    
                    	**range:** 256..4294967295
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.Encryption, self).__init__()

                        self.yang_name = "encryption"
                        self.yang_parent_name = "default-vrf"

                        self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                        self.authentication_password = YLeaf(YType.str, "authentication-password")

                        self.enable = YLeaf(YType.boolean, "enable")

                        self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                        self.encryption_password = YLeaf(YType.str, "encryption-password")

                        self.spi = YLeaf(YType.uint32, "spi")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_algorithm",
                                        "authentication_password",
                                        "enable",
                                        "encryption_algorithm",
                                        "encryption_password",
                                        "spi") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.Encryption, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.Encryption, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_algorithm.is_set or
                            self.authentication_password.is_set or
                            self.enable.is_set or
                            self.encryption_algorithm.is_set or
                            self.encryption_password.is_set or
                            self.spi.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_algorithm.yfilter != YFilter.not_set or
                            self.authentication_password.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.encryption_algorithm.yfilter != YFilter.not_set or
                            self.encryption_password.yfilter != YFilter.not_set or
                            self.spi.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "encryption" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                        if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_password.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                        if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.encryption_password.get_name_leafdata())
                        if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.spi.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-algorithm"):
                            self.authentication_algorithm = value
                            self.authentication_algorithm.value_namespace = name_space
                            self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                        if(value_path == "authentication-password"):
                            self.authentication_password = value
                            self.authentication_password.value_namespace = name_space
                            self.authentication_password.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "encryption-algorithm"):
                            self.encryption_algorithm = value
                            self.encryption_algorithm.value_namespace = name_space
                            self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                        if(value_path == "encryption-password"):
                            self.encryption_password = value
                            self.encryption_password.value_namespace = name_space
                            self.encryption_password.value_namespace_prefix = name_space_prefix
                        if(value_path == "spi"):
                            self.spi = value
                            self.spi.value_namespace = name_space
                            self.spi.value_namespace_prefix = name_space_prefix


                class AutoCost(Entity):
                    """
                    Calculate interface cost according to bandwidth
                    
                    .. attribute:: disable
                    
                    	Specify 'true' to assign cost based on interface type
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: reference_bandwidth
                    
                    	Specify reference bandwidth for cost computations in terms of Mbits per second
                    	**type**\:  int
                    
                    	**range:** 1..4294967
                    
                    	**units**\: Mbit/s
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.DefaultVrf.AutoCost, self).__init__()

                        self.yang_name = "auto-cost"
                        self.yang_parent_name = "default-vrf"
                        self.is_presence_container = True

                        self.disable = YLeaf(YType.empty, "disable")

                        self.reference_bandwidth = YLeaf(YType.uint32, "reference-bandwidth")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable",
                                        "reference_bandwidth") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.DefaultVrf.AutoCost, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.DefaultVrf.AutoCost, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.disable.is_set or
                            self.reference_bandwidth.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable.yfilter != YFilter.not_set or
                            self.reference_bandwidth.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "auto-cost" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable.get_name_leafdata())
                        if (self.reference_bandwidth.is_set or self.reference_bandwidth.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reference_bandwidth.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable" or name == "reference-bandwidth"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable"):
                            self.disable = value
                            self.disable.value_namespace = name_space
                            self.disable.value_namespace_prefix = name_space_prefix
                        if(value_path == "reference-bandwidth"):
                            self.reference_bandwidth = value
                            self.reference_bandwidth.value_namespace = name_space
                            self.reference_bandwidth.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.cost.is_set or
                        self.dead_interval.is_set or
                        self.default_metric.is_set or
                        self.demand_circuit.is_set or
                        self.flood_reduction.is_set or
                        self.hello_interval.is_set or
                        self.instance.is_set or
                        self.ldp_sync.is_set or
                        self.log_adjacency_changes.is_set or
                        self.mtu_ignore.is_set or
                        self.network.is_set or
                        self.packet_size.is_set or
                        self.passive.is_set or
                        self.prefix_suppression.is_set or
                        self.priority.is_set or
                        self.retransmit_interval.is_set or
                        self.router_id.is_set or
                        self.spf_prefix_priority_disable.is_set or
                        self.spf_prefix_priority_policy.is_set or
                        self.transmit_delay.is_set or
                        (self.area_addresses is not None and self.area_addresses.has_data()) or
                        (self.authentication is not None and self.authentication.has_data()) or
                        (self.bfd is not None and self.bfd.has_data()) or
                        (self.database_filter is not None and self.database_filter.has_data()) or
                        (self.default_information is not None and self.default_information.has_data()) or
                        (self.distance is not None and self.distance.has_data()) or
                        (self.distribute_list is not None and self.distribute_list.has_data()) or
                        (self.distribute_list_out is not None and self.distribute_list_out.has_data()) or
                        (self.encryption is not None and self.encryption.has_data()) or
                        (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                        (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                        (self.ignore is not None and self.ignore.has_data()) or
                        (self.maximum is not None and self.maximum.has_data()) or
                        (self.process_scope is not None and self.process_scope.has_data()) or
                        (self.redistributes is not None and self.redistributes.has_data()) or
                        (self.snmp is not None and self.snmp.has_data()) or
                        (self.stub_router is not None and self.stub_router.has_data()) or
                        (self.summary_prefixes is not None and self.summary_prefixes.has_data()) or
                        (self.timers is not None and self.timers.has_data()) or
                        (self.auto_cost is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.cost.yfilter != YFilter.not_set or
                        self.dead_interval.yfilter != YFilter.not_set or
                        self.default_metric.yfilter != YFilter.not_set or
                        self.demand_circuit.yfilter != YFilter.not_set or
                        self.flood_reduction.yfilter != YFilter.not_set or
                        self.hello_interval.yfilter != YFilter.not_set or
                        self.instance.yfilter != YFilter.not_set or
                        self.ldp_sync.yfilter != YFilter.not_set or
                        self.log_adjacency_changes.yfilter != YFilter.not_set or
                        self.mtu_ignore.yfilter != YFilter.not_set or
                        self.network.yfilter != YFilter.not_set or
                        self.packet_size.yfilter != YFilter.not_set or
                        self.passive.yfilter != YFilter.not_set or
                        self.prefix_suppression.yfilter != YFilter.not_set or
                        self.priority.yfilter != YFilter.not_set or
                        self.retransmit_interval.yfilter != YFilter.not_set or
                        self.router_id.yfilter != YFilter.not_set or
                        self.spf_prefix_priority_disable.yfilter != YFilter.not_set or
                        self.spf_prefix_priority_policy.yfilter != YFilter.not_set or
                        self.transmit_delay.yfilter != YFilter.not_set or
                        (self.area_addresses is not None and self.area_addresses.has_operation()) or
                        (self.authentication is not None and self.authentication.has_operation()) or
                        (self.auto_cost is not None and self.auto_cost.has_operation()) or
                        (self.bfd is not None and self.bfd.has_operation()) or
                        (self.database_filter is not None and self.database_filter.has_operation()) or
                        (self.default_information is not None and self.default_information.has_operation()) or
                        (self.distance is not None and self.distance.has_operation()) or
                        (self.distribute_list is not None and self.distribute_list.has_operation()) or
                        (self.distribute_list_out is not None and self.distribute_list_out.has_operation()) or
                        (self.encryption is not None and self.encryption.has_operation()) or
                        (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                        (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                        (self.ignore is not None and self.ignore.has_operation()) or
                        (self.maximum is not None and self.maximum.has_operation()) or
                        (self.process_scope is not None and self.process_scope.has_operation()) or
                        (self.redistributes is not None and self.redistributes.has_operation()) or
                        (self.snmp is not None and self.snmp.has_operation()) or
                        (self.stub_router is not None and self.stub_router.has_operation()) or
                        (self.summary_prefixes is not None and self.summary_prefixes.has_operation()) or
                        (self.timers is not None and self.timers.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "default-vrf" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cost.get_name_leafdata())
                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                    if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.default_metric.get_name_leafdata())
                    if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                    if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                    if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.instance.get_name_leafdata())
                    if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                    if (self.log_adjacency_changes.is_set or self.log_adjacency_changes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.log_adjacency_changes.get_name_leafdata())
                    if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                    if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.network.get_name_leafdata())
                    if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.packet_size.get_name_leafdata())
                    if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.passive.get_name_leafdata())
                    if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                    if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.priority.get_name_leafdata())
                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.router_id.get_name_leafdata())
                    if (self.spf_prefix_priority_disable.is_set or self.spf_prefix_priority_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.spf_prefix_priority_disable.get_name_leafdata())
                    if (self.spf_prefix_priority_policy.is_set or self.spf_prefix_priority_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.spf_prefix_priority_policy.get_name_leafdata())
                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "area-addresses"):
                        if (self.area_addresses is None):
                            self.area_addresses = Ospfv3.Processes.Process.DefaultVrf.AreaAddresses()
                            self.area_addresses.parent = self
                            self._children_name_map["area_addresses"] = "area-addresses"
                        return self.area_addresses

                    if (child_yang_name == "authentication"):
                        if (self.authentication is None):
                            self.authentication = Ospfv3.Processes.Process.DefaultVrf.Authentication()
                            self.authentication.parent = self
                            self._children_name_map["authentication"] = "authentication"
                        return self.authentication

                    if (child_yang_name == "auto-cost"):
                        if (self.auto_cost is None):
                            self.auto_cost = Ospfv3.Processes.Process.DefaultVrf.AutoCost()
                            self.auto_cost.parent = self
                            self._children_name_map["auto_cost"] = "auto-cost"
                        return self.auto_cost

                    if (child_yang_name == "bfd"):
                        if (self.bfd is None):
                            self.bfd = Ospfv3.Processes.Process.DefaultVrf.Bfd()
                            self.bfd.parent = self
                            self._children_name_map["bfd"] = "bfd"
                        return self.bfd

                    if (child_yang_name == "database-filter"):
                        if (self.database_filter is None):
                            self.database_filter = Ospfv3.Processes.Process.DefaultVrf.DatabaseFilter()
                            self.database_filter.parent = self
                            self._children_name_map["database_filter"] = "database-filter"
                        return self.database_filter

                    if (child_yang_name == "default-information"):
                        if (self.default_information is None):
                            self.default_information = Ospfv3.Processes.Process.DefaultVrf.DefaultInformation()
                            self.default_information.parent = self
                            self._children_name_map["default_information"] = "default-information"
                        return self.default_information

                    if (child_yang_name == "distance"):
                        if (self.distance is None):
                            self.distance = Ospfv3.Processes.Process.DefaultVrf.Distance()
                            self.distance.parent = self
                            self._children_name_map["distance"] = "distance"
                        return self.distance

                    if (child_yang_name == "distribute-list"):
                        if (self.distribute_list is None):
                            self.distribute_list = Ospfv3.Processes.Process.DefaultVrf.DistributeList()
                            self.distribute_list.parent = self
                            self._children_name_map["distribute_list"] = "distribute-list"
                        return self.distribute_list

                    if (child_yang_name == "distribute-list-out"):
                        if (self.distribute_list_out is None):
                            self.distribute_list_out = Ospfv3.Processes.Process.DefaultVrf.DistributeListOut()
                            self.distribute_list_out.parent = self
                            self._children_name_map["distribute_list_out"] = "distribute-list-out"
                        return self.distribute_list_out

                    if (child_yang_name == "encryption"):
                        if (self.encryption is None):
                            self.encryption = Ospfv3.Processes.Process.DefaultVrf.Encryption()
                            self.encryption.parent = self
                            self._children_name_map["encryption"] = "encryption"
                        return self.encryption

                    if (child_yang_name == "fast-reroute"):
                        if (self.fast_reroute is None):
                            self.fast_reroute = Ospfv3.Processes.Process.DefaultVrf.FastReroute()
                            self.fast_reroute.parent = self
                            self._children_name_map["fast_reroute"] = "fast-reroute"
                        return self.fast_reroute

                    if (child_yang_name == "graceful-restart"):
                        if (self.graceful_restart is None):
                            self.graceful_restart = Ospfv3.Processes.Process.DefaultVrf.GracefulRestart()
                            self.graceful_restart.parent = self
                            self._children_name_map["graceful_restart"] = "graceful-restart"
                        return self.graceful_restart

                    if (child_yang_name == "ignore"):
                        if (self.ignore is None):
                            self.ignore = Ospfv3.Processes.Process.DefaultVrf.Ignore()
                            self.ignore.parent = self
                            self._children_name_map["ignore"] = "ignore"
                        return self.ignore

                    if (child_yang_name == "maximum"):
                        if (self.maximum is None):
                            self.maximum = Ospfv3.Processes.Process.DefaultVrf.Maximum()
                            self.maximum.parent = self
                            self._children_name_map["maximum"] = "maximum"
                        return self.maximum

                    if (child_yang_name == "process-scope"):
                        if (self.process_scope is None):
                            self.process_scope = Ospfv3.Processes.Process.DefaultVrf.ProcessScope()
                            self.process_scope.parent = self
                            self._children_name_map["process_scope"] = "process-scope"
                        return self.process_scope

                    if (child_yang_name == "redistributes"):
                        if (self.redistributes is None):
                            self.redistributes = Ospfv3.Processes.Process.DefaultVrf.Redistributes()
                            self.redistributes.parent = self
                            self._children_name_map["redistributes"] = "redistributes"
                        return self.redistributes

                    if (child_yang_name == "snmp"):
                        if (self.snmp is None):
                            self.snmp = Ospfv3.Processes.Process.DefaultVrf.Snmp()
                            self.snmp.parent = self
                            self._children_name_map["snmp"] = "snmp"
                        return self.snmp

                    if (child_yang_name == "stub-router"):
                        if (self.stub_router is None):
                            self.stub_router = Ospfv3.Processes.Process.DefaultVrf.StubRouter()
                            self.stub_router.parent = self
                            self._children_name_map["stub_router"] = "stub-router"
                        return self.stub_router

                    if (child_yang_name == "summary-prefixes"):
                        if (self.summary_prefixes is None):
                            self.summary_prefixes = Ospfv3.Processes.Process.DefaultVrf.SummaryPrefixes()
                            self.summary_prefixes.parent = self
                            self._children_name_map["summary_prefixes"] = "summary-prefixes"
                        return self.summary_prefixes

                    if (child_yang_name == "timers"):
                        if (self.timers is None):
                            self.timers = Ospfv3.Processes.Process.DefaultVrf.Timers()
                            self.timers.parent = self
                            self._children_name_map["timers"] = "timers"
                        return self.timers

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "area-addresses" or name == "authentication" or name == "auto-cost" or name == "bfd" or name == "database-filter" or name == "default-information" or name == "distance" or name == "distribute-list" or name == "distribute-list-out" or name == "encryption" or name == "fast-reroute" or name == "graceful-restart" or name == "ignore" or name == "maximum" or name == "process-scope" or name == "redistributes" or name == "snmp" or name == "stub-router" or name == "summary-prefixes" or name == "timers" or name == "cost" or name == "dead-interval" or name == "default-metric" or name == "demand-circuit" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "log-adjacency-changes" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "router-id" or name == "spf-prefix-priority-disable" or name == "spf-prefix-priority-policy" or name == "transmit-delay"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "cost"):
                        self.cost = value
                        self.cost.value_namespace = name_space
                        self.cost.value_namespace_prefix = name_space_prefix
                    if(value_path == "dead-interval"):
                        self.dead_interval = value
                        self.dead_interval.value_namespace = name_space
                        self.dead_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "default-metric"):
                        self.default_metric = value
                        self.default_metric.value_namespace = name_space
                        self.default_metric.value_namespace_prefix = name_space_prefix
                    if(value_path == "demand-circuit"):
                        self.demand_circuit = value
                        self.demand_circuit.value_namespace = name_space
                        self.demand_circuit.value_namespace_prefix = name_space_prefix
                    if(value_path == "flood-reduction"):
                        self.flood_reduction = value
                        self.flood_reduction.value_namespace = name_space
                        self.flood_reduction.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-interval"):
                        self.hello_interval = value
                        self.hello_interval.value_namespace = name_space
                        self.hello_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "instance"):
                        self.instance = value
                        self.instance.value_namespace = name_space
                        self.instance.value_namespace_prefix = name_space_prefix
                    if(value_path == "ldp-sync"):
                        self.ldp_sync = value
                        self.ldp_sync.value_namespace = name_space
                        self.ldp_sync.value_namespace_prefix = name_space_prefix
                    if(value_path == "log-adjacency-changes"):
                        self.log_adjacency_changes = value
                        self.log_adjacency_changes.value_namespace = name_space
                        self.log_adjacency_changes.value_namespace_prefix = name_space_prefix
                    if(value_path == "mtu-ignore"):
                        self.mtu_ignore = value
                        self.mtu_ignore.value_namespace = name_space
                        self.mtu_ignore.value_namespace_prefix = name_space_prefix
                    if(value_path == "network"):
                        self.network = value
                        self.network.value_namespace = name_space
                        self.network.value_namespace_prefix = name_space_prefix
                    if(value_path == "packet-size"):
                        self.packet_size = value
                        self.packet_size.value_namespace = name_space
                        self.packet_size.value_namespace_prefix = name_space_prefix
                    if(value_path == "passive"):
                        self.passive = value
                        self.passive.value_namespace = name_space
                        self.passive.value_namespace_prefix = name_space_prefix
                    if(value_path == "prefix-suppression"):
                        self.prefix_suppression = value
                        self.prefix_suppression.value_namespace = name_space
                        self.prefix_suppression.value_namespace_prefix = name_space_prefix
                    if(value_path == "priority"):
                        self.priority = value
                        self.priority.value_namespace = name_space
                        self.priority.value_namespace_prefix = name_space_prefix
                    if(value_path == "retransmit-interval"):
                        self.retransmit_interval = value
                        self.retransmit_interval.value_namespace = name_space
                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "router-id"):
                        self.router_id = value
                        self.router_id.value_namespace = name_space
                        self.router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "spf-prefix-priority-disable"):
                        self.spf_prefix_priority_disable = value
                        self.spf_prefix_priority_disable.value_namespace = name_space
                        self.spf_prefix_priority_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "spf-prefix-priority-policy"):
                        self.spf_prefix_priority_policy = value
                        self.spf_prefix_priority_policy.value_namespace = name_space
                        self.spf_prefix_priority_policy.value_namespace_prefix = name_space_prefix
                    if(value_path == "transmit-delay"):
                        self.transmit_delay = value
                        self.transmit_delay.value_namespace = name_space
                        self.transmit_delay.value_namespace_prefix = name_space_prefix


            class Vrfs(Entity):
                """
                VRF related configuration
                
                .. attribute:: vrf
                
                	Configuration for a particular OSPF VRF
                	**type**\: list of    :py:class:`Vrf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf>`
                
                

                """

                _prefix = 'ipv6-ospfv3-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Ospfv3.Processes.Process.Vrfs, self).__init__()

                    self.yang_name = "vrfs"
                    self.yang_parent_name = "process"

                    self.vrf = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Ospfv3.Processes.Process.Vrfs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Ospfv3.Processes.Process.Vrfs, self).__setattr__(name, value)


                class Vrf(Entity):
                    """
                    Configuration for a particular OSPF VRF
                    
                    .. attribute:: vrf_name  <key>
                    
                    	Name for this VRF
                    	**type**\:  str
                    
                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                    
                    .. attribute:: area_addresses
                    
                    	Area configuration
                    	**type**\:   :py:class:`AreaAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses>`
                    
                    .. attribute:: authentication
                    
                    	Authenticate OSPFv3 packets
                    	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Authentication>`
                    
                    .. attribute:: auto_cost
                    
                    	Calculate interface cost according to bandwidth
                    	**type**\:   :py:class:`AutoCost <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AutoCost>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: bfd
                    
                    	Configure BFD parameters
                    	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Bfd>`
                    
                    .. attribute:: capability
                    
                    	OSPFv3 Capability
                    	**type**\:   :py:class:`Capability <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Capability>`
                    
                    .. attribute:: cost
                    
                    	Interface cost
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    .. attribute:: database_filter
                    
                    	Database filter
                    	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter>`
                    
                    .. attribute:: dead_interval
                    
                    	Interval after which a neighbor is declared dead (in seconds)
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**units**\: second
                    
                    .. attribute:: default_information
                    
                    	Control distribution of default information
                    	**type**\:   :py:class:`DefaultInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation>`
                    
                    .. attribute:: default_metric
                    
                    	Set metric of redistributed routes
                    	**type**\:  int
                    
                    	**range:** 1..16777214
                    
                    .. attribute:: demand_circuit
                    
                    	Enable/disable demand circuit operation
                    	**type**\:  bool
                    
                    .. attribute:: distance
                    
                    	Define an administrative distance
                    	**type**\:   :py:class:`Distance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Distance>`
                    
                    .. attribute:: distribute_list
                    
                    	Filter prefixes to/from RIB
                    	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList>`
                    
                    .. attribute:: distribute_list_out
                    
                    	Filter prefixes from RIB 
                    	**type**\:   :py:class:`DistributeListOut <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut>`
                    
                    .. attribute:: domain_id
                    
                    	OSPFv3 Domain ID
                    	**type**\:   :py:class:`DomainId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DomainId>`
                    
                    .. attribute:: enable
                    
                    	Enable OSPFv3 VRF configuration
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: encryption
                    
                    	Encrypt and authenticate OSPFv3 packets
                    	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Encryption>`
                    
                    .. attribute:: fast_reroute
                    
                    	Fast\-reroute instance scoped parameters
                    	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute>`
                    
                    .. attribute:: flood_reduction
                    
                    	Enable/disable flood reduction
                    	**type**\:  bool
                    
                    .. attribute:: graceful_restart
                    
                    	Graceful restart configuration
                    	**type**\:   :py:class:`GracefulRestart <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.GracefulRestart>`
                    
                    .. attribute:: hello_interval
                    
                    	Time between HELLO packets
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**units**\: second
                    
                    .. attribute:: ignore
                    
                    	Do not complain about a specified event
                    	**type**\:   :py:class:`Ignore <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Ignore>`
                    
                    .. attribute:: instance
                    
                    	Instance ID
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: log_adjacency_changes
                    
                    	Log changes in adjacency state
                    	**type**\:   :py:class:`Ospfv3LogAdj <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3LogAdj>`
                    
                    .. attribute:: maximum
                    
                    	Set OSPFv3 limits
                    	**type**\:   :py:class:`Maximum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Maximum>`
                    
                    .. attribute:: mtu_ignore
                    
                    	Enable/disable ignoring of MTU in DBD packets
                    	**type**\:  bool
                    
                    .. attribute:: network
                    
                    	Specify network type
                    	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                    
                    .. attribute:: packet_size
                    
                    	Limit size of OSPFv3 packets
                    	**type**\:  int
                    
                    	**range:** 256..10000
                    
                    .. attribute:: passive
                    
                    	Enable/disable routing updates on an interface
                    	**type**\:  bool
                    
                    .. attribute:: prefix_suppression
                    
                    	Enable/disable prefix suppression on an interface
                    	**type**\:  bool
                    
                    .. attribute:: priority
                    
                    	Specify router priority
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: process_scope
                    
                    	Process scope configuration
                    	**type**\:   :py:class:`ProcessScope <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope>`
                    
                    .. attribute:: redistributes
                    
                    	Redistribute information from another routing protocol
                    	**type**\:   :py:class:`Redistributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes>`
                    
                    .. attribute:: retransmit_interval
                    
                    	Specify the transmit interval in seconds
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**units**\: second
                    
                    .. attribute:: router_id
                    
                    	Specify the router ID for this OSPFv3 process in IPv4 address format
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: snmp
                    
                    	SNMP configuration
                    	**type**\:   :py:class:`Snmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Snmp>`
                    
                    .. attribute:: snmpvrf_trap
                    
                    	Enable SNMP trap configuration in a VRF
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: spf_prefix_priority_policy
                    
                    	Route policy for SPF prefix prioritization
                    	**type**\:  str
                    
                    .. attribute:: stub_router
                    
                    	Stub router configuration
                    	**type**\:   :py:class:`StubRouter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter>`
                    
                    .. attribute:: summary_prefixes
                    
                    	Summarize redistributed routes matching prefix/length
                    	**type**\:   :py:class:`SummaryPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes>`
                    
                    .. attribute:: timers
                    
                    	Adjust routing timers
                    	**type**\:   :py:class:`Timers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Timers>`
                    
                    .. attribute:: transmit_delay
                    
                    	Specify the transmit delay in seconds
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.Vrfs.Vrf, self).__init__()

                        self.yang_name = "vrf"
                        self.yang_parent_name = "vrfs"

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.cost = YLeaf(YType.uint32, "cost")

                        self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                        self.default_metric = YLeaf(YType.uint32, "default-metric")

                        self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                        self.instance = YLeaf(YType.uint32, "instance")

                        self.log_adjacency_changes = YLeaf(YType.enumeration, "log-adjacency-changes")

                        self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                        self.network = YLeaf(YType.enumeration, "network")

                        self.packet_size = YLeaf(YType.uint32, "packet-size")

                        self.passive = YLeaf(YType.boolean, "passive")

                        self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                        self.priority = YLeaf(YType.uint32, "priority")

                        self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                        self.router_id = YLeaf(YType.str, "router-id")

                        self.snmpvrf_trap = YLeaf(YType.empty, "snmpvrf-trap")

                        self.spf_prefix_priority_policy = YLeaf(YType.str, "spf-prefix-priority-policy")

                        self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                        self.area_addresses = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses()
                        self.area_addresses.parent = self
                        self._children_name_map["area_addresses"] = "area-addresses"
                        self._children_yang_names.add("area-addresses")

                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.Authentication()
                        self.authentication.parent = self
                        self._children_name_map["authentication"] = "authentication"
                        self._children_yang_names.add("authentication")

                        self.auto_cost = None
                        self._children_name_map["auto_cost"] = "auto-cost"
                        self._children_yang_names.add("auto-cost")

                        self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.Bfd()
                        self.bfd.parent = self
                        self._children_name_map["bfd"] = "bfd"
                        self._children_yang_names.add("bfd")

                        self.capability = Ospfv3.Processes.Process.Vrfs.Vrf.Capability()
                        self.capability.parent = self
                        self._children_name_map["capability"] = "capability"
                        self._children_yang_names.add("capability")

                        self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter()
                        self.database_filter.parent = self
                        self._children_name_map["database_filter"] = "database-filter"
                        self._children_yang_names.add("database-filter")

                        self.default_information = Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation()
                        self.default_information.parent = self
                        self._children_name_map["default_information"] = "default-information"
                        self._children_yang_names.add("default-information")

                        self.distance = Ospfv3.Processes.Process.Vrfs.Vrf.Distance()
                        self.distance.parent = self
                        self._children_name_map["distance"] = "distance"
                        self._children_yang_names.add("distance")

                        self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList()
                        self.distribute_list.parent = self
                        self._children_name_map["distribute_list"] = "distribute-list"
                        self._children_yang_names.add("distribute-list")

                        self.distribute_list_out = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut()
                        self.distribute_list_out.parent = self
                        self._children_name_map["distribute_list_out"] = "distribute-list-out"
                        self._children_yang_names.add("distribute-list-out")

                        self.domain_id = Ospfv3.Processes.Process.Vrfs.Vrf.DomainId()
                        self.domain_id.parent = self
                        self._children_name_map["domain_id"] = "domain-id"
                        self._children_yang_names.add("domain-id")

                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.Encryption()
                        self.encryption.parent = self
                        self._children_name_map["encryption"] = "encryption"
                        self._children_yang_names.add("encryption")

                        self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute()
                        self.fast_reroute.parent = self
                        self._children_name_map["fast_reroute"] = "fast-reroute"
                        self._children_yang_names.add("fast-reroute")

                        self.graceful_restart = Ospfv3.Processes.Process.Vrfs.Vrf.GracefulRestart()
                        self.graceful_restart.parent = self
                        self._children_name_map["graceful_restart"] = "graceful-restart"
                        self._children_yang_names.add("graceful-restart")

                        self.ignore = Ospfv3.Processes.Process.Vrfs.Vrf.Ignore()
                        self.ignore.parent = self
                        self._children_name_map["ignore"] = "ignore"
                        self._children_yang_names.add("ignore")

                        self.maximum = Ospfv3.Processes.Process.Vrfs.Vrf.Maximum()
                        self.maximum.parent = self
                        self._children_name_map["maximum"] = "maximum"
                        self._children_yang_names.add("maximum")

                        self.process_scope = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope()
                        self.process_scope.parent = self
                        self._children_name_map["process_scope"] = "process-scope"
                        self._children_yang_names.add("process-scope")

                        self.redistributes = Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes()
                        self.redistributes.parent = self
                        self._children_name_map["redistributes"] = "redistributes"
                        self._children_yang_names.add("redistributes")

                        self.snmp = Ospfv3.Processes.Process.Vrfs.Vrf.Snmp()
                        self.snmp.parent = self
                        self._children_name_map["snmp"] = "snmp"
                        self._children_yang_names.add("snmp")

                        self.stub_router = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter()
                        self.stub_router.parent = self
                        self._children_name_map["stub_router"] = "stub-router"
                        self._children_yang_names.add("stub-router")

                        self.summary_prefixes = Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes()
                        self.summary_prefixes.parent = self
                        self._children_name_map["summary_prefixes"] = "summary-prefixes"
                        self._children_yang_names.add("summary-prefixes")

                        self.timers = Ospfv3.Processes.Process.Vrfs.Vrf.Timers()
                        self.timers.parent = self
                        self._children_name_map["timers"] = "timers"
                        self._children_yang_names.add("timers")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("vrf_name",
                                        "cost",
                                        "dead_interval",
                                        "default_metric",
                                        "demand_circuit",
                                        "enable",
                                        "flood_reduction",
                                        "hello_interval",
                                        "instance",
                                        "log_adjacency_changes",
                                        "mtu_ignore",
                                        "network",
                                        "packet_size",
                                        "passive",
                                        "prefix_suppression",
                                        "priority",
                                        "retransmit_interval",
                                        "router_id",
                                        "snmpvrf_trap",
                                        "spf_prefix_priority_policy",
                                        "transmit_delay") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.Vrfs.Vrf, self).__setattr__(name, value)


                    class Capability(Entity):
                        """
                        OSPFv3 Capability
                        
                        .. attribute:: vrf_lite
                        
                        	Enable VRF Lite
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Capability, self).__init__()

                            self.yang_name = "capability"
                            self.yang_parent_name = "vrf"

                            self.vrf_lite = YLeaf(YType.boolean, "vrf-lite")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("vrf_lite") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Capability, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Capability, self).__setattr__(name, value)

                        def has_data(self):
                            return self.vrf_lite.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.vrf_lite.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "capability" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.vrf_lite.is_set or self.vrf_lite.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.vrf_lite.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "vrf-lite"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "vrf-lite"):
                                self.vrf_lite = value
                                self.vrf_lite.value_namespace = name_space
                                self.vrf_lite.value_namespace_prefix = name_space_prefix


                    class DomainId(Entity):
                        """
                        OSPFv3 Domain ID
                        
                        .. attribute:: primary_domain_id
                        
                        	OSPF Primary domain ID
                        	**type**\:   :py:class:`PrimaryDomainId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.PrimaryDomainId>`
                        
                        .. attribute:: secondary_domain_ids
                        
                        	Secondary domain ID Table
                        	**type**\:   :py:class:`SecondaryDomainIds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId, self).__init__()

                            self.yang_name = "domain-id"
                            self.yang_parent_name = "vrf"

                            self.primary_domain_id = Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.PrimaryDomainId()
                            self.primary_domain_id.parent = self
                            self._children_name_map["primary_domain_id"] = "primary-domain-id"
                            self._children_yang_names.add("primary-domain-id")

                            self.secondary_domain_ids = Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds()
                            self.secondary_domain_ids.parent = self
                            self._children_name_map["secondary_domain_ids"] = "secondary-domain-ids"
                            self._children_yang_names.add("secondary-domain-ids")


                        class SecondaryDomainIds(Entity):
                            """
                            Secondary domain ID Table
                            
                            .. attribute:: secondary_domain_id
                            
                            	OSPF Secondary domain ID
                            	**type**\: list of    :py:class:`SecondaryDomainId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds.SecondaryDomainId>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds, self).__init__()

                                self.yang_name = "secondary-domain-ids"
                                self.yang_parent_name = "domain-id"

                                self.secondary_domain_id = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds, self).__setattr__(name, value)


                            class SecondaryDomainId(Entity):
                                """
                                OSPF Secondary domain ID
                                
                                .. attribute:: domain_id_type  <key>
                                
                                	Secondary domain ID type
                                	**type**\:   :py:class:`Ospfv3DomainId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3DomainId>`
                                
                                .. attribute:: domain_id_name  <key>
                                
                                	Secondary domain ID value
                                	**type**\:  str
                                
                                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds.SecondaryDomainId, self).__init__()

                                    self.yang_name = "secondary-domain-id"
                                    self.yang_parent_name = "secondary-domain-ids"

                                    self.domain_id_type = YLeaf(YType.enumeration, "domain-id-type")

                                    self.domain_id_name = YLeaf(YType.str, "domain-id-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("domain_id_type",
                                                    "domain_id_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds.SecondaryDomainId, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds.SecondaryDomainId, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.domain_id_type.is_set or
                                        self.domain_id_name.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.domain_id_type.yfilter != YFilter.not_set or
                                        self.domain_id_name.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "secondary-domain-id" + "[domain-id-type='" + self.domain_id_type.get() + "']" + "[domain-id-name='" + self.domain_id_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.domain_id_type.is_set or self.domain_id_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.domain_id_type.get_name_leafdata())
                                    if (self.domain_id_name.is_set or self.domain_id_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.domain_id_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "domain-id-type" or name == "domain-id-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "domain-id-type"):
                                        self.domain_id_type = value
                                        self.domain_id_type.value_namespace = name_space
                                        self.domain_id_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "domain-id-name"):
                                        self.domain_id_name = value
                                        self.domain_id_name.value_namespace = name_space
                                        self.domain_id_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.secondary_domain_id:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.secondary_domain_id:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "secondary-domain-ids" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "secondary-domain-id"):
                                    for c in self.secondary_domain_id:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds.SecondaryDomainId()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.secondary_domain_id.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "secondary-domain-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class PrimaryDomainId(Entity):
                            """
                            OSPF Primary domain ID
                            
                            .. attribute:: domain_id_name
                            
                            	Primary domain ID value
                            	**type**\:  str
                            
                            .. attribute:: domain_id_type
                            
                            	Primary domain ID type
                            	**type**\:   :py:class:`Ospfv3DomainId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3DomainId>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.PrimaryDomainId, self).__init__()

                                self.yang_name = "primary-domain-id"
                                self.yang_parent_name = "domain-id"

                                self.domain_id_name = YLeaf(YType.str, "domain-id-name")

                                self.domain_id_type = YLeaf(YType.enumeration, "domain-id-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("domain_id_name",
                                                "domain_id_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.PrimaryDomainId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.PrimaryDomainId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.domain_id_name.is_set or
                                    self.domain_id_type.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.domain_id_name.yfilter != YFilter.not_set or
                                    self.domain_id_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "primary-domain-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.domain_id_name.is_set or self.domain_id_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.domain_id_name.get_name_leafdata())
                                if (self.domain_id_type.is_set or self.domain_id_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.domain_id_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "domain-id-name" or name == "domain-id-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "domain-id-name"):
                                    self.domain_id_name = value
                                    self.domain_id_name.value_namespace = name_space
                                    self.domain_id_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "domain-id-type"):
                                    self.domain_id_type = value
                                    self.domain_id_type.value_namespace = name_space
                                    self.domain_id_type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.primary_domain_id is not None and self.primary_domain_id.has_data()) or
                                (self.secondary_domain_ids is not None and self.secondary_domain_ids.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.primary_domain_id is not None and self.primary_domain_id.has_operation()) or
                                (self.secondary_domain_ids is not None and self.secondary_domain_ids.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "domain-id" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "primary-domain-id"):
                                if (self.primary_domain_id is None):
                                    self.primary_domain_id = Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.PrimaryDomainId()
                                    self.primary_domain_id.parent = self
                                    self._children_name_map["primary_domain_id"] = "primary-domain-id"
                                return self.primary_domain_id

                            if (child_yang_name == "secondary-domain-ids"):
                                if (self.secondary_domain_ids is None):
                                    self.secondary_domain_ids = Ospfv3.Processes.Process.Vrfs.Vrf.DomainId.SecondaryDomainIds()
                                    self.secondary_domain_ids.parent = self
                                    self._children_name_map["secondary_domain_ids"] = "secondary-domain-ids"
                                return self.secondary_domain_ids

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "primary-domain-id" or name == "secondary-domain-ids"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class AreaAddresses(Entity):
                        """
                        Area configuration
                        
                        .. attribute:: area_address
                        
                        	Configuration for a particular area
                        	**type**\: list of    :py:class:`AreaAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress>`
                        
                        .. attribute:: area_area_id
                        
                        	Configuration for a particular area
                        	**type**\: list of    :py:class:`AreaAreaId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses, self).__init__()

                            self.yang_name = "area-addresses"
                            self.yang_parent_name = "vrf"

                            self.area_address = YList(self)
                            self.area_area_id = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses, self).__setattr__(name, value)


                        class AreaAddress(Entity):
                            """
                            Configuration for a particular area
                            
                            .. attribute:: address  <key>
                            
                            	Area ID if in IP address format
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: area_scope
                            
                            	Area Scope Configuration
                            	**type**\:   :py:class:`AreaScope <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope>`
                            
                            .. attribute:: authentication
                            
                            	Authenticate OSPFv3 packets
                            	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Authentication>`
                            
                            .. attribute:: bfd
                            
                            	Configure BFD parameters
                            	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Bfd>`
                            
                            .. attribute:: cost
                            
                            	Interface cost
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            .. attribute:: database_filter
                            
                            	Database filter
                            	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter>`
                            
                            .. attribute:: dead_interval
                            
                            	Interval after which a neighbor is declared dead (in seconds)
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: default_cost
                            
                            	Set the summary default\-cost of a NSSA/stub area
                            	**type**\:  int
                            
                            	**range:** 0..16777215
                            
                            .. attribute:: demand_circuit
                            
                            	Enable/disable demand circuit operation
                            	**type**\:  bool
                            
                            .. attribute:: distribute_list
                            
                            	Filter prefixes to/from RIB
                            	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList>`
                            
                            .. attribute:: enable
                            
                            	Enable OSPFv3 area
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: encryption
                            
                            	Encrypt and authenticate OSPFv3 packets
                            	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Encryption>`
                            
                            .. attribute:: flood_reduction
                            
                            	Enable/disable flood reduction
                            	**type**\:  bool
                            
                            .. attribute:: hello_interval
                            
                            	Time between HELLO packets
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: instance
                            
                            	Instance ID
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: interfaces
                            
                            	OSPFv3 interfaces
                            	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces>`
                            
                            .. attribute:: ldp_sync
                            
                            	Enable/Disable MPLS LDP sync
                            	**type**\:  bool
                            
                            .. attribute:: mtu_ignore
                            
                            	Enable/disable ignoring of MTU in DBD packets
                            	**type**\:  bool
                            
                            .. attribute:: network
                            
                            	Specify network type
                            	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                            
                            .. attribute:: nssa
                            
                            	Specify area as a NSSA area.  Allowed only in non\-backbone areas
                            	**type**\:   :py:class:`Nssa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Nssa>`
                            
                            .. attribute:: packet_size
                            
                            	Limit size of OSPFv3 packets
                            	**type**\:  int
                            
                            	**range:** 256..10000
                            
                            .. attribute:: passive
                            
                            	Enable/disable routing updates on an interface
                            	**type**\:  bool
                            
                            .. attribute:: prefix_suppression
                            
                            	Enable/disable prefix suppression on an interface
                            	**type**\:  bool
                            
                            .. attribute:: priority
                            
                            	Specify router priority
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: ranges
                            
                            	Range configuration
                            	**type**\:   :py:class:`Ranges <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges>`
                            
                            .. attribute:: retransmit_interval
                            
                            	Specify the transmit interval in seconds
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: sham_links
                            
                            	Sham Link sub\-mode
                            	**type**\:   :py:class:`ShamLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks>`
                            
                            .. attribute:: stub
                            
                            	Specify area as a stub area.  Allowed only in non\-backbone areas
                            	**type**\:  bool
                            
                            .. attribute:: transmit_delay
                            
                            	Specify the transmit delay in seconds
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: virtual_links
                            
                            	Virtual link sub\-mode
                            	**type**\:   :py:class:`VirtualLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress, self).__init__()

                                self.yang_name = "area-address"
                                self.yang_parent_name = "area-addresses"

                                self.address = YLeaf(YType.str, "address")

                                self.cost = YLeaf(YType.uint32, "cost")

                                self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                self.default_cost = YLeaf(YType.uint32, "default-cost")

                                self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                self.instance = YLeaf(YType.uint32, "instance")

                                self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                                self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                self.network = YLeaf(YType.enumeration, "network")

                                self.packet_size = YLeaf(YType.uint32, "packet-size")

                                self.passive = YLeaf(YType.boolean, "passive")

                                self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                self.priority = YLeaf(YType.uint32, "priority")

                                self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                self.stub = YLeaf(YType.boolean, "stub")

                                self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                self.area_scope = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope()
                                self.area_scope.parent = self
                                self._children_name_map["area_scope"] = "area-scope"
                                self._children_yang_names.add("area-scope")

                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Authentication()
                                self.authentication.parent = self
                                self._children_name_map["authentication"] = "authentication"
                                self._children_yang_names.add("authentication")

                                self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Bfd()
                                self.bfd.parent = self
                                self._children_name_map["bfd"] = "bfd"
                                self._children_yang_names.add("bfd")

                                self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter()
                                self.database_filter.parent = self
                                self._children_name_map["database_filter"] = "database-filter"
                                self._children_yang_names.add("database-filter")

                                self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList()
                                self.distribute_list.parent = self
                                self._children_name_map["distribute_list"] = "distribute-list"
                                self._children_yang_names.add("distribute-list")

                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Encryption()
                                self.encryption.parent = self
                                self._children_name_map["encryption"] = "encryption"
                                self._children_yang_names.add("encryption")

                                self.interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces()
                                self.interfaces.parent = self
                                self._children_name_map["interfaces"] = "interfaces"
                                self._children_yang_names.add("interfaces")

                                self.nssa = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Nssa()
                                self.nssa.parent = self
                                self._children_name_map["nssa"] = "nssa"
                                self._children_yang_names.add("nssa")

                                self.ranges = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges()
                                self.ranges.parent = self
                                self._children_name_map["ranges"] = "ranges"
                                self._children_yang_names.add("ranges")

                                self.sham_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks()
                                self.sham_links.parent = self
                                self._children_name_map["sham_links"] = "sham-links"
                                self._children_yang_names.add("sham-links")

                                self.virtual_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks()
                                self.virtual_links.parent = self
                                self._children_name_map["virtual_links"] = "virtual-links"
                                self._children_yang_names.add("virtual-links")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("address",
                                                "cost",
                                                "dead_interval",
                                                "default_cost",
                                                "demand_circuit",
                                                "enable",
                                                "flood_reduction",
                                                "hello_interval",
                                                "instance",
                                                "ldp_sync",
                                                "mtu_ignore",
                                                "network",
                                                "packet_size",
                                                "passive",
                                                "prefix_suppression",
                                                "priority",
                                                "retransmit_interval",
                                                "stub",
                                                "transmit_delay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress, self).__setattr__(name, value)


                            class Authentication(Entity):
                                """
                                Authenticate OSPFv3 packets
                                
                                .. attribute:: algorithm
                                
                                	Use the MD5 or SHA1 algorithm
                                	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                
                                .. attribute:: enable
                                
                                	Authenticate packets
                                	**type**\:  bool
                                
                                .. attribute:: password
                                
                                	Specify MD5 or SHA1 password
                                	**type**\:  str
                                
                                	**pattern:** (!.+)\|([^!].+)
                                
                                .. attribute:: spi
                                
                                	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                	**type**\:  int
                                
                                	**range:** 256..4294967295
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Authentication, self).__init__()

                                    self.yang_name = "authentication"
                                    self.yang_parent_name = "area-address"

                                    self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.password = YLeaf(YType.str, "password")

                                    self.spi = YLeaf(YType.uint32, "spi")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("algorithm",
                                                    "enable",
                                                    "password",
                                                    "spi") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Authentication, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Authentication, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.algorithm.is_set or
                                        self.enable.is_set or
                                        self.password.is_set or
                                        self.spi.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.algorithm.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.password.yfilter != YFilter.not_set or
                                        self.spi.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "authentication" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.algorithm.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.password.get_name_leafdata())
                                    if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.spi.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "algorithm"):
                                        self.algorithm = value
                                        self.algorithm.value_namespace = name_space
                                        self.algorithm.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "password"):
                                        self.password = value
                                        self.password.value_namespace = name_space
                                        self.password.value_namespace_prefix = name_space_prefix
                                    if(value_path == "spi"):
                                        self.spi = value
                                        self.spi.value_namespace = name_space
                                        self.spi.value_namespace_prefix = name_space_prefix


                            class Bfd(Entity):
                                """
                                Configure BFD parameters
                                
                                .. attribute:: detection_multiplier
                                
                                	Detect multiplier
                                	**type**\:  int
                                
                                	**range:** 2..50
                                
                                .. attribute:: fast_detect_mode
                                
                                	Enable or disable BFD fast detection
                                	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                                
                                .. attribute:: interval
                                
                                	Hello interval in milli\-seconds
                                	**type**\:  int
                                
                                	**range:** 3..30000
                                
                                	**units**\: millisecond
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Bfd, self).__init__()

                                    self.yang_name = "bfd"
                                    self.yang_parent_name = "area-address"

                                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                    self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                    self.interval = YLeaf(YType.uint32, "interval")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("detection_multiplier",
                                                    "fast_detect_mode",
                                                    "interval") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Bfd, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Bfd, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.detection_multiplier.is_set or
                                        self.fast_detect_mode.is_set or
                                        self.interval.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.detection_multiplier.yfilter != YFilter.not_set or
                                        self.fast_detect_mode.yfilter != YFilter.not_set or
                                        self.interval.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bfd" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                    if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interval.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "detection-multiplier"):
                                        self.detection_multiplier = value
                                        self.detection_multiplier.value_namespace = name_space
                                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fast-detect-mode"):
                                        self.fast_detect_mode = value
                                        self.fast_detect_mode.value_namespace = name_space
                                        self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interval"):
                                        self.interval = value
                                        self.interval.value_namespace = name_space
                                        self.interval.value_namespace_prefix = name_space_prefix


                            class Ranges(Entity):
                                """
                                Range configuration
                                
                                .. attribute:: range
                                
                                	Summarize inter\-area routes matching prefix/length
                                	**type**\: list of    :py:class:`Range <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges.Range>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges, self).__init__()

                                    self.yang_name = "ranges"
                                    self.yang_parent_name = "area-address"

                                    self.range = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges, self).__setattr__(name, value)


                                class Range(Entity):
                                    """
                                    Summarize inter\-area routes matching
                                    prefix/length
                                    
                                    .. attribute:: prefix  <key>
                                    
                                    	IPv6 prefix format
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: prefix_length  <key>
                                    
                                    	IPV6 prefix length
                                    	**type**\:  int
                                    
                                    	**range:** 0..128
                                    
                                    .. attribute:: cost
                                    
                                    	Specified metric for this range
                                    	**type**\:  int
                                    
                                    	**range:** 1..16777214
                                    
                                    .. attribute:: not_advertise
                                    
                                    	Do not advertise address range
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges.Range, self).__init__()

                                        self.yang_name = "range"
                                        self.yang_parent_name = "ranges"

                                        self.prefix = YLeaf(YType.str, "prefix")

                                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                        self.cost = YLeaf(YType.uint32, "cost")

                                        self.not_advertise = YLeaf(YType.boolean, "not-advertise")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("prefix",
                                                        "prefix_length",
                                                        "cost",
                                                        "not_advertise") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges.Range, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges.Range, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.prefix.is_set or
                                            self.prefix_length.is_set or
                                            self.cost.is_set or
                                            self.not_advertise.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.prefix.yfilter != YFilter.not_set or
                                            self.prefix_length.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set or
                                            self.not_advertise.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "range" + "[prefix='" + self.prefix.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())
                                        if (self.not_advertise.is_set or self.not_advertise.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.not_advertise.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "prefix" or name == "prefix-length" or name == "cost" or name == "not-advertise"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "prefix"):
                                            self.prefix = value
                                            self.prefix.value_namespace = name_space
                                            self.prefix.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-length"):
                                            self.prefix_length = value
                                            self.prefix_length.value_namespace = name_space
                                            self.prefix_length.value_namespace_prefix = name_space_prefix
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix
                                        if(value_path == "not-advertise"):
                                            self.not_advertise = value
                                            self.not_advertise.value_namespace = name_space
                                            self.not_advertise.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.range:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.range:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ranges" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "range"):
                                        for c in self.range:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges.Range()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.range.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "range"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Encryption(Entity):
                                """
                                Encrypt and authenticate OSPFv3 packets
                                
                                .. attribute:: authentication_algorithm
                                
                                	Use the NULL, MD5 or SHA1 algorithm
                                	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                
                                .. attribute:: authentication_password
                                
                                	Specify MD5 or SHA1 password
                                	**type**\:  str
                                
                                	**pattern:** (!.+)\|([^!].+)
                                
                                .. attribute:: enable
                                
                                	Authenticate packets
                                	**type**\:  bool
                                
                                .. attribute:: encryption_algorithm
                                
                                	Specify the encryption algorithm
                                	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                
                                .. attribute:: encryption_password
                                
                                	Encryption password
                                	**type**\:  str
                                
                                	**pattern:** (!.+)\|([^!].+)
                                
                                .. attribute:: spi
                                
                                	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                	**type**\:  int
                                
                                	**range:** 256..4294967295
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Encryption, self).__init__()

                                    self.yang_name = "encryption"
                                    self.yang_parent_name = "area-address"

                                    self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                    self.authentication_password = YLeaf(YType.str, "authentication-password")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                    self.encryption_password = YLeaf(YType.str, "encryption-password")

                                    self.spi = YLeaf(YType.uint32, "spi")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("authentication_algorithm",
                                                    "authentication_password",
                                                    "enable",
                                                    "encryption_algorithm",
                                                    "encryption_password",
                                                    "spi") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Encryption, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Encryption, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.authentication_algorithm.is_set or
                                        self.authentication_password.is_set or
                                        self.enable.is_set or
                                        self.encryption_algorithm.is_set or
                                        self.encryption_password.is_set or
                                        self.spi.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.authentication_algorithm.yfilter != YFilter.not_set or
                                        self.authentication_password.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.encryption_algorithm.yfilter != YFilter.not_set or
                                        self.encryption_password.yfilter != YFilter.not_set or
                                        self.spi.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "encryption" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                    if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                    if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                    if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.spi.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "authentication-algorithm"):
                                        self.authentication_algorithm = value
                                        self.authentication_algorithm.value_namespace = name_space
                                        self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                    if(value_path == "authentication-password"):
                                        self.authentication_password = value
                                        self.authentication_password.value_namespace = name_space
                                        self.authentication_password.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "encryption-algorithm"):
                                        self.encryption_algorithm = value
                                        self.encryption_algorithm.value_namespace = name_space
                                        self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                    if(value_path == "encryption-password"):
                                        self.encryption_password = value
                                        self.encryption_password.value_namespace = name_space
                                        self.encryption_password.value_namespace_prefix = name_space_prefix
                                    if(value_path == "spi"):
                                        self.spi = value
                                        self.spi.value_namespace = name_space
                                        self.spi.value_namespace_prefix = name_space_prefix


                            class Nssa(Entity):
                                """
                                Specify area as a NSSA area.  Allowed only in
                                non\-backbone areas
                                
                                .. attribute:: default_info_originate
                                
                                	Originate Type 7 default into NSSA area
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: metric
                                
                                	Only valid with DefaultInfoOriginate
                                	**type**\:  int
                                
                                	**range:** 0..16777214
                                
                                .. attribute:: metric_type
                                
                                	Only valid with DefaultInfoOriginate
                                	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                                
                                .. attribute:: no_redistribution
                                
                                	No redistribution into this NSSA area
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: no_summary
                                
                                	Do not send summary LSA into NSSA
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Nssa, self).__init__()

                                    self.yang_name = "nssa"
                                    self.yang_parent_name = "area-address"

                                    self.default_info_originate = YLeaf(YType.boolean, "default-info-originate")

                                    self.metric = YLeaf(YType.uint32, "metric")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.no_redistribution = YLeaf(YType.boolean, "no-redistribution")

                                    self.no_summary = YLeaf(YType.empty, "no-summary")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("default_info_originate",
                                                    "metric",
                                                    "metric_type",
                                                    "no_redistribution",
                                                    "no_summary") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Nssa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Nssa, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.default_info_originate.is_set or
                                        self.metric.is_set or
                                        self.metric_type.is_set or
                                        self.no_redistribution.is_set or
                                        self.no_summary.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.default_info_originate.yfilter != YFilter.not_set or
                                        self.metric.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.no_redistribution.yfilter != YFilter.not_set or
                                        self.no_summary.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "nssa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.default_info_originate.is_set or self.default_info_originate.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.default_info_originate.get_name_leafdata())
                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.no_redistribution.is_set or self.no_redistribution.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.no_redistribution.get_name_leafdata())
                                    if (self.no_summary.is_set or self.no_summary.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.no_summary.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "default-info-originate" or name == "metric" or name == "metric-type" or name == "no-redistribution" or name == "no-summary"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "default-info-originate"):
                                        self.default_info_originate = value
                                        self.default_info_originate.value_namespace = name_space
                                        self.default_info_originate.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric"):
                                        self.metric = value
                                        self.metric.value_namespace = name_space
                                        self.metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "no-redistribution"):
                                        self.no_redistribution = value
                                        self.no_redistribution.value_namespace = name_space
                                        self.no_redistribution.value_namespace_prefix = name_space_prefix
                                    if(value_path == "no-summary"):
                                        self.no_summary = value
                                        self.no_summary.value_namespace = name_space
                                        self.no_summary.value_namespace_prefix = name_space_prefix


                            class DatabaseFilter(Entity):
                                """
                                Database filter
                                
                                .. attribute:: all
                                
                                	All
                                	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter.All>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter, self).__init__()

                                    self.yang_name = "database-filter"
                                    self.yang_parent_name = "area-address"

                                    self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter.All()
                                    self.all.parent = self
                                    self._children_name_map["all"] = "all"
                                    self._children_yang_names.add("all")


                                class All(Entity):
                                    """
                                    All
                                    
                                    .. attribute:: out
                                    
                                    	Enable or disable database\-filter
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter.All, self).__init__()

                                        self.yang_name = "all"
                                        self.yang_parent_name = "database-filter"

                                        self.out = YLeaf(YType.boolean, "out")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("out") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter.All, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter.All, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.out.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.out.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "all" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.out.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "out"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "out"):
                                            self.out = value
                                            self.out.value_namespace = name_space
                                            self.out.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.all is not None and self.all.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.all is not None and self.all.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "database-filter" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "all"):
                                        if (self.all is None):
                                            self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter.All()
                                            self.all.parent = self
                                            self._children_name_map["all"] = "all"
                                        return self.all

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "all"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class DistributeList(Entity):
                                """
                                Filter prefixes to/from RIB
                                
                                .. attribute:: in_
                                
                                	Filter prefixes installed to RIB
                                	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList.In_>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList, self).__init__()

                                    self.yang_name = "distribute-list"
                                    self.yang_parent_name = "area-address"

                                    self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList.In_()
                                    self.in_.parent = self
                                    self._children_name_map["in_"] = "in"
                                    self._children_yang_names.add("in")


                                class In_(Entity):
                                    """
                                    Filter prefixes installed to RIB
                                    
                                    .. attribute:: prefix_list
                                    
                                    	Filter prefixes based on an IPv6 prefix\-list
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList.In_, self).__init__()

                                        self.yang_name = "in"
                                        self.yang_parent_name = "distribute-list"

                                        self.prefix_list = YLeaf(YType.str, "prefix-list")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("prefix_list") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList.In_, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList.In_, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.prefix_list.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.prefix_list.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "in" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "prefix-list"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "prefix-list"):
                                            self.prefix_list = value
                                            self.prefix_list.value_namespace = name_space
                                            self.prefix_list.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.in_ is not None and self.in_.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.in_ is not None and self.in_.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "distribute-list" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "in"):
                                        if (self.in_ is None):
                                            self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList.In_()
                                            self.in_.parent = self
                                            self._children_name_map["in_"] = "in"
                                        return self.in_

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "in"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Interfaces(Entity):
                                """
                                OSPFv3 interfaces
                                
                                .. attribute:: interface
                                
                                	OSPFv3 interface
                                	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces, self).__init__()

                                    self.yang_name = "interfaces"
                                    self.yang_parent_name = "area-address"

                                    self.interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces, self).__setattr__(name, value)


                                class Interface(Entity):
                                    """
                                    OSPFv3 interface
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Interface to configure
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    .. attribute:: authentication
                                    
                                    	Authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication>`
                                    
                                    .. attribute:: bfd
                                    
                                    	Configure BFD parameters
                                    	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd>`
                                    
                                    .. attribute:: cost
                                    
                                    	Interface cost
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    .. attribute:: database_filter
                                    
                                    	Database filter
                                    	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter>`
                                    
                                    .. attribute:: dead_interval
                                    
                                    	Interval after which a neighbor is declared dead (in seconds)
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: demand_circuit
                                    
                                    	Enable/disable demand circuit operation
                                    	**type**\:  bool
                                    
                                    .. attribute:: distribute_list
                                    
                                    	Filter prefixes to/from RIB
                                    	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList>`
                                    
                                    .. attribute:: enable
                                    
                                    	Enable OSPFv3 interface
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: encryption
                                    
                                    	Encrypt and authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption>`
                                    
                                    .. attribute:: fast_reroute
                                    
                                    	Fast\-reroute configuration
                                    	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute>`
                                    
                                    .. attribute:: flood_reduction
                                    
                                    	Enable/disable flood reduction
                                    	**type**\:  bool
                                    
                                    .. attribute:: hello_interval
                                    
                                    	Time between HELLO packets
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: instance
                                    
                                    	Instance ID
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: ldp_sync
                                    
                                    	Enable/Disable MPLS LDP sync
                                    	**type**\:  bool
                                    
                                    .. attribute:: mtu_ignore
                                    
                                    	Enable/disable ignoring of MTU in DBD packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: neighbors
                                    
                                    	Specify a neighbor router
                                    	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors>`
                                    
                                    .. attribute:: network
                                    
                                    	Specify network type
                                    	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                                    
                                    .. attribute:: packet_size
                                    
                                    	Limit size of OSPFv3 packets
                                    	**type**\:  int
                                    
                                    	**range:** 256..10000
                                    
                                    .. attribute:: passive
                                    
                                    	Enable/disable routing updates on an interface
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_suppression
                                    
                                    	Enable/disable prefix suppression on an interface
                                    	**type**\:  bool
                                    
                                    .. attribute:: priority
                                    
                                    	Specify router priority
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: retransmit_interval
                                    
                                    	Specify the transmit interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: transmit_delay
                                    
                                    	Specify the transmit delay in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface, self).__init__()

                                        self.yang_name = "interface"
                                        self.yang_parent_name = "interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                        self.cost = YLeaf(YType.uint32, "cost")

                                        self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                        self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                        self.instance = YLeaf(YType.uint32, "instance")

                                        self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                                        self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                        self.network = YLeaf(YType.enumeration, "network")

                                        self.packet_size = YLeaf(YType.uint32, "packet-size")

                                        self.passive = YLeaf(YType.boolean, "passive")

                                        self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                        self.priority = YLeaf(YType.uint32, "priority")

                                        self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                        self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                        self._children_yang_names.add("authentication")

                                        self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd()
                                        self.bfd.parent = self
                                        self._children_name_map["bfd"] = "bfd"
                                        self._children_yang_names.add("bfd")

                                        self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter()
                                        self.database_filter.parent = self
                                        self._children_name_map["database_filter"] = "database-filter"
                                        self._children_yang_names.add("database-filter")

                                        self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList()
                                        self.distribute_list.parent = self
                                        self._children_name_map["distribute_list"] = "distribute-list"
                                        self._children_yang_names.add("distribute-list")

                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                        self._children_yang_names.add("encryption")

                                        self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute()
                                        self.fast_reroute.parent = self
                                        self._children_name_map["fast_reroute"] = "fast-reroute"
                                        self._children_yang_names.add("fast-reroute")

                                        self.neighbors = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors()
                                        self.neighbors.parent = self
                                        self._children_name_map["neighbors"] = "neighbors"
                                        self._children_yang_names.add("neighbors")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name",
                                                        "cost",
                                                        "dead_interval",
                                                        "demand_circuit",
                                                        "enable",
                                                        "flood_reduction",
                                                        "hello_interval",
                                                        "instance",
                                                        "ldp_sync",
                                                        "mtu_ignore",
                                                        "network",
                                                        "packet_size",
                                                        "passive",
                                                        "prefix_suppression",
                                                        "priority",
                                                        "retransmit_interval",
                                                        "transmit_delay") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface, self).__setattr__(name, value)


                                    class Authentication(Entity):
                                        """
                                        Authenticate OSPFv3 packets
                                        
                                        .. attribute:: algorithm
                                        
                                        	Use the MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication, self).__init__()

                                            self.yang_name = "authentication"
                                            self.yang_parent_name = "interface"

                                            self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.password = YLeaf(YType.str, "password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("algorithm",
                                                            "enable",
                                                            "password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.algorithm.is_set or
                                                self.enable.is_set or
                                                self.password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.algorithm.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "authentication" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.algorithm.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "algorithm"):
                                                self.algorithm = value
                                                self.algorithm.value_namespace = name_space
                                                self.algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "password"):
                                                self.password = value
                                                self.password.value_namespace = name_space
                                                self.password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Neighbors(Entity):
                                        """
                                        Specify a neighbor router
                                        
                                        .. attribute:: neighbor
                                        
                                        	IPv6 address
                                        	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors, self).__init__()

                                            self.yang_name = "neighbors"
                                            self.yang_parent_name = "interface"

                                            self.neighbor = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors, self).__setattr__(name, value)


                                        class Neighbor(Entity):
                                            """
                                            IPv6 address
                                            
                                            .. attribute:: neighbor_address  <key>
                                            
                                            	IPV6 address
                                            	**type**\:  str
                                            
                                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                            
                                            .. attribute:: cost
                                            
                                            	OSPFv3 cost for point\-to\-multipoint neighbor
                                            	**type**\:  int
                                            
                                            	**range:** 1..65535
                                            
                                            .. attribute:: database_filter
                                            
                                            	Filter OSPFv3 LSA during synchronization and flooding for point\-to\-multipoint neighbor
                                            	**type**\:  bool
                                            
                                            .. attribute:: poll_interval
                                            
                                            	OSPFv3 dead\-router polling interval (in seconds)
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**units**\: second
                                            
                                            .. attribute:: priority
                                            
                                            	OSPFv3 priority of non\-broadcast neighbor
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: zone
                                            
                                            	Zone
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor, self).__init__()

                                                self.yang_name = "neighbor"
                                                self.yang_parent_name = "neighbors"

                                                self.neighbor_address = YLeaf(YType.str, "neighbor-address")

                                                self.cost = YLeaf(YType.uint32, "cost")

                                                self.database_filter = YLeaf(YType.boolean, "database-filter")

                                                self.poll_interval = YLeaf(YType.uint32, "poll-interval")

                                                self.priority = YLeaf(YType.uint32, "priority")

                                                self.zone = YLeaf(YType.str, "zone")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("neighbor_address",
                                                                "cost",
                                                                "database_filter",
                                                                "poll_interval",
                                                                "priority",
                                                                "zone") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.neighbor_address.is_set or
                                                    self.cost.is_set or
                                                    self.database_filter.is_set or
                                                    self.poll_interval.is_set or
                                                    self.priority.is_set or
                                                    self.zone.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.neighbor_address.yfilter != YFilter.not_set or
                                                    self.cost.yfilter != YFilter.not_set or
                                                    self.database_filter.yfilter != YFilter.not_set or
                                                    self.poll_interval.yfilter != YFilter.not_set or
                                                    self.priority.yfilter != YFilter.not_set or
                                                    self.zone.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "neighbor" + "[neighbor-address='" + self.neighbor_address.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.neighbor_address.is_set or self.neighbor_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.neighbor_address.get_name_leafdata())
                                                if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.cost.get_name_leafdata())
                                                if (self.database_filter.is_set or self.database_filter.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.database_filter.get_name_leafdata())
                                                if (self.poll_interval.is_set or self.poll_interval.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.poll_interval.get_name_leafdata())
                                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                                if (self.zone.is_set or self.zone.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.zone.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "neighbor-address" or name == "cost" or name == "database-filter" or name == "poll-interval" or name == "priority" or name == "zone"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "neighbor-address"):
                                                    self.neighbor_address = value
                                                    self.neighbor_address.value_namespace = name_space
                                                    self.neighbor_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "cost"):
                                                    self.cost = value
                                                    self.cost.value_namespace = name_space
                                                    self.cost.value_namespace_prefix = name_space_prefix
                                                if(value_path == "database-filter"):
                                                    self.database_filter = value
                                                    self.database_filter.value_namespace = name_space
                                                    self.database_filter.value_namespace_prefix = name_space_prefix
                                                if(value_path == "poll-interval"):
                                                    self.poll_interval = value
                                                    self.poll_interval.value_namespace = name_space
                                                    self.poll_interval.value_namespace_prefix = name_space_prefix
                                                if(value_path == "priority"):
                                                    self.priority = value
                                                    self.priority.value_namespace = name_space
                                                    self.priority.value_namespace_prefix = name_space_prefix
                                                if(value_path == "zone"):
                                                    self.zone = value
                                                    self.zone.value_namespace = name_space
                                                    self.zone.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.neighbor:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.neighbor:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "neighbors" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "neighbor"):
                                                for c in self.neighbor:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors.Neighbor()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.neighbor.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "neighbor"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class Encryption(Entity):
                                        """
                                        Encrypt and authenticate OSPFv3 packets
                                        
                                        .. attribute:: authentication_algorithm
                                        
                                        	Use the NULL, MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                        
                                        .. attribute:: authentication_password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: encryption_algorithm
                                        
                                        	Specify the encryption algorithm
                                        	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                        
                                        .. attribute:: encryption_password
                                        
                                        	Encryption password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption, self).__init__()

                                            self.yang_name = "encryption"
                                            self.yang_parent_name = "interface"

                                            self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                            self.authentication_password = YLeaf(YType.str, "authentication-password")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                            self.encryption_password = YLeaf(YType.str, "encryption-password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("authentication_algorithm",
                                                            "authentication_password",
                                                            "enable",
                                                            "encryption_algorithm",
                                                            "encryption_password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.authentication_algorithm.is_set or
                                                self.authentication_password.is_set or
                                                self.enable.is_set or
                                                self.encryption_algorithm.is_set or
                                                self.encryption_password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.authentication_algorithm.yfilter != YFilter.not_set or
                                                self.authentication_password.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.encryption_algorithm.yfilter != YFilter.not_set or
                                                self.encryption_password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "encryption" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                            if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                            if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "authentication-algorithm"):
                                                self.authentication_algorithm = value
                                                self.authentication_algorithm.value_namespace = name_space
                                                self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "authentication-password"):
                                                self.authentication_password = value
                                                self.authentication_password.value_namespace = name_space
                                                self.authentication_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-algorithm"):
                                                self.encryption_algorithm = value
                                                self.encryption_algorithm.value_namespace = name_space
                                                self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-password"):
                                                self.encryption_password = value
                                                self.encryption_password.value_namespace = name_space
                                                self.encryption_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Bfd(Entity):
                                        """
                                        Configure BFD parameters
                                        
                                        .. attribute:: detection_multiplier
                                        
                                        	Detect multiplier
                                        	**type**\:  int
                                        
                                        	**range:** 2..50
                                        
                                        .. attribute:: fast_detect_mode
                                        
                                        	Enable or disable BFD fast detection
                                        	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                                        
                                        .. attribute:: interval
                                        
                                        	Hello interval in milli\-seconds
                                        	**type**\:  int
                                        
                                        	**range:** 3..30000
                                        
                                        	**units**\: millisecond
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd, self).__init__()

                                            self.yang_name = "bfd"
                                            self.yang_parent_name = "interface"

                                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                            self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                            self.interval = YLeaf(YType.uint32, "interval")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("detection_multiplier",
                                                            "fast_detect_mode",
                                                            "interval") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.detection_multiplier.is_set or
                                                self.fast_detect_mode.is_set or
                                                self.interval.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.detection_multiplier.yfilter != YFilter.not_set or
                                                self.fast_detect_mode.yfilter != YFilter.not_set or
                                                self.interval.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bfd" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                            if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interval.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "detection-multiplier"):
                                                self.detection_multiplier = value
                                                self.detection_multiplier.value_namespace = name_space
                                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fast-detect-mode"):
                                                self.fast_detect_mode = value
                                                self.fast_detect_mode.value_namespace = name_space
                                                self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                            if(value_path == "interval"):
                                                self.interval = value
                                                self.interval.value_namespace = name_space
                                                self.interval.value_namespace_prefix = name_space_prefix


                                    class DatabaseFilter(Entity):
                                        """
                                        Database filter
                                        
                                        .. attribute:: all
                                        
                                        	All
                                        	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter, self).__init__()

                                            self.yang_name = "database-filter"
                                            self.yang_parent_name = "interface"

                                            self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All()
                                            self.all.parent = self
                                            self._children_name_map["all"] = "all"
                                            self._children_yang_names.add("all")


                                        class All(Entity):
                                            """
                                            All
                                            
                                            .. attribute:: out
                                            
                                            	Enable or disable database\-filter
                                            	**type**\:  bool
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All, self).__init__()

                                                self.yang_name = "all"
                                                self.yang_parent_name = "database-filter"

                                                self.out = YLeaf(YType.boolean, "out")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("out") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.out.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.out.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "all" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.out.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "out"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "out"):
                                                    self.out = value
                                                    self.out.value_namespace = name_space
                                                    self.out.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (self.all is not None and self.all.has_data())

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.all is not None and self.all.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "database-filter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "all"):
                                                if (self.all is None):
                                                    self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter.All()
                                                    self.all.parent = self
                                                    self._children_name_map["all"] = "all"
                                                return self.all

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "all"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class DistributeList(Entity):
                                        """
                                        Filter prefixes to/from RIB
                                        
                                        .. attribute:: in_
                                        
                                        	Filter prefixes installed to RIB
                                        	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList, self).__init__()

                                            self.yang_name = "distribute-list"
                                            self.yang_parent_name = "interface"

                                            self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_()
                                            self.in_.parent = self
                                            self._children_name_map["in_"] = "in"
                                            self._children_yang_names.add("in")


                                        class In_(Entity):
                                            """
                                            Filter prefixes installed to RIB
                                            
                                            .. attribute:: prefix_list
                                            
                                            	Filter prefixes based on an IPv6 prefix\-list
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_, self).__init__()

                                                self.yang_name = "in"
                                                self.yang_parent_name = "distribute-list"

                                                self.prefix_list = YLeaf(YType.str, "prefix-list")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("prefix_list") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.prefix_list.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.prefix_list.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "in" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "prefix-list"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "prefix-list"):
                                                    self.prefix_list = value
                                                    self.prefix_list.value_namespace = name_space
                                                    self.prefix_list.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (self.in_ is not None and self.in_.has_data())

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.in_ is not None and self.in_.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "distribute-list" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "in"):
                                                if (self.in_ is None):
                                                    self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList.In_()
                                                    self.in_.parent = self
                                                    self._children_name_map["in_"] = "in"
                                                return self.in_

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "in"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FastReroute(Entity):
                                        """
                                        Fast\-reroute configuration
                                        
                                        .. attribute:: fast_reroute_enable
                                        
                                        	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                        	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                        
                                        .. attribute:: per_link
                                        
                                        	Fast\-reroute per\-link configuration
                                        	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink>`
                                        
                                        .. attribute:: per_prefix
                                        
                                        	Fast\-reroute per\-link configuration
                                        	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute, self).__init__()

                                            self.yang_name = "fast-reroute"
                                            self.yang_parent_name = "interface"

                                            self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                            self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink()
                                            self.per_link.parent = self
                                            self._children_name_map["per_link"] = "per-link"
                                            self._children_yang_names.add("per-link")

                                            self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix()
                                            self.per_prefix.parent = self
                                            self._children_name_map["per_prefix"] = "per-prefix"
                                            self._children_yang_names.add("per-prefix")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_enable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute, self).__setattr__(name, value)


                                        class PerLink(Entity):
                                            """
                                            Fast\-reroute per\-link configuration
                                            
                                            .. attribute:: candidate_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                            	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces>`
                                            
                                            .. attribute:: exclude_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces>`
                                            
                                            .. attribute:: fast_reroute_use_candidate_only
                                            
                                            	Use only interfaces on the candidate list as a backup path
                                            	**type**\:  bool
                                            
                                            	**default value**\: false
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink, self).__init__()

                                                self.yang_name = "per-link"
                                                self.yang_parent_name = "fast-reroute"

                                                self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                                self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                self._children_yang_names.add("candidate-interfaces")

                                                self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                self._children_yang_names.add("exclude-interfaces")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)


                                            class CandidateInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix candidate
                                                interface configuration
                                                
                                                .. attribute:: candidate_interface
                                                
                                                	Candidate backup interface
                                                	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                                    self.yang_name = "candidate-interfaces"
                                                    self.yang_parent_name = "per-link"

                                                    self.candidate_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                                class CandidateInterface(Entity):
                                                    """
                                                    Candidate backup interface
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                        self.yang_name = "candidate-interface"
                                                        self.yang_parent_name = "candidate-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "candidate-interface"):
                                                        for c in self.candidate_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.candidate_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "candidate-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass


                                            class ExcludeInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix exclude
                                                interface configuration
                                                
                                                .. attribute:: exclude_interface
                                                
                                                	Exclude an interface from becoming a backup
                                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                                    self.yang_name = "exclude-interfaces"
                                                    self.yang_parent_name = "per-link"

                                                    self.exclude_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                                class ExcludeInterface(Entity):
                                                    """
                                                    Exclude an interface from becoming a backup
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                        self.yang_name = "exclude-interface"
                                                        self.yang_parent_name = "exclude-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "exclude-interface"):
                                                        for c in self.exclude_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.exclude_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "exclude-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    self.fast_reroute_use_candidate_only.is_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "per-link" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interfaces"):
                                                    if (self.candidate_interfaces is None):
                                                        self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                                        self.candidate_interfaces.parent = self
                                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                    return self.candidate_interfaces

                                                if (child_yang_name == "exclude-interfaces"):
                                                    if (self.exclude_interfaces is None):
                                                        self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                                        self.exclude_interfaces.parent = self
                                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                    return self.exclude_interfaces

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "fast-reroute-use-candidate-only"):
                                                    self.fast_reroute_use_candidate_only = value
                                                    self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                    self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                        class PerPrefix(Entity):
                                            """
                                            Fast\-reroute per\-link configuration
                                            
                                            .. attribute:: candidate_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                            	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces>`
                                            
                                            .. attribute:: exclude_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces>`
                                            
                                            .. attribute:: fast_reroute_use_candidate_only
                                            
                                            	Use only interfaces on the candidate list as a backup path
                                            	**type**\:  bool
                                            
                                            	**default value**\: false
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix, self).__init__()

                                                self.yang_name = "per-prefix"
                                                self.yang_parent_name = "fast-reroute"

                                                self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                                self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                self._children_yang_names.add("candidate-interfaces")

                                                self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                self._children_yang_names.add("exclude-interfaces")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)


                                            class CandidateInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix candidate
                                                interface configuration
                                                
                                                .. attribute:: candidate_interface
                                                
                                                	Candidate backup interface
                                                	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                                    self.yang_name = "candidate-interfaces"
                                                    self.yang_parent_name = "per-prefix"

                                                    self.candidate_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                                class CandidateInterface(Entity):
                                                    """
                                                    Candidate backup interface
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                        self.yang_name = "candidate-interface"
                                                        self.yang_parent_name = "candidate-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "candidate-interface"):
                                                        for c in self.candidate_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.candidate_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "candidate-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass


                                            class ExcludeInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix exclude
                                                interface configuration
                                                
                                                .. attribute:: exclude_interface
                                                
                                                	Exclude an interface from becoming a backup
                                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                                    self.yang_name = "exclude-interfaces"
                                                    self.yang_parent_name = "per-prefix"

                                                    self.exclude_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                                class ExcludeInterface(Entity):
                                                    """
                                                    Exclude an interface from becoming a backup
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                        self.yang_name = "exclude-interface"
                                                        self.yang_parent_name = "exclude-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "exclude-interface"):
                                                        for c in self.exclude_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.exclude_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "exclude-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    self.fast_reroute_use_candidate_only.is_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "per-prefix" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interfaces"):
                                                    if (self.candidate_interfaces is None):
                                                        self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                                        self.candidate_interfaces.parent = self
                                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                    return self.candidate_interfaces

                                                if (child_yang_name == "exclude-interfaces"):
                                                    if (self.exclude_interfaces is None):
                                                        self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                                        self.exclude_interfaces.parent = self
                                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                    return self.exclude_interfaces

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "fast-reroute-use-candidate-only"):
                                                    self.fast_reroute_use_candidate_only = value
                                                    self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                    self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_enable.is_set or
                                                (self.per_link is not None and self.per_link.has_data()) or
                                                (self.per_prefix is not None and self.per_prefix.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_enable.yfilter != YFilter.not_set or
                                                (self.per_link is not None and self.per_link.has_operation()) or
                                                (self.per_prefix is not None and self.per_prefix.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fast-reroute" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "per-link"):
                                                if (self.per_link is None):
                                                    self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerLink()
                                                    self.per_link.parent = self
                                                    self._children_name_map["per_link"] = "per-link"
                                                return self.per_link

                                            if (child_yang_name == "per-prefix"):
                                                if (self.per_prefix is None):
                                                    self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute.PerPrefix()
                                                    self.per_prefix.parent = self
                                                    self._children_name_map["per_prefix"] = "per-prefix"
                                                return self.per_prefix

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-enable"):
                                                self.fast_reroute_enable = value
                                                self.fast_reroute_enable.value_namespace = name_space
                                                self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.interface_name.is_set or
                                            self.cost.is_set or
                                            self.dead_interval.is_set or
                                            self.demand_circuit.is_set or
                                            self.enable.is_set or
                                            self.flood_reduction.is_set or
                                            self.hello_interval.is_set or
                                            self.instance.is_set or
                                            self.ldp_sync.is_set or
                                            self.mtu_ignore.is_set or
                                            self.network.is_set or
                                            self.packet_size.is_set or
                                            self.passive.is_set or
                                            self.prefix_suppression.is_set or
                                            self.priority.is_set or
                                            self.retransmit_interval.is_set or
                                            self.transmit_delay.is_set or
                                            (self.authentication is not None and self.authentication.has_data()) or
                                            (self.bfd is not None and self.bfd.has_data()) or
                                            (self.database_filter is not None and self.database_filter.has_data()) or
                                            (self.distribute_list is not None and self.distribute_list.has_data()) or
                                            (self.encryption is not None and self.encryption.has_data()) or
                                            (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                                            (self.neighbors is not None and self.neighbors.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set or
                                            self.dead_interval.yfilter != YFilter.not_set or
                                            self.demand_circuit.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.flood_reduction.yfilter != YFilter.not_set or
                                            self.hello_interval.yfilter != YFilter.not_set or
                                            self.instance.yfilter != YFilter.not_set or
                                            self.ldp_sync.yfilter != YFilter.not_set or
                                            self.mtu_ignore.yfilter != YFilter.not_set or
                                            self.network.yfilter != YFilter.not_set or
                                            self.packet_size.yfilter != YFilter.not_set or
                                            self.passive.yfilter != YFilter.not_set or
                                            self.prefix_suppression.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.retransmit_interval.yfilter != YFilter.not_set or
                                            self.transmit_delay.yfilter != YFilter.not_set or
                                            (self.authentication is not None and self.authentication.has_operation()) or
                                            (self.bfd is not None and self.bfd.has_operation()) or
                                            (self.database_filter is not None and self.database_filter.has_operation()) or
                                            (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                            (self.encryption is not None and self.encryption.has_operation()) or
                                            (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                                            (self.neighbors is not None and self.neighbors.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())
                                        if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                        if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                        if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.instance.get_name_leafdata())
                                        if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                                        if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                        if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.network.get_name_leafdata())
                                        if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.packet_size.get_name_leafdata())
                                        if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.passive.get_name_leafdata())
                                        if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                        if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "authentication"):
                                            if (self.authentication is None):
                                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Authentication()
                                                self.authentication.parent = self
                                                self._children_name_map["authentication"] = "authentication"
                                            return self.authentication

                                        if (child_yang_name == "bfd"):
                                            if (self.bfd is None):
                                                self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Bfd()
                                                self.bfd.parent = self
                                                self._children_name_map["bfd"] = "bfd"
                                            return self.bfd

                                        if (child_yang_name == "database-filter"):
                                            if (self.database_filter is None):
                                                self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DatabaseFilter()
                                                self.database_filter.parent = self
                                                self._children_name_map["database_filter"] = "database-filter"
                                            return self.database_filter

                                        if (child_yang_name == "distribute-list"):
                                            if (self.distribute_list is None):
                                                self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.DistributeList()
                                                self.distribute_list.parent = self
                                                self._children_name_map["distribute_list"] = "distribute-list"
                                            return self.distribute_list

                                        if (child_yang_name == "encryption"):
                                            if (self.encryption is None):
                                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Encryption()
                                                self.encryption.parent = self
                                                self._children_name_map["encryption"] = "encryption"
                                            return self.encryption

                                        if (child_yang_name == "fast-reroute"):
                                            if (self.fast_reroute is None):
                                                self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.FastReroute()
                                                self.fast_reroute.parent = self
                                                self._children_name_map["fast_reroute"] = "fast-reroute"
                                            return self.fast_reroute

                                        if (child_yang_name == "neighbors"):
                                            if (self.neighbors is None):
                                                self.neighbors = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface.Neighbors()
                                                self.neighbors.parent = self
                                                self._children_name_map["neighbors"] = "neighbors"
                                            return self.neighbors

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "fast-reroute" or name == "neighbors" or name == "interface-name" or name == "cost" or name == "dead-interval" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "transmit-delay"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dead-interval"):
                                            self.dead_interval = value
                                            self.dead_interval.value_namespace = name_space
                                            self.dead_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "demand-circuit"):
                                            self.demand_circuit = value
                                            self.demand_circuit.value_namespace = name_space
                                            self.demand_circuit.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "flood-reduction"):
                                            self.flood_reduction = value
                                            self.flood_reduction.value_namespace = name_space
                                            self.flood_reduction.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hello-interval"):
                                            self.hello_interval = value
                                            self.hello_interval.value_namespace = name_space
                                            self.hello_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "instance"):
                                            self.instance = value
                                            self.instance.value_namespace = name_space
                                            self.instance.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ldp-sync"):
                                            self.ldp_sync = value
                                            self.ldp_sync.value_namespace = name_space
                                            self.ldp_sync.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mtu-ignore"):
                                            self.mtu_ignore = value
                                            self.mtu_ignore.value_namespace = name_space
                                            self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                        if(value_path == "network"):
                                            self.network = value
                                            self.network.value_namespace = name_space
                                            self.network.value_namespace_prefix = name_space_prefix
                                        if(value_path == "packet-size"):
                                            self.packet_size = value
                                            self.packet_size.value_namespace = name_space
                                            self.packet_size.value_namespace_prefix = name_space_prefix
                                        if(value_path == "passive"):
                                            self.passive = value
                                            self.passive.value_namespace = name_space
                                            self.passive.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-suppression"):
                                            self.prefix_suppression = value
                                            self.prefix_suppression.value_namespace = name_space
                                            self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retransmit-interval"):
                                            self.retransmit_interval = value
                                            self.retransmit_interval.value_namespace = name_space
                                            self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-delay"):
                                            self.transmit_delay = value
                                            self.transmit_delay.value_namespace = name_space
                                            self.transmit_delay.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "interface"):
                                        for c in self.interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces.Interface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class AreaScope(Entity):
                                """
                                Area Scope Configuration
                                
                                .. attribute:: fast_reroute
                                
                                	Fast\-reroute configuration
                                	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope, self).__init__()

                                    self.yang_name = "area-scope"
                                    self.yang_parent_name = "area-address"

                                    self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                    self._children_yang_names.add("fast-reroute")


                                class FastReroute(Entity):
                                    """
                                    Fast\-reroute configuration
                                    
                                    .. attribute:: fast_reroute_enable
                                    
                                    	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                    	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                    
                                    .. attribute:: per_link
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink>`
                                    
                                    .. attribute:: per_prefix
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute, self).__init__()

                                        self.yang_name = "fast-reroute"
                                        self.yang_parent_name = "area-scope"

                                        self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                        self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink()
                                        self.per_link.parent = self
                                        self._children_name_map["per_link"] = "per-link"
                                        self._children_yang_names.add("per-link")

                                        self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix()
                                        self.per_prefix.parent = self
                                        self._children_name_map["per_prefix"] = "per-prefix"
                                        self._children_yang_names.add("per-prefix")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_enable") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute, self).__setattr__(name, value)


                                    class PerLink(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink, self).__init__()

                                            self.yang_name = "per-link"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-link" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                    class PerPrefix(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix, self).__init__()

                                            self.yang_name = "per-prefix"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-prefix" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_enable.is_set or
                                            (self.per_link is not None and self.per_link.has_data()) or
                                            (self.per_prefix is not None and self.per_prefix.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_enable.yfilter != YFilter.not_set or
                                            (self.per_link is not None and self.per_link.has_operation()) or
                                            (self.per_prefix is not None and self.per_prefix.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fast-reroute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "per-link"):
                                            if (self.per_link is None):
                                                self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerLink()
                                                self.per_link.parent = self
                                                self._children_name_map["per_link"] = "per-link"
                                            return self.per_link

                                        if (child_yang_name == "per-prefix"):
                                            if (self.per_prefix is None):
                                                self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute.PerPrefix()
                                                self.per_prefix.parent = self
                                                self._children_name_map["per_prefix"] = "per-prefix"
                                            return self.per_prefix

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-enable"):
                                            self.fast_reroute_enable = value
                                            self.fast_reroute_enable.value_namespace = name_space
                                            self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.fast_reroute is not None and self.fast_reroute.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.fast_reroute is not None and self.fast_reroute.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "area-scope" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "fast-reroute"):
                                        if (self.fast_reroute is None):
                                            self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope.FastReroute()
                                            self.fast_reroute.parent = self
                                            self._children_name_map["fast_reroute"] = "fast-reroute"
                                        return self.fast_reroute

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fast-reroute"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class ShamLinks(Entity):
                                """
                                Sham Link sub\-mode
                                
                                .. attribute:: sham_link
                                
                                	ShamLink local and remote endpoints
                                	**type**\: list of    :py:class:`ShamLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks, self).__init__()

                                    self.yang_name = "sham-links"
                                    self.yang_parent_name = "area-address"

                                    self.sham_link = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks, self).__setattr__(name, value)


                                class ShamLink(Entity):
                                    """
                                    ShamLink local and remote endpoints
                                    
                                    .. attribute:: source_address  <key>
                                    
                                    	Local sham\-link endpoint
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: destination_address  <key>
                                    
                                    	Remote sham\-link endpoint
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: authentication
                                    
                                    	Authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication>`
                                    
                                    .. attribute:: dead_interval
                                    
                                    	Interval after which a neighbor is declared dead (in seconds)
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: enable
                                    
                                    	Enable sham link
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: encryption
                                    
                                    	Encrypt and authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption>`
                                    
                                    .. attribute:: hello_interval
                                    
                                    	Time between HELLO packets
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: retransmit_interval
                                    
                                    	Specify the transmit interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: transmit_delay
                                    
                                    	Specify the transmit delay in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink, self).__init__()

                                        self.yang_name = "sham-link"
                                        self.yang_parent_name = "sham-links"

                                        self.source_address = YLeaf(YType.str, "source-address")

                                        self.destination_address = YLeaf(YType.str, "destination-address")

                                        self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                        self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                        self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                        self._children_yang_names.add("authentication")

                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                        self._children_yang_names.add("encryption")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("source_address",
                                                        "destination_address",
                                                        "dead_interval",
                                                        "enable",
                                                        "hello_interval",
                                                        "retransmit_interval",
                                                        "transmit_delay") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink, self).__setattr__(name, value)


                                    class Authentication(Entity):
                                        """
                                        Authenticate OSPFv3 packets
                                        
                                        .. attribute:: algorithm
                                        
                                        	Use the MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication, self).__init__()

                                            self.yang_name = "authentication"
                                            self.yang_parent_name = "sham-link"

                                            self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.password = YLeaf(YType.str, "password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("algorithm",
                                                            "enable",
                                                            "password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.algorithm.is_set or
                                                self.enable.is_set or
                                                self.password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.algorithm.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "authentication" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.algorithm.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "algorithm"):
                                                self.algorithm = value
                                                self.algorithm.value_namespace = name_space
                                                self.algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "password"):
                                                self.password = value
                                                self.password.value_namespace = name_space
                                                self.password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Encryption(Entity):
                                        """
                                        Encrypt and authenticate OSPFv3 packets
                                        
                                        .. attribute:: authentication_algorithm
                                        
                                        	Use the NULL, MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                        
                                        .. attribute:: authentication_password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: encryption_algorithm
                                        
                                        	Specify the encryption algorithm
                                        	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                        
                                        .. attribute:: encryption_password
                                        
                                        	Encryption password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption, self).__init__()

                                            self.yang_name = "encryption"
                                            self.yang_parent_name = "sham-link"

                                            self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                            self.authentication_password = YLeaf(YType.str, "authentication-password")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                            self.encryption_password = YLeaf(YType.str, "encryption-password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("authentication_algorithm",
                                                            "authentication_password",
                                                            "enable",
                                                            "encryption_algorithm",
                                                            "encryption_password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.authentication_algorithm.is_set or
                                                self.authentication_password.is_set or
                                                self.enable.is_set or
                                                self.encryption_algorithm.is_set or
                                                self.encryption_password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.authentication_algorithm.yfilter != YFilter.not_set or
                                                self.authentication_password.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.encryption_algorithm.yfilter != YFilter.not_set or
                                                self.encryption_password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "encryption" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                            if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                            if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "authentication-algorithm"):
                                                self.authentication_algorithm = value
                                                self.authentication_algorithm.value_namespace = name_space
                                                self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "authentication-password"):
                                                self.authentication_password = value
                                                self.authentication_password.value_namespace = name_space
                                                self.authentication_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-algorithm"):
                                                self.encryption_algorithm = value
                                                self.encryption_algorithm.value_namespace = name_space
                                                self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-password"):
                                                self.encryption_password = value
                                                self.encryption_password.value_namespace = name_space
                                                self.encryption_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.source_address.is_set or
                                            self.destination_address.is_set or
                                            self.dead_interval.is_set or
                                            self.enable.is_set or
                                            self.hello_interval.is_set or
                                            self.retransmit_interval.is_set or
                                            self.transmit_delay.is_set or
                                            (self.authentication is not None and self.authentication.has_data()) or
                                            (self.encryption is not None and self.encryption.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.source_address.yfilter != YFilter.not_set or
                                            self.destination_address.yfilter != YFilter.not_set or
                                            self.dead_interval.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hello_interval.yfilter != YFilter.not_set or
                                            self.retransmit_interval.yfilter != YFilter.not_set or
                                            self.transmit_delay.yfilter != YFilter.not_set or
                                            (self.authentication is not None and self.authentication.has_operation()) or
                                            (self.encryption is not None and self.encryption.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "sham-link" + "[source-address='" + self.source_address.get() + "']" + "[destination-address='" + self.destination_address.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.source_address.get_name_leafdata())
                                        if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.destination_address.get_name_leafdata())
                                        if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                        if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                        if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "authentication"):
                                            if (self.authentication is None):
                                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Authentication()
                                                self.authentication.parent = self
                                                self._children_name_map["authentication"] = "authentication"
                                            return self.authentication

                                        if (child_yang_name == "encryption"):
                                            if (self.encryption is None):
                                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink.Encryption()
                                                self.encryption.parent = self
                                                self._children_name_map["encryption"] = "encryption"
                                            return self.encryption

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication" or name == "encryption" or name == "source-address" or name == "destination-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "source-address"):
                                            self.source_address = value
                                            self.source_address.value_namespace = name_space
                                            self.source_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "destination-address"):
                                            self.destination_address = value
                                            self.destination_address.value_namespace = name_space
                                            self.destination_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dead-interval"):
                                            self.dead_interval = value
                                            self.dead_interval.value_namespace = name_space
                                            self.dead_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hello-interval"):
                                            self.hello_interval = value
                                            self.hello_interval.value_namespace = name_space
                                            self.hello_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retransmit-interval"):
                                            self.retransmit_interval = value
                                            self.retransmit_interval.value_namespace = name_space
                                            self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-delay"):
                                            self.transmit_delay = value
                                            self.transmit_delay.value_namespace = name_space
                                            self.transmit_delay.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.sham_link:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.sham_link:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sham-links" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "sham-link"):
                                        for c in self.sham_link:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks.ShamLink()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.sham_link.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "sham-link"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class VirtualLinks(Entity):
                                """
                                Virtual link sub\-mode
                                
                                .. attribute:: virtual_link
                                
                                	Router ID of virtual link neighbor
                                	**type**\: list of    :py:class:`VirtualLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks, self).__init__()

                                    self.yang_name = "virtual-links"
                                    self.yang_parent_name = "area-address"

                                    self.virtual_link = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks, self).__setattr__(name, value)


                                class VirtualLink(Entity):
                                    """
                                    Router ID of virtual link neighbor
                                    
                                    .. attribute:: virtual_link_address  <key>
                                    
                                    	Router ID of virtual link neighbor
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: authentication
                                    
                                    	Authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication>`
                                    
                                    .. attribute:: dead_interval
                                    
                                    	Interval after which a neighbor is declared dead (in seconds)
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: enable
                                    
                                    	Enabled virtual link
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: encryption
                                    
                                    	Encrypt and authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption>`
                                    
                                    .. attribute:: hello_interval
                                    
                                    	Time between HELLO packets
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: retransmit_interval
                                    
                                    	Specify the transmit interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: transmit_delay
                                    
                                    	Specify the transmit delay in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink, self).__init__()

                                        self.yang_name = "virtual-link"
                                        self.yang_parent_name = "virtual-links"

                                        self.virtual_link_address = YLeaf(YType.str, "virtual-link-address")

                                        self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                        self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                        self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                        self._children_yang_names.add("authentication")

                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                        self._children_yang_names.add("encryption")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("virtual_link_address",
                                                        "dead_interval",
                                                        "enable",
                                                        "hello_interval",
                                                        "retransmit_interval",
                                                        "transmit_delay") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink, self).__setattr__(name, value)


                                    class Authentication(Entity):
                                        """
                                        Authenticate OSPFv3 packets
                                        
                                        .. attribute:: algorithm
                                        
                                        	Use the MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication, self).__init__()

                                            self.yang_name = "authentication"
                                            self.yang_parent_name = "virtual-link"

                                            self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.password = YLeaf(YType.str, "password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("algorithm",
                                                            "enable",
                                                            "password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.algorithm.is_set or
                                                self.enable.is_set or
                                                self.password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.algorithm.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "authentication" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.algorithm.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "algorithm"):
                                                self.algorithm = value
                                                self.algorithm.value_namespace = name_space
                                                self.algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "password"):
                                                self.password = value
                                                self.password.value_namespace = name_space
                                                self.password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Encryption(Entity):
                                        """
                                        Encrypt and authenticate OSPFv3 packets
                                        
                                        .. attribute:: authentication_algorithm
                                        
                                        	Use the NULL, MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                        
                                        .. attribute:: authentication_password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: encryption_algorithm
                                        
                                        	Specify the encryption algorithm
                                        	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                        
                                        .. attribute:: encryption_password
                                        
                                        	Encryption password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption, self).__init__()

                                            self.yang_name = "encryption"
                                            self.yang_parent_name = "virtual-link"

                                            self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                            self.authentication_password = YLeaf(YType.str, "authentication-password")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                            self.encryption_password = YLeaf(YType.str, "encryption-password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("authentication_algorithm",
                                                            "authentication_password",
                                                            "enable",
                                                            "encryption_algorithm",
                                                            "encryption_password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.authentication_algorithm.is_set or
                                                self.authentication_password.is_set or
                                                self.enable.is_set or
                                                self.encryption_algorithm.is_set or
                                                self.encryption_password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.authentication_algorithm.yfilter != YFilter.not_set or
                                                self.authentication_password.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.encryption_algorithm.yfilter != YFilter.not_set or
                                                self.encryption_password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "encryption" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                            if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                            if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "authentication-algorithm"):
                                                self.authentication_algorithm = value
                                                self.authentication_algorithm.value_namespace = name_space
                                                self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "authentication-password"):
                                                self.authentication_password = value
                                                self.authentication_password.value_namespace = name_space
                                                self.authentication_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-algorithm"):
                                                self.encryption_algorithm = value
                                                self.encryption_algorithm.value_namespace = name_space
                                                self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-password"):
                                                self.encryption_password = value
                                                self.encryption_password.value_namespace = name_space
                                                self.encryption_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.virtual_link_address.is_set or
                                            self.dead_interval.is_set or
                                            self.enable.is_set or
                                            self.hello_interval.is_set or
                                            self.retransmit_interval.is_set or
                                            self.transmit_delay.is_set or
                                            (self.authentication is not None and self.authentication.has_data()) or
                                            (self.encryption is not None and self.encryption.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.virtual_link_address.yfilter != YFilter.not_set or
                                            self.dead_interval.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hello_interval.yfilter != YFilter.not_set or
                                            self.retransmit_interval.yfilter != YFilter.not_set or
                                            self.transmit_delay.yfilter != YFilter.not_set or
                                            (self.authentication is not None and self.authentication.has_operation()) or
                                            (self.encryption is not None and self.encryption.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "virtual-link" + "[virtual-link-address='" + self.virtual_link_address.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.virtual_link_address.is_set or self.virtual_link_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_link_address.get_name_leafdata())
                                        if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                        if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                        if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "authentication"):
                                            if (self.authentication is None):
                                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Authentication()
                                                self.authentication.parent = self
                                                self._children_name_map["authentication"] = "authentication"
                                            return self.authentication

                                        if (child_yang_name == "encryption"):
                                            if (self.encryption is None):
                                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink.Encryption()
                                                self.encryption.parent = self
                                                self._children_name_map["encryption"] = "encryption"
                                            return self.encryption

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication" or name == "encryption" or name == "virtual-link-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "virtual-link-address"):
                                            self.virtual_link_address = value
                                            self.virtual_link_address.value_namespace = name_space
                                            self.virtual_link_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dead-interval"):
                                            self.dead_interval = value
                                            self.dead_interval.value_namespace = name_space
                                            self.dead_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hello-interval"):
                                            self.hello_interval = value
                                            self.hello_interval.value_namespace = name_space
                                            self.hello_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retransmit-interval"):
                                            self.retransmit_interval = value
                                            self.retransmit_interval.value_namespace = name_space
                                            self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-delay"):
                                            self.transmit_delay = value
                                            self.transmit_delay.value_namespace = name_space
                                            self.transmit_delay.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.virtual_link:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.virtual_link:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "virtual-links" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "virtual-link"):
                                        for c in self.virtual_link:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks.VirtualLink()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.virtual_link.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "virtual-link"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.address.is_set or
                                    self.cost.is_set or
                                    self.dead_interval.is_set or
                                    self.default_cost.is_set or
                                    self.demand_circuit.is_set or
                                    self.enable.is_set or
                                    self.flood_reduction.is_set or
                                    self.hello_interval.is_set or
                                    self.instance.is_set or
                                    self.ldp_sync.is_set or
                                    self.mtu_ignore.is_set or
                                    self.network.is_set or
                                    self.packet_size.is_set or
                                    self.passive.is_set or
                                    self.prefix_suppression.is_set or
                                    self.priority.is_set or
                                    self.retransmit_interval.is_set or
                                    self.stub.is_set or
                                    self.transmit_delay.is_set or
                                    (self.area_scope is not None and self.area_scope.has_data()) or
                                    (self.authentication is not None and self.authentication.has_data()) or
                                    (self.bfd is not None and self.bfd.has_data()) or
                                    (self.database_filter is not None and self.database_filter.has_data()) or
                                    (self.distribute_list is not None and self.distribute_list.has_data()) or
                                    (self.encryption is not None and self.encryption.has_data()) or
                                    (self.interfaces is not None and self.interfaces.has_data()) or
                                    (self.nssa is not None and self.nssa.has_data()) or
                                    (self.ranges is not None and self.ranges.has_data()) or
                                    (self.sham_links is not None and self.sham_links.has_data()) or
                                    (self.virtual_links is not None and self.virtual_links.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.cost.yfilter != YFilter.not_set or
                                    self.dead_interval.yfilter != YFilter.not_set or
                                    self.default_cost.yfilter != YFilter.not_set or
                                    self.demand_circuit.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.flood_reduction.yfilter != YFilter.not_set or
                                    self.hello_interval.yfilter != YFilter.not_set or
                                    self.instance.yfilter != YFilter.not_set or
                                    self.ldp_sync.yfilter != YFilter.not_set or
                                    self.mtu_ignore.yfilter != YFilter.not_set or
                                    self.network.yfilter != YFilter.not_set or
                                    self.packet_size.yfilter != YFilter.not_set or
                                    self.passive.yfilter != YFilter.not_set or
                                    self.prefix_suppression.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    self.retransmit_interval.yfilter != YFilter.not_set or
                                    self.stub.yfilter != YFilter.not_set or
                                    self.transmit_delay.yfilter != YFilter.not_set or
                                    (self.area_scope is not None and self.area_scope.has_operation()) or
                                    (self.authentication is not None and self.authentication.has_operation()) or
                                    (self.bfd is not None and self.bfd.has_operation()) or
                                    (self.database_filter is not None and self.database_filter.has_operation()) or
                                    (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                    (self.encryption is not None and self.encryption.has_operation()) or
                                    (self.interfaces is not None and self.interfaces.has_operation()) or
                                    (self.nssa is not None and self.nssa.has_operation()) or
                                    (self.ranges is not None and self.ranges.has_operation()) or
                                    (self.sham_links is not None and self.sham_links.has_operation()) or
                                    (self.virtual_links is not None and self.virtual_links.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "area-address" + "[address='" + self.address.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cost.get_name_leafdata())
                                if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                if (self.default_cost.is_set or self.default_cost.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_cost.get_name_leafdata())
                                if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                                if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.instance.get_name_leafdata())
                                if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                                if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.network.get_name_leafdata())
                                if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.packet_size.get_name_leafdata())
                                if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.passive.get_name_leafdata())
                                if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                if (self.stub.is_set or self.stub.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stub.get_name_leafdata())
                                if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "area-scope"):
                                    if (self.area_scope is None):
                                        self.area_scope = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.AreaScope()
                                        self.area_scope.parent = self
                                        self._children_name_map["area_scope"] = "area-scope"
                                    return self.area_scope

                                if (child_yang_name == "authentication"):
                                    if (self.authentication is None):
                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                    return self.authentication

                                if (child_yang_name == "bfd"):
                                    if (self.bfd is None):
                                        self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Bfd()
                                        self.bfd.parent = self
                                        self._children_name_map["bfd"] = "bfd"
                                    return self.bfd

                                if (child_yang_name == "database-filter"):
                                    if (self.database_filter is None):
                                        self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DatabaseFilter()
                                        self.database_filter.parent = self
                                        self._children_name_map["database_filter"] = "database-filter"
                                    return self.database_filter

                                if (child_yang_name == "distribute-list"):
                                    if (self.distribute_list is None):
                                        self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.DistributeList()
                                        self.distribute_list.parent = self
                                        self._children_name_map["distribute_list"] = "distribute-list"
                                    return self.distribute_list

                                if (child_yang_name == "encryption"):
                                    if (self.encryption is None):
                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                    return self.encryption

                                if (child_yang_name == "interfaces"):
                                    if (self.interfaces is None):
                                        self.interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Interfaces()
                                        self.interfaces.parent = self
                                        self._children_name_map["interfaces"] = "interfaces"
                                    return self.interfaces

                                if (child_yang_name == "nssa"):
                                    if (self.nssa is None):
                                        self.nssa = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Nssa()
                                        self.nssa.parent = self
                                        self._children_name_map["nssa"] = "nssa"
                                    return self.nssa

                                if (child_yang_name == "ranges"):
                                    if (self.ranges is None):
                                        self.ranges = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.Ranges()
                                        self.ranges.parent = self
                                        self._children_name_map["ranges"] = "ranges"
                                    return self.ranges

                                if (child_yang_name == "sham-links"):
                                    if (self.sham_links is None):
                                        self.sham_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.ShamLinks()
                                        self.sham_links.parent = self
                                        self._children_name_map["sham_links"] = "sham-links"
                                    return self.sham_links

                                if (child_yang_name == "virtual-links"):
                                    if (self.virtual_links is None):
                                        self.virtual_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress.VirtualLinks()
                                        self.virtual_links.parent = self
                                        self._children_name_map["virtual_links"] = "virtual-links"
                                    return self.virtual_links

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area-scope" or name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "interfaces" or name == "nssa" or name == "ranges" or name == "sham-links" or name == "virtual-links" or name == "address" or name == "cost" or name == "dead-interval" or name == "default-cost" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "stub" or name == "transmit-delay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "cost"):
                                    self.cost = value
                                    self.cost.value_namespace = name_space
                                    self.cost.value_namespace_prefix = name_space_prefix
                                if(value_path == "dead-interval"):
                                    self.dead_interval = value
                                    self.dead_interval.value_namespace = name_space
                                    self.dead_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-cost"):
                                    self.default_cost = value
                                    self.default_cost.value_namespace = name_space
                                    self.default_cost.value_namespace_prefix = name_space_prefix
                                if(value_path == "demand-circuit"):
                                    self.demand_circuit = value
                                    self.demand_circuit.value_namespace = name_space
                                    self.demand_circuit.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "flood-reduction"):
                                    self.flood_reduction = value
                                    self.flood_reduction.value_namespace = name_space
                                    self.flood_reduction.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-interval"):
                                    self.hello_interval = value
                                    self.hello_interval.value_namespace = name_space
                                    self.hello_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "instance"):
                                    self.instance = value
                                    self.instance.value_namespace = name_space
                                    self.instance.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-sync"):
                                    self.ldp_sync = value
                                    self.ldp_sync.value_namespace = name_space
                                    self.ldp_sync.value_namespace_prefix = name_space_prefix
                                if(value_path == "mtu-ignore"):
                                    self.mtu_ignore = value
                                    self.mtu_ignore.value_namespace = name_space
                                    self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                if(value_path == "network"):
                                    self.network = value
                                    self.network.value_namespace = name_space
                                    self.network.value_namespace_prefix = name_space_prefix
                                if(value_path == "packet-size"):
                                    self.packet_size = value
                                    self.packet_size.value_namespace = name_space
                                    self.packet_size.value_namespace_prefix = name_space_prefix
                                if(value_path == "passive"):
                                    self.passive = value
                                    self.passive.value_namespace = name_space
                                    self.passive.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-suppression"):
                                    self.prefix_suppression = value
                                    self.prefix_suppression.value_namespace = name_space
                                    self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "retransmit-interval"):
                                    self.retransmit_interval = value
                                    self.retransmit_interval.value_namespace = name_space
                                    self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "stub"):
                                    self.stub = value
                                    self.stub.value_namespace = name_space
                                    self.stub.value_namespace_prefix = name_space_prefix
                                if(value_path == "transmit-delay"):
                                    self.transmit_delay = value
                                    self.transmit_delay.value_namespace = name_space
                                    self.transmit_delay.value_namespace_prefix = name_space_prefix


                        class AreaAreaId(Entity):
                            """
                            Configuration for a particular area
                            
                            .. attribute:: area_id  <key>
                            
                            	Area ID if in integer format
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: area_scope
                            
                            	Area Scope Configuration
                            	**type**\:   :py:class:`AreaScope <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope>`
                            
                            .. attribute:: authentication
                            
                            	Authenticate OSPFv3 packets
                            	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Authentication>`
                            
                            .. attribute:: bfd
                            
                            	Configure BFD parameters
                            	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Bfd>`
                            
                            .. attribute:: cost
                            
                            	Interface cost
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            .. attribute:: database_filter
                            
                            	Database filter
                            	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter>`
                            
                            .. attribute:: dead_interval
                            
                            	Interval after which a neighbor is declared dead (in seconds)
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: default_cost
                            
                            	Set the summary default\-cost of a NSSA/stub area
                            	**type**\:  int
                            
                            	**range:** 0..16777215
                            
                            .. attribute:: demand_circuit
                            
                            	Enable/disable demand circuit operation
                            	**type**\:  bool
                            
                            .. attribute:: distribute_list
                            
                            	Filter prefixes to/from RIB
                            	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList>`
                            
                            .. attribute:: enable
                            
                            	Enable OSPFv3 area
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: encryption
                            
                            	Encrypt and authenticate OSPFv3 packets
                            	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Encryption>`
                            
                            .. attribute:: flood_reduction
                            
                            	Enable/disable flood reduction
                            	**type**\:  bool
                            
                            .. attribute:: hello_interval
                            
                            	Time between HELLO packets
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: instance
                            
                            	Instance ID
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: interfaces
                            
                            	OSPFv3 interfaces
                            	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces>`
                            
                            .. attribute:: ldp_sync
                            
                            	Enable/Disable MPLS LDP sync
                            	**type**\:  bool
                            
                            .. attribute:: mtu_ignore
                            
                            	Enable/disable ignoring of MTU in DBD packets
                            	**type**\:  bool
                            
                            .. attribute:: network
                            
                            	Specify network type
                            	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                            
                            .. attribute:: nssa
                            
                            	Specify area as a NSSA area.  Allowed only in non\-backbone areas
                            	**type**\:   :py:class:`Nssa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Nssa>`
                            
                            .. attribute:: packet_size
                            
                            	Limit size of OSPFv3 packets
                            	**type**\:  int
                            
                            	**range:** 256..10000
                            
                            .. attribute:: passive
                            
                            	Enable/disable routing updates on an interface
                            	**type**\:  bool
                            
                            .. attribute:: prefix_suppression
                            
                            	Enable/disable prefix suppression on an interface
                            	**type**\:  bool
                            
                            .. attribute:: priority
                            
                            	Specify router priority
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: ranges
                            
                            	Range configuration
                            	**type**\:   :py:class:`Ranges <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges>`
                            
                            .. attribute:: retransmit_interval
                            
                            	Specify the transmit interval in seconds
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: sham_links
                            
                            	Sham Link sub\-mode
                            	**type**\:   :py:class:`ShamLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks>`
                            
                            .. attribute:: stub
                            
                            	Specify area as a stub area.  Allowed only in non\-backbone areas
                            	**type**\:  bool
                            
                            .. attribute:: transmit_delay
                            
                            	Specify the transmit delay in seconds
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**units**\: second
                            
                            .. attribute:: virtual_links
                            
                            	Virtual link sub\-mode
                            	**type**\:   :py:class:`VirtualLinks <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId, self).__init__()

                                self.yang_name = "area-area-id"
                                self.yang_parent_name = "area-addresses"

                                self.area_id = YLeaf(YType.int32, "area-id")

                                self.cost = YLeaf(YType.uint32, "cost")

                                self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                self.default_cost = YLeaf(YType.uint32, "default-cost")

                                self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                self.instance = YLeaf(YType.uint32, "instance")

                                self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                                self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                self.network = YLeaf(YType.enumeration, "network")

                                self.packet_size = YLeaf(YType.uint32, "packet-size")

                                self.passive = YLeaf(YType.boolean, "passive")

                                self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                self.priority = YLeaf(YType.uint32, "priority")

                                self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                self.stub = YLeaf(YType.boolean, "stub")

                                self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                self.area_scope = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope()
                                self.area_scope.parent = self
                                self._children_name_map["area_scope"] = "area-scope"
                                self._children_yang_names.add("area-scope")

                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Authentication()
                                self.authentication.parent = self
                                self._children_name_map["authentication"] = "authentication"
                                self._children_yang_names.add("authentication")

                                self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Bfd()
                                self.bfd.parent = self
                                self._children_name_map["bfd"] = "bfd"
                                self._children_yang_names.add("bfd")

                                self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter()
                                self.database_filter.parent = self
                                self._children_name_map["database_filter"] = "database-filter"
                                self._children_yang_names.add("database-filter")

                                self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList()
                                self.distribute_list.parent = self
                                self._children_name_map["distribute_list"] = "distribute-list"
                                self._children_yang_names.add("distribute-list")

                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Encryption()
                                self.encryption.parent = self
                                self._children_name_map["encryption"] = "encryption"
                                self._children_yang_names.add("encryption")

                                self.interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces()
                                self.interfaces.parent = self
                                self._children_name_map["interfaces"] = "interfaces"
                                self._children_yang_names.add("interfaces")

                                self.nssa = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Nssa()
                                self.nssa.parent = self
                                self._children_name_map["nssa"] = "nssa"
                                self._children_yang_names.add("nssa")

                                self.ranges = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges()
                                self.ranges.parent = self
                                self._children_name_map["ranges"] = "ranges"
                                self._children_yang_names.add("ranges")

                                self.sham_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks()
                                self.sham_links.parent = self
                                self._children_name_map["sham_links"] = "sham-links"
                                self._children_yang_names.add("sham-links")

                                self.virtual_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks()
                                self.virtual_links.parent = self
                                self._children_name_map["virtual_links"] = "virtual-links"
                                self._children_yang_names.add("virtual-links")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area_id",
                                                "cost",
                                                "dead_interval",
                                                "default_cost",
                                                "demand_circuit",
                                                "enable",
                                                "flood_reduction",
                                                "hello_interval",
                                                "instance",
                                                "ldp_sync",
                                                "mtu_ignore",
                                                "network",
                                                "packet_size",
                                                "passive",
                                                "prefix_suppression",
                                                "priority",
                                                "retransmit_interval",
                                                "stub",
                                                "transmit_delay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId, self).__setattr__(name, value)


                            class Authentication(Entity):
                                """
                                Authenticate OSPFv3 packets
                                
                                .. attribute:: algorithm
                                
                                	Use the MD5 or SHA1 algorithm
                                	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                
                                .. attribute:: enable
                                
                                	Authenticate packets
                                	**type**\:  bool
                                
                                .. attribute:: password
                                
                                	Specify MD5 or SHA1 password
                                	**type**\:  str
                                
                                	**pattern:** (!.+)\|([^!].+)
                                
                                .. attribute:: spi
                                
                                	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                	**type**\:  int
                                
                                	**range:** 256..4294967295
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Authentication, self).__init__()

                                    self.yang_name = "authentication"
                                    self.yang_parent_name = "area-area-id"

                                    self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.password = YLeaf(YType.str, "password")

                                    self.spi = YLeaf(YType.uint32, "spi")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("algorithm",
                                                    "enable",
                                                    "password",
                                                    "spi") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Authentication, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Authentication, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.algorithm.is_set or
                                        self.enable.is_set or
                                        self.password.is_set or
                                        self.spi.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.algorithm.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.password.yfilter != YFilter.not_set or
                                        self.spi.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "authentication" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.algorithm.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.password.get_name_leafdata())
                                    if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.spi.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "algorithm"):
                                        self.algorithm = value
                                        self.algorithm.value_namespace = name_space
                                        self.algorithm.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "password"):
                                        self.password = value
                                        self.password.value_namespace = name_space
                                        self.password.value_namespace_prefix = name_space_prefix
                                    if(value_path == "spi"):
                                        self.spi = value
                                        self.spi.value_namespace = name_space
                                        self.spi.value_namespace_prefix = name_space_prefix


                            class Bfd(Entity):
                                """
                                Configure BFD parameters
                                
                                .. attribute:: detection_multiplier
                                
                                	Detect multiplier
                                	**type**\:  int
                                
                                	**range:** 2..50
                                
                                .. attribute:: fast_detect_mode
                                
                                	Enable or disable BFD fast detection
                                	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                                
                                .. attribute:: interval
                                
                                	Hello interval in milli\-seconds
                                	**type**\:  int
                                
                                	**range:** 3..30000
                                
                                	**units**\: millisecond
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Bfd, self).__init__()

                                    self.yang_name = "bfd"
                                    self.yang_parent_name = "area-area-id"

                                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                    self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                    self.interval = YLeaf(YType.uint32, "interval")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("detection_multiplier",
                                                    "fast_detect_mode",
                                                    "interval") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Bfd, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Bfd, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.detection_multiplier.is_set or
                                        self.fast_detect_mode.is_set or
                                        self.interval.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.detection_multiplier.yfilter != YFilter.not_set or
                                        self.fast_detect_mode.yfilter != YFilter.not_set or
                                        self.interval.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bfd" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                    if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interval.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "detection-multiplier"):
                                        self.detection_multiplier = value
                                        self.detection_multiplier.value_namespace = name_space
                                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fast-detect-mode"):
                                        self.fast_detect_mode = value
                                        self.fast_detect_mode.value_namespace = name_space
                                        self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interval"):
                                        self.interval = value
                                        self.interval.value_namespace = name_space
                                        self.interval.value_namespace_prefix = name_space_prefix


                            class Ranges(Entity):
                                """
                                Range configuration
                                
                                .. attribute:: range
                                
                                	Summarize inter\-area routes matching prefix/length
                                	**type**\: list of    :py:class:`Range <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges.Range>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges, self).__init__()

                                    self.yang_name = "ranges"
                                    self.yang_parent_name = "area-area-id"

                                    self.range = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges, self).__setattr__(name, value)


                                class Range(Entity):
                                    """
                                    Summarize inter\-area routes matching
                                    prefix/length
                                    
                                    .. attribute:: prefix  <key>
                                    
                                    	IPv6 prefix format
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: prefix_length  <key>
                                    
                                    	IPV6 prefix length
                                    	**type**\:  int
                                    
                                    	**range:** 0..128
                                    
                                    .. attribute:: cost
                                    
                                    	Specified metric for this range
                                    	**type**\:  int
                                    
                                    	**range:** 1..16777214
                                    
                                    .. attribute:: not_advertise
                                    
                                    	Do not advertise address range
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges.Range, self).__init__()

                                        self.yang_name = "range"
                                        self.yang_parent_name = "ranges"

                                        self.prefix = YLeaf(YType.str, "prefix")

                                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                        self.cost = YLeaf(YType.uint32, "cost")

                                        self.not_advertise = YLeaf(YType.boolean, "not-advertise")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("prefix",
                                                        "prefix_length",
                                                        "cost",
                                                        "not_advertise") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges.Range, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges.Range, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.prefix.is_set or
                                            self.prefix_length.is_set or
                                            self.cost.is_set or
                                            self.not_advertise.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.prefix.yfilter != YFilter.not_set or
                                            self.prefix_length.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set or
                                            self.not_advertise.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "range" + "[prefix='" + self.prefix.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())
                                        if (self.not_advertise.is_set or self.not_advertise.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.not_advertise.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "prefix" or name == "prefix-length" or name == "cost" or name == "not-advertise"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "prefix"):
                                            self.prefix = value
                                            self.prefix.value_namespace = name_space
                                            self.prefix.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-length"):
                                            self.prefix_length = value
                                            self.prefix_length.value_namespace = name_space
                                            self.prefix_length.value_namespace_prefix = name_space_prefix
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix
                                        if(value_path == "not-advertise"):
                                            self.not_advertise = value
                                            self.not_advertise.value_namespace = name_space
                                            self.not_advertise.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.range:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.range:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ranges" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "range"):
                                        for c in self.range:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges.Range()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.range.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "range"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Encryption(Entity):
                                """
                                Encrypt and authenticate OSPFv3 packets
                                
                                .. attribute:: authentication_algorithm
                                
                                	Use the NULL, MD5 or SHA1 algorithm
                                	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                
                                .. attribute:: authentication_password
                                
                                	Specify MD5 or SHA1 password
                                	**type**\:  str
                                
                                	**pattern:** (!.+)\|([^!].+)
                                
                                .. attribute:: enable
                                
                                	Authenticate packets
                                	**type**\:  bool
                                
                                .. attribute:: encryption_algorithm
                                
                                	Specify the encryption algorithm
                                	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                
                                .. attribute:: encryption_password
                                
                                	Encryption password
                                	**type**\:  str
                                
                                	**pattern:** (!.+)\|([^!].+)
                                
                                .. attribute:: spi
                                
                                	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                	**type**\:  int
                                
                                	**range:** 256..4294967295
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Encryption, self).__init__()

                                    self.yang_name = "encryption"
                                    self.yang_parent_name = "area-area-id"

                                    self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                    self.authentication_password = YLeaf(YType.str, "authentication-password")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                    self.encryption_password = YLeaf(YType.str, "encryption-password")

                                    self.spi = YLeaf(YType.uint32, "spi")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("authentication_algorithm",
                                                    "authentication_password",
                                                    "enable",
                                                    "encryption_algorithm",
                                                    "encryption_password",
                                                    "spi") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Encryption, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Encryption, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.authentication_algorithm.is_set or
                                        self.authentication_password.is_set or
                                        self.enable.is_set or
                                        self.encryption_algorithm.is_set or
                                        self.encryption_password.is_set or
                                        self.spi.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.authentication_algorithm.yfilter != YFilter.not_set or
                                        self.authentication_password.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.encryption_algorithm.yfilter != YFilter.not_set or
                                        self.encryption_password.yfilter != YFilter.not_set or
                                        self.spi.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "encryption" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                    if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                    if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                    if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.spi.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "authentication-algorithm"):
                                        self.authentication_algorithm = value
                                        self.authentication_algorithm.value_namespace = name_space
                                        self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                    if(value_path == "authentication-password"):
                                        self.authentication_password = value
                                        self.authentication_password.value_namespace = name_space
                                        self.authentication_password.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "encryption-algorithm"):
                                        self.encryption_algorithm = value
                                        self.encryption_algorithm.value_namespace = name_space
                                        self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                    if(value_path == "encryption-password"):
                                        self.encryption_password = value
                                        self.encryption_password.value_namespace = name_space
                                        self.encryption_password.value_namespace_prefix = name_space_prefix
                                    if(value_path == "spi"):
                                        self.spi = value
                                        self.spi.value_namespace = name_space
                                        self.spi.value_namespace_prefix = name_space_prefix


                            class Nssa(Entity):
                                """
                                Specify area as a NSSA area.  Allowed only in
                                non\-backbone areas
                                
                                .. attribute:: default_info_originate
                                
                                	Originate Type 7 default into NSSA area
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: metric
                                
                                	Only valid with DefaultInfoOriginate
                                	**type**\:  int
                                
                                	**range:** 0..16777214
                                
                                .. attribute:: metric_type
                                
                                	Only valid with DefaultInfoOriginate
                                	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                                
                                .. attribute:: no_redistribution
                                
                                	No redistribution into this NSSA area
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: no_summary
                                
                                	Do not send summary LSA into NSSA
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Nssa, self).__init__()

                                    self.yang_name = "nssa"
                                    self.yang_parent_name = "area-area-id"

                                    self.default_info_originate = YLeaf(YType.boolean, "default-info-originate")

                                    self.metric = YLeaf(YType.uint32, "metric")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.no_redistribution = YLeaf(YType.boolean, "no-redistribution")

                                    self.no_summary = YLeaf(YType.empty, "no-summary")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("default_info_originate",
                                                    "metric",
                                                    "metric_type",
                                                    "no_redistribution",
                                                    "no_summary") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Nssa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Nssa, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.default_info_originate.is_set or
                                        self.metric.is_set or
                                        self.metric_type.is_set or
                                        self.no_redistribution.is_set or
                                        self.no_summary.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.default_info_originate.yfilter != YFilter.not_set or
                                        self.metric.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.no_redistribution.yfilter != YFilter.not_set or
                                        self.no_summary.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "nssa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.default_info_originate.is_set or self.default_info_originate.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.default_info_originate.get_name_leafdata())
                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.no_redistribution.is_set or self.no_redistribution.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.no_redistribution.get_name_leafdata())
                                    if (self.no_summary.is_set or self.no_summary.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.no_summary.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "default-info-originate" or name == "metric" or name == "metric-type" or name == "no-redistribution" or name == "no-summary"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "default-info-originate"):
                                        self.default_info_originate = value
                                        self.default_info_originate.value_namespace = name_space
                                        self.default_info_originate.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric"):
                                        self.metric = value
                                        self.metric.value_namespace = name_space
                                        self.metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "no-redistribution"):
                                        self.no_redistribution = value
                                        self.no_redistribution.value_namespace = name_space
                                        self.no_redistribution.value_namespace_prefix = name_space_prefix
                                    if(value_path == "no-summary"):
                                        self.no_summary = value
                                        self.no_summary.value_namespace = name_space
                                        self.no_summary.value_namespace_prefix = name_space_prefix


                            class DatabaseFilter(Entity):
                                """
                                Database filter
                                
                                .. attribute:: all
                                
                                	All
                                	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter.All>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter, self).__init__()

                                    self.yang_name = "database-filter"
                                    self.yang_parent_name = "area-area-id"

                                    self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter.All()
                                    self.all.parent = self
                                    self._children_name_map["all"] = "all"
                                    self._children_yang_names.add("all")


                                class All(Entity):
                                    """
                                    All
                                    
                                    .. attribute:: out
                                    
                                    	Enable or disable database\-filter
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter.All, self).__init__()

                                        self.yang_name = "all"
                                        self.yang_parent_name = "database-filter"

                                        self.out = YLeaf(YType.boolean, "out")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("out") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter.All, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter.All, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.out.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.out.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "all" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.out.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "out"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "out"):
                                            self.out = value
                                            self.out.value_namespace = name_space
                                            self.out.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.all is not None and self.all.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.all is not None and self.all.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "database-filter" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "all"):
                                        if (self.all is None):
                                            self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter.All()
                                            self.all.parent = self
                                            self._children_name_map["all"] = "all"
                                        return self.all

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "all"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class DistributeList(Entity):
                                """
                                Filter prefixes to/from RIB
                                
                                .. attribute:: in_
                                
                                	Filter prefixes installed to RIB
                                	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList.In_>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList, self).__init__()

                                    self.yang_name = "distribute-list"
                                    self.yang_parent_name = "area-area-id"

                                    self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList.In_()
                                    self.in_.parent = self
                                    self._children_name_map["in_"] = "in"
                                    self._children_yang_names.add("in")


                                class In_(Entity):
                                    """
                                    Filter prefixes installed to RIB
                                    
                                    .. attribute:: prefix_list
                                    
                                    	Filter prefixes based on an IPv6 prefix\-list
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList.In_, self).__init__()

                                        self.yang_name = "in"
                                        self.yang_parent_name = "distribute-list"

                                        self.prefix_list = YLeaf(YType.str, "prefix-list")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("prefix_list") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList.In_, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList.In_, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.prefix_list.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.prefix_list.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "in" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "prefix-list"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "prefix-list"):
                                            self.prefix_list = value
                                            self.prefix_list.value_namespace = name_space
                                            self.prefix_list.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.in_ is not None and self.in_.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.in_ is not None and self.in_.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "distribute-list" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "in"):
                                        if (self.in_ is None):
                                            self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList.In_()
                                            self.in_.parent = self
                                            self._children_name_map["in_"] = "in"
                                        return self.in_

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "in"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Interfaces(Entity):
                                """
                                OSPFv3 interfaces
                                
                                .. attribute:: interface
                                
                                	OSPFv3 interface
                                	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces, self).__init__()

                                    self.yang_name = "interfaces"
                                    self.yang_parent_name = "area-area-id"

                                    self.interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces, self).__setattr__(name, value)


                                class Interface(Entity):
                                    """
                                    OSPFv3 interface
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Interface to configure
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    .. attribute:: authentication
                                    
                                    	Authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication>`
                                    
                                    .. attribute:: bfd
                                    
                                    	Configure BFD parameters
                                    	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd>`
                                    
                                    .. attribute:: cost
                                    
                                    	Interface cost
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    .. attribute:: database_filter
                                    
                                    	Database filter
                                    	**type**\:   :py:class:`DatabaseFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter>`
                                    
                                    .. attribute:: dead_interval
                                    
                                    	Interval after which a neighbor is declared dead (in seconds)
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: demand_circuit
                                    
                                    	Enable/disable demand circuit operation
                                    	**type**\:  bool
                                    
                                    .. attribute:: distribute_list
                                    
                                    	Filter prefixes to/from RIB
                                    	**type**\:   :py:class:`DistributeList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList>`
                                    
                                    .. attribute:: enable
                                    
                                    	Enable OSPFv3 interface
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: encryption
                                    
                                    	Encrypt and authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption>`
                                    
                                    .. attribute:: fast_reroute
                                    
                                    	Fast\-reroute configuration
                                    	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute>`
                                    
                                    .. attribute:: flood_reduction
                                    
                                    	Enable/disable flood reduction
                                    	**type**\:  bool
                                    
                                    .. attribute:: hello_interval
                                    
                                    	Time between HELLO packets
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: instance
                                    
                                    	Instance ID
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: ldp_sync
                                    
                                    	Enable/Disable MPLS LDP sync
                                    	**type**\:  bool
                                    
                                    .. attribute:: mtu_ignore
                                    
                                    	Enable/disable ignoring of MTU in DBD packets
                                    	**type**\:  bool
                                    
                                    .. attribute:: neighbors
                                    
                                    	Specify a neighbor router
                                    	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors>`
                                    
                                    .. attribute:: network
                                    
                                    	Specify network type
                                    	**type**\:   :py:class:`Ospfv3Network <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Network>`
                                    
                                    .. attribute:: packet_size
                                    
                                    	Limit size of OSPFv3 packets
                                    	**type**\:  int
                                    
                                    	**range:** 256..10000
                                    
                                    .. attribute:: passive
                                    
                                    	Enable/disable routing updates on an interface
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_suppression
                                    
                                    	Enable/disable prefix suppression on an interface
                                    	**type**\:  bool
                                    
                                    .. attribute:: priority
                                    
                                    	Specify router priority
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: retransmit_interval
                                    
                                    	Specify the transmit interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: transmit_delay
                                    
                                    	Specify the transmit delay in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface, self).__init__()

                                        self.yang_name = "interface"
                                        self.yang_parent_name = "interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                        self.cost = YLeaf(YType.uint32, "cost")

                                        self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                        self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                        self.instance = YLeaf(YType.uint32, "instance")

                                        self.ldp_sync = YLeaf(YType.boolean, "ldp-sync")

                                        self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                        self.network = YLeaf(YType.enumeration, "network")

                                        self.packet_size = YLeaf(YType.uint32, "packet-size")

                                        self.passive = YLeaf(YType.boolean, "passive")

                                        self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                        self.priority = YLeaf(YType.uint32, "priority")

                                        self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                        self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                        self._children_yang_names.add("authentication")

                                        self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd()
                                        self.bfd.parent = self
                                        self._children_name_map["bfd"] = "bfd"
                                        self._children_yang_names.add("bfd")

                                        self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter()
                                        self.database_filter.parent = self
                                        self._children_name_map["database_filter"] = "database-filter"
                                        self._children_yang_names.add("database-filter")

                                        self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList()
                                        self.distribute_list.parent = self
                                        self._children_name_map["distribute_list"] = "distribute-list"
                                        self._children_yang_names.add("distribute-list")

                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                        self._children_yang_names.add("encryption")

                                        self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute()
                                        self.fast_reroute.parent = self
                                        self._children_name_map["fast_reroute"] = "fast-reroute"
                                        self._children_yang_names.add("fast-reroute")

                                        self.neighbors = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors()
                                        self.neighbors.parent = self
                                        self._children_name_map["neighbors"] = "neighbors"
                                        self._children_yang_names.add("neighbors")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name",
                                                        "cost",
                                                        "dead_interval",
                                                        "demand_circuit",
                                                        "enable",
                                                        "flood_reduction",
                                                        "hello_interval",
                                                        "instance",
                                                        "ldp_sync",
                                                        "mtu_ignore",
                                                        "network",
                                                        "packet_size",
                                                        "passive",
                                                        "prefix_suppression",
                                                        "priority",
                                                        "retransmit_interval",
                                                        "transmit_delay") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface, self).__setattr__(name, value)


                                    class Authentication(Entity):
                                        """
                                        Authenticate OSPFv3 packets
                                        
                                        .. attribute:: algorithm
                                        
                                        	Use the MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication, self).__init__()

                                            self.yang_name = "authentication"
                                            self.yang_parent_name = "interface"

                                            self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.password = YLeaf(YType.str, "password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("algorithm",
                                                            "enable",
                                                            "password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.algorithm.is_set or
                                                self.enable.is_set or
                                                self.password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.algorithm.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "authentication" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.algorithm.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "algorithm"):
                                                self.algorithm = value
                                                self.algorithm.value_namespace = name_space
                                                self.algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "password"):
                                                self.password = value
                                                self.password.value_namespace = name_space
                                                self.password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Neighbors(Entity):
                                        """
                                        Specify a neighbor router
                                        
                                        .. attribute:: neighbor
                                        
                                        	IPv6 address
                                        	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors, self).__init__()

                                            self.yang_name = "neighbors"
                                            self.yang_parent_name = "interface"

                                            self.neighbor = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors, self).__setattr__(name, value)


                                        class Neighbor(Entity):
                                            """
                                            IPv6 address
                                            
                                            .. attribute:: neighbor_address  <key>
                                            
                                            	IPV6 address
                                            	**type**\:  str
                                            
                                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                            
                                            .. attribute:: cost
                                            
                                            	OSPFv3 cost for point\-to\-multipoint neighbor
                                            	**type**\:  int
                                            
                                            	**range:** 1..65535
                                            
                                            .. attribute:: database_filter
                                            
                                            	Filter OSPFv3 LSA during synchronization and flooding for point\-to\-multipoint neighbor
                                            	**type**\:  bool
                                            
                                            .. attribute:: poll_interval
                                            
                                            	OSPFv3 dead\-router polling interval (in seconds)
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**units**\: second
                                            
                                            .. attribute:: priority
                                            
                                            	OSPFv3 priority of non\-broadcast neighbor
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: zone
                                            
                                            	Zone
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor, self).__init__()

                                                self.yang_name = "neighbor"
                                                self.yang_parent_name = "neighbors"

                                                self.neighbor_address = YLeaf(YType.str, "neighbor-address")

                                                self.cost = YLeaf(YType.uint32, "cost")

                                                self.database_filter = YLeaf(YType.boolean, "database-filter")

                                                self.poll_interval = YLeaf(YType.uint32, "poll-interval")

                                                self.priority = YLeaf(YType.uint32, "priority")

                                                self.zone = YLeaf(YType.str, "zone")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("neighbor_address",
                                                                "cost",
                                                                "database_filter",
                                                                "poll_interval",
                                                                "priority",
                                                                "zone") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.neighbor_address.is_set or
                                                    self.cost.is_set or
                                                    self.database_filter.is_set or
                                                    self.poll_interval.is_set or
                                                    self.priority.is_set or
                                                    self.zone.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.neighbor_address.yfilter != YFilter.not_set or
                                                    self.cost.yfilter != YFilter.not_set or
                                                    self.database_filter.yfilter != YFilter.not_set or
                                                    self.poll_interval.yfilter != YFilter.not_set or
                                                    self.priority.yfilter != YFilter.not_set or
                                                    self.zone.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "neighbor" + "[neighbor-address='" + self.neighbor_address.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.neighbor_address.is_set or self.neighbor_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.neighbor_address.get_name_leafdata())
                                                if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.cost.get_name_leafdata())
                                                if (self.database_filter.is_set or self.database_filter.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.database_filter.get_name_leafdata())
                                                if (self.poll_interval.is_set or self.poll_interval.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.poll_interval.get_name_leafdata())
                                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                                if (self.zone.is_set or self.zone.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.zone.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "neighbor-address" or name == "cost" or name == "database-filter" or name == "poll-interval" or name == "priority" or name == "zone"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "neighbor-address"):
                                                    self.neighbor_address = value
                                                    self.neighbor_address.value_namespace = name_space
                                                    self.neighbor_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "cost"):
                                                    self.cost = value
                                                    self.cost.value_namespace = name_space
                                                    self.cost.value_namespace_prefix = name_space_prefix
                                                if(value_path == "database-filter"):
                                                    self.database_filter = value
                                                    self.database_filter.value_namespace = name_space
                                                    self.database_filter.value_namespace_prefix = name_space_prefix
                                                if(value_path == "poll-interval"):
                                                    self.poll_interval = value
                                                    self.poll_interval.value_namespace = name_space
                                                    self.poll_interval.value_namespace_prefix = name_space_prefix
                                                if(value_path == "priority"):
                                                    self.priority = value
                                                    self.priority.value_namespace = name_space
                                                    self.priority.value_namespace_prefix = name_space_prefix
                                                if(value_path == "zone"):
                                                    self.zone = value
                                                    self.zone.value_namespace = name_space
                                                    self.zone.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.neighbor:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.neighbor:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "neighbors" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "neighbor"):
                                                for c in self.neighbor:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors.Neighbor()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.neighbor.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "neighbor"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class Encryption(Entity):
                                        """
                                        Encrypt and authenticate OSPFv3 packets
                                        
                                        .. attribute:: authentication_algorithm
                                        
                                        	Use the NULL, MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                        
                                        .. attribute:: authentication_password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: encryption_algorithm
                                        
                                        	Specify the encryption algorithm
                                        	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                        
                                        .. attribute:: encryption_password
                                        
                                        	Encryption password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption, self).__init__()

                                            self.yang_name = "encryption"
                                            self.yang_parent_name = "interface"

                                            self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                            self.authentication_password = YLeaf(YType.str, "authentication-password")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                            self.encryption_password = YLeaf(YType.str, "encryption-password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("authentication_algorithm",
                                                            "authentication_password",
                                                            "enable",
                                                            "encryption_algorithm",
                                                            "encryption_password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.authentication_algorithm.is_set or
                                                self.authentication_password.is_set or
                                                self.enable.is_set or
                                                self.encryption_algorithm.is_set or
                                                self.encryption_password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.authentication_algorithm.yfilter != YFilter.not_set or
                                                self.authentication_password.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.encryption_algorithm.yfilter != YFilter.not_set or
                                                self.encryption_password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "encryption" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                            if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                            if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "authentication-algorithm"):
                                                self.authentication_algorithm = value
                                                self.authentication_algorithm.value_namespace = name_space
                                                self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "authentication-password"):
                                                self.authentication_password = value
                                                self.authentication_password.value_namespace = name_space
                                                self.authentication_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-algorithm"):
                                                self.encryption_algorithm = value
                                                self.encryption_algorithm.value_namespace = name_space
                                                self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-password"):
                                                self.encryption_password = value
                                                self.encryption_password.value_namespace = name_space
                                                self.encryption_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Bfd(Entity):
                                        """
                                        Configure BFD parameters
                                        
                                        .. attribute:: detection_multiplier
                                        
                                        	Detect multiplier
                                        	**type**\:  int
                                        
                                        	**range:** 2..50
                                        
                                        .. attribute:: fast_detect_mode
                                        
                                        	Enable or disable BFD fast detection
                                        	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                                        
                                        .. attribute:: interval
                                        
                                        	Hello interval in milli\-seconds
                                        	**type**\:  int
                                        
                                        	**range:** 3..30000
                                        
                                        	**units**\: millisecond
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd, self).__init__()

                                            self.yang_name = "bfd"
                                            self.yang_parent_name = "interface"

                                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                            self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                                            self.interval = YLeaf(YType.uint32, "interval")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("detection_multiplier",
                                                            "fast_detect_mode",
                                                            "interval") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.detection_multiplier.is_set or
                                                self.fast_detect_mode.is_set or
                                                self.interval.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.detection_multiplier.yfilter != YFilter.not_set or
                                                self.fast_detect_mode.yfilter != YFilter.not_set or
                                                self.interval.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bfd" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                            if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interval.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "detection-multiplier"):
                                                self.detection_multiplier = value
                                                self.detection_multiplier.value_namespace = name_space
                                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fast-detect-mode"):
                                                self.fast_detect_mode = value
                                                self.fast_detect_mode.value_namespace = name_space
                                                self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                                            if(value_path == "interval"):
                                                self.interval = value
                                                self.interval.value_namespace = name_space
                                                self.interval.value_namespace_prefix = name_space_prefix


                                    class DatabaseFilter(Entity):
                                        """
                                        Database filter
                                        
                                        .. attribute:: all
                                        
                                        	All
                                        	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter, self).__init__()

                                            self.yang_name = "database-filter"
                                            self.yang_parent_name = "interface"

                                            self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All()
                                            self.all.parent = self
                                            self._children_name_map["all"] = "all"
                                            self._children_yang_names.add("all")


                                        class All(Entity):
                                            """
                                            All
                                            
                                            .. attribute:: out
                                            
                                            	Enable or disable database\-filter
                                            	**type**\:  bool
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All, self).__init__()

                                                self.yang_name = "all"
                                                self.yang_parent_name = "database-filter"

                                                self.out = YLeaf(YType.boolean, "out")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("out") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.out.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.out.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "all" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.out.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "out"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "out"):
                                                    self.out = value
                                                    self.out.value_namespace = name_space
                                                    self.out.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (self.all is not None and self.all.has_data())

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.all is not None and self.all.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "database-filter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "all"):
                                                if (self.all is None):
                                                    self.all = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter.All()
                                                    self.all.parent = self
                                                    self._children_name_map["all"] = "all"
                                                return self.all

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "all"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class DistributeList(Entity):
                                        """
                                        Filter prefixes to/from RIB
                                        
                                        .. attribute:: in_
                                        
                                        	Filter prefixes installed to RIB
                                        	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList, self).__init__()

                                            self.yang_name = "distribute-list"
                                            self.yang_parent_name = "interface"

                                            self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_()
                                            self.in_.parent = self
                                            self._children_name_map["in_"] = "in"
                                            self._children_yang_names.add("in")


                                        class In_(Entity):
                                            """
                                            Filter prefixes installed to RIB
                                            
                                            .. attribute:: prefix_list
                                            
                                            	Filter prefixes based on an IPv6 prefix\-list
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_, self).__init__()

                                                self.yang_name = "in"
                                                self.yang_parent_name = "distribute-list"

                                                self.prefix_list = YLeaf(YType.str, "prefix-list")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("prefix_list") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.prefix_list.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.prefix_list.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "in" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "prefix-list"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "prefix-list"):
                                                    self.prefix_list = value
                                                    self.prefix_list.value_namespace = name_space
                                                    self.prefix_list.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (self.in_ is not None and self.in_.has_data())

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.in_ is not None and self.in_.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "distribute-list" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "in"):
                                                if (self.in_ is None):
                                                    self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList.In_()
                                                    self.in_.parent = self
                                                    self._children_name_map["in_"] = "in"
                                                return self.in_

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "in"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FastReroute(Entity):
                                        """
                                        Fast\-reroute configuration
                                        
                                        .. attribute:: fast_reroute_enable
                                        
                                        	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                        	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                        
                                        .. attribute:: per_link
                                        
                                        	Fast\-reroute per\-link configuration
                                        	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink>`
                                        
                                        .. attribute:: per_prefix
                                        
                                        	Fast\-reroute per\-link configuration
                                        	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix>`
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute, self).__init__()

                                            self.yang_name = "fast-reroute"
                                            self.yang_parent_name = "interface"

                                            self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                            self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink()
                                            self.per_link.parent = self
                                            self._children_name_map["per_link"] = "per-link"
                                            self._children_yang_names.add("per-link")

                                            self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix()
                                            self.per_prefix.parent = self
                                            self._children_name_map["per_prefix"] = "per-prefix"
                                            self._children_yang_names.add("per-prefix")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_enable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute, self).__setattr__(name, value)


                                        class PerLink(Entity):
                                            """
                                            Fast\-reroute per\-link configuration
                                            
                                            .. attribute:: candidate_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                            	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces>`
                                            
                                            .. attribute:: exclude_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces>`
                                            
                                            .. attribute:: fast_reroute_use_candidate_only
                                            
                                            	Use only interfaces on the candidate list as a backup path
                                            	**type**\:  bool
                                            
                                            	**default value**\: false
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink, self).__init__()

                                                self.yang_name = "per-link"
                                                self.yang_parent_name = "fast-reroute"

                                                self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                                self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                self._children_yang_names.add("candidate-interfaces")

                                                self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                self._children_yang_names.add("exclude-interfaces")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink, self).__setattr__(name, value)


                                            class CandidateInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix candidate
                                                interface configuration
                                                
                                                .. attribute:: candidate_interface
                                                
                                                	Candidate backup interface
                                                	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                                    self.yang_name = "candidate-interfaces"
                                                    self.yang_parent_name = "per-link"

                                                    self.candidate_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                                class CandidateInterface(Entity):
                                                    """
                                                    Candidate backup interface
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                        self.yang_name = "candidate-interface"
                                                        self.yang_parent_name = "candidate-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "candidate-interface"):
                                                        for c in self.candidate_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.candidate_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "candidate-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass


                                            class ExcludeInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix exclude
                                                interface configuration
                                                
                                                .. attribute:: exclude_interface
                                                
                                                	Exclude an interface from becoming a backup
                                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                                    self.yang_name = "exclude-interfaces"
                                                    self.yang_parent_name = "per-link"

                                                    self.exclude_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                                class ExcludeInterface(Entity):
                                                    """
                                                    Exclude an interface from becoming a backup
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                        self.yang_name = "exclude-interface"
                                                        self.yang_parent_name = "exclude-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "exclude-interface"):
                                                        for c in self.exclude_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.exclude_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "exclude-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    self.fast_reroute_use_candidate_only.is_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "per-link" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interfaces"):
                                                    if (self.candidate_interfaces is None):
                                                        self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.CandidateInterfaces()
                                                        self.candidate_interfaces.parent = self
                                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                    return self.candidate_interfaces

                                                if (child_yang_name == "exclude-interfaces"):
                                                    if (self.exclude_interfaces is None):
                                                        self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink.ExcludeInterfaces()
                                                        self.exclude_interfaces.parent = self
                                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                    return self.exclude_interfaces

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "fast-reroute-use-candidate-only"):
                                                    self.fast_reroute_use_candidate_only = value
                                                    self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                    self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                        class PerPrefix(Entity):
                                            """
                                            Fast\-reroute per\-link configuration
                                            
                                            .. attribute:: candidate_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                            	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces>`
                                            
                                            .. attribute:: exclude_interfaces
                                            
                                            	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces>`
                                            
                                            .. attribute:: fast_reroute_use_candidate_only
                                            
                                            	Use only interfaces on the candidate list as a backup path
                                            	**type**\:  bool
                                            
                                            	**default value**\: false
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix, self).__init__()

                                                self.yang_name = "per-prefix"
                                                self.yang_parent_name = "fast-reroute"

                                                self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                                self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                                self.candidate_interfaces.parent = self
                                                self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                self._children_yang_names.add("candidate-interfaces")

                                                self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                                self.exclude_interfaces.parent = self
                                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                self._children_yang_names.add("exclude-interfaces")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix, self).__setattr__(name, value)


                                            class CandidateInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix candidate
                                                interface configuration
                                                
                                                .. attribute:: candidate_interface
                                                
                                                	Candidate backup interface
                                                	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                                    self.yang_name = "candidate-interfaces"
                                                    self.yang_parent_name = "per-prefix"

                                                    self.candidate_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                                class CandidateInterface(Entity):
                                                    """
                                                    Candidate backup interface
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                        self.yang_name = "candidate-interface"
                                                        self.yang_parent_name = "candidate-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.candidate_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "candidate-interface"):
                                                        for c in self.candidate_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.candidate_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "candidate-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass


                                            class ExcludeInterfaces(Entity):
                                                """
                                                Fast\-reroute per\-link/per\-prefix exclude
                                                interface configuration
                                                
                                                .. attribute:: exclude_interface
                                                
                                                	Exclude an interface from becoming a backup
                                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                                    self.yang_name = "exclude-interfaces"
                                                    self.yang_parent_name = "per-prefix"

                                                    self.exclude_interface = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                                class ExcludeInterface(Entity):
                                                    """
                                                    Exclude an interface from becoming a backup
                                                    
                                                    .. attribute:: interface_name  <key>
                                                    
                                                    	Interface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'ipv6-ospfv3-cfg'
                                                    _revision = '2015-11-09'

                                                    def __init__(self):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                        self.yang_name = "exclude-interface"
                                                        self.yang_parent_name = "exclude-interfaces"

                                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.interface_name.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-name"):
                                                            self.interface_name = value
                                                            self.interface_name.value_namespace = name_space
                                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_data()):
                                                            return True
                                                    return False

                                                def has_operation(self):
                                                    for c in self.exclude_interface:
                                                        if (c.has_operation()):
                                                            return True
                                                    return self.yfilter != YFilter.not_set

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interfaces" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "exclude-interface"):
                                                        for c in self.exclude_interface:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.exclude_interface.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "exclude-interface"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    self.fast_reroute_use_candidate_only.is_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                    (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "per-prefix" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interfaces"):
                                                    if (self.candidate_interfaces is None):
                                                        self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.CandidateInterfaces()
                                                        self.candidate_interfaces.parent = self
                                                        self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                    return self.candidate_interfaces

                                                if (child_yang_name == "exclude-interfaces"):
                                                    if (self.exclude_interfaces is None):
                                                        self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix.ExcludeInterfaces()
                                                        self.exclude_interfaces.parent = self
                                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                    return self.exclude_interfaces

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "fast-reroute-use-candidate-only"):
                                                    self.fast_reroute_use_candidate_only = value
                                                    self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                    self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_enable.is_set or
                                                (self.per_link is not None and self.per_link.has_data()) or
                                                (self.per_prefix is not None and self.per_prefix.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_enable.yfilter != YFilter.not_set or
                                                (self.per_link is not None and self.per_link.has_operation()) or
                                                (self.per_prefix is not None and self.per_prefix.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fast-reroute" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "per-link"):
                                                if (self.per_link is None):
                                                    self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerLink()
                                                    self.per_link.parent = self
                                                    self._children_name_map["per_link"] = "per-link"
                                                return self.per_link

                                            if (child_yang_name == "per-prefix"):
                                                if (self.per_prefix is None):
                                                    self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute.PerPrefix()
                                                    self.per_prefix.parent = self
                                                    self._children_name_map["per_prefix"] = "per-prefix"
                                                return self.per_prefix

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-enable"):
                                                self.fast_reroute_enable = value
                                                self.fast_reroute_enable.value_namespace = name_space
                                                self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.interface_name.is_set or
                                            self.cost.is_set or
                                            self.dead_interval.is_set or
                                            self.demand_circuit.is_set or
                                            self.enable.is_set or
                                            self.flood_reduction.is_set or
                                            self.hello_interval.is_set or
                                            self.instance.is_set or
                                            self.ldp_sync.is_set or
                                            self.mtu_ignore.is_set or
                                            self.network.is_set or
                                            self.packet_size.is_set or
                                            self.passive.is_set or
                                            self.prefix_suppression.is_set or
                                            self.priority.is_set or
                                            self.retransmit_interval.is_set or
                                            self.transmit_delay.is_set or
                                            (self.authentication is not None and self.authentication.has_data()) or
                                            (self.bfd is not None and self.bfd.has_data()) or
                                            (self.database_filter is not None and self.database_filter.has_data()) or
                                            (self.distribute_list is not None and self.distribute_list.has_data()) or
                                            (self.encryption is not None and self.encryption.has_data()) or
                                            (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                                            (self.neighbors is not None and self.neighbors.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set or
                                            self.dead_interval.yfilter != YFilter.not_set or
                                            self.demand_circuit.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.flood_reduction.yfilter != YFilter.not_set or
                                            self.hello_interval.yfilter != YFilter.not_set or
                                            self.instance.yfilter != YFilter.not_set or
                                            self.ldp_sync.yfilter != YFilter.not_set or
                                            self.mtu_ignore.yfilter != YFilter.not_set or
                                            self.network.yfilter != YFilter.not_set or
                                            self.packet_size.yfilter != YFilter.not_set or
                                            self.passive.yfilter != YFilter.not_set or
                                            self.prefix_suppression.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.retransmit_interval.yfilter != YFilter.not_set or
                                            self.transmit_delay.yfilter != YFilter.not_set or
                                            (self.authentication is not None and self.authentication.has_operation()) or
                                            (self.bfd is not None and self.bfd.has_operation()) or
                                            (self.database_filter is not None and self.database_filter.has_operation()) or
                                            (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                            (self.encryption is not None and self.encryption.has_operation()) or
                                            (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                                            (self.neighbors is not None and self.neighbors.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())
                                        if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                        if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                        if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.instance.get_name_leafdata())
                                        if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                                        if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                        if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.network.get_name_leafdata())
                                        if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.packet_size.get_name_leafdata())
                                        if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.passive.get_name_leafdata())
                                        if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                        if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "authentication"):
                                            if (self.authentication is None):
                                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Authentication()
                                                self.authentication.parent = self
                                                self._children_name_map["authentication"] = "authentication"
                                            return self.authentication

                                        if (child_yang_name == "bfd"):
                                            if (self.bfd is None):
                                                self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Bfd()
                                                self.bfd.parent = self
                                                self._children_name_map["bfd"] = "bfd"
                                            return self.bfd

                                        if (child_yang_name == "database-filter"):
                                            if (self.database_filter is None):
                                                self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DatabaseFilter()
                                                self.database_filter.parent = self
                                                self._children_name_map["database_filter"] = "database-filter"
                                            return self.database_filter

                                        if (child_yang_name == "distribute-list"):
                                            if (self.distribute_list is None):
                                                self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.DistributeList()
                                                self.distribute_list.parent = self
                                                self._children_name_map["distribute_list"] = "distribute-list"
                                            return self.distribute_list

                                        if (child_yang_name == "encryption"):
                                            if (self.encryption is None):
                                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Encryption()
                                                self.encryption.parent = self
                                                self._children_name_map["encryption"] = "encryption"
                                            return self.encryption

                                        if (child_yang_name == "fast-reroute"):
                                            if (self.fast_reroute is None):
                                                self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.FastReroute()
                                                self.fast_reroute.parent = self
                                                self._children_name_map["fast_reroute"] = "fast-reroute"
                                            return self.fast_reroute

                                        if (child_yang_name == "neighbors"):
                                            if (self.neighbors is None):
                                                self.neighbors = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface.Neighbors()
                                                self.neighbors.parent = self
                                                self._children_name_map["neighbors"] = "neighbors"
                                            return self.neighbors

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "fast-reroute" or name == "neighbors" or name == "interface-name" or name == "cost" or name == "dead-interval" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "transmit-delay"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dead-interval"):
                                            self.dead_interval = value
                                            self.dead_interval.value_namespace = name_space
                                            self.dead_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "demand-circuit"):
                                            self.demand_circuit = value
                                            self.demand_circuit.value_namespace = name_space
                                            self.demand_circuit.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "flood-reduction"):
                                            self.flood_reduction = value
                                            self.flood_reduction.value_namespace = name_space
                                            self.flood_reduction.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hello-interval"):
                                            self.hello_interval = value
                                            self.hello_interval.value_namespace = name_space
                                            self.hello_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "instance"):
                                            self.instance = value
                                            self.instance.value_namespace = name_space
                                            self.instance.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ldp-sync"):
                                            self.ldp_sync = value
                                            self.ldp_sync.value_namespace = name_space
                                            self.ldp_sync.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mtu-ignore"):
                                            self.mtu_ignore = value
                                            self.mtu_ignore.value_namespace = name_space
                                            self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                        if(value_path == "network"):
                                            self.network = value
                                            self.network.value_namespace = name_space
                                            self.network.value_namespace_prefix = name_space_prefix
                                        if(value_path == "packet-size"):
                                            self.packet_size = value
                                            self.packet_size.value_namespace = name_space
                                            self.packet_size.value_namespace_prefix = name_space_prefix
                                        if(value_path == "passive"):
                                            self.passive = value
                                            self.passive.value_namespace = name_space
                                            self.passive.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-suppression"):
                                            self.prefix_suppression = value
                                            self.prefix_suppression.value_namespace = name_space
                                            self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retransmit-interval"):
                                            self.retransmit_interval = value
                                            self.retransmit_interval.value_namespace = name_space
                                            self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-delay"):
                                            self.transmit_delay = value
                                            self.transmit_delay.value_namespace = name_space
                                            self.transmit_delay.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "interface"):
                                        for c in self.interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces.Interface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class AreaScope(Entity):
                                """
                                Area Scope Configuration
                                
                                .. attribute:: fast_reroute
                                
                                	Fast\-reroute configuration
                                	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope, self).__init__()

                                    self.yang_name = "area-scope"
                                    self.yang_parent_name = "area-area-id"

                                    self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                    self._children_yang_names.add("fast-reroute")


                                class FastReroute(Entity):
                                    """
                                    Fast\-reroute configuration
                                    
                                    .. attribute:: fast_reroute_enable
                                    
                                    	Enable/Disable Fast\-reroute per\-link or per\-prefix
                                    	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                                    
                                    .. attribute:: per_link
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink>`
                                    
                                    .. attribute:: per_prefix
                                    
                                    	Fast\-reroute per\-link configuration
                                    	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute, self).__init__()

                                        self.yang_name = "fast-reroute"
                                        self.yang_parent_name = "area-scope"

                                        self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                        self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink()
                                        self.per_link.parent = self
                                        self._children_name_map["per_link"] = "per-link"
                                        self._children_yang_names.add("per-link")

                                        self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix()
                                        self.per_prefix.parent = self
                                        self._children_name_map["per_prefix"] = "per-prefix"
                                        self._children_yang_names.add("per-prefix")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fast_reroute_enable") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute, self).__setattr__(name, value)


                                    class PerLink(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink, self).__init__()

                                            self.yang_name = "per-link"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-link"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-link" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                                    class PerPrefix(Entity):
                                        """
                                        Fast\-reroute per\-link configuration
                                        
                                        .. attribute:: candidate_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                        	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces>`
                                        
                                        .. attribute:: exclude_interfaces
                                        
                                        	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                        	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces>`
                                        
                                        .. attribute:: fast_reroute_use_candidate_only
                                        
                                        	Use only interfaces on the candidate list as a backup path
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix, self).__init__()

                                            self.yang_name = "per-prefix"
                                            self.yang_parent_name = "fast-reroute"

                                            self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                            self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                            self._children_yang_names.add("candidate-interfaces")

                                            self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                            self._children_yang_names.add("exclude-interfaces")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix, self).__setattr__(name, value)


                                        class CandidateInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix candidate
                                            interface configuration
                                            
                                            .. attribute:: candidate_interface
                                            
                                            	Candidate backup interface
                                            	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                                self.yang_name = "candidate-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.candidate_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                            class CandidateInterface(Entity):
                                                """
                                                Candidate backup interface
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                                    self.yang_name = "candidate-interface"
                                                    self.yang_parent_name = "candidate-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.candidate_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "candidate-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "candidate-interface"):
                                                    for c in self.candidate_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.candidate_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "candidate-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class ExcludeInterfaces(Entity):
                                            """
                                            Fast\-reroute per\-link/per\-prefix exclude
                                            interface configuration
                                            
                                            .. attribute:: exclude_interface
                                            
                                            	Exclude an interface from becoming a backup
                                            	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                            
                                            

                                            """

                                            _prefix = 'ipv6-ospfv3-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                                self.yang_name = "exclude-interfaces"
                                                self.yang_parent_name = "per-prefix"

                                                self.exclude_interface = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                            class ExcludeInterface(Entity):
                                                """
                                                Exclude an interface from becoming a backup
                                                
                                                .. attribute:: interface_name  <key>
                                                
                                                	Interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                

                                                """

                                                _prefix = 'ipv6-ospfv3-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                                    self.yang_name = "exclude-interface"
                                                    self.yang_parent_name = "exclude-interfaces"

                                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_name") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.interface_name.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_name.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-name"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-name"):
                                                        self.interface_name = value
                                                        self.interface_name.value_namespace = name_space
                                                        self.interface_name.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.exclude_interface:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "exclude-interfaces" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "exclude-interface"):
                                                    for c in self.exclude_interface:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.exclude_interface.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "exclude-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.fast_reroute_use_candidate_only.is_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                                (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                                (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "per-prefix" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "candidate-interfaces"):
                                                if (self.candidate_interfaces is None):
                                                    self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.CandidateInterfaces()
                                                    self.candidate_interfaces.parent = self
                                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                                return self.candidate_interfaces

                                            if (child_yang_name == "exclude-interfaces"):
                                                if (self.exclude_interfaces is None):
                                                    self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                                    self.exclude_interfaces.parent = self
                                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                                return self.exclude_interfaces

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fast-reroute-use-candidate-only"):
                                                self.fast_reroute_use_candidate_only = value
                                                self.fast_reroute_use_candidate_only.value_namespace = name_space
                                                self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.fast_reroute_enable.is_set or
                                            (self.per_link is not None and self.per_link.has_data()) or
                                            (self.per_prefix is not None and self.per_prefix.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fast_reroute_enable.yfilter != YFilter.not_set or
                                            (self.per_link is not None and self.per_link.has_operation()) or
                                            (self.per_prefix is not None and self.per_prefix.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fast-reroute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "per-link"):
                                            if (self.per_link is None):
                                                self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerLink()
                                                self.per_link.parent = self
                                                self._children_name_map["per_link"] = "per-link"
                                            return self.per_link

                                        if (child_yang_name == "per-prefix"):
                                            if (self.per_prefix is None):
                                                self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute.PerPrefix()
                                                self.per_prefix.parent = self
                                                self._children_name_map["per_prefix"] = "per-prefix"
                                            return self.per_prefix

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fast-reroute-enable"):
                                            self.fast_reroute_enable = value
                                            self.fast_reroute_enable.value_namespace = name_space
                                            self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.fast_reroute is not None and self.fast_reroute.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.fast_reroute is not None and self.fast_reroute.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "area-scope" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "fast-reroute"):
                                        if (self.fast_reroute is None):
                                            self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope.FastReroute()
                                            self.fast_reroute.parent = self
                                            self._children_name_map["fast_reroute"] = "fast-reroute"
                                        return self.fast_reroute

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fast-reroute"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class ShamLinks(Entity):
                                """
                                Sham Link sub\-mode
                                
                                .. attribute:: sham_link
                                
                                	ShamLink local and remote endpoints
                                	**type**\: list of    :py:class:`ShamLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks, self).__init__()

                                    self.yang_name = "sham-links"
                                    self.yang_parent_name = "area-area-id"

                                    self.sham_link = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks, self).__setattr__(name, value)


                                class ShamLink(Entity):
                                    """
                                    ShamLink local and remote endpoints
                                    
                                    .. attribute:: source_address  <key>
                                    
                                    	Local sham\-link endpoint
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: destination_address  <key>
                                    
                                    	Remote sham\-link endpoint
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: authentication
                                    
                                    	Authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication>`
                                    
                                    .. attribute:: dead_interval
                                    
                                    	Interval after which a neighbor is declared dead (in seconds)
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: enable
                                    
                                    	Enable sham link
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: encryption
                                    
                                    	Encrypt and authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption>`
                                    
                                    .. attribute:: hello_interval
                                    
                                    	Time between HELLO packets
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: retransmit_interval
                                    
                                    	Specify the transmit interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: transmit_delay
                                    
                                    	Specify the transmit delay in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink, self).__init__()

                                        self.yang_name = "sham-link"
                                        self.yang_parent_name = "sham-links"

                                        self.source_address = YLeaf(YType.str, "source-address")

                                        self.destination_address = YLeaf(YType.str, "destination-address")

                                        self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                        self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                        self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                        self._children_yang_names.add("authentication")

                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                        self._children_yang_names.add("encryption")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("source_address",
                                                        "destination_address",
                                                        "dead_interval",
                                                        "enable",
                                                        "hello_interval",
                                                        "retransmit_interval",
                                                        "transmit_delay") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink, self).__setattr__(name, value)


                                    class Authentication(Entity):
                                        """
                                        Authenticate OSPFv3 packets
                                        
                                        .. attribute:: algorithm
                                        
                                        	Use the MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication, self).__init__()

                                            self.yang_name = "authentication"
                                            self.yang_parent_name = "sham-link"

                                            self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.password = YLeaf(YType.str, "password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("algorithm",
                                                            "enable",
                                                            "password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.algorithm.is_set or
                                                self.enable.is_set or
                                                self.password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.algorithm.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "authentication" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.algorithm.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "algorithm"):
                                                self.algorithm = value
                                                self.algorithm.value_namespace = name_space
                                                self.algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "password"):
                                                self.password = value
                                                self.password.value_namespace = name_space
                                                self.password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Encryption(Entity):
                                        """
                                        Encrypt and authenticate OSPFv3 packets
                                        
                                        .. attribute:: authentication_algorithm
                                        
                                        	Use the NULL, MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                        
                                        .. attribute:: authentication_password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: encryption_algorithm
                                        
                                        	Specify the encryption algorithm
                                        	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                        
                                        .. attribute:: encryption_password
                                        
                                        	Encryption password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption, self).__init__()

                                            self.yang_name = "encryption"
                                            self.yang_parent_name = "sham-link"

                                            self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                            self.authentication_password = YLeaf(YType.str, "authentication-password")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                            self.encryption_password = YLeaf(YType.str, "encryption-password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("authentication_algorithm",
                                                            "authentication_password",
                                                            "enable",
                                                            "encryption_algorithm",
                                                            "encryption_password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.authentication_algorithm.is_set or
                                                self.authentication_password.is_set or
                                                self.enable.is_set or
                                                self.encryption_algorithm.is_set or
                                                self.encryption_password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.authentication_algorithm.yfilter != YFilter.not_set or
                                                self.authentication_password.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.encryption_algorithm.yfilter != YFilter.not_set or
                                                self.encryption_password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "encryption" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                            if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                            if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "authentication-algorithm"):
                                                self.authentication_algorithm = value
                                                self.authentication_algorithm.value_namespace = name_space
                                                self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "authentication-password"):
                                                self.authentication_password = value
                                                self.authentication_password.value_namespace = name_space
                                                self.authentication_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-algorithm"):
                                                self.encryption_algorithm = value
                                                self.encryption_algorithm.value_namespace = name_space
                                                self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-password"):
                                                self.encryption_password = value
                                                self.encryption_password.value_namespace = name_space
                                                self.encryption_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.source_address.is_set or
                                            self.destination_address.is_set or
                                            self.dead_interval.is_set or
                                            self.enable.is_set or
                                            self.hello_interval.is_set or
                                            self.retransmit_interval.is_set or
                                            self.transmit_delay.is_set or
                                            (self.authentication is not None and self.authentication.has_data()) or
                                            (self.encryption is not None and self.encryption.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.source_address.yfilter != YFilter.not_set or
                                            self.destination_address.yfilter != YFilter.not_set or
                                            self.dead_interval.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hello_interval.yfilter != YFilter.not_set or
                                            self.retransmit_interval.yfilter != YFilter.not_set or
                                            self.transmit_delay.yfilter != YFilter.not_set or
                                            (self.authentication is not None and self.authentication.has_operation()) or
                                            (self.encryption is not None and self.encryption.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "sham-link" + "[source-address='" + self.source_address.get() + "']" + "[destination-address='" + self.destination_address.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.source_address.get_name_leafdata())
                                        if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.destination_address.get_name_leafdata())
                                        if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                        if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                        if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "authentication"):
                                            if (self.authentication is None):
                                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Authentication()
                                                self.authentication.parent = self
                                                self._children_name_map["authentication"] = "authentication"
                                            return self.authentication

                                        if (child_yang_name == "encryption"):
                                            if (self.encryption is None):
                                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink.Encryption()
                                                self.encryption.parent = self
                                                self._children_name_map["encryption"] = "encryption"
                                            return self.encryption

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication" or name == "encryption" or name == "source-address" or name == "destination-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "source-address"):
                                            self.source_address = value
                                            self.source_address.value_namespace = name_space
                                            self.source_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "destination-address"):
                                            self.destination_address = value
                                            self.destination_address.value_namespace = name_space
                                            self.destination_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dead-interval"):
                                            self.dead_interval = value
                                            self.dead_interval.value_namespace = name_space
                                            self.dead_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hello-interval"):
                                            self.hello_interval = value
                                            self.hello_interval.value_namespace = name_space
                                            self.hello_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retransmit-interval"):
                                            self.retransmit_interval = value
                                            self.retransmit_interval.value_namespace = name_space
                                            self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-delay"):
                                            self.transmit_delay = value
                                            self.transmit_delay.value_namespace = name_space
                                            self.transmit_delay.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.sham_link:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.sham_link:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sham-links" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "sham-link"):
                                        for c in self.sham_link:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks.ShamLink()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.sham_link.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "sham-link"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class VirtualLinks(Entity):
                                """
                                Virtual link sub\-mode
                                
                                .. attribute:: virtual_link
                                
                                	Router ID of virtual link neighbor
                                	**type**\: list of    :py:class:`VirtualLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks, self).__init__()

                                    self.yang_name = "virtual-links"
                                    self.yang_parent_name = "area-area-id"

                                    self.virtual_link = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks, self).__setattr__(name, value)


                                class VirtualLink(Entity):
                                    """
                                    Router ID of virtual link neighbor
                                    
                                    .. attribute:: virtual_link_address  <key>
                                    
                                    	Router ID of virtual link neighbor
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: authentication
                                    
                                    	Authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication>`
                                    
                                    .. attribute:: dead_interval
                                    
                                    	Interval after which a neighbor is declared dead (in seconds)
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: enable
                                    
                                    	Enabled virtual link
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: encryption
                                    
                                    	Encrypt and authenticate OSPFv3 packets
                                    	**type**\:   :py:class:`Encryption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption>`
                                    
                                    .. attribute:: hello_interval
                                    
                                    	Time between HELLO packets
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: retransmit_interval
                                    
                                    	Specify the transmit interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: transmit_delay
                                    
                                    	Specify the transmit delay in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink, self).__init__()

                                        self.yang_name = "virtual-link"
                                        self.yang_parent_name = "virtual-links"

                                        self.virtual_link_address = YLeaf(YType.str, "virtual-link-address")

                                        self.dead_interval = YLeaf(YType.uint32, "dead-interval")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                                        self.retransmit_interval = YLeaf(YType.uint32, "retransmit-interval")

                                        self.transmit_delay = YLeaf(YType.uint32, "transmit-delay")

                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                        self._children_yang_names.add("authentication")

                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                        self._children_yang_names.add("encryption")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("virtual_link_address",
                                                        "dead_interval",
                                                        "enable",
                                                        "hello_interval",
                                                        "retransmit_interval",
                                                        "transmit_delay") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink, self).__setattr__(name, value)


                                    class Authentication(Entity):
                                        """
                                        Authenticate OSPFv3 packets
                                        
                                        .. attribute:: algorithm
                                        
                                        	Use the MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication, self).__init__()

                                            self.yang_name = "authentication"
                                            self.yang_parent_name = "virtual-link"

                                            self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.password = YLeaf(YType.str, "password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("algorithm",
                                                            "enable",
                                                            "password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.algorithm.is_set or
                                                self.enable.is_set or
                                                self.password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.algorithm.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "authentication" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.algorithm.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "algorithm"):
                                                self.algorithm = value
                                                self.algorithm.value_namespace = name_space
                                                self.algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "password"):
                                                self.password = value
                                                self.password.value_namespace = name_space
                                                self.password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix


                                    class Encryption(Entity):
                                        """
                                        Encrypt and authenticate OSPFv3 packets
                                        
                                        .. attribute:: authentication_algorithm
                                        
                                        	Use the NULL, MD5 or SHA1 algorithm
                                        	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                                        
                                        .. attribute:: authentication_password
                                        
                                        	Specify MD5 or SHA1 password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: enable
                                        
                                        	Authenticate packets
                                        	**type**\:  bool
                                        
                                        .. attribute:: encryption_algorithm
                                        
                                        	Specify the encryption algorithm
                                        	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                                        
                                        .. attribute:: encryption_password
                                        
                                        	Encryption password
                                        	**type**\:  str
                                        
                                        	**pattern:** (!.+)\|([^!].+)
                                        
                                        .. attribute:: spi
                                        
                                        	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                                        	**type**\:  int
                                        
                                        	**range:** 256..4294967295
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption, self).__init__()

                                            self.yang_name = "encryption"
                                            self.yang_parent_name = "virtual-link"

                                            self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                                            self.authentication_password = YLeaf(YType.str, "authentication-password")

                                            self.enable = YLeaf(YType.boolean, "enable")

                                            self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                                            self.encryption_password = YLeaf(YType.str, "encryption-password")

                                            self.spi = YLeaf(YType.uint32, "spi")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("authentication_algorithm",
                                                            "authentication_password",
                                                            "enable",
                                                            "encryption_algorithm",
                                                            "encryption_password",
                                                            "spi") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.authentication_algorithm.is_set or
                                                self.authentication_password.is_set or
                                                self.enable.is_set or
                                                self.encryption_algorithm.is_set or
                                                self.encryption_password.is_set or
                                                self.spi.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.authentication_algorithm.yfilter != YFilter.not_set or
                                                self.authentication_password.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.encryption_algorithm.yfilter != YFilter.not_set or
                                                self.encryption_password.yfilter != YFilter.not_set or
                                                self.spi.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "encryption" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                                            if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.authentication_password.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                                            if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.encryption_password.get_name_leafdata())
                                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.spi.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "authentication-algorithm"):
                                                self.authentication_algorithm = value
                                                self.authentication_algorithm.value_namespace = name_space
                                                self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "authentication-password"):
                                                self.authentication_password = value
                                                self.authentication_password.value_namespace = name_space
                                                self.authentication_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-algorithm"):
                                                self.encryption_algorithm = value
                                                self.encryption_algorithm.value_namespace = name_space
                                                self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                                            if(value_path == "encryption-password"):
                                                self.encryption_password = value
                                                self.encryption_password.value_namespace = name_space
                                                self.encryption_password.value_namespace_prefix = name_space_prefix
                                            if(value_path == "spi"):
                                                self.spi = value
                                                self.spi.value_namespace = name_space
                                                self.spi.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.virtual_link_address.is_set or
                                            self.dead_interval.is_set or
                                            self.enable.is_set or
                                            self.hello_interval.is_set or
                                            self.retransmit_interval.is_set or
                                            self.transmit_delay.is_set or
                                            (self.authentication is not None and self.authentication.has_data()) or
                                            (self.encryption is not None and self.encryption.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.virtual_link_address.yfilter != YFilter.not_set or
                                            self.dead_interval.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hello_interval.yfilter != YFilter.not_set or
                                            self.retransmit_interval.yfilter != YFilter.not_set or
                                            self.transmit_delay.yfilter != YFilter.not_set or
                                            (self.authentication is not None and self.authentication.has_operation()) or
                                            (self.encryption is not None and self.encryption.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "virtual-link" + "[virtual-link-address='" + self.virtual_link_address.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.virtual_link_address.is_set or self.virtual_link_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_link_address.get_name_leafdata())
                                        if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                        if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                        if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "authentication"):
                                            if (self.authentication is None):
                                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Authentication()
                                                self.authentication.parent = self
                                                self._children_name_map["authentication"] = "authentication"
                                            return self.authentication

                                        if (child_yang_name == "encryption"):
                                            if (self.encryption is None):
                                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink.Encryption()
                                                self.encryption.parent = self
                                                self._children_name_map["encryption"] = "encryption"
                                            return self.encryption

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "authentication" or name == "encryption" or name == "virtual-link-address" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "retransmit-interval" or name == "transmit-delay"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "virtual-link-address"):
                                            self.virtual_link_address = value
                                            self.virtual_link_address.value_namespace = name_space
                                            self.virtual_link_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dead-interval"):
                                            self.dead_interval = value
                                            self.dead_interval.value_namespace = name_space
                                            self.dead_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hello-interval"):
                                            self.hello_interval = value
                                            self.hello_interval.value_namespace = name_space
                                            self.hello_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retransmit-interval"):
                                            self.retransmit_interval = value
                                            self.retransmit_interval.value_namespace = name_space
                                            self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-delay"):
                                            self.transmit_delay = value
                                            self.transmit_delay.value_namespace = name_space
                                            self.transmit_delay.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.virtual_link:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.virtual_link:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "virtual-links" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "virtual-link"):
                                        for c in self.virtual_link:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks.VirtualLink()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.virtual_link.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "virtual-link"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.area_id.is_set or
                                    self.cost.is_set or
                                    self.dead_interval.is_set or
                                    self.default_cost.is_set or
                                    self.demand_circuit.is_set or
                                    self.enable.is_set or
                                    self.flood_reduction.is_set or
                                    self.hello_interval.is_set or
                                    self.instance.is_set or
                                    self.ldp_sync.is_set or
                                    self.mtu_ignore.is_set or
                                    self.network.is_set or
                                    self.packet_size.is_set or
                                    self.passive.is_set or
                                    self.prefix_suppression.is_set or
                                    self.priority.is_set or
                                    self.retransmit_interval.is_set or
                                    self.stub.is_set or
                                    self.transmit_delay.is_set or
                                    (self.area_scope is not None and self.area_scope.has_data()) or
                                    (self.authentication is not None and self.authentication.has_data()) or
                                    (self.bfd is not None and self.bfd.has_data()) or
                                    (self.database_filter is not None and self.database_filter.has_data()) or
                                    (self.distribute_list is not None and self.distribute_list.has_data()) or
                                    (self.encryption is not None and self.encryption.has_data()) or
                                    (self.interfaces is not None and self.interfaces.has_data()) or
                                    (self.nssa is not None and self.nssa.has_data()) or
                                    (self.ranges is not None and self.ranges.has_data()) or
                                    (self.sham_links is not None and self.sham_links.has_data()) or
                                    (self.virtual_links is not None and self.virtual_links.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area_id.yfilter != YFilter.not_set or
                                    self.cost.yfilter != YFilter.not_set or
                                    self.dead_interval.yfilter != YFilter.not_set or
                                    self.default_cost.yfilter != YFilter.not_set or
                                    self.demand_circuit.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.flood_reduction.yfilter != YFilter.not_set or
                                    self.hello_interval.yfilter != YFilter.not_set or
                                    self.instance.yfilter != YFilter.not_set or
                                    self.ldp_sync.yfilter != YFilter.not_set or
                                    self.mtu_ignore.yfilter != YFilter.not_set or
                                    self.network.yfilter != YFilter.not_set or
                                    self.packet_size.yfilter != YFilter.not_set or
                                    self.passive.yfilter != YFilter.not_set or
                                    self.prefix_suppression.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    self.retransmit_interval.yfilter != YFilter.not_set or
                                    self.stub.yfilter != YFilter.not_set or
                                    self.transmit_delay.yfilter != YFilter.not_set or
                                    (self.area_scope is not None and self.area_scope.has_operation()) or
                                    (self.authentication is not None and self.authentication.has_operation()) or
                                    (self.bfd is not None and self.bfd.has_operation()) or
                                    (self.database_filter is not None and self.database_filter.has_operation()) or
                                    (self.distribute_list is not None and self.distribute_list.has_operation()) or
                                    (self.encryption is not None and self.encryption.has_operation()) or
                                    (self.interfaces is not None and self.interfaces.has_operation()) or
                                    (self.nssa is not None and self.nssa.has_operation()) or
                                    (self.ranges is not None and self.ranges.has_operation()) or
                                    (self.sham_links is not None and self.sham_links.has_operation()) or
                                    (self.virtual_links is not None and self.virtual_links.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "area-area-id" + "[area-id='" + self.area_id.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area_id.get_name_leafdata())
                                if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cost.get_name_leafdata())
                                if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                if (self.default_cost.is_set or self.default_cost.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_cost.get_name_leafdata())
                                if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                                if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.instance.get_name_leafdata())
                                if (self.ldp_sync.is_set or self.ldp_sync.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_sync.get_name_leafdata())
                                if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.network.get_name_leafdata())
                                if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.packet_size.get_name_leafdata())
                                if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.passive.get_name_leafdata())
                                if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                if (self.stub.is_set or self.stub.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stub.get_name_leafdata())
                                if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "area-scope"):
                                    if (self.area_scope is None):
                                        self.area_scope = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.AreaScope()
                                        self.area_scope.parent = self
                                        self._children_name_map["area_scope"] = "area-scope"
                                    return self.area_scope

                                if (child_yang_name == "authentication"):
                                    if (self.authentication is None):
                                        self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Authentication()
                                        self.authentication.parent = self
                                        self._children_name_map["authentication"] = "authentication"
                                    return self.authentication

                                if (child_yang_name == "bfd"):
                                    if (self.bfd is None):
                                        self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Bfd()
                                        self.bfd.parent = self
                                        self._children_name_map["bfd"] = "bfd"
                                    return self.bfd

                                if (child_yang_name == "database-filter"):
                                    if (self.database_filter is None):
                                        self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DatabaseFilter()
                                        self.database_filter.parent = self
                                        self._children_name_map["database_filter"] = "database-filter"
                                    return self.database_filter

                                if (child_yang_name == "distribute-list"):
                                    if (self.distribute_list is None):
                                        self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.DistributeList()
                                        self.distribute_list.parent = self
                                        self._children_name_map["distribute_list"] = "distribute-list"
                                    return self.distribute_list

                                if (child_yang_name == "encryption"):
                                    if (self.encryption is None):
                                        self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Encryption()
                                        self.encryption.parent = self
                                        self._children_name_map["encryption"] = "encryption"
                                    return self.encryption

                                if (child_yang_name == "interfaces"):
                                    if (self.interfaces is None):
                                        self.interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Interfaces()
                                        self.interfaces.parent = self
                                        self._children_name_map["interfaces"] = "interfaces"
                                    return self.interfaces

                                if (child_yang_name == "nssa"):
                                    if (self.nssa is None):
                                        self.nssa = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Nssa()
                                        self.nssa.parent = self
                                        self._children_name_map["nssa"] = "nssa"
                                    return self.nssa

                                if (child_yang_name == "ranges"):
                                    if (self.ranges is None):
                                        self.ranges = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.Ranges()
                                        self.ranges.parent = self
                                        self._children_name_map["ranges"] = "ranges"
                                    return self.ranges

                                if (child_yang_name == "sham-links"):
                                    if (self.sham_links is None):
                                        self.sham_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.ShamLinks()
                                        self.sham_links.parent = self
                                        self._children_name_map["sham_links"] = "sham-links"
                                    return self.sham_links

                                if (child_yang_name == "virtual-links"):
                                    if (self.virtual_links is None):
                                        self.virtual_links = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId.VirtualLinks()
                                        self.virtual_links.parent = self
                                        self._children_name_map["virtual_links"] = "virtual-links"
                                    return self.virtual_links

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area-scope" or name == "authentication" or name == "bfd" or name == "database-filter" or name == "distribute-list" or name == "encryption" or name == "interfaces" or name == "nssa" or name == "ranges" or name == "sham-links" or name == "virtual-links" or name == "area-id" or name == "cost" or name == "dead-interval" or name == "default-cost" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "ldp-sync" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "stub" or name == "transmit-delay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area-id"):
                                    self.area_id = value
                                    self.area_id.value_namespace = name_space
                                    self.area_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "cost"):
                                    self.cost = value
                                    self.cost.value_namespace = name_space
                                    self.cost.value_namespace_prefix = name_space_prefix
                                if(value_path == "dead-interval"):
                                    self.dead_interval = value
                                    self.dead_interval.value_namespace = name_space
                                    self.dead_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-cost"):
                                    self.default_cost = value
                                    self.default_cost.value_namespace = name_space
                                    self.default_cost.value_namespace_prefix = name_space_prefix
                                if(value_path == "demand-circuit"):
                                    self.demand_circuit = value
                                    self.demand_circuit.value_namespace = name_space
                                    self.demand_circuit.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "flood-reduction"):
                                    self.flood_reduction = value
                                    self.flood_reduction.value_namespace = name_space
                                    self.flood_reduction.value_namespace_prefix = name_space_prefix
                                if(value_path == "hello-interval"):
                                    self.hello_interval = value
                                    self.hello_interval.value_namespace = name_space
                                    self.hello_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "instance"):
                                    self.instance = value
                                    self.instance.value_namespace = name_space
                                    self.instance.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-sync"):
                                    self.ldp_sync = value
                                    self.ldp_sync.value_namespace = name_space
                                    self.ldp_sync.value_namespace_prefix = name_space_prefix
                                if(value_path == "mtu-ignore"):
                                    self.mtu_ignore = value
                                    self.mtu_ignore.value_namespace = name_space
                                    self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                if(value_path == "network"):
                                    self.network = value
                                    self.network.value_namespace = name_space
                                    self.network.value_namespace_prefix = name_space_prefix
                                if(value_path == "packet-size"):
                                    self.packet_size = value
                                    self.packet_size.value_namespace = name_space
                                    self.packet_size.value_namespace_prefix = name_space_prefix
                                if(value_path == "passive"):
                                    self.passive = value
                                    self.passive.value_namespace = name_space
                                    self.passive.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-suppression"):
                                    self.prefix_suppression = value
                                    self.prefix_suppression.value_namespace = name_space
                                    self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "retransmit-interval"):
                                    self.retransmit_interval = value
                                    self.retransmit_interval.value_namespace = name_space
                                    self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "stub"):
                                    self.stub = value
                                    self.stub.value_namespace = name_space
                                    self.stub.value_namespace_prefix = name_space_prefix
                                if(value_path == "transmit-delay"):
                                    self.transmit_delay = value
                                    self.transmit_delay.value_namespace = name_space
                                    self.transmit_delay.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.area_address:
                                if (c.has_data()):
                                    return True
                            for c in self.area_area_id:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.area_address:
                                if (c.has_operation()):
                                    return True
                            for c in self.area_area_id:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "area-addresses" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "area-address"):
                                for c in self.area_address:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAddress()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.area_address.append(c)
                                return c

                            if (child_yang_name == "area-area-id"):
                                for c in self.area_area_id:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses.AreaAreaId()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.area_area_id.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "area-address" or name == "area-area-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Timers(Entity):
                        """
                        Adjust routing timers
                        
                        .. attribute:: lsa_timers
                        
                        	LSA timers
                        	**type**\:   :py:class:`LsaTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Timers.LsaTimers>`
                        
                        .. attribute:: pacing
                        
                        	Pacing timers
                        	**type**\:   :py:class:`Pacing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Pacing>`
                        
                        .. attribute:: throttle
                        
                        	Throttle timers
                        	**type**\:   :py:class:`Throttle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers, self).__init__()

                            self.yang_name = "timers"
                            self.yang_parent_name = "vrf"

                            self.lsa_timers = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.LsaTimers()
                            self.lsa_timers.parent = self
                            self._children_name_map["lsa_timers"] = "lsa-timers"
                            self._children_yang_names.add("lsa-timers")

                            self.pacing = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Pacing()
                            self.pacing.parent = self
                            self._children_name_map["pacing"] = "pacing"
                            self._children_yang_names.add("pacing")

                            self.throttle = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle()
                            self.throttle.parent = self
                            self._children_name_map["throttle"] = "throttle"
                            self._children_yang_names.add("throttle")


                        class Pacing(Entity):
                            """
                            Pacing timers
                            
                            .. attribute:: flood
                            
                            	The minimum interval in milliseconds to pace limit flooding on interface
                            	**type**\:  int
                            
                            	**range:** 5..100
                            
                            	**units**\: millisecond
                            
                            .. attribute:: lsa_group
                            
                            	Interval in seconds at which LSAs are grouped and refreshed, checksummed, or aged
                            	**type**\:  int
                            
                            	**range:** 10..1800
                            
                            	**units**\: second
                            
                            .. attribute:: retransmission
                            
                            	The minimum interval in msec between neighbor retransmissions
                            	**type**\:  int
                            
                            	**range:** 5..100
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Pacing, self).__init__()

                                self.yang_name = "pacing"
                                self.yang_parent_name = "timers"

                                self.flood = YLeaf(YType.uint32, "flood")

                                self.lsa_group = YLeaf(YType.uint32, "lsa-group")

                                self.retransmission = YLeaf(YType.uint32, "retransmission")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("flood",
                                                "lsa_group",
                                                "retransmission") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Pacing, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Pacing, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.flood.is_set or
                                    self.lsa_group.is_set or
                                    self.retransmission.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.flood.yfilter != YFilter.not_set or
                                    self.lsa_group.yfilter != YFilter.not_set or
                                    self.retransmission.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "pacing" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.flood.is_set or self.flood.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.flood.get_name_leafdata())
                                if (self.lsa_group.is_set or self.lsa_group.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_group.get_name_leafdata())
                                if (self.retransmission.is_set or self.retransmission.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retransmission.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "flood" or name == "lsa-group" or name == "retransmission"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "flood"):
                                    self.flood = value
                                    self.flood.value_namespace = name_space
                                    self.flood.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-group"):
                                    self.lsa_group = value
                                    self.lsa_group.value_namespace = name_space
                                    self.lsa_group.value_namespace_prefix = name_space_prefix
                                if(value_path == "retransmission"):
                                    self.retransmission = value
                                    self.retransmission.value_namespace = name_space
                                    self.retransmission.value_namespace_prefix = name_space_prefix


                        class LsaTimers(Entity):
                            """
                            LSA timers
                            
                            .. attribute:: arrival
                            
                            	The minimum interval in milliseconds between accepting the same LSA
                            	**type**\:  int
                            
                            	**range:** 0..60000
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.LsaTimers, self).__init__()

                                self.yang_name = "lsa-timers"
                                self.yang_parent_name = "timers"

                                self.arrival = YLeaf(YType.uint32, "arrival")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("arrival") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.LsaTimers, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.LsaTimers, self).__setattr__(name, value)

                            def has_data(self):
                                return self.arrival.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.arrival.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa-timers" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.arrival.is_set or self.arrival.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.arrival.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "arrival"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "arrival"):
                                    self.arrival = value
                                    self.arrival.value_namespace = name_space
                                    self.arrival.value_namespace_prefix = name_space_prefix


                        class Throttle(Entity):
                            """
                            Throttle timers
                            
                            .. attribute:: lsa
                            
                            	LSA throttle timers for all types of OSPF LSAs
                            	**type**\:   :py:class:`Lsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Lsa>`
                            
                            .. attribute:: spf
                            
                            	SPF throttle timers
                            	**type**\:   :py:class:`Spf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Spf>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle, self).__init__()

                                self.yang_name = "throttle"
                                self.yang_parent_name = "timers"

                                self.lsa = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Lsa()
                                self.lsa.parent = self
                                self._children_name_map["lsa"] = "lsa"
                                self._children_yang_names.add("lsa")

                                self.spf = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Spf()
                                self.spf.parent = self
                                self._children_name_map["spf"] = "spf"
                                self._children_yang_names.add("spf")


                            class Lsa(Entity):
                                """
                                LSA throttle timers for all types of OSPF LSAs
                                
                                .. attribute:: first_delay
                                
                                	Delay to generate first occurrence of LSA in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..600000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: maximum_delay
                                
                                	Maximum delay between originating the same LSA in milliseconds
                                	**type**\:  int
                                
                                	**range:** 1..600000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: minimum_delay
                                
                                	Minimum delay between originating the same LSA in milliseconds
                                	**type**\:  int
                                
                                	**range:** 1..600000
                                
                                	**units**\: millisecond
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Lsa, self).__init__()

                                    self.yang_name = "lsa"
                                    self.yang_parent_name = "throttle"

                                    self.first_delay = YLeaf(YType.uint32, "first-delay")

                                    self.maximum_delay = YLeaf(YType.uint32, "maximum-delay")

                                    self.minimum_delay = YLeaf(YType.uint32, "minimum-delay")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("first_delay",
                                                    "maximum_delay",
                                                    "minimum_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Lsa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Lsa, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.first_delay.is_set or
                                        self.maximum_delay.is_set or
                                        self.minimum_delay.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.first_delay.yfilter != YFilter.not_set or
                                        self.maximum_delay.yfilter != YFilter.not_set or
                                        self.minimum_delay.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lsa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.first_delay.is_set or self.first_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.first_delay.get_name_leafdata())
                                    if (self.maximum_delay.is_set or self.maximum_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_delay.get_name_leafdata())
                                    if (self.minimum_delay.is_set or self.minimum_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.minimum_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "first-delay" or name == "maximum-delay" or name == "minimum-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "first-delay"):
                                        self.first_delay = value
                                        self.first_delay.value_namespace = name_space
                                        self.first_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "maximum-delay"):
                                        self.maximum_delay = value
                                        self.maximum_delay.value_namespace = name_space
                                        self.maximum_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "minimum-delay"):
                                        self.minimum_delay = value
                                        self.minimum_delay.value_namespace = name_space
                                        self.minimum_delay.value_namespace_prefix = name_space_prefix


                            class Spf(Entity):
                                """
                                SPF throttle timers
                                
                                .. attribute:: first_delay
                                
                                	Initial delay between receiving a change and starting SPF in ms
                                	**type**\:  int
                                
                                	**range:** 1..600000
                                
                                .. attribute:: maximum_delay
                                
                                	Maximum wait time between consecutive SPF calculations in ms
                                	**type**\:  int
                                
                                	**range:** 1..600000
                                
                                .. attribute:: minimum_delay
                                
                                	Minimum hold time between consecutive SPF calculations in ms
                                	**type**\:  int
                                
                                	**range:** 1..600000
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Spf, self).__init__()

                                    self.yang_name = "spf"
                                    self.yang_parent_name = "throttle"

                                    self.first_delay = YLeaf(YType.uint32, "first-delay")

                                    self.maximum_delay = YLeaf(YType.uint32, "maximum-delay")

                                    self.minimum_delay = YLeaf(YType.uint32, "minimum-delay")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("first_delay",
                                                    "maximum_delay",
                                                    "minimum_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Spf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Spf, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.first_delay.is_set or
                                        self.maximum_delay.is_set or
                                        self.minimum_delay.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.first_delay.yfilter != YFilter.not_set or
                                        self.maximum_delay.yfilter != YFilter.not_set or
                                        self.minimum_delay.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "spf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.first_delay.is_set or self.first_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.first_delay.get_name_leafdata())
                                    if (self.maximum_delay.is_set or self.maximum_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_delay.get_name_leafdata())
                                    if (self.minimum_delay.is_set or self.minimum_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.minimum_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "first-delay" or name == "maximum-delay" or name == "minimum-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "first-delay"):
                                        self.first_delay = value
                                        self.first_delay.value_namespace = name_space
                                        self.first_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "maximum-delay"):
                                        self.maximum_delay = value
                                        self.maximum_delay.value_namespace = name_space
                                        self.maximum_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "minimum-delay"):
                                        self.minimum_delay = value
                                        self.minimum_delay.value_namespace = name_space
                                        self.minimum_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.lsa is not None and self.lsa.has_data()) or
                                    (self.spf is not None and self.spf.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.lsa is not None and self.lsa.has_operation()) or
                                    (self.spf is not None and self.spf.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "throttle" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lsa"):
                                    if (self.lsa is None):
                                        self.lsa = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Lsa()
                                        self.lsa.parent = self
                                        self._children_name_map["lsa"] = "lsa"
                                    return self.lsa

                                if (child_yang_name == "spf"):
                                    if (self.spf is None):
                                        self.spf = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle.Spf()
                                        self.spf.parent = self
                                        self._children_name_map["spf"] = "spf"
                                    return self.spf

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lsa" or name == "spf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.lsa_timers is not None and self.lsa_timers.has_data()) or
                                (self.pacing is not None and self.pacing.has_data()) or
                                (self.throttle is not None and self.throttle.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.lsa_timers is not None and self.lsa_timers.has_operation()) or
                                (self.pacing is not None and self.pacing.has_operation()) or
                                (self.throttle is not None and self.throttle.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "timers" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsa-timers"):
                                if (self.lsa_timers is None):
                                    self.lsa_timers = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.LsaTimers()
                                    self.lsa_timers.parent = self
                                    self._children_name_map["lsa_timers"] = "lsa-timers"
                                return self.lsa_timers

                            if (child_yang_name == "pacing"):
                                if (self.pacing is None):
                                    self.pacing = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Pacing()
                                    self.pacing.parent = self
                                    self._children_name_map["pacing"] = "pacing"
                                return self.pacing

                            if (child_yang_name == "throttle"):
                                if (self.throttle is None):
                                    self.throttle = Ospfv3.Processes.Process.Vrfs.Vrf.Timers.Throttle()
                                    self.throttle.parent = self
                                    self._children_name_map["throttle"] = "throttle"
                                return self.throttle

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsa-timers" or name == "pacing" or name == "throttle"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class SummaryPrefixes(Entity):
                        """
                        Summarize redistributed routes matching
                        prefix/length
                        
                        .. attribute:: summary_prefix
                        
                        	IPv6 address
                        	**type**\: list of    :py:class:`SummaryPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes.SummaryPrefix>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes, self).__init__()

                            self.yang_name = "summary-prefixes"
                            self.yang_parent_name = "vrf"

                            self.summary_prefix = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes, self).__setattr__(name, value)


                        class SummaryPrefix(Entity):
                            """
                            IPv6 address
                            
                            .. attribute:: prefix  <key>
                            
                            	IPv6 prefix string format
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: prefix_length  <key>
                            
                            	IPV6 prefix length
                            	**type**\:  int
                            
                            	**range:** 0..128
                            
                            .. attribute:: not_advertise
                            
                            	Suppress routes matching prefix/length
                            	**type**\:  bool
                            
                            .. attribute:: tag
                            
                            	Tag
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes.SummaryPrefix, self).__init__()

                                self.yang_name = "summary-prefix"
                                self.yang_parent_name = "summary-prefixes"

                                self.prefix = YLeaf(YType.str, "prefix")

                                self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                self.not_advertise = YLeaf(YType.boolean, "not-advertise")

                                self.tag = YLeaf(YType.uint32, "tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("prefix",
                                                "prefix_length",
                                                "not_advertise",
                                                "tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.prefix.is_set or
                                    self.prefix_length.is_set or
                                    self.not_advertise.is_set or
                                    self.tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.prefix.yfilter != YFilter.not_set or
                                    self.prefix_length.yfilter != YFilter.not_set or
                                    self.not_advertise.yfilter != YFilter.not_set or
                                    self.tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "summary-prefix" + "[prefix='" + self.prefix.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix.get_name_leafdata())
                                if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                if (self.not_advertise.is_set or self.not_advertise.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.not_advertise.get_name_leafdata())
                                if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "prefix" or name == "prefix-length" or name == "not-advertise" or name == "tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "prefix"):
                                    self.prefix = value
                                    self.prefix.value_namespace = name_space
                                    self.prefix.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-length"):
                                    self.prefix_length = value
                                    self.prefix_length.value_namespace = name_space
                                    self.prefix_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "not-advertise"):
                                    self.not_advertise = value
                                    self.not_advertise.value_namespace = name_space
                                    self.not_advertise.value_namespace_prefix = name_space_prefix
                                if(value_path == "tag"):
                                    self.tag = value
                                    self.tag.value_namespace = name_space
                                    self.tag.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.summary_prefix:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.summary_prefix:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "summary-prefixes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "summary-prefix"):
                                for c in self.summary_prefix:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes.SummaryPrefix()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.summary_prefix.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "summary-prefix"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Snmp(Entity):
                        """
                        SNMP configuration
                        
                        .. attribute:: context
                        
                        	SNMP context configuration
                        	**type**\:  str
                        
                        .. attribute:: trap_rate_limit
                        
                        	SNMP trap rate configuration
                        	**type**\:   :py:class:`TrapRateLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Snmp.TrapRateLimit>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Snmp, self).__init__()

                            self.yang_name = "snmp"
                            self.yang_parent_name = "vrf"

                            self.context = YLeaf(YType.str, "context")

                            self.trap_rate_limit = Ospfv3.Processes.Process.Vrfs.Vrf.Snmp.TrapRateLimit()
                            self.trap_rate_limit.parent = self
                            self._children_name_map["trap_rate_limit"] = "trap-rate-limit"
                            self._children_yang_names.add("trap-rate-limit")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("context") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Snmp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Snmp, self).__setattr__(name, value)


                        class TrapRateLimit(Entity):
                            """
                            SNMP trap rate configuration
                            
                            .. attribute:: max_window_traps
                            
                            	Max number of traps sent in window time
                            	**type**\:  int
                            
                            	**range:** 0..300
                            
                            .. attribute:: window_size
                            
                            	Trap rate limit sliding window size
                            	**type**\:  int
                            
                            	**range:** 2..60
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Snmp.TrapRateLimit, self).__init__()

                                self.yang_name = "trap-rate-limit"
                                self.yang_parent_name = "snmp"

                                self.max_window_traps = YLeaf(YType.uint32, "max-window-traps")

                                self.window_size = YLeaf(YType.uint32, "window-size")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_window_traps",
                                                "window_size") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Snmp.TrapRateLimit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Snmp.TrapRateLimit, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_window_traps.is_set or
                                    self.window_size.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_window_traps.yfilter != YFilter.not_set or
                                    self.window_size.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trap-rate-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_window_traps.is_set or self.max_window_traps.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_window_traps.get_name_leafdata())
                                if (self.window_size.is_set or self.window_size.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.window_size.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-window-traps" or name == "window-size"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-window-traps"):
                                    self.max_window_traps = value
                                    self.max_window_traps.value_namespace = name_space
                                    self.max_window_traps.value_namespace_prefix = name_space_prefix
                                if(value_path == "window-size"):
                                    self.window_size = value
                                    self.window_size.value_namespace = name_space
                                    self.window_size.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.context.is_set or
                                (self.trap_rate_limit is not None and self.trap_rate_limit.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.context.yfilter != YFilter.not_set or
                                (self.trap_rate_limit is not None and self.trap_rate_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "snmp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.context.is_set or self.context.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.context.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "trap-rate-limit"):
                                if (self.trap_rate_limit is None):
                                    self.trap_rate_limit = Ospfv3.Processes.Process.Vrfs.Vrf.Snmp.TrapRateLimit()
                                    self.trap_rate_limit.parent = self
                                    self._children_name_map["trap_rate_limit"] = "trap-rate-limit"
                                return self.trap_rate_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "trap-rate-limit" or name == "context"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "context"):
                                self.context = value
                                self.context.value_namespace = name_space
                                self.context.value_namespace_prefix = name_space_prefix


                    class FastReroute(Entity):
                        """
                        Fast\-reroute instance scoped parameters
                        
                        .. attribute:: per_link
                        
                        	Fast\-reroute per\-link global configuration
                        	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerLink>`
                        
                        .. attribute:: per_prefix
                        
                        	Fast\-reroute per\-prefix global configuration
                        	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute, self).__init__()

                            self.yang_name = "fast-reroute"
                            self.yang_parent_name = "vrf"

                            self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerLink()
                            self.per_link.parent = self
                            self._children_name_map["per_link"] = "per-link"
                            self._children_yang_names.add("per-link")

                            self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix()
                            self.per_prefix.parent = self
                            self._children_name_map["per_prefix"] = "per-prefix"
                            self._children_yang_names.add("per-prefix")


                        class PerLink(Entity):
                            """
                            Fast\-reroute per\-link global configuration
                            
                            .. attribute:: priority
                            
                            	Fast\-reroute per\-link/per\-prefix priority\-limit command
                            	**type**\:   :py:class:`Ospfv3FastReroutePriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroutePriority>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerLink, self).__init__()

                                self.yang_name = "per-link"
                                self.yang_parent_name = "fast-reroute"

                                self.priority = YLeaf(YType.enumeration, "priority")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("priority") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerLink, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerLink, self).__setattr__(name, value)

                            def has_data(self):
                                return self.priority.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "per-link" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix


                        class PerPrefix(Entity):
                            """
                            Fast\-reroute per\-prefix global configuration
                            
                            .. attribute:: load_sharing_disable
                            
                            	Disable load sharing between multiple backups
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: priority
                            
                            	Fast\-reroute per\-link/per\-prefix priority\-limit command
                            	**type**\:   :py:class:`Ospfv3FastReroutePriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroutePriority>`
                            
                            .. attribute:: tiebreakers
                            
                            	Fast\-reroute tiebreakers configurations
                            	**type**\:   :py:class:`Tiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix, self).__init__()

                                self.yang_name = "per-prefix"
                                self.yang_parent_name = "fast-reroute"

                                self.load_sharing_disable = YLeaf(YType.empty, "load-sharing-disable")

                                self.priority = YLeaf(YType.enumeration, "priority")

                                self.tiebreakers = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers()
                                self.tiebreakers.parent = self
                                self._children_name_map["tiebreakers"] = "tiebreakers"
                                self._children_yang_names.add("tiebreakers")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("load_sharing_disable",
                                                "priority") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix, self).__setattr__(name, value)


                            class Tiebreakers(Entity):
                                """
                                Fast\-reroute tiebreakers configurations
                                
                                .. attribute:: tiebreaker
                                
                                	Fast\-reroute tiebreakers configuration
                                	**type**\: list of    :py:class:`Tiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers, self).__init__()

                                    self.yang_name = "tiebreakers"
                                    self.yang_parent_name = "per-prefix"

                                    self.tiebreaker = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers, self).__setattr__(name, value)


                                class Tiebreaker(Entity):
                                    """
                                    Fast\-reroute tiebreakers configuration
                                    
                                    .. attribute:: tiebreaker_type  <key>
                                    
                                    	Tiebreaker type
                                    	**type**\:   :py:class:`Ospfv3FastRerouteTiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastRerouteTiebreakers>`
                                    
                                    .. attribute:: tiebreaker_index
                                    
                                    	Index value for a tiebreaker
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker, self).__init__()

                                        self.yang_name = "tiebreaker"
                                        self.yang_parent_name = "tiebreakers"

                                        self.tiebreaker_type = YLeaf(YType.enumeration, "tiebreaker-type")

                                        self.tiebreaker_index = YLeaf(YType.uint32, "tiebreaker-index")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("tiebreaker_type",
                                                        "tiebreaker_index") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.tiebreaker_type.is_set or
                                            self.tiebreaker_index.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.tiebreaker_type.yfilter != YFilter.not_set or
                                            self.tiebreaker_index.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "tiebreaker" + "[tiebreaker-type='" + self.tiebreaker_type.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.tiebreaker_type.is_set or self.tiebreaker_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tiebreaker_type.get_name_leafdata())
                                        if (self.tiebreaker_index.is_set or self.tiebreaker_index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tiebreaker_index.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "tiebreaker-type" or name == "tiebreaker-index"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "tiebreaker-type"):
                                            self.tiebreaker_type = value
                                            self.tiebreaker_type.value_namespace = name_space
                                            self.tiebreaker_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tiebreaker-index"):
                                            self.tiebreaker_index = value
                                            self.tiebreaker_index.value_namespace = name_space
                                            self.tiebreaker_index.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.tiebreaker:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.tiebreaker:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "tiebreakers" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "tiebreaker"):
                                        for c in self.tiebreaker:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers.Tiebreaker()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.tiebreaker.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "tiebreaker"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.load_sharing_disable.is_set or
                                    self.priority.is_set or
                                    (self.tiebreakers is not None and self.tiebreakers.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.load_sharing_disable.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    (self.tiebreakers is not None and self.tiebreakers.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "per-prefix" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.load_sharing_disable.is_set or self.load_sharing_disable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.load_sharing_disable.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "tiebreakers"):
                                    if (self.tiebreakers is None):
                                        self.tiebreakers = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix.Tiebreakers()
                                        self.tiebreakers.parent = self
                                        self._children_name_map["tiebreakers"] = "tiebreakers"
                                    return self.tiebreakers

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "tiebreakers" or name == "load-sharing-disable" or name == "priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "load-sharing-disable"):
                                    self.load_sharing_disable = value
                                    self.load_sharing_disable.value_namespace = name_space
                                    self.load_sharing_disable.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.per_link is not None and self.per_link.has_data()) or
                                (self.per_prefix is not None and self.per_prefix.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.per_link is not None and self.per_link.has_operation()) or
                                (self.per_prefix is not None and self.per_prefix.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "fast-reroute" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "per-link"):
                                if (self.per_link is None):
                                    self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerLink()
                                    self.per_link.parent = self
                                    self._children_name_map["per_link"] = "per-link"
                                return self.per_link

                            if (child_yang_name == "per-prefix"):
                                if (self.per_prefix is None):
                                    self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute.PerPrefix()
                                    self.per_prefix.parent = self
                                    self._children_name_map["per_prefix"] = "per-prefix"
                                return self.per_prefix

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "per-link" or name == "per-prefix"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Distance(Entity):
                        """
                        Define an administrative distance
                        
                        .. attribute:: administrative
                        
                        	Define an administrative distance
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        .. attribute:: ospfv3
                        
                        	OSPFv3 administrative distance
                        	**type**\:   :py:class:`Ospfv3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Distance.Ospfv3>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Distance, self).__init__()

                            self.yang_name = "distance"
                            self.yang_parent_name = "vrf"

                            self.administrative = YLeaf(YType.uint32, "administrative")

                            self.ospfv3 = Ospfv3.Processes.Process.Vrfs.Vrf.Distance.Ospfv3()
                            self.ospfv3.parent = self
                            self._children_name_map["ospfv3"] = "ospfv3"
                            self._children_yang_names.add("ospfv3")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("administrative") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Distance, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Distance, self).__setattr__(name, value)


                        class Ospfv3(Entity):
                            """
                            OSPFv3 administrative distance
                            
                            .. attribute:: external
                            
                            	Distance for external type 5 and type 7 routes
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            .. attribute:: inter_area
                            
                            	Distance for inter\-area routes
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            .. attribute:: intra_area
                            
                            	Distance for intra\-area routes
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Distance.Ospfv3, self).__init__()

                                self.yang_name = "ospfv3"
                                self.yang_parent_name = "distance"

                                self.external = YLeaf(YType.uint32, "external")

                                self.inter_area = YLeaf(YType.uint32, "inter-area")

                                self.intra_area = YLeaf(YType.uint32, "intra-area")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("external",
                                                "inter_area",
                                                "intra_area") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Distance.Ospfv3, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Distance.Ospfv3, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.external.is_set or
                                    self.inter_area.is_set or
                                    self.intra_area.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.external.yfilter != YFilter.not_set or
                                    self.inter_area.yfilter != YFilter.not_set or
                                    self.intra_area.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ospfv3" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.external.is_set or self.external.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external.get_name_leafdata())
                                if (self.inter_area.is_set or self.inter_area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.inter_area.get_name_leafdata())
                                if (self.intra_area.is_set or self.intra_area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.intra_area.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "external" or name == "inter-area" or name == "intra-area"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "external"):
                                    self.external = value
                                    self.external.value_namespace = name_space
                                    self.external.value_namespace_prefix = name_space_prefix
                                if(value_path == "inter-area"):
                                    self.inter_area = value
                                    self.inter_area.value_namespace = name_space
                                    self.inter_area.value_namespace_prefix = name_space_prefix
                                if(value_path == "intra-area"):
                                    self.intra_area = value
                                    self.intra_area.value_namespace = name_space
                                    self.intra_area.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.administrative.is_set or
                                (self.ospfv3 is not None and self.ospfv3.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.administrative.yfilter != YFilter.not_set or
                                (self.ospfv3 is not None and self.ospfv3.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "distance" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.administrative.is_set or self.administrative.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.administrative.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ospfv3"):
                                if (self.ospfv3 is None):
                                    self.ospfv3 = Ospfv3.Processes.Process.Vrfs.Vrf.Distance.Ospfv3()
                                    self.ospfv3.parent = self
                                    self._children_name_map["ospfv3"] = "ospfv3"
                                return self.ospfv3

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ospfv3" or name == "administrative"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "administrative"):
                                self.administrative = value
                                self.administrative.value_namespace = name_space
                                self.administrative.value_namespace_prefix = name_space_prefix


                    class Maximum(Entity):
                        """
                        Set OSPFv3 limits
                        
                        .. attribute:: interfaces
                        
                        	Specify maximum number of interfaces
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: paths
                        
                        	Specify maximum number of paths per route
                        	**type**\:  int
                        
                        	**range:** 1..64
                        
                        .. attribute:: redistributed_prefixes
                        
                        	Limit number of redistributed prefixes
                        	**type**\:   :py:class:`RedistributedPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Maximum.RedistributedPrefixes>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Maximum, self).__init__()

                            self.yang_name = "maximum"
                            self.yang_parent_name = "vrf"

                            self.interfaces = YLeaf(YType.uint32, "interfaces")

                            self.paths = YLeaf(YType.uint32, "paths")

                            self.redistributed_prefixes = Ospfv3.Processes.Process.Vrfs.Vrf.Maximum.RedistributedPrefixes()
                            self.redistributed_prefixes.parent = self
                            self._children_name_map["redistributed_prefixes"] = "redistributed-prefixes"
                            self._children_yang_names.add("redistributed-prefixes")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interfaces",
                                            "paths") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Maximum, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Maximum, self).__setattr__(name, value)


                        class RedistributedPrefixes(Entity):
                            """
                            Limit number of redistributed prefixes
                            
                            .. attribute:: prefixes
                            
                            	Maximum number of prefixes redistributed to protocol
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            .. attribute:: threshold
                            
                            	Threshold value (%) at which to generate a warning message
                            	**type**\:  int
                            
                            	**range:** 1..100
                            
                            .. attribute:: warning_only
                            
                            	Only give warning message when limit is exceeded
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Maximum.RedistributedPrefixes, self).__init__()

                                self.yang_name = "redistributed-prefixes"
                                self.yang_parent_name = "maximum"

                                self.prefixes = YLeaf(YType.uint32, "prefixes")

                                self.threshold = YLeaf(YType.uint32, "threshold")

                                self.warning_only = YLeaf(YType.empty, "warning-only")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("prefixes",
                                                "threshold",
                                                "warning_only") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Maximum.RedistributedPrefixes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Maximum.RedistributedPrefixes, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.prefixes.is_set or
                                    self.threshold.is_set or
                                    self.warning_only.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.prefixes.yfilter != YFilter.not_set or
                                    self.threshold.yfilter != YFilter.not_set or
                                    self.warning_only.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "redistributed-prefixes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.prefixes.is_set or self.prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefixes.get_name_leafdata())
                                if (self.threshold.is_set or self.threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.threshold.get_name_leafdata())
                                if (self.warning_only.is_set or self.warning_only.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.warning_only.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "prefixes" or name == "threshold" or name == "warning-only"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "prefixes"):
                                    self.prefixes = value
                                    self.prefixes.value_namespace = name_space
                                    self.prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "threshold"):
                                    self.threshold = value
                                    self.threshold.value_namespace = name_space
                                    self.threshold.value_namespace_prefix = name_space_prefix
                                if(value_path == "warning-only"):
                                    self.warning_only = value
                                    self.warning_only.value_namespace = name_space
                                    self.warning_only.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.interfaces.is_set or
                                self.paths.is_set or
                                (self.redistributed_prefixes is not None and self.redistributed_prefixes.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interfaces.yfilter != YFilter.not_set or
                                self.paths.yfilter != YFilter.not_set or
                                (self.redistributed_prefixes is not None and self.redistributed_prefixes.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "maximum" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interfaces.is_set or self.interfaces.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interfaces.get_name_leafdata())
                            if (self.paths.is_set or self.paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.paths.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "redistributed-prefixes"):
                                if (self.redistributed_prefixes is None):
                                    self.redistributed_prefixes = Ospfv3.Processes.Process.Vrfs.Vrf.Maximum.RedistributedPrefixes()
                                    self.redistributed_prefixes.parent = self
                                    self._children_name_map["redistributed_prefixes"] = "redistributed-prefixes"
                                return self.redistributed_prefixes

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "redistributed-prefixes" or name == "interfaces" or name == "paths"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interfaces"):
                                self.interfaces = value
                                self.interfaces.value_namespace = name_space
                                self.interfaces.value_namespace_prefix = name_space_prefix
                            if(value_path == "paths"):
                                self.paths = value
                                self.paths.value_namespace = name_space
                                self.paths.value_namespace_prefix = name_space_prefix


                    class Redistributes(Entity):
                        """
                        Redistribute information from another routing
                        protocol
                        
                        .. attribute:: redistribute
                        
                        	Redistribute information from another routing protocol
                        	**type**\: list of    :py:class:`Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes, self).__init__()

                            self.yang_name = "redistributes"
                            self.yang_parent_name = "vrf"

                            self.redistribute = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes, self).__setattr__(name, value)


                        class Redistribute(Entity):
                            """
                            Redistribute information from another routing
                            protocol
                            
                            .. attribute:: protocol_name  <key>
                            
                            	Protocol
                            	**type**\:   :py:class:`Ospfv3ProtocolType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ProtocolType2>`
                            
                            .. attribute:: bgp
                            
                            	bgp
                            	**type**\: list of    :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Bgp>`
                            
                            .. attribute:: connected_or_static_or_subscriber_or_mobile
                            
                            	connected or static or subscriber or mobile
                            	**type**\:   :py:class:`ConnectedOrStaticOrSubscriberOrMobile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile>`
                            
                            	**presence node**\: True
                            
                            .. attribute:: eigrp
                            
                            	eigrp
                            	**type**\: list of    :py:class:`Eigrp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Eigrp>`
                            
                            .. attribute:: ospfv3_or_isis_or_application
                            
                            	ospfv3 or isis or application
                            	**type**\: list of    :py:class:`Ospfv3OrIsisOrApplication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute, self).__init__()

                                self.yang_name = "redistribute"
                                self.yang_parent_name = "redistributes"

                                self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                                self.connected_or_static_or_subscriber_or_mobile = None
                                self._children_name_map["connected_or_static_or_subscriber_or_mobile"] = "connected-or-static-or-subscriber-or-mobile"
                                self._children_yang_names.add("connected-or-static-or-subscriber-or-mobile")

                                self.bgp = YList(self)
                                self.eigrp = YList(self)
                                self.ospfv3_or_isis_or_application = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("protocol_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute, self).__setattr__(name, value)


                            class ConnectedOrStaticOrSubscriberOrMobile(Entity):
                                """
                                connected or static or subscriber or mobile
                                
                                .. attribute:: default_metric
                                
                                	OSPFv3 default metric
                                	**type**\:  int
                                
                                	**range:** 0..16777214
                                
                                .. attribute:: eigrp_route_type
                                
                                	EIGRP route type
                                	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                                
                                .. attribute:: external_route_type
                                
                                	Redistribute OSPFv3 external routes
                                	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                                
                                .. attribute:: internal_route_type
                                
                                	Redistribute OSPFv3 routes
                                	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                                
                                .. attribute:: isis_route_type
                                
                                	ISIS route type
                                	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                                
                                .. attribute:: metric_type
                                
                                	OSPFv3 exterior metric type for redistributed routes
                                	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                                
                                .. attribute:: nssa_external_route_type
                                
                                	Redistribute OSPFv3 NSSA external routes
                                	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                                
                                .. attribute:: preserve_med
                                
                                	Preserve (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: preserve_med_info
                                
                                	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: redistribute_route
                                
                                	Redistribution of OSPFv3 routes
                                	**type**\:  bool
                                
                                .. attribute:: route_policy_name
                                
                                	Route policy to redistribution
                                	**type**\:  str
                                
                                .. attribute:: tag
                                
                                	Tag for routes redistributed into OSPFv3
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile, self).__init__()

                                    self.yang_name = "connected-or-static-or-subscriber-or-mobile"
                                    self.yang_parent_name = "redistribute"
                                    self.is_presence_container = True

                                    self.default_metric = YLeaf(YType.uint32, "default-metric")

                                    self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                    self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                    self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                    self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                    self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                    self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                    self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                    self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    self.tag = YLeaf(YType.int32, "tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("default_metric",
                                                    "eigrp_route_type",
                                                    "external_route_type",
                                                    "internal_route_type",
                                                    "isis_route_type",
                                                    "metric_type",
                                                    "nssa_external_route_type",
                                                    "preserve_med",
                                                    "preserve_med_info",
                                                    "redistribute_route",
                                                    "route_policy_name",
                                                    "tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.default_metric.is_set or
                                        self.eigrp_route_type.is_set or
                                        self.external_route_type.is_set or
                                        self.internal_route_type.is_set or
                                        self.isis_route_type.is_set or
                                        self.metric_type.is_set or
                                        self.nssa_external_route_type.is_set or
                                        self.preserve_med.is_set or
                                        self.preserve_med_info.is_set or
                                        self.redistribute_route.is_set or
                                        self.route_policy_name.is_set or
                                        self.tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.default_metric.yfilter != YFilter.not_set or
                                        self.eigrp_route_type.yfilter != YFilter.not_set or
                                        self.external_route_type.yfilter != YFilter.not_set or
                                        self.internal_route_type.yfilter != YFilter.not_set or
                                        self.isis_route_type.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.nssa_external_route_type.yfilter != YFilter.not_set or
                                        self.preserve_med.yfilter != YFilter.not_set or
                                        self.preserve_med_info.yfilter != YFilter.not_set or
                                        self.redistribute_route.yfilter != YFilter.not_set or
                                        self.route_policy_name.yfilter != YFilter.not_set or
                                        self.tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "connected-or-static-or-subscriber-or-mobile" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.default_metric.get_name_leafdata())
                                    if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                    if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                    if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                    if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                    if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                    if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                    if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                    if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                    if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "default-metric"):
                                        self.default_metric = value
                                        self.default_metric.value_namespace = name_space
                                        self.default_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "eigrp-route-type"):
                                        self.eigrp_route_type = value
                                        self.eigrp_route_type.value_namespace = name_space
                                        self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "external-route-type"):
                                        self.external_route_type = value
                                        self.external_route_type.value_namespace = name_space
                                        self.external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "internal-route-type"):
                                        self.internal_route_type = value
                                        self.internal_route_type.value_namespace = name_space
                                        self.internal_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "isis-route-type"):
                                        self.isis_route_type = value
                                        self.isis_route_type.value_namespace = name_space
                                        self.isis_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "nssa-external-route-type"):
                                        self.nssa_external_route_type = value
                                        self.nssa_external_route_type.value_namespace = name_space
                                        self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med"):
                                        self.preserve_med = value
                                        self.preserve_med.value_namespace = name_space
                                        self.preserve_med.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med-info"):
                                        self.preserve_med_info = value
                                        self.preserve_med_info.value_namespace = name_space
                                        self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                    if(value_path == "redistribute-route"):
                                        self.redistribute_route = value
                                        self.redistribute_route.value_namespace = name_space
                                        self.redistribute_route.value_namespace_prefix = name_space_prefix
                                    if(value_path == "route-policy-name"):
                                        self.route_policy_name = value
                                        self.route_policy_name.value_namespace = name_space
                                        self.route_policy_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag"):
                                        self.tag = value
                                        self.tag.value_namespace = name_space
                                        self.tag.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                bgp
                                
                                .. attribute:: as_xx  <key>
                                
                                	4\-byte AS number in asdot (X.Y) format \- first half (X)
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: as_yy  <key>
                                
                                	4\-byte AS number in asdot (X.Y) format \- second half (Y), or 2\-byte AS number, or 4\-byte AS number in asplain format
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: default_metric
                                
                                	OSPFv3 default metric
                                	**type**\:  int
                                
                                	**range:** 0..16777214
                                
                                .. attribute:: eigrp_route_type
                                
                                	EIGRP route type
                                	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                                
                                .. attribute:: external_route_type
                                
                                	Redistribute OSPFv3 external routes
                                	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                                
                                .. attribute:: internal_route_type
                                
                                	Redistribute OSPFv3 routes
                                	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                                
                                .. attribute:: isis_route_type
                                
                                	ISIS route type
                                	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                                
                                .. attribute:: metric_type
                                
                                	OSPFv3 exterior metric type for redistributed routes
                                	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                                
                                .. attribute:: nssa_external_route_type
                                
                                	Redistribute OSPFv3 NSSA external routes
                                	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                                
                                .. attribute:: preserve_med
                                
                                	Preserve (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: preserve_med_info
                                
                                	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: redistribute_route
                                
                                	Redistribution of OSPFv3 routes
                                	**type**\:  bool
                                
                                .. attribute:: route_policy_name
                                
                                	Route policy to redistribution
                                	**type**\:  str
                                
                                .. attribute:: tag
                                
                                	Tag for routes redistributed into OSPFv3
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "redistribute"

                                    self.as_xx = YLeaf(YType.uint32, "as-xx")

                                    self.as_yy = YLeaf(YType.uint32, "as-yy")

                                    self.default_metric = YLeaf(YType.uint32, "default-metric")

                                    self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                    self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                    self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                    self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                    self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                    self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                    self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                    self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    self.tag = YLeaf(YType.int32, "tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("as_xx",
                                                    "as_yy",
                                                    "default_metric",
                                                    "eigrp_route_type",
                                                    "external_route_type",
                                                    "internal_route_type",
                                                    "isis_route_type",
                                                    "metric_type",
                                                    "nssa_external_route_type",
                                                    "preserve_med",
                                                    "preserve_med_info",
                                                    "redistribute_route",
                                                    "route_policy_name",
                                                    "tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Bgp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.as_xx.is_set or
                                        self.as_yy.is_set or
                                        self.default_metric.is_set or
                                        self.eigrp_route_type.is_set or
                                        self.external_route_type.is_set or
                                        self.internal_route_type.is_set or
                                        self.isis_route_type.is_set or
                                        self.metric_type.is_set or
                                        self.nssa_external_route_type.is_set or
                                        self.preserve_med.is_set or
                                        self.preserve_med_info.is_set or
                                        self.redistribute_route.is_set or
                                        self.route_policy_name.is_set or
                                        self.tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.as_xx.yfilter != YFilter.not_set or
                                        self.as_yy.yfilter != YFilter.not_set or
                                        self.default_metric.yfilter != YFilter.not_set or
                                        self.eigrp_route_type.yfilter != YFilter.not_set or
                                        self.external_route_type.yfilter != YFilter.not_set or
                                        self.internal_route_type.yfilter != YFilter.not_set or
                                        self.isis_route_type.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.nssa_external_route_type.yfilter != YFilter.not_set or
                                        self.preserve_med.yfilter != YFilter.not_set or
                                        self.preserve_med_info.yfilter != YFilter.not_set or
                                        self.redistribute_route.yfilter != YFilter.not_set or
                                        self.route_policy_name.yfilter != YFilter.not_set or
                                        self.tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + "[as-xx='" + self.as_xx.get() + "']" + "[as-yy='" + self.as_yy.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.as_xx.get_name_leafdata())
                                    if (self.as_yy.is_set or self.as_yy.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.as_yy.get_name_leafdata())
                                    if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.default_metric.get_name_leafdata())
                                    if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                    if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                    if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                    if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                    if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                    if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                    if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                    if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                    if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "as-xx" or name == "as-yy" or name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "as-xx"):
                                        self.as_xx = value
                                        self.as_xx.value_namespace = name_space
                                        self.as_xx.value_namespace_prefix = name_space_prefix
                                    if(value_path == "as-yy"):
                                        self.as_yy = value
                                        self.as_yy.value_namespace = name_space
                                        self.as_yy.value_namespace_prefix = name_space_prefix
                                    if(value_path == "default-metric"):
                                        self.default_metric = value
                                        self.default_metric.value_namespace = name_space
                                        self.default_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "eigrp-route-type"):
                                        self.eigrp_route_type = value
                                        self.eigrp_route_type.value_namespace = name_space
                                        self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "external-route-type"):
                                        self.external_route_type = value
                                        self.external_route_type.value_namespace = name_space
                                        self.external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "internal-route-type"):
                                        self.internal_route_type = value
                                        self.internal_route_type.value_namespace = name_space
                                        self.internal_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "isis-route-type"):
                                        self.isis_route_type = value
                                        self.isis_route_type.value_namespace = name_space
                                        self.isis_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "nssa-external-route-type"):
                                        self.nssa_external_route_type = value
                                        self.nssa_external_route_type.value_namespace = name_space
                                        self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med"):
                                        self.preserve_med = value
                                        self.preserve_med.value_namespace = name_space
                                        self.preserve_med.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med-info"):
                                        self.preserve_med_info = value
                                        self.preserve_med_info.value_namespace = name_space
                                        self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                    if(value_path == "redistribute-route"):
                                        self.redistribute_route = value
                                        self.redistribute_route.value_namespace = name_space
                                        self.redistribute_route.value_namespace_prefix = name_space_prefix
                                    if(value_path == "route-policy-name"):
                                        self.route_policy_name = value
                                        self.route_policy_name.value_namespace = name_space
                                        self.route_policy_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag"):
                                        self.tag = value
                                        self.tag.value_namespace = name_space
                                        self.tag.value_namespace_prefix = name_space_prefix


                            class Ospfv3OrIsisOrApplication(Entity):
                                """
                                ospfv3 or isis or application
                                
                                .. attribute:: process_name  <key>
                                
                                	ISIS process name if protocol is ISIS, or OSPFv3 process name if protocol is OSPFv3
                                	**type**\:  str
                                
                                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                
                                .. attribute:: default_metric
                                
                                	OSPFv3 default metric
                                	**type**\:  int
                                
                                	**range:** 0..16777214
                                
                                .. attribute:: eigrp_route_type
                                
                                	EIGRP route type
                                	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                                
                                .. attribute:: external_route_type
                                
                                	Redistribute OSPFv3 external routes
                                	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                                
                                .. attribute:: internal_route_type
                                
                                	Redistribute OSPFv3 routes
                                	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                                
                                .. attribute:: isis_route_type
                                
                                	ISIS route type
                                	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                                
                                .. attribute:: metric_type
                                
                                	OSPFv3 exterior metric type for redistributed routes
                                	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                                
                                .. attribute:: nssa_external_route_type
                                
                                	Redistribute OSPFv3 NSSA external routes
                                	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                                
                                .. attribute:: preserve_med
                                
                                	Preserve (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: preserve_med_info
                                
                                	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: redistribute_route
                                
                                	Redistribution of OSPFv3 routes
                                	**type**\:  bool
                                
                                .. attribute:: route_policy_name
                                
                                	Route policy to redistribution
                                	**type**\:  str
                                
                                .. attribute:: tag
                                
                                	Tag for routes redistributed into OSPFv3
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication, self).__init__()

                                    self.yang_name = "ospfv3-or-isis-or-application"
                                    self.yang_parent_name = "redistribute"

                                    self.process_name = YLeaf(YType.str, "process-name")

                                    self.default_metric = YLeaf(YType.uint32, "default-metric")

                                    self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                    self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                    self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                    self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                    self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                    self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                    self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                    self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    self.tag = YLeaf(YType.int32, "tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("process_name",
                                                    "default_metric",
                                                    "eigrp_route_type",
                                                    "external_route_type",
                                                    "internal_route_type",
                                                    "isis_route_type",
                                                    "metric_type",
                                                    "nssa_external_route_type",
                                                    "preserve_med",
                                                    "preserve_med_info",
                                                    "redistribute_route",
                                                    "route_policy_name",
                                                    "tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.process_name.is_set or
                                        self.default_metric.is_set or
                                        self.eigrp_route_type.is_set or
                                        self.external_route_type.is_set or
                                        self.internal_route_type.is_set or
                                        self.isis_route_type.is_set or
                                        self.metric_type.is_set or
                                        self.nssa_external_route_type.is_set or
                                        self.preserve_med.is_set or
                                        self.preserve_med_info.is_set or
                                        self.redistribute_route.is_set or
                                        self.route_policy_name.is_set or
                                        self.tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.process_name.yfilter != YFilter.not_set or
                                        self.default_metric.yfilter != YFilter.not_set or
                                        self.eigrp_route_type.yfilter != YFilter.not_set or
                                        self.external_route_type.yfilter != YFilter.not_set or
                                        self.internal_route_type.yfilter != YFilter.not_set or
                                        self.isis_route_type.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.nssa_external_route_type.yfilter != YFilter.not_set or
                                        self.preserve_med.yfilter != YFilter.not_set or
                                        self.preserve_med_info.yfilter != YFilter.not_set or
                                        self.redistribute_route.yfilter != YFilter.not_set or
                                        self.route_policy_name.yfilter != YFilter.not_set or
                                        self.tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospfv3-or-isis-or-application" + "[process-name='" + self.process_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.process_name.get_name_leafdata())
                                    if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.default_metric.get_name_leafdata())
                                    if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                    if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                    if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                    if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                    if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                    if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                    if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                    if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                    if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "process-name" or name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "process-name"):
                                        self.process_name = value
                                        self.process_name.value_namespace = name_space
                                        self.process_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "default-metric"):
                                        self.default_metric = value
                                        self.default_metric.value_namespace = name_space
                                        self.default_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "eigrp-route-type"):
                                        self.eigrp_route_type = value
                                        self.eigrp_route_type.value_namespace = name_space
                                        self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "external-route-type"):
                                        self.external_route_type = value
                                        self.external_route_type.value_namespace = name_space
                                        self.external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "internal-route-type"):
                                        self.internal_route_type = value
                                        self.internal_route_type.value_namespace = name_space
                                        self.internal_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "isis-route-type"):
                                        self.isis_route_type = value
                                        self.isis_route_type.value_namespace = name_space
                                        self.isis_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "nssa-external-route-type"):
                                        self.nssa_external_route_type = value
                                        self.nssa_external_route_type.value_namespace = name_space
                                        self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med"):
                                        self.preserve_med = value
                                        self.preserve_med.value_namespace = name_space
                                        self.preserve_med.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med-info"):
                                        self.preserve_med_info = value
                                        self.preserve_med_info.value_namespace = name_space
                                        self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                    if(value_path == "redistribute-route"):
                                        self.redistribute_route = value
                                        self.redistribute_route.value_namespace = name_space
                                        self.redistribute_route.value_namespace_prefix = name_space_prefix
                                    if(value_path == "route-policy-name"):
                                        self.route_policy_name = value
                                        self.route_policy_name.value_namespace = name_space
                                        self.route_policy_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag"):
                                        self.tag = value
                                        self.tag.value_namespace = name_space
                                        self.tag.value_namespace_prefix = name_space_prefix


                            class Eigrp(Entity):
                                """
                                eigrp
                                
                                .. attribute:: as_xx  <key>
                                
                                	4\-byte AS number in asdot (X.Y) format \- first half (X)
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: default_metric
                                
                                	OSPFv3 default metric
                                	**type**\:  int
                                
                                	**range:** 0..16777214
                                
                                .. attribute:: eigrp_route_type
                                
                                	EIGRP route type
                                	**type**\:   :py:class:`Ospfv3EigrpRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EigrpRoute>`
                                
                                .. attribute:: external_route_type
                                
                                	Redistribute OSPFv3 external routes
                                	**type**\:   :py:class:`Ospfv3ExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3ExternalRoute>`
                                
                                .. attribute:: internal_route_type
                                
                                	Redistribute OSPFv3 routes
                                	**type**\:   :py:class:`Ospfv3InternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3InternalRoute>`
                                
                                .. attribute:: isis_route_type
                                
                                	ISIS route type
                                	**type**\:   :py:class:`Ospfv3IsisRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3IsisRoute>`
                                
                                .. attribute:: metric_type
                                
                                	OSPFv3 exterior metric type for redistributed routes
                                	**type**\:   :py:class:`Ospfv3Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Metric>`
                                
                                .. attribute:: nssa_external_route_type
                                
                                	Redistribute OSPFv3 NSSA external routes
                                	**type**\:   :py:class:`Ospfv3NssaExternalRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3NssaExternalRoute>`
                                
                                .. attribute:: preserve_med
                                
                                	Preserve (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: preserve_med_info
                                
                                	Preserve Information (Multi\-Exit Discriminator) of BGP routes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: redistribute_route
                                
                                	Redistribution of OSPFv3 routes
                                	**type**\:  bool
                                
                                .. attribute:: route_policy_name
                                
                                	Route policy to redistribution
                                	**type**\:  str
                                
                                .. attribute:: tag
                                
                                	Tag for routes redistributed into OSPFv3
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Eigrp, self).__init__()

                                    self.yang_name = "eigrp"
                                    self.yang_parent_name = "redistribute"

                                    self.as_xx = YLeaf(YType.uint32, "as-xx")

                                    self.default_metric = YLeaf(YType.uint32, "default-metric")

                                    self.eigrp_route_type = YLeaf(YType.enumeration, "eigrp-route-type")

                                    self.external_route_type = YLeaf(YType.enumeration, "external-route-type")

                                    self.internal_route_type = YLeaf(YType.enumeration, "internal-route-type")

                                    self.isis_route_type = YLeaf(YType.enumeration, "isis-route-type")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.nssa_external_route_type = YLeaf(YType.enumeration, "nssa-external-route-type")

                                    self.preserve_med = YLeaf(YType.empty, "preserve-med")

                                    self.preserve_med_info = YLeaf(YType.empty, "preserve-med-info")

                                    self.redistribute_route = YLeaf(YType.boolean, "redistribute-route")

                                    self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    self.tag = YLeaf(YType.int32, "tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("as_xx",
                                                    "default_metric",
                                                    "eigrp_route_type",
                                                    "external_route_type",
                                                    "internal_route_type",
                                                    "isis_route_type",
                                                    "metric_type",
                                                    "nssa_external_route_type",
                                                    "preserve_med",
                                                    "preserve_med_info",
                                                    "redistribute_route",
                                                    "route_policy_name",
                                                    "tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Eigrp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Eigrp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.as_xx.is_set or
                                        self.default_metric.is_set or
                                        self.eigrp_route_type.is_set or
                                        self.external_route_type.is_set or
                                        self.internal_route_type.is_set or
                                        self.isis_route_type.is_set or
                                        self.metric_type.is_set or
                                        self.nssa_external_route_type.is_set or
                                        self.preserve_med.is_set or
                                        self.preserve_med_info.is_set or
                                        self.redistribute_route.is_set or
                                        self.route_policy_name.is_set or
                                        self.tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.as_xx.yfilter != YFilter.not_set or
                                        self.default_metric.yfilter != YFilter.not_set or
                                        self.eigrp_route_type.yfilter != YFilter.not_set or
                                        self.external_route_type.yfilter != YFilter.not_set or
                                        self.internal_route_type.yfilter != YFilter.not_set or
                                        self.isis_route_type.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.nssa_external_route_type.yfilter != YFilter.not_set or
                                        self.preserve_med.yfilter != YFilter.not_set or
                                        self.preserve_med_info.yfilter != YFilter.not_set or
                                        self.redistribute_route.yfilter != YFilter.not_set or
                                        self.route_policy_name.yfilter != YFilter.not_set or
                                        self.tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "eigrp" + "[as-xx='" + self.as_xx.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.as_xx.get_name_leafdata())
                                    if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.default_metric.get_name_leafdata())
                                    if (self.eigrp_route_type.is_set or self.eigrp_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.eigrp_route_type.get_name_leafdata())
                                    if (self.external_route_type.is_set or self.external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.external_route_type.get_name_leafdata())
                                    if (self.internal_route_type.is_set or self.internal_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.internal_route_type.get_name_leafdata())
                                    if (self.isis_route_type.is_set or self.isis_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.isis_route_type.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.nssa_external_route_type.is_set or self.nssa_external_route_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.nssa_external_route_type.get_name_leafdata())
                                    if (self.preserve_med.is_set or self.preserve_med.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med.get_name_leafdata())
                                    if (self.preserve_med_info.is_set or self.preserve_med_info.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.preserve_med_info.get_name_leafdata())
                                    if (self.redistribute_route.is_set or self.redistribute_route.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.redistribute_route.get_name_leafdata())
                                    if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                    if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "as-xx" or name == "default-metric" or name == "eigrp-route-type" or name == "external-route-type" or name == "internal-route-type" or name == "isis-route-type" or name == "metric-type" or name == "nssa-external-route-type" or name == "preserve-med" or name == "preserve-med-info" or name == "redistribute-route" or name == "route-policy-name" or name == "tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "as-xx"):
                                        self.as_xx = value
                                        self.as_xx.value_namespace = name_space
                                        self.as_xx.value_namespace_prefix = name_space_prefix
                                    if(value_path == "default-metric"):
                                        self.default_metric = value
                                        self.default_metric.value_namespace = name_space
                                        self.default_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "eigrp-route-type"):
                                        self.eigrp_route_type = value
                                        self.eigrp_route_type.value_namespace = name_space
                                        self.eigrp_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "external-route-type"):
                                        self.external_route_type = value
                                        self.external_route_type.value_namespace = name_space
                                        self.external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "internal-route-type"):
                                        self.internal_route_type = value
                                        self.internal_route_type.value_namespace = name_space
                                        self.internal_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "isis-route-type"):
                                        self.isis_route_type = value
                                        self.isis_route_type.value_namespace = name_space
                                        self.isis_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "nssa-external-route-type"):
                                        self.nssa_external_route_type = value
                                        self.nssa_external_route_type.value_namespace = name_space
                                        self.nssa_external_route_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med"):
                                        self.preserve_med = value
                                        self.preserve_med.value_namespace = name_space
                                        self.preserve_med.value_namespace_prefix = name_space_prefix
                                    if(value_path == "preserve-med-info"):
                                        self.preserve_med_info = value
                                        self.preserve_med_info.value_namespace = name_space
                                        self.preserve_med_info.value_namespace_prefix = name_space_prefix
                                    if(value_path == "redistribute-route"):
                                        self.redistribute_route = value
                                        self.redistribute_route.value_namespace = name_space
                                        self.redistribute_route.value_namespace_prefix = name_space_prefix
                                    if(value_path == "route-policy-name"):
                                        self.route_policy_name = value
                                        self.route_policy_name.value_namespace = name_space
                                        self.route_policy_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag"):
                                        self.tag = value
                                        self.tag.value_namespace = name_space
                                        self.tag.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.bgp:
                                    if (c.has_data()):
                                        return True
                                for c in self.eigrp:
                                    if (c.has_data()):
                                        return True
                                for c in self.ospfv3_or_isis_or_application:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.protocol_name.is_set or
                                    (self.connected_or_static_or_subscriber_or_mobile is not None))

                            def has_operation(self):
                                for c in self.bgp:
                                    if (c.has_operation()):
                                        return True
                                for c in self.eigrp:
                                    if (c.has_operation()):
                                        return True
                                for c in self.ospfv3_or_isis_or_application:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.protocol_name.yfilter != YFilter.not_set or
                                    (self.connected_or_static_or_subscriber_or_mobile is not None and self.connected_or_static_or_subscriber_or_mobile.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "redistribute" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protocol_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bgp"):
                                    for c in self.bgp:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Bgp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.bgp.append(c)
                                    return c

                                if (child_yang_name == "connected-or-static-or-subscriber-or-mobile"):
                                    if (self.connected_or_static_or_subscriber_or_mobile is None):
                                        self.connected_or_static_or_subscriber_or_mobile = Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.ConnectedOrStaticOrSubscriberOrMobile()
                                        self.connected_or_static_or_subscriber_or_mobile.parent = self
                                        self._children_name_map["connected_or_static_or_subscriber_or_mobile"] = "connected-or-static-or-subscriber-or-mobile"
                                    return self.connected_or_static_or_subscriber_or_mobile

                                if (child_yang_name == "eigrp"):
                                    for c in self.eigrp:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Eigrp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.eigrp.append(c)
                                    return c

                                if (child_yang_name == "ospfv3-or-isis-or-application"):
                                    for c in self.ospfv3_or_isis_or_application:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute.Ospfv3OrIsisOrApplication()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.ospfv3_or_isis_or_application.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bgp" or name == "connected-or-static-or-subscriber-or-mobile" or name == "eigrp" or name == "ospfv3-or-isis-or-application" or name == "protocol-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "protocol-name"):
                                    self.protocol_name = value
                                    self.protocol_name.value_namespace = name_space
                                    self.protocol_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.redistribute:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.redistribute:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "redistributes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "redistribute"):
                                for c in self.redistribute:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes.Redistribute()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.redistribute.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "redistribute"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ignore(Entity):
                        """
                        Do not complain about a specified event
                        
                        .. attribute:: lsa
                        
                        	Do not complain upon receiving LSA of the specified type
                        	**type**\:   :py:class:`Lsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.Ignore.Lsa>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Ignore, self).__init__()

                            self.yang_name = "ignore"
                            self.yang_parent_name = "vrf"

                            self.lsa = Ospfv3.Processes.Process.Vrfs.Vrf.Ignore.Lsa()
                            self.lsa.parent = self
                            self._children_name_map["lsa"] = "lsa"
                            self._children_yang_names.add("lsa")


                        class Lsa(Entity):
                            """
                            Do not complain upon receiving LSA of the
                            specified type
                            
                            .. attribute:: mospf
                            
                            	Enable ignore of MOSPF type 6 LSA
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.Ignore.Lsa, self).__init__()

                                self.yang_name = "lsa"
                                self.yang_parent_name = "ignore"

                                self.mospf = YLeaf(YType.empty, "mospf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mospf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Ignore.Lsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Ignore.Lsa, self).__setattr__(name, value)

                            def has_data(self):
                                return self.mospf.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mospf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mospf.is_set or self.mospf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mospf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mospf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mospf"):
                                    self.mospf = value
                                    self.mospf.value_namespace = name_space
                                    self.mospf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (self.lsa is not None and self.lsa.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.lsa is not None and self.lsa.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ignore" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsa"):
                                if (self.lsa is None):
                                    self.lsa = Ospfv3.Processes.Process.Vrfs.Vrf.Ignore.Lsa()
                                    self.lsa.parent = self
                                    self._children_name_map["lsa"] = "lsa"
                                return self.lsa

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsa"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class DistributeListOut(Entity):
                        """
                        Filter prefixes from RIB 
                        
                        .. attribute:: distribute_outs
                        
                        	Filter generated type\-5 LSAs
                        	**type**\:   :py:class:`DistributeOuts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut, self).__init__()

                            self.yang_name = "distribute-list-out"
                            self.yang_parent_name = "vrf"

                            self.distribute_outs = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts()
                            self.distribute_outs.parent = self
                            self._children_name_map["distribute_outs"] = "distribute-outs"
                            self._children_yang_names.add("distribute-outs")


                        class DistributeOuts(Entity):
                            """
                            Filter generated type\-5 LSAs
                            
                            .. attribute:: distribute_out
                            
                            	Filter generated type\-5 LSAs
                            	**type**\: list of    :py:class:`DistributeOut <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts, self).__init__()

                                self.yang_name = "distribute-outs"
                                self.yang_parent_name = "distribute-list-out"

                                self.distribute_out = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts, self).__setattr__(name, value)


                            class DistributeOut(Entity):
                                """
                                Filter generated type\-5 LSAs
                                
                                .. attribute:: protocol_name  <key>
                                
                                	none
                                	**type**\:   :py:class:`Ospfv3Protocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Protocol>`
                                
                                .. attribute:: as_yy_and_as_xx_and_process_name
                                
                                	keys\: as\-yy, as\-xx, process\-name
                                	**type**\: list of    :py:class:`AsYyAndAsXxAndProcessName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName>`
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut, self).__init__()

                                    self.yang_name = "distribute-out"
                                    self.yang_parent_name = "distribute-outs"

                                    self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                                    self.as_yy_and_as_xx_and_process_name = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("protocol_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut, self).__setattr__(name, value)


                                class AsYyAndAsXxAndProcessName(Entity):
                                    """
                                    keys\: as\-yy, as\-xx, process\-name
                                    
                                    .. attribute:: as_yy  <key>
                                    
                                    	4\-byte AS number in asdot (X.Y) format \- second half (Y), or 2\-byte AS number, or 4\-byte AS number in asplain format
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: as_xx  <key>
                                    
                                    	4\-byte AS number in asdot (X.Y) format \- first half (X)
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    .. attribute:: process_name  <key>
                                    
                                    	If ISIS or OSPFv3, specify the instance name
                                    	**type**\:  str
                                    
                                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                    
                                    .. attribute:: prefix_list
                                    
                                    	Prefix\-list name
                                    	**type**\:  str
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName, self).__init__()

                                        self.yang_name = "as-yy-and-as-xx-and-process-name"
                                        self.yang_parent_name = "distribute-out"

                                        self.as_yy = YLeaf(YType.uint32, "as-yy")

                                        self.as_xx = YLeaf(YType.uint32, "as-xx")

                                        self.process_name = YLeaf(YType.str, "process-name")

                                        self.prefix_list = YLeaf(YType.str, "prefix-list")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("as_yy",
                                                        "as_xx",
                                                        "process_name",
                                                        "prefix_list") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.as_yy.is_set or
                                            self.as_xx.is_set or
                                            self.process_name.is_set or
                                            self.prefix_list.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.as_yy.yfilter != YFilter.not_set or
                                            self.as_xx.yfilter != YFilter.not_set or
                                            self.process_name.yfilter != YFilter.not_set or
                                            self.prefix_list.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "as-yy-and-as-xx-and-process-name" + "[as-yy='" + self.as_yy.get() + "']" + "[as-xx='" + self.as_xx.get() + "']" + "[process-name='" + self.process_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.as_yy.is_set or self.as_yy.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_yy.get_name_leafdata())
                                        if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_xx.get_name_leafdata())
                                        if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.process_name.get_name_leafdata())
                                        if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "as-yy" or name == "as-xx" or name == "process-name" or name == "prefix-list"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "as-yy"):
                                            self.as_yy = value
                                            self.as_yy.value_namespace = name_space
                                            self.as_yy.value_namespace_prefix = name_space_prefix
                                        if(value_path == "as-xx"):
                                            self.as_xx = value
                                            self.as_xx.value_namespace = name_space
                                            self.as_xx.value_namespace_prefix = name_space_prefix
                                        if(value_path == "process-name"):
                                            self.process_name = value
                                            self.process_name.value_namespace = name_space
                                            self.process_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-list"):
                                            self.prefix_list = value
                                            self.prefix_list.value_namespace = name_space
                                            self.prefix_list.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.as_yy_and_as_xx_and_process_name:
                                        if (c.has_data()):
                                            return True
                                    return self.protocol_name.is_set

                                def has_operation(self):
                                    for c in self.as_yy_and_as_xx_and_process_name:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.protocol_name.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "distribute-out" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.protocol_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "as-yy-and-as-xx-and-process-name"):
                                        for c in self.as_yy_and_as_xx_and_process_name:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut.AsYyAndAsXxAndProcessName()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.as_yy_and_as_xx_and_process_name.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "as-yy-and-as-xx-and-process-name" or name == "protocol-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "protocol-name"):
                                        self.protocol_name = value
                                        self.protocol_name.value_namespace = name_space
                                        self.protocol_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.distribute_out:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.distribute_out:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "distribute-outs" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "distribute-out"):
                                    for c in self.distribute_out:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts.DistributeOut()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.distribute_out.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "distribute-out"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.distribute_outs is not None and self.distribute_outs.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.distribute_outs is not None and self.distribute_outs.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "distribute-list-out" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "distribute-outs"):
                                if (self.distribute_outs is None):
                                    self.distribute_outs = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut.DistributeOuts()
                                    self.distribute_outs.parent = self
                                    self._children_name_map["distribute_outs"] = "distribute-outs"
                                return self.distribute_outs

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "distribute-outs"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class DistributeList(Entity):
                        """
                        Filter prefixes to/from RIB
                        
                        .. attribute:: in_
                        
                        	Filter prefixes installed to RIB
                        	**type**\:   :py:class:`In_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList.In_>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList, self).__init__()

                            self.yang_name = "distribute-list"
                            self.yang_parent_name = "vrf"

                            self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList.In_()
                            self.in_.parent = self
                            self._children_name_map["in_"] = "in"
                            self._children_yang_names.add("in")


                        class In_(Entity):
                            """
                            Filter prefixes installed to RIB
                            
                            .. attribute:: prefix_list
                            
                            	Filter prefixes based on an IPv6 prefix\-list
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList.In_, self).__init__()

                                self.yang_name = "in"
                                self.yang_parent_name = "distribute-list"

                                self.prefix_list = YLeaf(YType.str, "prefix-list")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("prefix_list") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList.In_, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList.In_, self).__setattr__(name, value)

                            def has_data(self):
                                return self.prefix_list.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.prefix_list.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "in" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "prefix-list"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "prefix-list"):
                                    self.prefix_list = value
                                    self.prefix_list.value_namespace = name_space
                                    self.prefix_list.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (self.in_ is not None and self.in_.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.in_ is not None and self.in_.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "distribute-list" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "in"):
                                if (self.in_ is None):
                                    self.in_ = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList.In_()
                                    self.in_.parent = self
                                    self._children_name_map["in_"] = "in"
                                return self.in_

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "in"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class StubRouter(Entity):
                        """
                        Stub router configuration
                        
                        .. attribute:: max_metric
                        
                        	Stub router max\-metric configuration
                        	**type**\:   :py:class:`MaxMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric>`
                        
                        .. attribute:: rbit
                        
                        	Stub router R\-bit configuration
                        	**type**\:   :py:class:`Rbit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit>`
                        
                        .. attribute:: v6bit
                        
                        	Stub router V6\-bit configuration
                        	**type**\:   :py:class:`V6Bit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter, self).__init__()

                            self.yang_name = "stub-router"
                            self.yang_parent_name = "vrf"

                            self.max_metric = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric()
                            self.max_metric.parent = self
                            self._children_name_map["max_metric"] = "max-metric"
                            self._children_yang_names.add("max-metric")

                            self.rbit = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit()
                            self.rbit.parent = self
                            self._children_name_map["rbit"] = "rbit"
                            self._children_yang_names.add("rbit")

                            self.v6bit = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit()
                            self.v6bit.parent = self
                            self._children_name_map["v6bit"] = "v6bit"
                            self._children_yang_names.add("v6bit")


                        class Rbit(Entity):
                            """
                            Stub router R\-bit configuration
                            
                            .. attribute:: always
                            
                            	Unconditionally enter stub router operational state
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: enable
                            
                            	Enabled stub router configuration mode
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: external_lsa
                            
                            	Advertise external LSAs with modified metric in stub router mode
                            	**type**\:  int
                            
                            	**range:** 1..16777214
                            
                            	**default value**\: 16711680
                            
                            .. attribute:: include_stub
                            
                            	Advertise stub links with maximum metric in stub router mode
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: on_proc_migration
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: on_proc_restart
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: on_startup
                            
                            	Enter stub router operational state on startup
                            	**type**\:   :py:class:`OnStartup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit.OnStartup>`
                            
                            .. attribute:: on_switchover
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: summary_lsa
                            
                            	Advertise summary LSAs with modified metric in stub router mode
                            	**type**\:  int
                            
                            	**range:** 1..16777214
                            
                            	**default value**\: 16711680
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit, self).__init__()

                                self.yang_name = "rbit"
                                self.yang_parent_name = "stub-router"

                                self.always = YLeaf(YType.empty, "always")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.external_lsa = YLeaf(YType.uint32, "external-lsa")

                                self.include_stub = YLeaf(YType.empty, "include-stub")

                                self.on_proc_migration = YLeaf(YType.uint32, "on-proc-migration")

                                self.on_proc_restart = YLeaf(YType.uint32, "on-proc-restart")

                                self.on_switchover = YLeaf(YType.uint32, "on-switchover")

                                self.summary_lsa = YLeaf(YType.uint32, "summary-lsa")

                                self.on_startup = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit.OnStartup()
                                self.on_startup.parent = self
                                self._children_name_map["on_startup"] = "on-startup"
                                self._children_yang_names.add("on-startup")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("always",
                                                "enable",
                                                "external_lsa",
                                                "include_stub",
                                                "on_proc_migration",
                                                "on_proc_restart",
                                                "on_switchover",
                                                "summary_lsa") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit, self).__setattr__(name, value)


                            class OnStartup(Entity):
                                """
                                Enter stub router operational state on startup
                                
                                .. attribute:: wait_for_bgp
                                
                                	Wait until BGP converges (only applicable to default VRF)
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: wait_time
                                
                                	Time (in seconds) to stay in stub router operational state
                                	**type**\:  int
                                
                                	**range:** 5..86400
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit.OnStartup, self).__init__()

                                    self.yang_name = "on-startup"
                                    self.yang_parent_name = "rbit"

                                    self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                    self.wait_time = YLeaf(YType.uint32, "wait-time")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("wait_for_bgp",
                                                    "wait_time") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit.OnStartup, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit.OnStartup, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.wait_for_bgp.is_set or
                                        self.wait_time.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.wait_for_bgp.yfilter != YFilter.not_set or
                                        self.wait_time.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "on-startup" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())
                                    if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wait_time.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "wait-for-bgp" or name == "wait-time"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "wait-for-bgp"):
                                        self.wait_for_bgp = value
                                        self.wait_for_bgp.value_namespace = name_space
                                        self.wait_for_bgp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wait-time"):
                                        self.wait_time = value
                                        self.wait_time.value_namespace = name_space
                                        self.wait_time.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.always.is_set or
                                    self.enable.is_set or
                                    self.external_lsa.is_set or
                                    self.include_stub.is_set or
                                    self.on_proc_migration.is_set or
                                    self.on_proc_restart.is_set or
                                    self.on_switchover.is_set or
                                    self.summary_lsa.is_set or
                                    (self.on_startup is not None and self.on_startup.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.always.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.external_lsa.yfilter != YFilter.not_set or
                                    self.include_stub.yfilter != YFilter.not_set or
                                    self.on_proc_migration.yfilter != YFilter.not_set or
                                    self.on_proc_restart.yfilter != YFilter.not_set or
                                    self.on_switchover.yfilter != YFilter.not_set or
                                    self.summary_lsa.yfilter != YFilter.not_set or
                                    (self.on_startup is not None and self.on_startup.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "rbit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.always.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.include_stub.get_name_leafdata())
                                if (self.on_proc_migration.is_set or self.on_proc_migration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_proc_migration.get_name_leafdata())
                                if (self.on_proc_restart.is_set or self.on_proc_restart.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_proc_restart.get_name_leafdata())
                                if (self.on_switchover.is_set or self.on_switchover.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_switchover.get_name_leafdata())
                                if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.summary_lsa.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "on-startup"):
                                    if (self.on_startup is None):
                                        self.on_startup = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit.OnStartup()
                                        self.on_startup.parent = self
                                        self._children_name_map["on_startup"] = "on-startup"
                                    return self.on_startup

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "on-startup" or name == "always" or name == "enable" or name == "external-lsa" or name == "include-stub" or name == "on-proc-migration" or name == "on-proc-restart" or name == "on-switchover" or name == "summary-lsa"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "always"):
                                    self.always = value
                                    self.always.value_namespace = name_space
                                    self.always.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-lsa"):
                                    self.external_lsa = value
                                    self.external_lsa.value_namespace = name_space
                                    self.external_lsa.value_namespace_prefix = name_space_prefix
                                if(value_path == "include-stub"):
                                    self.include_stub = value
                                    self.include_stub.value_namespace = name_space
                                    self.include_stub.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-proc-migration"):
                                    self.on_proc_migration = value
                                    self.on_proc_migration.value_namespace = name_space
                                    self.on_proc_migration.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-proc-restart"):
                                    self.on_proc_restart = value
                                    self.on_proc_restart.value_namespace = name_space
                                    self.on_proc_restart.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-switchover"):
                                    self.on_switchover = value
                                    self.on_switchover.value_namespace = name_space
                                    self.on_switchover.value_namespace_prefix = name_space_prefix
                                if(value_path == "summary-lsa"):
                                    self.summary_lsa = value
                                    self.summary_lsa.value_namespace = name_space
                                    self.summary_lsa.value_namespace_prefix = name_space_prefix


                        class V6Bit(Entity):
                            """
                            Stub router V6\-bit configuration
                            
                            .. attribute:: always
                            
                            	Unconditionally enter stub router operational state
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: enable
                            
                            	Enabled stub router configuration mode
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: external_lsa
                            
                            	Advertise external LSAs with modified metric in stub router mode
                            	**type**\:  int
                            
                            	**range:** 1..16777214
                            
                            	**default value**\: 16711680
                            
                            .. attribute:: include_stub
                            
                            	Advertise stub links with maximum metric in stub router mode
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: on_proc_migration
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: on_proc_restart
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: on_startup
                            
                            	Enter stub router operational state on startup
                            	**type**\:   :py:class:`OnStartup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit.OnStartup>`
                            
                            .. attribute:: on_switchover
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: summary_lsa
                            
                            	Advertise summary LSAs with modified metric in stub router mode
                            	**type**\:  int
                            
                            	**range:** 1..16777214
                            
                            	**default value**\: 16711680
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit, self).__init__()

                                self.yang_name = "v6bit"
                                self.yang_parent_name = "stub-router"

                                self.always = YLeaf(YType.empty, "always")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.external_lsa = YLeaf(YType.uint32, "external-lsa")

                                self.include_stub = YLeaf(YType.empty, "include-stub")

                                self.on_proc_migration = YLeaf(YType.uint32, "on-proc-migration")

                                self.on_proc_restart = YLeaf(YType.uint32, "on-proc-restart")

                                self.on_switchover = YLeaf(YType.uint32, "on-switchover")

                                self.summary_lsa = YLeaf(YType.uint32, "summary-lsa")

                                self.on_startup = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit.OnStartup()
                                self.on_startup.parent = self
                                self._children_name_map["on_startup"] = "on-startup"
                                self._children_yang_names.add("on-startup")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("always",
                                                "enable",
                                                "external_lsa",
                                                "include_stub",
                                                "on_proc_migration",
                                                "on_proc_restart",
                                                "on_switchover",
                                                "summary_lsa") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit, self).__setattr__(name, value)


                            class OnStartup(Entity):
                                """
                                Enter stub router operational state on startup
                                
                                .. attribute:: wait_for_bgp
                                
                                	Wait until BGP converges (only applicable to default VRF)
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: wait_time
                                
                                	Time (in seconds) to stay in stub router operational state
                                	**type**\:  int
                                
                                	**range:** 5..86400
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit.OnStartup, self).__init__()

                                    self.yang_name = "on-startup"
                                    self.yang_parent_name = "v6bit"

                                    self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                    self.wait_time = YLeaf(YType.uint32, "wait-time")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("wait_for_bgp",
                                                    "wait_time") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit.OnStartup, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit.OnStartup, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.wait_for_bgp.is_set or
                                        self.wait_time.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.wait_for_bgp.yfilter != YFilter.not_set or
                                        self.wait_time.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "on-startup" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())
                                    if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wait_time.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "wait-for-bgp" or name == "wait-time"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "wait-for-bgp"):
                                        self.wait_for_bgp = value
                                        self.wait_for_bgp.value_namespace = name_space
                                        self.wait_for_bgp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wait-time"):
                                        self.wait_time = value
                                        self.wait_time.value_namespace = name_space
                                        self.wait_time.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.always.is_set or
                                    self.enable.is_set or
                                    self.external_lsa.is_set or
                                    self.include_stub.is_set or
                                    self.on_proc_migration.is_set or
                                    self.on_proc_restart.is_set or
                                    self.on_switchover.is_set or
                                    self.summary_lsa.is_set or
                                    (self.on_startup is not None and self.on_startup.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.always.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.external_lsa.yfilter != YFilter.not_set or
                                    self.include_stub.yfilter != YFilter.not_set or
                                    self.on_proc_migration.yfilter != YFilter.not_set or
                                    self.on_proc_restart.yfilter != YFilter.not_set or
                                    self.on_switchover.yfilter != YFilter.not_set or
                                    self.summary_lsa.yfilter != YFilter.not_set or
                                    (self.on_startup is not None and self.on_startup.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v6bit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.always.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.include_stub.get_name_leafdata())
                                if (self.on_proc_migration.is_set or self.on_proc_migration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_proc_migration.get_name_leafdata())
                                if (self.on_proc_restart.is_set or self.on_proc_restart.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_proc_restart.get_name_leafdata())
                                if (self.on_switchover.is_set or self.on_switchover.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_switchover.get_name_leafdata())
                                if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.summary_lsa.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "on-startup"):
                                    if (self.on_startup is None):
                                        self.on_startup = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit.OnStartup()
                                        self.on_startup.parent = self
                                        self._children_name_map["on_startup"] = "on-startup"
                                    return self.on_startup

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "on-startup" or name == "always" or name == "enable" or name == "external-lsa" or name == "include-stub" or name == "on-proc-migration" or name == "on-proc-restart" or name == "on-switchover" or name == "summary-lsa"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "always"):
                                    self.always = value
                                    self.always.value_namespace = name_space
                                    self.always.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-lsa"):
                                    self.external_lsa = value
                                    self.external_lsa.value_namespace = name_space
                                    self.external_lsa.value_namespace_prefix = name_space_prefix
                                if(value_path == "include-stub"):
                                    self.include_stub = value
                                    self.include_stub.value_namespace = name_space
                                    self.include_stub.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-proc-migration"):
                                    self.on_proc_migration = value
                                    self.on_proc_migration.value_namespace = name_space
                                    self.on_proc_migration.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-proc-restart"):
                                    self.on_proc_restart = value
                                    self.on_proc_restart.value_namespace = name_space
                                    self.on_proc_restart.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-switchover"):
                                    self.on_switchover = value
                                    self.on_switchover.value_namespace = name_space
                                    self.on_switchover.value_namespace_prefix = name_space_prefix
                                if(value_path == "summary-lsa"):
                                    self.summary_lsa = value
                                    self.summary_lsa.value_namespace = name_space
                                    self.summary_lsa.value_namespace_prefix = name_space_prefix


                        class MaxMetric(Entity):
                            """
                            Stub router max\-metric configuration
                            
                            .. attribute:: always
                            
                            	Unconditionally enter stub router operational state
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: enable
                            
                            	Enabled stub router configuration mode
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: external_lsa
                            
                            	Advertise external LSAs with modified metric in stub router mode
                            	**type**\:  int
                            
                            	**range:** 1..16777214
                            
                            	**default value**\: 16711680
                            
                            .. attribute:: include_stub
                            
                            	Advertise stub links with maximum metric in stub router mode
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: on_proc_migration
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: on_proc_restart
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: on_startup
                            
                            	Enter stub router operational state on startup
                            	**type**\:   :py:class:`OnStartup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric.OnStartup>`
                            
                            .. attribute:: on_switchover
                            
                            	Time (in seconds) to stay in stub router operational state
                            	**type**\:  int
                            
                            	**range:** 5..86400
                            
                            	**units**\: second
                            
                            .. attribute:: summary_lsa
                            
                            	Advertise summary LSAs with modified metric in stub router mode
                            	**type**\:  int
                            
                            	**range:** 1..16777214
                            
                            	**default value**\: 16711680
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric, self).__init__()

                                self.yang_name = "max-metric"
                                self.yang_parent_name = "stub-router"

                                self.always = YLeaf(YType.empty, "always")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.external_lsa = YLeaf(YType.uint32, "external-lsa")

                                self.include_stub = YLeaf(YType.empty, "include-stub")

                                self.on_proc_migration = YLeaf(YType.uint32, "on-proc-migration")

                                self.on_proc_restart = YLeaf(YType.uint32, "on-proc-restart")

                                self.on_switchover = YLeaf(YType.uint32, "on-switchover")

                                self.summary_lsa = YLeaf(YType.uint32, "summary-lsa")

                                self.on_startup = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric.OnStartup()
                                self.on_startup.parent = self
                                self._children_name_map["on_startup"] = "on-startup"
                                self._children_yang_names.add("on-startup")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("always",
                                                "enable",
                                                "external_lsa",
                                                "include_stub",
                                                "on_proc_migration",
                                                "on_proc_restart",
                                                "on_switchover",
                                                "summary_lsa") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric, self).__setattr__(name, value)


                            class OnStartup(Entity):
                                """
                                Enter stub router operational state on startup
                                
                                .. attribute:: wait_for_bgp
                                
                                	Wait until BGP converges (only applicable to default VRF)
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: wait_time
                                
                                	Time (in seconds) to stay in stub router operational state
                                	**type**\:  int
                                
                                	**range:** 5..86400
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric.OnStartup, self).__init__()

                                    self.yang_name = "on-startup"
                                    self.yang_parent_name = "max-metric"

                                    self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                    self.wait_time = YLeaf(YType.uint32, "wait-time")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("wait_for_bgp",
                                                    "wait_time") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric.OnStartup, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric.OnStartup, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.wait_for_bgp.is_set or
                                        self.wait_time.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.wait_for_bgp.yfilter != YFilter.not_set or
                                        self.wait_time.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "on-startup" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())
                                    if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wait_time.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "wait-for-bgp" or name == "wait-time"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "wait-for-bgp"):
                                        self.wait_for_bgp = value
                                        self.wait_for_bgp.value_namespace = name_space
                                        self.wait_for_bgp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wait-time"):
                                        self.wait_time = value
                                        self.wait_time.value_namespace = name_space
                                        self.wait_time.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.always.is_set or
                                    self.enable.is_set or
                                    self.external_lsa.is_set or
                                    self.include_stub.is_set or
                                    self.on_proc_migration.is_set or
                                    self.on_proc_restart.is_set or
                                    self.on_switchover.is_set or
                                    self.summary_lsa.is_set or
                                    (self.on_startup is not None and self.on_startup.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.always.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.external_lsa.yfilter != YFilter.not_set or
                                    self.include_stub.yfilter != YFilter.not_set or
                                    self.on_proc_migration.yfilter != YFilter.not_set or
                                    self.on_proc_restart.yfilter != YFilter.not_set or
                                    self.on_switchover.yfilter != YFilter.not_set or
                                    self.summary_lsa.yfilter != YFilter.not_set or
                                    (self.on_startup is not None and self.on_startup.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "max-metric" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.always.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.include_stub.get_name_leafdata())
                                if (self.on_proc_migration.is_set or self.on_proc_migration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_proc_migration.get_name_leafdata())
                                if (self.on_proc_restart.is_set or self.on_proc_restart.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_proc_restart.get_name_leafdata())
                                if (self.on_switchover.is_set or self.on_switchover.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.on_switchover.get_name_leafdata())
                                if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.summary_lsa.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "on-startup"):
                                    if (self.on_startup is None):
                                        self.on_startup = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric.OnStartup()
                                        self.on_startup.parent = self
                                        self._children_name_map["on_startup"] = "on-startup"
                                    return self.on_startup

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "on-startup" or name == "always" or name == "enable" or name == "external-lsa" or name == "include-stub" or name == "on-proc-migration" or name == "on-proc-restart" or name == "on-switchover" or name == "summary-lsa"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "always"):
                                    self.always = value
                                    self.always.value_namespace = name_space
                                    self.always.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-lsa"):
                                    self.external_lsa = value
                                    self.external_lsa.value_namespace = name_space
                                    self.external_lsa.value_namespace_prefix = name_space_prefix
                                if(value_path == "include-stub"):
                                    self.include_stub = value
                                    self.include_stub.value_namespace = name_space
                                    self.include_stub.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-proc-migration"):
                                    self.on_proc_migration = value
                                    self.on_proc_migration.value_namespace = name_space
                                    self.on_proc_migration.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-proc-restart"):
                                    self.on_proc_restart = value
                                    self.on_proc_restart.value_namespace = name_space
                                    self.on_proc_restart.value_namespace_prefix = name_space_prefix
                                if(value_path == "on-switchover"):
                                    self.on_switchover = value
                                    self.on_switchover.value_namespace = name_space
                                    self.on_switchover.value_namespace_prefix = name_space_prefix
                                if(value_path == "summary-lsa"):
                                    self.summary_lsa = value
                                    self.summary_lsa.value_namespace = name_space
                                    self.summary_lsa.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.max_metric is not None and self.max_metric.has_data()) or
                                (self.rbit is not None and self.rbit.has_data()) or
                                (self.v6bit is not None and self.v6bit.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.max_metric is not None and self.max_metric.has_operation()) or
                                (self.rbit is not None and self.rbit.has_operation()) or
                                (self.v6bit is not None and self.v6bit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "stub-router" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "max-metric"):
                                if (self.max_metric is None):
                                    self.max_metric = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.MaxMetric()
                                    self.max_metric.parent = self
                                    self._children_name_map["max_metric"] = "max-metric"
                                return self.max_metric

                            if (child_yang_name == "rbit"):
                                if (self.rbit is None):
                                    self.rbit = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.Rbit()
                                    self.rbit.parent = self
                                    self._children_name_map["rbit"] = "rbit"
                                return self.rbit

                            if (child_yang_name == "v6bit"):
                                if (self.v6bit is None):
                                    self.v6bit = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter.V6Bit()
                                    self.v6bit.parent = self
                                    self._children_name_map["v6bit"] = "v6bit"
                                return self.v6bit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "max-metric" or name == "rbit" or name == "v6bit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Bfd(Entity):
                        """
                        Configure BFD parameters
                        
                        .. attribute:: detection_multiplier
                        
                        	Detect multiplier
                        	**type**\:  int
                        
                        	**range:** 2..50
                        
                        .. attribute:: fast_detect_mode
                        
                        	Enable or disable BFD fast detection
                        	**type**\:   :py:class:`Ospfv3BfdEnableMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3BfdEnableMode>`
                        
                        .. attribute:: interval
                        
                        	Hello interval in milli\-seconds
                        	**type**\:  int
                        
                        	**range:** 3..30000
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Bfd, self).__init__()

                            self.yang_name = "bfd"
                            self.yang_parent_name = "vrf"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.fast_detect_mode = YLeaf(YType.enumeration, "fast-detect-mode")

                            self.interval = YLeaf(YType.uint32, "interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "fast_detect_mode",
                                            "interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Bfd, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Bfd, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.fast_detect_mode.is_set or
                                self.interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.fast_detect_mode.yfilter != YFilter.not_set or
                                self.interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfd" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.fast_detect_mode.is_set or self.fast_detect_mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fast_detect_mode.get_name_leafdata())
                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "fast-detect-mode" or name == "interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "fast-detect-mode"):
                                self.fast_detect_mode = value
                                self.fast_detect_mode.value_namespace = name_space
                                self.fast_detect_mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "interval"):
                                self.interval = value
                                self.interval.value_namespace = name_space
                                self.interval.value_namespace_prefix = name_space_prefix


                    class DatabaseFilter(Entity):
                        """
                        Database filter
                        
                        .. attribute:: all
                        
                        	All
                        	**type**\:   :py:class:`All <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter.All>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter, self).__init__()

                            self.yang_name = "database-filter"
                            self.yang_parent_name = "vrf"

                            self.all = Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter.All()
                            self.all.parent = self
                            self._children_name_map["all"] = "all"
                            self._children_yang_names.add("all")


                        class All(Entity):
                            """
                            All
                            
                            .. attribute:: out
                            
                            	Enable out
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter.All, self).__init__()

                                self.yang_name = "all"
                                self.yang_parent_name = "database-filter"

                                self.out = YLeaf(YType.empty, "out")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("out") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter.All, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter.All, self).__setattr__(name, value)

                            def has_data(self):
                                return self.out.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.out.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "all" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.out.is_set or self.out.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "out"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "out"):
                                    self.out = value
                                    self.out.value_namespace = name_space
                                    self.out.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (self.all is not None and self.all.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.all is not None and self.all.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "database-filter" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "all"):
                                if (self.all is None):
                                    self.all = Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter.All()
                                    self.all.parent = self
                                    self._children_name_map["all"] = "all"
                                return self.all

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "all"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Authentication(Entity):
                        """
                        Authenticate OSPFv3 packets
                        
                        .. attribute:: algorithm
                        
                        	Use the MD5 or SHA1 algorithm
                        	**type**\:   :py:class:`Ospfv3Authentication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3Authentication>`
                        
                        .. attribute:: enable
                        
                        	Authenticate packets
                        	**type**\:  bool
                        
                        .. attribute:: password
                        
                        	Specify MD5 or SHA1 password
                        	**type**\:  str
                        
                        	**pattern:** (!.+)\|([^!].+)
                        
                        .. attribute:: spi
                        
                        	Use IPSec AH authentication. Specify the Security Parameter Index (SPI) value
                        	**type**\:  int
                        
                        	**range:** 256..4294967295
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Authentication, self).__init__()

                            self.yang_name = "authentication"
                            self.yang_parent_name = "vrf"

                            self.algorithm = YLeaf(YType.enumeration, "algorithm")

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.password = YLeaf(YType.str, "password")

                            self.spi = YLeaf(YType.uint32, "spi")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("algorithm",
                                            "enable",
                                            "password",
                                            "spi") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Authentication, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Authentication, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.algorithm.is_set or
                                self.enable.is_set or
                                self.password.is_set or
                                self.spi.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.algorithm.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.password.yfilter != YFilter.not_set or
                                self.spi.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "authentication" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.algorithm.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.password.get_name_leafdata())
                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spi.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "algorithm" or name == "enable" or name == "password" or name == "spi"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "algorithm"):
                                self.algorithm = value
                                self.algorithm.value_namespace = name_space
                                self.algorithm.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "password"):
                                self.password = value
                                self.password.value_namespace = name_space
                                self.password.value_namespace_prefix = name_space_prefix
                            if(value_path == "spi"):
                                self.spi = value
                                self.spi.value_namespace = name_space
                                self.spi.value_namespace_prefix = name_space_prefix


                    class GracefulRestart(Entity):
                        """
                        Graceful restart configuration
                        
                        .. attribute:: enable
                        
                        	Enable graceful restart
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: helper
                        
                        	Disable router's helper support
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: interval
                        
                        	Minimum interval between graceful restarts (seconds)
                        	**type**\:  int
                        
                        	**range:** 90..3600
                        
                        	**units**\: second
                        
                        .. attribute:: lifetime
                        
                        	Maximum route lifetime following restart (seconds)
                        	**type**\:  int
                        
                        	**range:** 90..1800
                        
                        	**units**\: second
                        
                        .. attribute:: strict_lsa_checking
                        
                        	Terminate graceful restart helper mode if LSA changed
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.GracefulRestart, self).__init__()

                            self.yang_name = "graceful-restart"
                            self.yang_parent_name = "vrf"

                            self.enable = YLeaf(YType.empty, "enable")

                            self.helper = YLeaf(YType.empty, "helper")

                            self.interval = YLeaf(YType.uint32, "interval")

                            self.lifetime = YLeaf(YType.uint32, "lifetime")

                            self.strict_lsa_checking = YLeaf(YType.empty, "strict-lsa-checking")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "helper",
                                            "interval",
                                            "lifetime",
                                            "strict_lsa_checking") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.GracefulRestart, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.GracefulRestart, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.helper.is_set or
                                self.interval.is_set or
                                self.lifetime.is_set or
                                self.strict_lsa_checking.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.helper.yfilter != YFilter.not_set or
                                self.interval.yfilter != YFilter.not_set or
                                self.lifetime.yfilter != YFilter.not_set or
                                self.strict_lsa_checking.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "graceful-restart" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.helper.is_set or self.helper.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.helper.get_name_leafdata())
                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interval.get_name_leafdata())
                            if (self.lifetime.is_set or self.lifetime.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lifetime.get_name_leafdata())
                            if (self.strict_lsa_checking.is_set or self.strict_lsa_checking.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.strict_lsa_checking.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable" or name == "helper" or name == "interval" or name == "lifetime" or name == "strict-lsa-checking"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "helper"):
                                self.helper = value
                                self.helper.value_namespace = name_space
                                self.helper.value_namespace_prefix = name_space_prefix
                            if(value_path == "interval"):
                                self.interval = value
                                self.interval.value_namespace = name_space
                                self.interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "lifetime"):
                                self.lifetime = value
                                self.lifetime.value_namespace = name_space
                                self.lifetime.value_namespace_prefix = name_space_prefix
                            if(value_path == "strict-lsa-checking"):
                                self.strict_lsa_checking = value
                                self.strict_lsa_checking.value_namespace = name_space
                                self.strict_lsa_checking.value_namespace_prefix = name_space_prefix


                    class DefaultInformation(Entity):
                        """
                        Control distribution of default information
                        
                        .. attribute:: originate
                        
                        	Distribute a default route
                        	**type**\:   :py:class:`Originate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation.Originate>`
                        
                        	**presence node**\: True
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation, self).__init__()

                            self.yang_name = "default-information"
                            self.yang_parent_name = "vrf"

                            self.originate = None
                            self._children_name_map["originate"] = "originate"
                            self._children_yang_names.add("originate")


                        class Originate(Entity):
                            """
                            Distribute a default route
                            
                            .. attribute:: always
                            
                            	Always advertise default route
                            	**type**\:  bool
                            
                            	**mandatory**\: True
                            
                            .. attribute:: metric
                            
                            	OSPFv3 default metric
                            	**type**\:  int
                            
                            	**range:** 0..16777214
                            
                            .. attribute:: metric_type
                            
                            	OSPFv3 metric type for default routes
                            	**type**\:  int
                            
                            	**range:** 1..2
                            
                            .. attribute:: route_policy_name
                            
                            	Route policy to default\-information origination
                            	**type**\:  str
                            
                            .. attribute:: tag
                            
                            	Tag for default route
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation.Originate, self).__init__()

                                self.yang_name = "originate"
                                self.yang_parent_name = "default-information"
                                self.is_presence_container = True

                                self.always = YLeaf(YType.boolean, "always")

                                self.metric = YLeaf(YType.uint32, "metric")

                                self.metric_type = YLeaf(YType.uint32, "metric-type")

                                self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                self.tag = YLeaf(YType.int32, "tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("always",
                                                "metric",
                                                "metric_type",
                                                "route_policy_name",
                                                "tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation.Originate, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation.Originate, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.always.is_set or
                                    self.metric.is_set or
                                    self.metric_type.is_set or
                                    self.route_policy_name.is_set or
                                    self.tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.always.yfilter != YFilter.not_set or
                                    self.metric.yfilter != YFilter.not_set or
                                    self.metric_type.yfilter != YFilter.not_set or
                                    self.route_policy_name.yfilter != YFilter.not_set or
                                    self.tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "originate" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.always.is_set or self.always.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.always.get_name_leafdata())
                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric.get_name_leafdata())
                                if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.metric_type.get_name_leafdata())
                                if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_policy_name.get_name_leafdata())
                                if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "always" or name == "metric" or name == "metric-type" or name == "route-policy-name" or name == "tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "always"):
                                    self.always = value
                                    self.always.value_namespace = name_space
                                    self.always.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric"):
                                    self.metric = value
                                    self.metric.value_namespace = name_space
                                    self.metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "metric-type"):
                                    self.metric_type = value
                                    self.metric_type.value_namespace = name_space
                                    self.metric_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-policy-name"):
                                    self.route_policy_name = value
                                    self.route_policy_name.value_namespace = name_space
                                    self.route_policy_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "tag"):
                                    self.tag = value
                                    self.tag.value_namespace = name_space
                                    self.tag.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (self.originate is not None)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.originate is not None and self.originate.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "default-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "originate"):
                                if (self.originate is None):
                                    self.originate = Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation.Originate()
                                    self.originate.parent = self
                                    self._children_name_map["originate"] = "originate"
                                return self.originate

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "originate"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class ProcessScope(Entity):
                        """
                        Process scope configuration
                        
                        .. attribute:: fast_reroute
                        
                        	Fast\-reroute configuration
                        	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute>`
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope, self).__init__()

                            self.yang_name = "process-scope"
                            self.yang_parent_name = "vrf"

                            self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute()
                            self.fast_reroute.parent = self
                            self._children_name_map["fast_reroute"] = "fast-reroute"
                            self._children_yang_names.add("fast-reroute")


                        class FastReroute(Entity):
                            """
                            Fast\-reroute configuration
                            
                            .. attribute:: fast_reroute_enable
                            
                            	Enable/Disable Fast\-reroute per\-link or per\-prefix
                            	**type**\:   :py:class:`Ospfv3FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3FastReroute>`
                            
                            .. attribute:: per_link
                            
                            	Fast\-reroute per\-link configuration
                            	**type**\:   :py:class:`PerLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink>`
                            
                            .. attribute:: per_prefix
                            
                            	Fast\-reroute per\-link configuration
                            	**type**\:   :py:class:`PerPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix>`
                            
                            

                            """

                            _prefix = 'ipv6-ospfv3-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute, self).__init__()

                                self.yang_name = "fast-reroute"
                                self.yang_parent_name = "process-scope"

                                self.fast_reroute_enable = YLeaf(YType.enumeration, "fast-reroute-enable")

                                self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink()
                                self.per_link.parent = self
                                self._children_name_map["per_link"] = "per-link"
                                self._children_yang_names.add("per-link")

                                self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix()
                                self.per_prefix.parent = self
                                self._children_name_map["per_prefix"] = "per-prefix"
                                self._children_yang_names.add("per-prefix")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fast_reroute_enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute, self).__setattr__(name, value)


                            class PerLink(Entity):
                                """
                                Fast\-reroute per\-link configuration
                                
                                .. attribute:: candidate_interfaces
                                
                                	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces>`
                                
                                .. attribute:: exclude_interfaces
                                
                                	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces>`
                                
                                .. attribute:: fast_reroute_use_candidate_only
                                
                                	Use only interfaces on the candidate list as a backup path
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink, self).__init__()

                                    self.yang_name = "per-link"
                                    self.yang_parent_name = "fast-reroute"

                                    self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                    self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces()
                                    self.candidate_interfaces.parent = self
                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                    self._children_yang_names.add("candidate-interfaces")

                                    self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces()
                                    self.exclude_interfaces.parent = self
                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                    self._children_yang_names.add("exclude-interfaces")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink, self).__setattr__(name, value)


                                class CandidateInterfaces(Entity):
                                    """
                                    Fast\-reroute per\-link/per\-prefix candidate
                                    interface configuration
                                    
                                    .. attribute:: candidate_interface
                                    
                                    	Candidate backup interface
                                    	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces, self).__init__()

                                        self.yang_name = "candidate-interfaces"
                                        self.yang_parent_name = "per-link"

                                        self.candidate_interface = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces, self).__setattr__(name, value)


                                    class CandidateInterface(Entity):
                                        """
                                        Candidate backup interface
                                        
                                        .. attribute:: interface_name  <key>
                                        
                                        	Interface
                                        	**type**\:  str
                                        
                                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__init__()

                                            self.yang_name = "candidate-interface"
                                            self.yang_parent_name = "candidate-interfaces"

                                            self.interface_name = YLeaf(YType.str, "interface-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("interface_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.interface_name.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.interface_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "interface-name"):
                                                self.interface_name = value
                                                self.interface_name.value_namespace = name_space
                                                self.interface_name.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.candidate_interface:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.candidate_interface:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "candidate-interfaces" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "candidate-interface"):
                                            for c in self.candidate_interface:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces.CandidateInterface()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.candidate_interface.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "candidate-interface"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class ExcludeInterfaces(Entity):
                                    """
                                    Fast\-reroute per\-link/per\-prefix exclude
                                    interface configuration
                                    
                                    .. attribute:: exclude_interface
                                    
                                    	Exclude an interface from becoming a backup
                                    	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces, self).__init__()

                                        self.yang_name = "exclude-interfaces"
                                        self.yang_parent_name = "per-link"

                                        self.exclude_interface = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces, self).__setattr__(name, value)


                                    class ExcludeInterface(Entity):
                                        """
                                        Exclude an interface from becoming a backup
                                        
                                        .. attribute:: interface_name  <key>
                                        
                                        	Interface
                                        	**type**\:  str
                                        
                                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                            self.yang_name = "exclude-interface"
                                            self.yang_parent_name = "exclude-interfaces"

                                            self.interface_name = YLeaf(YType.str, "interface-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("interface_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.interface_name.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.interface_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "interface-name"):
                                                self.interface_name = value
                                                self.interface_name.value_namespace = name_space
                                                self.interface_name.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.exclude_interface:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.exclude_interface:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exclude-interfaces" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "exclude-interface"):
                                            for c in self.exclude_interface:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces.ExcludeInterface()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.exclude_interface.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "exclude-interface"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.fast_reroute_use_candidate_only.is_set or
                                        (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                        (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                        (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                        (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "per-link" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "candidate-interfaces"):
                                        if (self.candidate_interfaces is None):
                                            self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                        return self.candidate_interfaces

                                    if (child_yang_name == "exclude-interfaces"):
                                        if (self.exclude_interfaces is None):
                                            self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                        return self.exclude_interfaces

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fast-reroute-use-candidate-only"):
                                        self.fast_reroute_use_candidate_only = value
                                        self.fast_reroute_use_candidate_only.value_namespace = name_space
                                        self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix


                            class PerPrefix(Entity):
                                """
                                Fast\-reroute per\-link configuration
                                
                                .. attribute:: candidate_interfaces
                                
                                	Fast\-reroute per\-link/per\-prefix candidate interface configuration
                                	**type**\:   :py:class:`CandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces>`
                                
                                .. attribute:: exclude_interfaces
                                
                                	Fast\-reroute per\-link/per\-prefix exclude interface configuration
                                	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces>`
                                
                                .. attribute:: fast_reroute_use_candidate_only
                                
                                	Use only interfaces on the candidate list as a backup path
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'ipv6-ospfv3-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix, self).__init__()

                                    self.yang_name = "per-prefix"
                                    self.yang_parent_name = "fast-reroute"

                                    self.fast_reroute_use_candidate_only = YLeaf(YType.boolean, "fast-reroute-use-candidate-only")

                                    self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces()
                                    self.candidate_interfaces.parent = self
                                    self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                    self._children_yang_names.add("candidate-interfaces")

                                    self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                    self.exclude_interfaces.parent = self
                                    self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                    self._children_yang_names.add("exclude-interfaces")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fast_reroute_use_candidate_only") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix, self).__setattr__(name, value)


                                class CandidateInterfaces(Entity):
                                    """
                                    Fast\-reroute per\-link/per\-prefix candidate
                                    interface configuration
                                    
                                    .. attribute:: candidate_interface
                                    
                                    	Candidate backup interface
                                    	**type**\: list of    :py:class:`CandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces, self).__init__()

                                        self.yang_name = "candidate-interfaces"
                                        self.yang_parent_name = "per-prefix"

                                        self.candidate_interface = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces, self).__setattr__(name, value)


                                    class CandidateInterface(Entity):
                                        """
                                        Candidate backup interface
                                        
                                        .. attribute:: interface_name  <key>
                                        
                                        	Interface
                                        	**type**\:  str
                                        
                                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__init__()

                                            self.yang_name = "candidate-interface"
                                            self.yang_parent_name = "candidate-interfaces"

                                            self.interface_name = YLeaf(YType.str, "interface-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("interface_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.interface_name.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.interface_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "interface-name"):
                                                self.interface_name = value
                                                self.interface_name.value_namespace = name_space
                                                self.interface_name.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.candidate_interface:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.candidate_interface:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "candidate-interfaces" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "candidate-interface"):
                                            for c in self.candidate_interface:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces.CandidateInterface()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.candidate_interface.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "candidate-interface"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class ExcludeInterfaces(Entity):
                                    """
                                    Fast\-reroute per\-link/per\-prefix exclude
                                    interface configuration
                                    
                                    .. attribute:: exclude_interface
                                    
                                    	Exclude an interface from becoming a backup
                                    	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface>`
                                    
                                    

                                    """

                                    _prefix = 'ipv6-ospfv3-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__init__()

                                        self.yang_name = "exclude-interfaces"
                                        self.yang_parent_name = "per-prefix"

                                        self.exclude_interface = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces, self).__setattr__(name, value)


                                    class ExcludeInterface(Entity):
                                        """
                                        Exclude an interface from becoming a backup
                                        
                                        .. attribute:: interface_name  <key>
                                        
                                        	Interface
                                        	**type**\:  str
                                        
                                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                        
                                        

                                        """

                                        _prefix = 'ipv6-ospfv3-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                            self.yang_name = "exclude-interface"
                                            self.yang_parent_name = "exclude-interfaces"

                                            self.interface_name = YLeaf(YType.str, "interface-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("interface_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.interface_name.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.interface_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "interface-name"):
                                                self.interface_name = value
                                                self.interface_name.value_namespace = name_space
                                                self.interface_name.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.exclude_interface:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.exclude_interface:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exclude-interfaces" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "exclude-interface"):
                                            for c in self.exclude_interface:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces.ExcludeInterface()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.exclude_interface.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "exclude-interface"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.fast_reroute_use_candidate_only.is_set or
                                        (self.candidate_interfaces is not None and self.candidate_interfaces.has_data()) or
                                        (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set or
                                        (self.candidate_interfaces is not None and self.candidate_interfaces.has_operation()) or
                                        (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "per-prefix" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fast_reroute_use_candidate_only.is_set or self.fast_reroute_use_candidate_only.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fast_reroute_use_candidate_only.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "candidate-interfaces"):
                                        if (self.candidate_interfaces is None):
                                            self.candidate_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.CandidateInterfaces()
                                            self.candidate_interfaces.parent = self
                                            self._children_name_map["candidate_interfaces"] = "candidate-interfaces"
                                        return self.candidate_interfaces

                                    if (child_yang_name == "exclude-interfaces"):
                                        if (self.exclude_interfaces is None):
                                            self.exclude_interfaces = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix.ExcludeInterfaces()
                                            self.exclude_interfaces.parent = self
                                            self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                        return self.exclude_interfaces

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "candidate-interfaces" or name == "exclude-interfaces" or name == "fast-reroute-use-candidate-only"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fast-reroute-use-candidate-only"):
                                        self.fast_reroute_use_candidate_only = value
                                        self.fast_reroute_use_candidate_only.value_namespace = name_space
                                        self.fast_reroute_use_candidate_only.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.fast_reroute_enable.is_set or
                                    (self.per_link is not None and self.per_link.has_data()) or
                                    (self.per_prefix is not None and self.per_prefix.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fast_reroute_enable.yfilter != YFilter.not_set or
                                    (self.per_link is not None and self.per_link.has_operation()) or
                                    (self.per_prefix is not None and self.per_prefix.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "fast-reroute" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fast_reroute_enable.is_set or self.fast_reroute_enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fast_reroute_enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "per-link"):
                                    if (self.per_link is None):
                                        self.per_link = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerLink()
                                        self.per_link.parent = self
                                        self._children_name_map["per_link"] = "per-link"
                                    return self.per_link

                                if (child_yang_name == "per-prefix"):
                                    if (self.per_prefix is None):
                                        self.per_prefix = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute.PerPrefix()
                                        self.per_prefix.parent = self
                                        self._children_name_map["per_prefix"] = "per-prefix"
                                    return self.per_prefix

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "per-link" or name == "per-prefix" or name == "fast-reroute-enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fast-reroute-enable"):
                                    self.fast_reroute_enable = value
                                    self.fast_reroute_enable.value_namespace = name_space
                                    self.fast_reroute_enable.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (self.fast_reroute is not None and self.fast_reroute.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.fast_reroute is not None and self.fast_reroute.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "process-scope" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "fast-reroute"):
                                if (self.fast_reroute is None):
                                    self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                return self.fast_reroute

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "fast-reroute"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Encryption(Entity):
                        """
                        Encrypt and authenticate OSPFv3 packets
                        
                        .. attribute:: authentication_algorithm
                        
                        	Use the NULL, MD5 or SHA1 algorithm
                        	**type**\:   :py:class:`Ospfv3AuthenticationType2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AuthenticationType2>`
                        
                        .. attribute:: authentication_password
                        
                        	Specify MD5 or SHA1 password
                        	**type**\:  str
                        
                        	**pattern:** (!.+)\|([^!].+)
                        
                        .. attribute:: enable
                        
                        	Authenticate packets
                        	**type**\:  bool
                        
                        .. attribute:: encryption_algorithm
                        
                        	Specify the encryption algorithm
                        	**type**\:   :py:class:`Ospfv3EncryptionAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3EncryptionAlgorithm>`
                        
                        .. attribute:: encryption_password
                        
                        	Encryption password
                        	**type**\:  str
                        
                        	**pattern:** (!.+)\|([^!].+)
                        
                        .. attribute:: spi
                        
                        	Use IPSec ESP authentication. Specify the Security Parameter Index (SPI) value
                        	**type**\:  int
                        
                        	**range:** 256..4294967295
                        
                        

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.Encryption, self).__init__()

                            self.yang_name = "encryption"
                            self.yang_parent_name = "vrf"

                            self.authentication_algorithm = YLeaf(YType.enumeration, "authentication-algorithm")

                            self.authentication_password = YLeaf(YType.str, "authentication-password")

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.encryption_algorithm = YLeaf(YType.enumeration, "encryption-algorithm")

                            self.encryption_password = YLeaf(YType.str, "encryption-password")

                            self.spi = YLeaf(YType.uint32, "spi")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("authentication_algorithm",
                                            "authentication_password",
                                            "enable",
                                            "encryption_algorithm",
                                            "encryption_password",
                                            "spi") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.Encryption, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.Encryption, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.authentication_algorithm.is_set or
                                self.authentication_password.is_set or
                                self.enable.is_set or
                                self.encryption_algorithm.is_set or
                                self.encryption_password.is_set or
                                self.spi.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.authentication_algorithm.yfilter != YFilter.not_set or
                                self.authentication_password.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.encryption_algorithm.yfilter != YFilter.not_set or
                                self.encryption_password.yfilter != YFilter.not_set or
                                self.spi.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "encryption" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.authentication_algorithm.is_set or self.authentication_algorithm.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.authentication_algorithm.get_name_leafdata())
                            if (self.authentication_password.is_set or self.authentication_password.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.authentication_password.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.encryption_algorithm.is_set or self.encryption_algorithm.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encryption_algorithm.get_name_leafdata())
                            if (self.encryption_password.is_set or self.encryption_password.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encryption_password.get_name_leafdata())
                            if (self.spi.is_set or self.spi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spi.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "authentication-algorithm" or name == "authentication-password" or name == "enable" or name == "encryption-algorithm" or name == "encryption-password" or name == "spi"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "authentication-algorithm"):
                                self.authentication_algorithm = value
                                self.authentication_algorithm.value_namespace = name_space
                                self.authentication_algorithm.value_namespace_prefix = name_space_prefix
                            if(value_path == "authentication-password"):
                                self.authentication_password = value
                                self.authentication_password.value_namespace = name_space
                                self.authentication_password.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "encryption-algorithm"):
                                self.encryption_algorithm = value
                                self.encryption_algorithm.value_namespace = name_space
                                self.encryption_algorithm.value_namespace_prefix = name_space_prefix
                            if(value_path == "encryption-password"):
                                self.encryption_password = value
                                self.encryption_password.value_namespace = name_space
                                self.encryption_password.value_namespace_prefix = name_space_prefix
                            if(value_path == "spi"):
                                self.spi = value
                                self.spi.value_namespace = name_space
                                self.spi.value_namespace_prefix = name_space_prefix


                    class AutoCost(Entity):
                        """
                        Calculate interface cost according to bandwidth
                        
                        .. attribute:: disable
                        
                        	Specify 'true' to assign cost based on interface type
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reference_bandwidth
                        
                        	Specify reference bandwidth for cost computations in terms of Mbits per second
                        	**type**\:  int
                        
                        	**range:** 1..4294967
                        
                        	**units**\: Mbit/s
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv6-ospfv3-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Ospfv3.Processes.Process.Vrfs.Vrf.AutoCost, self).__init__()

                            self.yang_name = "auto-cost"
                            self.yang_parent_name = "vrf"
                            self.is_presence_container = True

                            self.disable = YLeaf(YType.empty, "disable")

                            self.reference_bandwidth = YLeaf(YType.uint32, "reference-bandwidth")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("disable",
                                            "reference_bandwidth") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Ospfv3.Processes.Process.Vrfs.Vrf.AutoCost, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Ospfv3.Processes.Process.Vrfs.Vrf.AutoCost, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.disable.is_set or
                                self.reference_bandwidth.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.disable.yfilter != YFilter.not_set or
                                self.reference_bandwidth.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "auto-cost" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.disable.get_name_leafdata())
                            if (self.reference_bandwidth.is_set or self.reference_bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reference_bandwidth.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "disable" or name == "reference-bandwidth"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "disable"):
                                self.disable = value
                                self.disable.value_namespace = name_space
                                self.disable.value_namespace_prefix = name_space_prefix
                            if(value_path == "reference-bandwidth"):
                                self.reference_bandwidth = value
                                self.reference_bandwidth.value_namespace = name_space
                                self.reference_bandwidth.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.vrf_name.is_set or
                            self.cost.is_set or
                            self.dead_interval.is_set or
                            self.default_metric.is_set or
                            self.demand_circuit.is_set or
                            self.enable.is_set or
                            self.flood_reduction.is_set or
                            self.hello_interval.is_set or
                            self.instance.is_set or
                            self.log_adjacency_changes.is_set or
                            self.mtu_ignore.is_set or
                            self.network.is_set or
                            self.packet_size.is_set or
                            self.passive.is_set or
                            self.prefix_suppression.is_set or
                            self.priority.is_set or
                            self.retransmit_interval.is_set or
                            self.router_id.is_set or
                            self.snmpvrf_trap.is_set or
                            self.spf_prefix_priority_policy.is_set or
                            self.transmit_delay.is_set or
                            (self.area_addresses is not None and self.area_addresses.has_data()) or
                            (self.authentication is not None and self.authentication.has_data()) or
                            (self.bfd is not None and self.bfd.has_data()) or
                            (self.capability is not None and self.capability.has_data()) or
                            (self.database_filter is not None and self.database_filter.has_data()) or
                            (self.default_information is not None and self.default_information.has_data()) or
                            (self.distance is not None and self.distance.has_data()) or
                            (self.distribute_list is not None and self.distribute_list.has_data()) or
                            (self.distribute_list_out is not None and self.distribute_list_out.has_data()) or
                            (self.domain_id is not None and self.domain_id.has_data()) or
                            (self.encryption is not None and self.encryption.has_data()) or
                            (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                            (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                            (self.ignore is not None and self.ignore.has_data()) or
                            (self.maximum is not None and self.maximum.has_data()) or
                            (self.process_scope is not None and self.process_scope.has_data()) or
                            (self.redistributes is not None and self.redistributes.has_data()) or
                            (self.snmp is not None and self.snmp.has_data()) or
                            (self.stub_router is not None and self.stub_router.has_data()) or
                            (self.summary_prefixes is not None and self.summary_prefixes.has_data()) or
                            (self.timers is not None and self.timers.has_data()) or
                            (self.auto_cost is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            self.cost.yfilter != YFilter.not_set or
                            self.dead_interval.yfilter != YFilter.not_set or
                            self.default_metric.yfilter != YFilter.not_set or
                            self.demand_circuit.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.flood_reduction.yfilter != YFilter.not_set or
                            self.hello_interval.yfilter != YFilter.not_set or
                            self.instance.yfilter != YFilter.not_set or
                            self.log_adjacency_changes.yfilter != YFilter.not_set or
                            self.mtu_ignore.yfilter != YFilter.not_set or
                            self.network.yfilter != YFilter.not_set or
                            self.packet_size.yfilter != YFilter.not_set or
                            self.passive.yfilter != YFilter.not_set or
                            self.prefix_suppression.yfilter != YFilter.not_set or
                            self.priority.yfilter != YFilter.not_set or
                            self.retransmit_interval.yfilter != YFilter.not_set or
                            self.router_id.yfilter != YFilter.not_set or
                            self.snmpvrf_trap.yfilter != YFilter.not_set or
                            self.spf_prefix_priority_policy.yfilter != YFilter.not_set or
                            self.transmit_delay.yfilter != YFilter.not_set or
                            (self.area_addresses is not None and self.area_addresses.has_operation()) or
                            (self.authentication is not None and self.authentication.has_operation()) or
                            (self.auto_cost is not None and self.auto_cost.has_operation()) or
                            (self.bfd is not None and self.bfd.has_operation()) or
                            (self.capability is not None and self.capability.has_operation()) or
                            (self.database_filter is not None and self.database_filter.has_operation()) or
                            (self.default_information is not None and self.default_information.has_operation()) or
                            (self.distance is not None and self.distance.has_operation()) or
                            (self.distribute_list is not None and self.distribute_list.has_operation()) or
                            (self.distribute_list_out is not None and self.distribute_list_out.has_operation()) or
                            (self.domain_id is not None and self.domain_id.has_operation()) or
                            (self.encryption is not None and self.encryption.has_operation()) or
                            (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                            (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                            (self.ignore is not None and self.ignore.has_operation()) or
                            (self.maximum is not None and self.maximum.has_operation()) or
                            (self.process_scope is not None and self.process_scope.has_operation()) or
                            (self.redistributes is not None and self.redistributes.has_operation()) or
                            (self.snmp is not None and self.snmp.has_operation()) or
                            (self.stub_router is not None and self.stub_router.has_operation()) or
                            (self.summary_prefixes is not None and self.summary_prefixes.has_operation()) or
                            (self.timers is not None and self.timers.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "vrf" + "[vrf-name='" + self.vrf_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())
                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.cost.get_name_leafdata())
                        if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dead_interval.get_name_leafdata())
                        if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_metric.get_name_leafdata())
                        if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.flood_reduction.get_name_leafdata())
                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                        if (self.instance.is_set or self.instance.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.instance.get_name_leafdata())
                        if (self.log_adjacency_changes.is_set or self.log_adjacency_changes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.log_adjacency_changes.get_name_leafdata())
                        if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                        if (self.network.is_set or self.network.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.network.get_name_leafdata())
                        if (self.packet_size.is_set or self.packet_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packet_size.get_name_leafdata())
                        if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.passive.get_name_leafdata())
                        if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.priority.get_name_leafdata())
                        if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                        if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.router_id.get_name_leafdata())
                        if (self.snmpvrf_trap.is_set or self.snmpvrf_trap.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.snmpvrf_trap.get_name_leafdata())
                        if (self.spf_prefix_priority_policy.is_set or self.spf_prefix_priority_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.spf_prefix_priority_policy.get_name_leafdata())
                        if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "area-addresses"):
                            if (self.area_addresses is None):
                                self.area_addresses = Ospfv3.Processes.Process.Vrfs.Vrf.AreaAddresses()
                                self.area_addresses.parent = self
                                self._children_name_map["area_addresses"] = "area-addresses"
                            return self.area_addresses

                        if (child_yang_name == "authentication"):
                            if (self.authentication is None):
                                self.authentication = Ospfv3.Processes.Process.Vrfs.Vrf.Authentication()
                                self.authentication.parent = self
                                self._children_name_map["authentication"] = "authentication"
                            return self.authentication

                        if (child_yang_name == "auto-cost"):
                            if (self.auto_cost is None):
                                self.auto_cost = Ospfv3.Processes.Process.Vrfs.Vrf.AutoCost()
                                self.auto_cost.parent = self
                                self._children_name_map["auto_cost"] = "auto-cost"
                            return self.auto_cost

                        if (child_yang_name == "bfd"):
                            if (self.bfd is None):
                                self.bfd = Ospfv3.Processes.Process.Vrfs.Vrf.Bfd()
                                self.bfd.parent = self
                                self._children_name_map["bfd"] = "bfd"
                            return self.bfd

                        if (child_yang_name == "capability"):
                            if (self.capability is None):
                                self.capability = Ospfv3.Processes.Process.Vrfs.Vrf.Capability()
                                self.capability.parent = self
                                self._children_name_map["capability"] = "capability"
                            return self.capability

                        if (child_yang_name == "database-filter"):
                            if (self.database_filter is None):
                                self.database_filter = Ospfv3.Processes.Process.Vrfs.Vrf.DatabaseFilter()
                                self.database_filter.parent = self
                                self._children_name_map["database_filter"] = "database-filter"
                            return self.database_filter

                        if (child_yang_name == "default-information"):
                            if (self.default_information is None):
                                self.default_information = Ospfv3.Processes.Process.Vrfs.Vrf.DefaultInformation()
                                self.default_information.parent = self
                                self._children_name_map["default_information"] = "default-information"
                            return self.default_information

                        if (child_yang_name == "distance"):
                            if (self.distance is None):
                                self.distance = Ospfv3.Processes.Process.Vrfs.Vrf.Distance()
                                self.distance.parent = self
                                self._children_name_map["distance"] = "distance"
                            return self.distance

                        if (child_yang_name == "distribute-list"):
                            if (self.distribute_list is None):
                                self.distribute_list = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeList()
                                self.distribute_list.parent = self
                                self._children_name_map["distribute_list"] = "distribute-list"
                            return self.distribute_list

                        if (child_yang_name == "distribute-list-out"):
                            if (self.distribute_list_out is None):
                                self.distribute_list_out = Ospfv3.Processes.Process.Vrfs.Vrf.DistributeListOut()
                                self.distribute_list_out.parent = self
                                self._children_name_map["distribute_list_out"] = "distribute-list-out"
                            return self.distribute_list_out

                        if (child_yang_name == "domain-id"):
                            if (self.domain_id is None):
                                self.domain_id = Ospfv3.Processes.Process.Vrfs.Vrf.DomainId()
                                self.domain_id.parent = self
                                self._children_name_map["domain_id"] = "domain-id"
                            return self.domain_id

                        if (child_yang_name == "encryption"):
                            if (self.encryption is None):
                                self.encryption = Ospfv3.Processes.Process.Vrfs.Vrf.Encryption()
                                self.encryption.parent = self
                                self._children_name_map["encryption"] = "encryption"
                            return self.encryption

                        if (child_yang_name == "fast-reroute"):
                            if (self.fast_reroute is None):
                                self.fast_reroute = Ospfv3.Processes.Process.Vrfs.Vrf.FastReroute()
                                self.fast_reroute.parent = self
                                self._children_name_map["fast_reroute"] = "fast-reroute"
                            return self.fast_reroute

                        if (child_yang_name == "graceful-restart"):
                            if (self.graceful_restart is None):
                                self.graceful_restart = Ospfv3.Processes.Process.Vrfs.Vrf.GracefulRestart()
                                self.graceful_restart.parent = self
                                self._children_name_map["graceful_restart"] = "graceful-restart"
                            return self.graceful_restart

                        if (child_yang_name == "ignore"):
                            if (self.ignore is None):
                                self.ignore = Ospfv3.Processes.Process.Vrfs.Vrf.Ignore()
                                self.ignore.parent = self
                                self._children_name_map["ignore"] = "ignore"
                            return self.ignore

                        if (child_yang_name == "maximum"):
                            if (self.maximum is None):
                                self.maximum = Ospfv3.Processes.Process.Vrfs.Vrf.Maximum()
                                self.maximum.parent = self
                                self._children_name_map["maximum"] = "maximum"
                            return self.maximum

                        if (child_yang_name == "process-scope"):
                            if (self.process_scope is None):
                                self.process_scope = Ospfv3.Processes.Process.Vrfs.Vrf.ProcessScope()
                                self.process_scope.parent = self
                                self._children_name_map["process_scope"] = "process-scope"
                            return self.process_scope

                        if (child_yang_name == "redistributes"):
                            if (self.redistributes is None):
                                self.redistributes = Ospfv3.Processes.Process.Vrfs.Vrf.Redistributes()
                                self.redistributes.parent = self
                                self._children_name_map["redistributes"] = "redistributes"
                            return self.redistributes

                        if (child_yang_name == "snmp"):
                            if (self.snmp is None):
                                self.snmp = Ospfv3.Processes.Process.Vrfs.Vrf.Snmp()
                                self.snmp.parent = self
                                self._children_name_map["snmp"] = "snmp"
                            return self.snmp

                        if (child_yang_name == "stub-router"):
                            if (self.stub_router is None):
                                self.stub_router = Ospfv3.Processes.Process.Vrfs.Vrf.StubRouter()
                                self.stub_router.parent = self
                                self._children_name_map["stub_router"] = "stub-router"
                            return self.stub_router

                        if (child_yang_name == "summary-prefixes"):
                            if (self.summary_prefixes is None):
                                self.summary_prefixes = Ospfv3.Processes.Process.Vrfs.Vrf.SummaryPrefixes()
                                self.summary_prefixes.parent = self
                                self._children_name_map["summary_prefixes"] = "summary-prefixes"
                            return self.summary_prefixes

                        if (child_yang_name == "timers"):
                            if (self.timers is None):
                                self.timers = Ospfv3.Processes.Process.Vrfs.Vrf.Timers()
                                self.timers.parent = self
                                self._children_name_map["timers"] = "timers"
                            return self.timers

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "area-addresses" or name == "authentication" or name == "auto-cost" or name == "bfd" or name == "capability" or name == "database-filter" or name == "default-information" or name == "distance" or name == "distribute-list" or name == "distribute-list-out" or name == "domain-id" or name == "encryption" or name == "fast-reroute" or name == "graceful-restart" or name == "ignore" or name == "maximum" or name == "process-scope" or name == "redistributes" or name == "snmp" or name == "stub-router" or name == "summary-prefixes" or name == "timers" or name == "vrf-name" or name == "cost" or name == "dead-interval" or name == "default-metric" or name == "demand-circuit" or name == "enable" or name == "flood-reduction" or name == "hello-interval" or name == "instance" or name == "log-adjacency-changes" or name == "mtu-ignore" or name == "network" or name == "packet-size" or name == "passive" or name == "prefix-suppression" or name == "priority" or name == "retransmit-interval" or name == "router-id" or name == "snmpvrf-trap" or name == "spf-prefix-priority-policy" or name == "transmit-delay"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "cost"):
                            self.cost = value
                            self.cost.value_namespace = name_space
                            self.cost.value_namespace_prefix = name_space_prefix
                        if(value_path == "dead-interval"):
                            self.dead_interval = value
                            self.dead_interval.value_namespace = name_space
                            self.dead_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "default-metric"):
                            self.default_metric = value
                            self.default_metric.value_namespace = name_space
                            self.default_metric.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand-circuit"):
                            self.demand_circuit = value
                            self.demand_circuit.value_namespace = name_space
                            self.demand_circuit.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "flood-reduction"):
                            self.flood_reduction = value
                            self.flood_reduction.value_namespace = name_space
                            self.flood_reduction.value_namespace_prefix = name_space_prefix
                        if(value_path == "hello-interval"):
                            self.hello_interval = value
                            self.hello_interval.value_namespace = name_space
                            self.hello_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "instance"):
                            self.instance = value
                            self.instance.value_namespace = name_space
                            self.instance.value_namespace_prefix = name_space_prefix
                        if(value_path == "log-adjacency-changes"):
                            self.log_adjacency_changes = value
                            self.log_adjacency_changes.value_namespace = name_space
                            self.log_adjacency_changes.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu-ignore"):
                            self.mtu_ignore = value
                            self.mtu_ignore.value_namespace = name_space
                            self.mtu_ignore.value_namespace_prefix = name_space_prefix
                        if(value_path == "network"):
                            self.network = value
                            self.network.value_namespace = name_space
                            self.network.value_namespace_prefix = name_space_prefix
                        if(value_path == "packet-size"):
                            self.packet_size = value
                            self.packet_size.value_namespace = name_space
                            self.packet_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "passive"):
                            self.passive = value
                            self.passive.value_namespace = name_space
                            self.passive.value_namespace_prefix = name_space_prefix
                        if(value_path == "prefix-suppression"):
                            self.prefix_suppression = value
                            self.prefix_suppression.value_namespace = name_space
                            self.prefix_suppression.value_namespace_prefix = name_space_prefix
                        if(value_path == "priority"):
                            self.priority = value
                            self.priority.value_namespace = name_space
                            self.priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "retransmit-interval"):
                            self.retransmit_interval = value
                            self.retransmit_interval.value_namespace = name_space
                            self.retransmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "router-id"):
                            self.router_id = value
                            self.router_id.value_namespace = name_space
                            self.router_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "snmpvrf-trap"):
                            self.snmpvrf_trap = value
                            self.snmpvrf_trap.value_namespace = name_space
                            self.snmpvrf_trap.value_namespace_prefix = name_space_prefix
                        if(value_path == "spf-prefix-priority-policy"):
                            self.spf_prefix_priority_policy = value
                            self.spf_prefix_priority_policy.value_namespace = name_space
                            self.spf_prefix_priority_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "transmit-delay"):
                            self.transmit_delay = value
                            self.transmit_delay.value_namespace = name_space
                            self.transmit_delay.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.vrf:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.vrf:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "vrfs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "vrf"):
                        for c in self.vrf:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Ospfv3.Processes.Process.Vrfs.Vrf()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.vrf.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vrf"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Af(Entity):
                """
                Address Family (AF)
                
                .. attribute:: af_name
                
                	Address Family (AF) identifier
                	**type**\:   :py:class:`Ospfv3AddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3AddressFamily>`
                
                	**mandatory**\: True
                
                .. attribute:: saf_name
                
                	Subsequent Address Family (SAF) identifier
                	**type**\:   :py:class:`Ospfv3SubsequentAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3SubsequentAddressFamily>`
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'ipv6-ospfv3-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Ospfv3.Processes.Process.Af, self).__init__()

                    self.yang_name = "af"
                    self.yang_parent_name = "process"
                    self.is_presence_container = True

                    self.af_name = YLeaf(YType.enumeration, "af-name")

                    self.saf_name = YLeaf(YType.enumeration, "saf-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("af_name",
                                    "saf_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Ospfv3.Processes.Process.Af, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Ospfv3.Processes.Process.Af, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.af_name.is_set or
                        self.saf_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.af_name.yfilter != YFilter.not_set or
                        self.saf_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "af" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.af_name.get_name_leafdata())
                    if (self.saf_name.is_set or self.saf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.saf_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "af-name" or name == "saf-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "af-name"):
                        self.af_name = value
                        self.af_name.value_namespace = name_space
                        self.af_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "saf-name"):
                        self.saf_name = value
                        self.saf_name.value_namespace = name_space
                        self.saf_name.value_namespace_prefix = name_space_prefix


            class TraceBufs(Entity):
                """
                Configuration to change size of trace buffer
                
                .. attribute:: trace_buf
                
                	Changes the size of the specified trace buffer
                	**type**\: list of    :py:class:`TraceBuf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.Ospfv3.Processes.Process.TraceBufs.TraceBuf>`
                
                

                """

                _prefix = 'ipv6-ospfv3-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Ospfv3.Processes.Process.TraceBufs, self).__init__()

                    self.yang_name = "trace-bufs"
                    self.yang_parent_name = "process"

                    self.trace_buf = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Ospfv3.Processes.Process.TraceBufs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Ospfv3.Processes.Process.TraceBufs, self).__setattr__(name, value)


                class TraceBuf(Entity):
                    """
                    Changes the size of the specified trace
                    buffer
                    
                    .. attribute:: trace_buf_name  <key>
                    
                    	Name for this VRF
                    	**type**\:  str
                    
                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                    
                    .. attribute:: bufsize
                    
                    	Buffer size
                    	**type**\:   :py:class:`TraceBufSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv6_ospfv3_cfg.TraceBufSize>`
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'ipv6-ospfv3-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Ospfv3.Processes.Process.TraceBufs.TraceBuf, self).__init__()

                        self.yang_name = "trace-buf"
                        self.yang_parent_name = "trace-bufs"

                        self.trace_buf_name = YLeaf(YType.str, "trace-buf-name")

                        self.bufsize = YLeaf(YType.enumeration, "bufsize")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("trace_buf_name",
                                        "bufsize") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Ospfv3.Processes.Process.TraceBufs.TraceBuf, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Ospfv3.Processes.Process.TraceBufs.TraceBuf, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.trace_buf_name.is_set or
                            self.bufsize.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.trace_buf_name.yfilter != YFilter.not_set or
                            self.bufsize.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "trace-buf" + "[trace-buf-name='" + self.trace_buf_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.trace_buf_name.is_set or self.trace_buf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.trace_buf_name.get_name_leafdata())
                        if (self.bufsize.is_set or self.bufsize.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bufsize.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "trace-buf-name" or name == "bufsize"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "trace-buf-name"):
                            self.trace_buf_name = value
                            self.trace_buf_name.value_namespace = name_space
                            self.trace_buf_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "bufsize"):
                            self.bufsize = value
                            self.bufsize.value_namespace = name_space
                            self.bufsize.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.trace_buf:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.trace_buf:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "trace-bufs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "trace-buf"):
                        for c in self.trace_buf:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Ospfv3.Processes.Process.TraceBufs.TraceBuf()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.trace_buf.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "trace-buf"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.process_name.is_set or
                    self.enable.is_set or
                    self.nsr.is_set or
                    self.protocol_shutdown.is_set or
                    (self.default_vrf is not None and self.default_vrf.has_data()) or
                    (self.trace_bufs is not None and self.trace_bufs.has_data()) or
                    (self.vrfs is not None and self.vrfs.has_data()) or
                    (self.af is not None))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.process_name.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.nsr.yfilter != YFilter.not_set or
                    self.protocol_shutdown.yfilter != YFilter.not_set or
                    (self.af is not None and self.af.has_operation()) or
                    (self.default_vrf is not None and self.default_vrf.has_operation()) or
                    (self.trace_bufs is not None and self.trace_bufs.has_operation()) or
                    (self.vrfs is not None and self.vrfs.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "process" + "[process-name='" + self.process_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3/processes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.process_name.get_name_leafdata())
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.nsr.is_set or self.nsr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr.get_name_leafdata())
                if (self.protocol_shutdown.is_set or self.protocol_shutdown.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocol_shutdown.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "af"):
                    if (self.af is None):
                        self.af = Ospfv3.Processes.Process.Af()
                        self.af.parent = self
                        self._children_name_map["af"] = "af"
                    return self.af

                if (child_yang_name == "default-vrf"):
                    if (self.default_vrf is None):
                        self.default_vrf = Ospfv3.Processes.Process.DefaultVrf()
                        self.default_vrf.parent = self
                        self._children_name_map["default_vrf"] = "default-vrf"
                    return self.default_vrf

                if (child_yang_name == "trace-bufs"):
                    if (self.trace_bufs is None):
                        self.trace_bufs = Ospfv3.Processes.Process.TraceBufs()
                        self.trace_bufs.parent = self
                        self._children_name_map["trace_bufs"] = "trace-bufs"
                    return self.trace_bufs

                if (child_yang_name == "vrfs"):
                    if (self.vrfs is None):
                        self.vrfs = Ospfv3.Processes.Process.Vrfs()
                        self.vrfs.parent = self
                        self._children_name_map["vrfs"] = "vrfs"
                    return self.vrfs

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "af" or name == "default-vrf" or name == "trace-bufs" or name == "vrfs" or name == "process-name" or name == "enable" or name == "nsr" or name == "protocol-shutdown"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "process-name"):
                    self.process_name = value
                    self.process_name.value_namespace = name_space
                    self.process_name.value_namespace_prefix = name_space_prefix
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr"):
                    self.nsr = value
                    self.nsr.value_namespace = name_space
                    self.nsr.value_namespace_prefix = name_space_prefix
                if(value_path == "protocol-shutdown"):
                    self.protocol_shutdown = value
                    self.protocol_shutdown.value_namespace = name_space
                    self.protocol_shutdown.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.process:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.process:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "processes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "process"):
                for c in self.process:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Ospfv3.Processes.Process()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.process.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "process"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            self.dns_name_lookup.is_set or
            (self.processes is not None and self.processes.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            self.dns_name_lookup.yfilter != YFilter.not_set or
            (self.processes is not None and self.processes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()
        if (self.dns_name_lookup.is_set or self.dns_name_lookup.yfilter != YFilter.not_set):
            leaf_name_data.append(self.dns_name_lookup.get_name_leafdata())

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "processes"):
            if (self.processes is None):
                self.processes = Ospfv3.Processes()
                self.processes.parent = self
                self._children_name_map["processes"] = "processes"
            return self.processes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "processes" or name == "dns-name-lookup"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        if(value_path == "dns-name-lookup"):
            self.dns_name_lookup = value
            self.dns_name_lookup.value_namespace = name_space
            self.dns_name_lookup.value_namespace_prefix = name_space_prefix

    def clone_ptr(self):
        self._top_entity = Ospfv3()
        return self._top_entity

