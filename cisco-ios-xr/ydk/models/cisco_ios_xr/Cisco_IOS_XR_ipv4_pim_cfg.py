""" Cisco_IOS_XR_ipv4_pim_cfg 

This module contains a collection of YANG definitions
for Cisco IOS\-XR ipv4\-pim package configuration.

This module contains definitions
for the following management objects\:
  pim\: PIM configuration

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class PimMultipath(Enum):
    """
    PimMultipath

    Pim multipath

    .. data:: enable = 0

    	Enable PIM multipath

    .. data:: interface_hash = 1

    	Enable PIM multipath with interface based

    	hashing

    .. data:: source_hash = 2

    	Enable PIM multipath with source based hashing

    .. data:: source_next_hop_hash = 3

    	Enable PIM multipath with source next-hop

    	hashing

    .. data:: source_group_hash = 4

    	Enable PIM multipath with source, group based

    	hashing

    """

    enable = Enum.YLeaf(0, "enable")

    interface_hash = Enum.YLeaf(1, "interface-hash")

    source_hash = Enum.YLeaf(2, "source-hash")

    source_next_hop_hash = Enum.YLeaf(3, "source-next-hop-hash")

    source_group_hash = Enum.YLeaf(4, "source-group-hash")


class PimProtocolMode(Enum):
    """
    PimProtocolMode

    Pim protocol mode

    .. data:: sm = 0

    	Sparse Mode

    .. data:: bidir = 1

    	Bidirectional

    """

    sm = Enum.YLeaf(0, "sm")

    bidir = Enum.YLeaf(1, "bidir")



class Pim(Entity):
    """
    PIM configuration
    
    .. attribute:: default_context
    
    	Default Context
    	**type**\:   :py:class:`DefaultContext <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext>`
    
    	**presence node**\: True
    
    .. attribute:: vrfs
    
    	VRF table
    	**type**\:   :py:class:`Vrfs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs>`
    
    

    This class is a :ref:`presence class<presence-class>`

    """

    _prefix = 'ipv4-pim-cfg'
    _revision = '2016-06-01'

    def __init__(self):
        super(Pim, self).__init__()
        self._top_entity = None

        self.yang_name = "pim"
        self.yang_parent_name = "Cisco-IOS-XR-ipv4-pim-cfg"
        self.is_presence_container = True

        self.default_context = None
        self._children_name_map["default_context"] = "default-context"
        self._children_yang_names.add("default-context")

        self.vrfs = Pim.Vrfs()
        self.vrfs.parent = self
        self._children_name_map["vrfs"] = "vrfs"
        self._children_yang_names.add("vrfs")


    class Vrfs(Entity):
        """
        VRF table
        
        .. attribute:: vrf
        
        	VRF name
        	**type**\: list of    :py:class:`Vrf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf>`
        
        

        """

        _prefix = 'ipv4-pim-cfg'
        _revision = '2016-06-01'

        def __init__(self):
            super(Pim.Vrfs, self).__init__()

            self.yang_name = "vrfs"
            self.yang_parent_name = "pim"

            self.vrf = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Pim.Vrfs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Pim.Vrfs, self).__setattr__(name, value)


        class Vrf(Entity):
            """
            VRF name
            
            .. attribute:: vrf_name  <key>
            
            	VRF name
            	**type**\:  str
            
            	**length:** 1..32
            
            .. attribute:: ipv4
            
            	IPV4 commands
            	**type**\:   :py:class:`Ipv4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4>`
            
            .. attribute:: ipv6
            
            	IPV6 commands
            	**type**\:   :py:class:`Ipv6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6>`
            
            

            """

            _prefix = 'ipv4-pim-cfg'
            _revision = '2016-06-01'

            def __init__(self):
                super(Pim.Vrfs.Vrf, self).__init__()

                self.yang_name = "vrf"
                self.yang_parent_name = "vrfs"

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.ipv4 = Pim.Vrfs.Vrf.Ipv4()
                self.ipv4.parent = self
                self._children_name_map["ipv4"] = "ipv4"
                self._children_yang_names.add("ipv4")

                self.ipv6 = Pim.Vrfs.Vrf.Ipv6()
                self.ipv6.parent = self
                self._children_name_map["ipv6"] = "ipv6"
                self._children_yang_names.add("ipv6")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pim.Vrfs.Vrf, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pim.Vrfs.Vrf, self).__setattr__(name, value)


            class Ipv4(Entity):
                """
                IPV4 commands
                
                .. attribute:: accept_register
                
                	Access\-list which specifies unauthorized sources
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: allow_rp
                
                	Enable allow\-rp filtering for SM joins
                	**type**\:   :py:class:`AllowRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.AllowRp>`
                
                	**presence node**\: True
                
                .. attribute:: auto_rp_disable
                
                	Disable Rendezvous Point discovery through the AutoRP protocol
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: bidir_rp_addresses
                
                	Configure Bidirectional PIM Rendezvous Point
                	**type**\:   :py:class:`BidirRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses>`
                
                .. attribute:: bsr
                
                	PIM BSR configuration
                	**type**\:   :py:class:`Bsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Bsr>`
                
                .. attribute:: cj_multicast_only_frrs
                
                	Clone Join Multicast Only FRR
                	**type**\:   :py:class:`CjMulticastOnlyFrrs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs>`
                
                .. attribute:: convergence
                
                	Configure convergence parameters
                	**type**\:   :py:class:`Convergence <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Convergence>`
                
                .. attribute:: cs_multicast_only_frrs
                
                	Clone Source Multicast Only FRR
                	**type**\:   :py:class:`CsMulticastOnlyFrrs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs>`
                
                .. attribute:: inheritable_defaults
                
                	Inheritable defaults
                	**type**\:   :py:class:`InheritableDefaults <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.InheritableDefaults>`
                
                .. attribute:: injects
                
                	Inject Explicit PIM RPF Vector Proxy's
                	**type**\:   :py:class:`Injects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Injects>`
                
                .. attribute:: interfaces
                
                	Interface\-level Configuration
                	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Interfaces>`
                
                .. attribute:: log_neighbor_changes
                
                	PIM neighbor state change logging is turned on if configured
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: maximum
                
                	Configure PIM State Limits
                	**type**\:   :py:class:`Maximum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Maximum>`
                
                .. attribute:: multicast_only_frr
                
                	Multicast Only FRR
                	**type**\:   :py:class:`MulticastOnlyFrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.MulticastOnlyFrr>`
                
                .. attribute:: multipath
                
                	Enable equal\-cost multipath routing
                	**type**\:   :py:class:`PimMultipath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimMultipath>`
                
                .. attribute:: neighbor_check_on_receive
                
                	Enable PIM neighbor checking when receiving PIM messages
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: neighbor_check_on_send
                
                	Enable PIM neighbor checking when sending join\-prunes
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: neighbor_filter
                
                	Access\-list of neighbors to be filtered
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: old_register_checksum
                
                	Generate registers compatible with older IOS versions
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: paths
                
                	Inject PIM RPF Vector Proxy's
                	**type**\:   :py:class:`Paths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Paths>`
                
                .. attribute:: register_source
                
                	Source address to use for register messages
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: rp_static_deny
                
                	Configure static RP deny range
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: rpf
                
                	Configure RPF options
                	**type**\:   :py:class:`Rpf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Rpf>`
                
                .. attribute:: rpf_vector_enable
                
                	Enable PIM RPF Vector Proxy's
                	**type**\:   :py:class:`RpfVectorEnable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.RpfVectorEnable>`
                
                	**presence node**\: True
                
                .. attribute:: sg_expiry_timer
                
                	Configure expiry timer for S,G routes
                	**type**\:   :py:class:`SgExpiryTimer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.SgExpiryTimer>`
                
                .. attribute:: sparse_mode_rp_addresses
                
                	Configure Sparse\-Mode Rendezvous Point
                	**type**\:   :py:class:`SparseModeRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses>`
                
                .. attribute:: spt_threshold_infinity
                
                	Configure threshold of infinity for switching to SPT on last\-hop
                	**type**\:  str
                
                .. attribute:: ssm
                
                	Configure IP Multicast SSM
                	**type**\:   :py:class:`Ssm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Ssm>`
                
                .. attribute:: ssm_allow_override
                
                	Allow SSM ranges to be overridden by more specific ranges
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: suppress_data_registers
                
                	Suppress data registers after initial state setup
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: suppress_rpf_prunes
                
                	Suppress prunes triggered as a result of RPF changes
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.Vrfs.Vrf.Ipv4, self).__init__()

                    self.yang_name = "ipv4"
                    self.yang_parent_name = "vrf"

                    self.accept_register = YLeaf(YType.str, "accept-register")

                    self.auto_rp_disable = YLeaf(YType.empty, "auto-rp-disable")

                    self.log_neighbor_changes = YLeaf(YType.empty, "log-neighbor-changes")

                    self.multipath = YLeaf(YType.enumeration, "multipath")

                    self.neighbor_check_on_receive = YLeaf(YType.empty, "neighbor-check-on-receive")

                    self.neighbor_check_on_send = YLeaf(YType.empty, "neighbor-check-on-send")

                    self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                    self.old_register_checksum = YLeaf(YType.empty, "old-register-checksum")

                    self.register_source = YLeaf(YType.str, "register-source")

                    self.rp_static_deny = YLeaf(YType.str, "rp-static-deny")

                    self.spt_threshold_infinity = YLeaf(YType.str, "spt-threshold-infinity")

                    self.ssm_allow_override = YLeaf(YType.empty, "ssm-allow-override")

                    self.suppress_data_registers = YLeaf(YType.empty, "suppress-data-registers")

                    self.suppress_rpf_prunes = YLeaf(YType.empty, "suppress-rpf-prunes")

                    self.allow_rp = None
                    self._children_name_map["allow_rp"] = "allow-rp"
                    self._children_yang_names.add("allow-rp")

                    self.bidir_rp_addresses = Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses()
                    self.bidir_rp_addresses.parent = self
                    self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                    self._children_yang_names.add("bidir-rp-addresses")

                    self.bsr = Pim.Vrfs.Vrf.Ipv4.Bsr()
                    self.bsr.parent = self
                    self._children_name_map["bsr"] = "bsr"
                    self._children_yang_names.add("bsr")

                    self.cj_multicast_only_frrs = Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs()
                    self.cj_multicast_only_frrs.parent = self
                    self._children_name_map["cj_multicast_only_frrs"] = "cj-multicast-only-frrs"
                    self._children_yang_names.add("cj-multicast-only-frrs")

                    self.convergence = Pim.Vrfs.Vrf.Ipv4.Convergence()
                    self.convergence.parent = self
                    self._children_name_map["convergence"] = "convergence"
                    self._children_yang_names.add("convergence")

                    self.cs_multicast_only_frrs = Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs()
                    self.cs_multicast_only_frrs.parent = self
                    self._children_name_map["cs_multicast_only_frrs"] = "cs-multicast-only-frrs"
                    self._children_yang_names.add("cs-multicast-only-frrs")

                    self.inheritable_defaults = Pim.Vrfs.Vrf.Ipv4.InheritableDefaults()
                    self.inheritable_defaults.parent = self
                    self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                    self._children_yang_names.add("inheritable-defaults")

                    self.injects = Pim.Vrfs.Vrf.Ipv4.Injects()
                    self.injects.parent = self
                    self._children_name_map["injects"] = "injects"
                    self._children_yang_names.add("injects")

                    self.interfaces = Pim.Vrfs.Vrf.Ipv4.Interfaces()
                    self.interfaces.parent = self
                    self._children_name_map["interfaces"] = "interfaces"
                    self._children_yang_names.add("interfaces")

                    self.maximum = Pim.Vrfs.Vrf.Ipv4.Maximum()
                    self.maximum.parent = self
                    self._children_name_map["maximum"] = "maximum"
                    self._children_yang_names.add("maximum")

                    self.multicast_only_frr = Pim.Vrfs.Vrf.Ipv4.MulticastOnlyFrr()
                    self.multicast_only_frr.parent = self
                    self._children_name_map["multicast_only_frr"] = "multicast-only-frr"
                    self._children_yang_names.add("multicast-only-frr")

                    self.paths = Pim.Vrfs.Vrf.Ipv4.Paths()
                    self.paths.parent = self
                    self._children_name_map["paths"] = "paths"
                    self._children_yang_names.add("paths")

                    self.rpf = Pim.Vrfs.Vrf.Ipv4.Rpf()
                    self.rpf.parent = self
                    self._children_name_map["rpf"] = "rpf"
                    self._children_yang_names.add("rpf")

                    self.rpf_vector_enable = None
                    self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                    self._children_yang_names.add("rpf-vector-enable")

                    self.sg_expiry_timer = Pim.Vrfs.Vrf.Ipv4.SgExpiryTimer()
                    self.sg_expiry_timer.parent = self
                    self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                    self._children_yang_names.add("sg-expiry-timer")

                    self.sparse_mode_rp_addresses = Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses()
                    self.sparse_mode_rp_addresses.parent = self
                    self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                    self._children_yang_names.add("sparse-mode-rp-addresses")

                    self.ssm = Pim.Vrfs.Vrf.Ipv4.Ssm()
                    self.ssm.parent = self
                    self._children_name_map["ssm"] = "ssm"
                    self._children_yang_names.add("ssm")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("accept_register",
                                    "auto_rp_disable",
                                    "log_neighbor_changes",
                                    "multipath",
                                    "neighbor_check_on_receive",
                                    "neighbor_check_on_send",
                                    "neighbor_filter",
                                    "old_register_checksum",
                                    "register_source",
                                    "rp_static_deny",
                                    "spt_threshold_infinity",
                                    "ssm_allow_override",
                                    "suppress_data_registers",
                                    "suppress_rpf_prunes") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.Vrfs.Vrf.Ipv4, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.Vrfs.Vrf.Ipv4, self).__setattr__(name, value)


                class SparseModeRpAddresses(Entity):
                    """
                    Configure Sparse\-Mode Rendezvous Point
                    
                    .. attribute:: sparse_mode_rp_address
                    
                    	Address of the Rendezvous Point
                    	**type**\: list of    :py:class:`SparseModeRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses.SparseModeRpAddress>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses, self).__init__()

                        self.yang_name = "sparse-mode-rp-addresses"
                        self.yang_parent_name = "ipv4"

                        self.sparse_mode_rp_address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses, self).__setattr__(name, value)


                    class SparseModeRpAddress(Entity):
                        """
                        Address of the Rendezvous Point
                        
                        .. attribute:: rp_address  <key>
                        
                        	RP address of Rendezvous Point
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: access_list_name
                        
                        	Access list of groups that should map to a  given RP
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: auto_rp_override
                        
                        	TRUE Indicates if static RP config overrides AutoRP and BSR
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses.SparseModeRpAddress, self).__init__()

                            self.yang_name = "sparse-mode-rp-address"
                            self.yang_parent_name = "sparse-mode-rp-addresses"

                            self.rp_address = YLeaf(YType.str, "rp-address")

                            self.access_list_name = YLeaf(YType.str, "access-list-name")

                            self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rp_address",
                                            "access_list_name",
                                            "auto_rp_override") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.rp_address.is_set or
                                self.access_list_name.is_set or
                                self.auto_rp_override.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rp_address.yfilter != YFilter.not_set or
                                self.access_list_name.yfilter != YFilter.not_set or
                                self.auto_rp_override.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sparse-mode-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rp_address.get_name_leafdata())
                            if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.access_list_name.get_name_leafdata())
                            if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rp-address"):
                                self.rp_address = value
                                self.rp_address.value_namespace = name_space
                                self.rp_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "access-list-name"):
                                self.access_list_name = value
                                self.access_list_name.value_namespace = name_space
                                self.access_list_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "auto-rp-override"):
                                self.auto_rp_override = value
                                self.auto_rp_override.value_namespace = name_space
                                self.auto_rp_override.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.sparse_mode_rp_address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.sparse_mode_rp_address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sparse-mode-rp-addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sparse-mode-rp-address"):
                            for c in self.sparse_mode_rp_address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses.SparseModeRpAddress()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.sparse_mode_rp_address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sparse-mode-rp-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class MulticastOnlyFrr(Entity):
                    """
                    Multicast Only FRR
                    
                    .. attribute:: enable
                    
                    	Enable Multicast Only FRR
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: flow_multicast_only_frr
                    
                    	Access\-list specifying SG that should do FLOW MOFRR
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: non_revertive_multicast_only_frr
                    
                    	Non\-revertive Multicast Only FRR
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: rib_multicast_only_frr
                    
                    	Access\-list specifying SG that should do RIB MOFRR
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.MulticastOnlyFrr, self).__init__()

                        self.yang_name = "multicast-only-frr"
                        self.yang_parent_name = "ipv4"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.flow_multicast_only_frr = YLeaf(YType.str, "flow-multicast-only-frr")

                        self.non_revertive_multicast_only_frr = YLeaf(YType.empty, "non-revertive-multicast-only-frr")

                        self.rib_multicast_only_frr = YLeaf(YType.str, "rib-multicast-only-frr")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "flow_multicast_only_frr",
                                        "non_revertive_multicast_only_frr",
                                        "rib_multicast_only_frr") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.MulticastOnlyFrr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.MulticastOnlyFrr, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.flow_multicast_only_frr.is_set or
                            self.non_revertive_multicast_only_frr.is_set or
                            self.rib_multicast_only_frr.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.flow_multicast_only_frr.yfilter != YFilter.not_set or
                            self.non_revertive_multicast_only_frr.yfilter != YFilter.not_set or
                            self.rib_multicast_only_frr.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "multicast-only-frr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.flow_multicast_only_frr.is_set or self.flow_multicast_only_frr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.flow_multicast_only_frr.get_name_leafdata())
                        if (self.non_revertive_multicast_only_frr.is_set or self.non_revertive_multicast_only_frr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.non_revertive_multicast_only_frr.get_name_leafdata())
                        if (self.rib_multicast_only_frr.is_set or self.rib_multicast_only_frr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rib_multicast_only_frr.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "flow-multicast-only-frr" or name == "non-revertive-multicast-only-frr" or name == "rib-multicast-only-frr"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "flow-multicast-only-frr"):
                            self.flow_multicast_only_frr = value
                            self.flow_multicast_only_frr.value_namespace = name_space
                            self.flow_multicast_only_frr.value_namespace_prefix = name_space_prefix
                        if(value_path == "non-revertive-multicast-only-frr"):
                            self.non_revertive_multicast_only_frr = value
                            self.non_revertive_multicast_only_frr.value_namespace = name_space
                            self.non_revertive_multicast_only_frr.value_namespace_prefix = name_space_prefix
                        if(value_path == "rib-multicast-only-frr"):
                            self.rib_multicast_only_frr = value
                            self.rib_multicast_only_frr.value_namespace = name_space
                            self.rib_multicast_only_frr.value_namespace_prefix = name_space_prefix


                class CsMulticastOnlyFrrs(Entity):
                    """
                    Clone Source Multicast Only FRR
                    
                    .. attribute:: cs_multicast_only_frr
                    
                    	Clone Source Multicast Only FRR
                    	**type**\: list of    :py:class:`CsMulticastOnlyFrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs, self).__init__()

                        self.yang_name = "cs-multicast-only-frrs"
                        self.yang_parent_name = "ipv4"

                        self.cs_multicast_only_frr = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs, self).__setattr__(name, value)


                    class CsMulticastOnlyFrr(Entity):
                        """
                        Clone Source Multicast Only FRR
                        
                        .. attribute:: source  <key>
                        
                        	Original address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: primary  <key>
                        
                        	Primary address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: backup  <key>
                        
                        	Backup address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_length  <key>
                        
                        	Masklen
                        	**type**\:  int
                        
                        	**range:** 0..32
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr, self).__init__()

                            self.yang_name = "cs-multicast-only-frr"
                            self.yang_parent_name = "cs-multicast-only-frrs"

                            self.source = YLeaf(YType.str, "source")

                            self.primary = YLeaf(YType.str, "primary")

                            self.backup = YLeaf(YType.str, "backup")

                            self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("source",
                                            "primary",
                                            "backup",
                                            "prefix_length") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.source.is_set or
                                self.primary.is_set or
                                self.backup.is_set or
                                self.prefix_length.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.source.yfilter != YFilter.not_set or
                                self.primary.yfilter != YFilter.not_set or
                                self.backup.yfilter != YFilter.not_set or
                                self.prefix_length.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "cs-multicast-only-frr" + "[source='" + self.source.get() + "']" + "[primary='" + self.primary.get() + "']" + "[backup='" + self.backup.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source.get_name_leafdata())
                            if (self.primary.is_set or self.primary.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.primary.get_name_leafdata())
                            if (self.backup.is_set or self.backup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.backup.get_name_leafdata())
                            if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_length.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "source" or name == "primary" or name == "backup" or name == "prefix-length"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "source"):
                                self.source = value
                                self.source.value_namespace = name_space
                                self.source.value_namespace_prefix = name_space_prefix
                            if(value_path == "primary"):
                                self.primary = value
                                self.primary.value_namespace = name_space
                                self.primary.value_namespace_prefix = name_space_prefix
                            if(value_path == "backup"):
                                self.backup = value
                                self.backup.value_namespace = name_space
                                self.backup.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-length"):
                                self.prefix_length = value
                                self.prefix_length.value_namespace = name_space
                                self.prefix_length.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.cs_multicast_only_frr:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.cs_multicast_only_frr:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "cs-multicast-only-frrs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "cs-multicast-only-frr"):
                            for c in self.cs_multicast_only_frr:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.cs_multicast_only_frr.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "cs-multicast-only-frr"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class InheritableDefaults(Entity):
                    """
                    Inheritable defaults
                    
                    .. attribute:: convergency
                    
                    	Convergency timeout in seconds
                    	**type**\:  int
                    
                    	**range:** 1800..2400
                    
                    	**units**\: second
                    
                    .. attribute:: dr_priority
                    
                    	Hello DR priority, preference given to larger value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: hello_interval
                    
                    	Hello interval in seconds
                    	**type**\:  int
                    
                    	**range:** 1..3600
                    
                    	**units**\: second
                    
                    .. attribute:: join_prune_mtu
                    
                    	Join\-Prune MTU in Bytes
                    	**type**\:  int
                    
                    	**range:** 576..65535
                    
                    	**units**\: byte
                    
                    .. attribute:: jp_interval
                    
                    	Join\-Prune interval in seconds
                    	**type**\:  int
                    
                    	**range:** 10..600
                    
                    	**units**\: second
                    
                    .. attribute:: override_interval
                    
                    	Override interval in milliseconds
                    	**type**\:  int
                    
                    	**range:** 400..65535
                    
                    	**units**\: millisecond
                    
                    .. attribute:: propagation_delay
                    
                    	Propagation delay in milli seconds
                    	**type**\:  int
                    
                    	**range:** 100..32767
                    
                    	**units**\: millisecond
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.InheritableDefaults, self).__init__()

                        self.yang_name = "inheritable-defaults"
                        self.yang_parent_name = "ipv4"

                        self.convergency = YLeaf(YType.uint32, "convergency")

                        self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                        self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                        self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                        self.override_interval = YLeaf(YType.uint32, "override-interval")

                        self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("convergency",
                                        "dr_priority",
                                        "hello_interval",
                                        "join_prune_mtu",
                                        "jp_interval",
                                        "override_interval",
                                        "propagation_delay") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.InheritableDefaults, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.InheritableDefaults, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.convergency.is_set or
                            self.dr_priority.is_set or
                            self.hello_interval.is_set or
                            self.join_prune_mtu.is_set or
                            self.jp_interval.is_set or
                            self.override_interval.is_set or
                            self.propagation_delay.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.convergency.yfilter != YFilter.not_set or
                            self.dr_priority.yfilter != YFilter.not_set or
                            self.hello_interval.yfilter != YFilter.not_set or
                            self.join_prune_mtu.yfilter != YFilter.not_set or
                            self.jp_interval.yfilter != YFilter.not_set or
                            self.override_interval.yfilter != YFilter.not_set or
                            self.propagation_delay.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "inheritable-defaults" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.convergency.is_set or self.convergency.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.convergency.get_name_leafdata())
                        if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dr_priority.get_name_leafdata())
                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                        if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                        if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.jp_interval.get_name_leafdata())
                        if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.override_interval.get_name_leafdata())
                        if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "convergency" or name == "dr-priority" or name == "hello-interval" or name == "join-prune-mtu" or name == "jp-interval" or name == "override-interval" or name == "propagation-delay"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "convergency"):
                            self.convergency = value
                            self.convergency.value_namespace = name_space
                            self.convergency.value_namespace_prefix = name_space_prefix
                        if(value_path == "dr-priority"):
                            self.dr_priority = value
                            self.dr_priority.value_namespace = name_space
                            self.dr_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "hello-interval"):
                            self.hello_interval = value
                            self.hello_interval.value_namespace = name_space
                            self.hello_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "join-prune-mtu"):
                            self.join_prune_mtu = value
                            self.join_prune_mtu.value_namespace = name_space
                            self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                        if(value_path == "jp-interval"):
                            self.jp_interval = value
                            self.jp_interval.value_namespace = name_space
                            self.jp_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "override-interval"):
                            self.override_interval = value
                            self.override_interval.value_namespace = name_space
                            self.override_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "propagation-delay"):
                            self.propagation_delay = value
                            self.propagation_delay.value_namespace = name_space
                            self.propagation_delay.value_namespace_prefix = name_space_prefix


                class Rpf(Entity):
                    """
                    Configure RPF options
                    
                    .. attribute:: route_policy
                    
                    	Route policy to select RPF topology
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Rpf, self).__init__()

                        self.yang_name = "rpf"
                        self.yang_parent_name = "ipv4"

                        self.route_policy = YLeaf(YType.str, "route-policy")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("route_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.Rpf, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.Rpf, self).__setattr__(name, value)

                    def has_data(self):
                        return self.route_policy.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.route_policy.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rpf" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.route_policy.is_set or self.route_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "route-policy"):
                            self.route_policy = value
                            self.route_policy.value_namespace = name_space
                            self.route_policy.value_namespace_prefix = name_space_prefix


                class Maximum(Entity):
                    """
                    Configure PIM State Limits
                    
                    .. attribute:: bsr_candidate_rp_cache
                    
                    	Override default maximum and threshold for BSR C\-RP cache setting
                    	**type**\:   :py:class:`BsrCandidateRpCache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Maximum.BsrCandidateRpCache>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: bsr_group_mappings
                    
                    	Override default maximum and threshold for number of group mappings from BSR
                    	**type**\:   :py:class:`BsrGroupMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Maximum.BsrGroupMappings>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: group_mappings_auto_rp
                    
                    	Override default maximum for number of group mappings from autorp mapping agent
                    	**type**\:   :py:class:`GroupMappingsAutoRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Maximum.GroupMappingsAutoRp>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: register_states
                    
                    	Override default maximum for number of sparse\-mode source registers
                    	**type**\:   :py:class:`RegisterStates <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Maximum.RegisterStates>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: route_interfaces
                    
                    	Override default maximum for number of route\-interfaces
                    	**type**\:   :py:class:`RouteInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Maximum.RouteInterfaces>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: routes
                    
                    	Override default maximum for number of routes
                    	**type**\:   :py:class:`Routes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Maximum.Routes>`
                    
                    	**presence node**\: True
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Maximum, self).__init__()

                        self.yang_name = "maximum"
                        self.yang_parent_name = "ipv4"

                        self.bsr_candidate_rp_cache = None
                        self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                        self._children_yang_names.add("bsr-candidate-rp-cache")

                        self.bsr_group_mappings = None
                        self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                        self._children_yang_names.add("bsr-group-mappings")

                        self.group_mappings_auto_rp = None
                        self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                        self._children_yang_names.add("group-mappings-auto-rp")

                        self.register_states = None
                        self._children_name_map["register_states"] = "register-states"
                        self._children_yang_names.add("register-states")

                        self.route_interfaces = None
                        self._children_name_map["route_interfaces"] = "route-interfaces"
                        self._children_yang_names.add("route-interfaces")

                        self.routes = None
                        self._children_name_map["routes"] = "routes"
                        self._children_yang_names.add("routes")


                    class GroupMappingsAutoRp(Entity):
                        """
                        Override default maximum for number of group
                        mappings from autorp mapping agent
                        
                        .. attribute:: maximum_group_ranges_auto_rp
                        
                        	Maximum number of PIM group mappings from autorp
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: threshold_group_ranges_auto_rp
                        
                        	Warning threshold number of PIM group mappings from autorp
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**default value**\: 450
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Maximum.GroupMappingsAutoRp, self).__init__()

                            self.yang_name = "group-mappings-auto-rp"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_group_ranges_auto_rp = YLeaf(YType.uint32, "maximum-group-ranges-auto-rp")

                            self.threshold_group_ranges_auto_rp = YLeaf(YType.uint32, "threshold-group-ranges-auto-rp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_group_ranges_auto_rp",
                                            "threshold_group_ranges_auto_rp") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_group_ranges_auto_rp.is_set or
                                self.threshold_group_ranges_auto_rp.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set or
                                self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "group-mappings-auto-rp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_group_ranges_auto_rp.is_set or self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_group_ranges_auto_rp.get_name_leafdata())
                            if (self.threshold_group_ranges_auto_rp.is_set or self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_group_ranges_auto_rp.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-group-ranges-auto-rp" or name == "threshold-group-ranges-auto-rp"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-group-ranges-auto-rp"):
                                self.maximum_group_ranges_auto_rp = value
                                self.maximum_group_ranges_auto_rp.value_namespace = name_space
                                self.maximum_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-group-ranges-auto-rp"):
                                self.threshold_group_ranges_auto_rp = value
                                self.threshold_group_ranges_auto_rp.value_namespace = name_space
                                self.threshold_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix


                    class BsrGroupMappings(Entity):
                        """
                        Override default maximum and threshold for
                        number of group mappings from BSR
                        
                        .. attribute:: bsr_maximum_group_ranges
                        
                        	Maximum number of PIM group mappings from BSR
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**default value**\: 500
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Maximum.BsrGroupMappings, self).__init__()

                            self.yang_name = "bsr-group-mappings"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.bsr_maximum_group_ranges = YLeaf(YType.uint32, "bsr-maximum-group-ranges")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bsr_maximum_group_ranges",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Maximum.BsrGroupMappings, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Maximum.BsrGroupMappings, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bsr_maximum_group_ranges.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bsr_maximum_group_ranges.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bsr-group-mappings" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bsr_maximum_group_ranges.is_set or self.bsr_maximum_group_ranges.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bsr_maximum_group_ranges.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bsr-maximum-group-ranges" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bsr-maximum-group-ranges"):
                                self.bsr_maximum_group_ranges = value
                                self.bsr_maximum_group_ranges.value_namespace = name_space
                                self.bsr_maximum_group_ranges.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class RegisterStates(Entity):
                        """
                        Override default maximum for number of
                        sparse\-mode source registers
                        
                        .. attribute:: maximum_register_states
                        
                        	Maximum number of PIM Sparse\-Mode register states
                        	**type**\:  int
                        
                        	**range:** 0..75000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 0..75000
                        
                        	**default value**\: 20000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Maximum.RegisterStates, self).__init__()

                            self.yang_name = "register-states"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_register_states = YLeaf(YType.uint32, "maximum-register-states")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_register_states",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Maximum.RegisterStates, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Maximum.RegisterStates, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_register_states.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_register_states.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "register-states" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_register_states.is_set or self.maximum_register_states.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_register_states.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-register-states" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-register-states"):
                                self.maximum_register_states = value
                                self.maximum_register_states.value_namespace = name_space
                                self.maximum_register_states.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class RouteInterfaces(Entity):
                        """
                        Override default maximum for number of
                        route\-interfaces
                        
                        .. attribute:: maximum_route_interfaces
                        
                        	Maximum number of PIM route\-interfaces
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        	**default value**\: 300000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Maximum.RouteInterfaces, self).__init__()

                            self.yang_name = "route-interfaces"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_route_interfaces = YLeaf(YType.uint32, "maximum-route-interfaces")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_route_interfaces",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Maximum.RouteInterfaces, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Maximum.RouteInterfaces, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_route_interfaces.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_route_interfaces.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "route-interfaces" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_route_interfaces.is_set or self.maximum_route_interfaces.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_route_interfaces.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-route-interfaces" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-route-interfaces"):
                                self.maximum_route_interfaces = value
                                self.maximum_route_interfaces.value_namespace = name_space
                                self.maximum_route_interfaces.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class BsrCandidateRpCache(Entity):
                        """
                        Override default maximum and threshold for BSR
                        C\-RP cache setting
                        
                        .. attribute:: bsr_maximum_candidate_rp_cache
                        
                        	Maximum number of BSR C\-RP cache setting
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**default value**\: 100
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Maximum.BsrCandidateRpCache, self).__init__()

                            self.yang_name = "bsr-candidate-rp-cache"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.bsr_maximum_candidate_rp_cache = YLeaf(YType.uint32, "bsr-maximum-candidate-rp-cache")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bsr_maximum_candidate_rp_cache",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bsr_maximum_candidate_rp_cache.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bsr-candidate-rp-cache" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bsr_maximum_candidate_rp_cache.is_set or self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bsr_maximum_candidate_rp_cache.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bsr-maximum-candidate-rp-cache" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bsr-maximum-candidate-rp-cache"):
                                self.bsr_maximum_candidate_rp_cache = value
                                self.bsr_maximum_candidate_rp_cache.value_namespace = name_space
                                self.bsr_maximum_candidate_rp_cache.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class Routes(Entity):
                        """
                        Override default maximum for number of routes
                        
                        .. attribute:: maximum_routes
                        
                        	Maximum number of PIM routes
                        	**type**\:  int
                        
                        	**range:** 1..200000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..200000
                        
                        	**default value**\: 100000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Maximum.Routes, self).__init__()

                            self.yang_name = "routes"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_routes = YLeaf(YType.uint32, "maximum-routes")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_routes",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Maximum.Routes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Maximum.Routes, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_routes.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_routes.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "routes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_routes.is_set or self.maximum_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_routes.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-routes" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-routes"):
                                self.maximum_routes = value
                                self.maximum_routes.value_namespace = name_space
                                self.maximum_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.bsr_candidate_rp_cache is not None) or
                            (self.bsr_group_mappings is not None) or
                            (self.group_mappings_auto_rp is not None) or
                            (self.register_states is not None) or
                            (self.route_interfaces is not None) or
                            (self.routes is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.bsr_candidate_rp_cache is not None and self.bsr_candidate_rp_cache.has_operation()) or
                            (self.bsr_group_mappings is not None and self.bsr_group_mappings.has_operation()) or
                            (self.group_mappings_auto_rp is not None and self.group_mappings_auto_rp.has_operation()) or
                            (self.register_states is not None and self.register_states.has_operation()) or
                            (self.route_interfaces is not None and self.route_interfaces.has_operation()) or
                            (self.routes is not None and self.routes.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "maximum" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bsr-candidate-rp-cache"):
                            if (self.bsr_candidate_rp_cache is None):
                                self.bsr_candidate_rp_cache = Pim.Vrfs.Vrf.Ipv4.Maximum.BsrCandidateRpCache()
                                self.bsr_candidate_rp_cache.parent = self
                                self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                            return self.bsr_candidate_rp_cache

                        if (child_yang_name == "bsr-group-mappings"):
                            if (self.bsr_group_mappings is None):
                                self.bsr_group_mappings = Pim.Vrfs.Vrf.Ipv4.Maximum.BsrGroupMappings()
                                self.bsr_group_mappings.parent = self
                                self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                            return self.bsr_group_mappings

                        if (child_yang_name == "group-mappings-auto-rp"):
                            if (self.group_mappings_auto_rp is None):
                                self.group_mappings_auto_rp = Pim.Vrfs.Vrf.Ipv4.Maximum.GroupMappingsAutoRp()
                                self.group_mappings_auto_rp.parent = self
                                self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                            return self.group_mappings_auto_rp

                        if (child_yang_name == "register-states"):
                            if (self.register_states is None):
                                self.register_states = Pim.Vrfs.Vrf.Ipv4.Maximum.RegisterStates()
                                self.register_states.parent = self
                                self._children_name_map["register_states"] = "register-states"
                            return self.register_states

                        if (child_yang_name == "route-interfaces"):
                            if (self.route_interfaces is None):
                                self.route_interfaces = Pim.Vrfs.Vrf.Ipv4.Maximum.RouteInterfaces()
                                self.route_interfaces.parent = self
                                self._children_name_map["route_interfaces"] = "route-interfaces"
                            return self.route_interfaces

                        if (child_yang_name == "routes"):
                            if (self.routes is None):
                                self.routes = Pim.Vrfs.Vrf.Ipv4.Maximum.Routes()
                                self.routes.parent = self
                                self._children_name_map["routes"] = "routes"
                            return self.routes

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-candidate-rp-cache" or name == "bsr-group-mappings" or name == "group-mappings-auto-rp" or name == "register-states" or name == "route-interfaces" or name == "routes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SgExpiryTimer(Entity):
                    """
                    Configure expiry timer for S,G routes
                    
                    .. attribute:: access_list_name
                    
                    	Access\-list of applicable S,G routes
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: interval
                    
                    	(S,G) expiry time in seconds
                    	**type**\:  int
                    
                    	**range:** 40..57600
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.SgExpiryTimer, self).__init__()

                        self.yang_name = "sg-expiry-timer"
                        self.yang_parent_name = "ipv4"

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                        self.interval = YLeaf(YType.uint32, "interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("access_list_name",
                                        "interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.SgExpiryTimer, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.SgExpiryTimer, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.access_list_name.is_set or
                            self.interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sg-expiry-timer" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "access-list-name" or name == "interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix


                class RpfVectorEnable(Entity):
                    """
                    Enable PIM RPF Vector Proxy's
                    
                    .. attribute:: allow_ebgp
                    
                    	Allow RPF Vector origination over eBGP sessions
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: disable_ibgp
                    
                    	Disable RPF Vector origination over iBGP sessions
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: enable
                    
                    	RPF Vector is turned on if configured
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    	**mandatory**\: True
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.RpfVectorEnable, self).__init__()

                        self.yang_name = "rpf-vector-enable"
                        self.yang_parent_name = "ipv4"
                        self.is_presence_container = True

                        self.allow_ebgp = YLeaf(YType.empty, "allow-ebgp")

                        self.disable_ibgp = YLeaf(YType.empty, "disable-ibgp")

                        self.enable = YLeaf(YType.empty, "enable")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_ebgp",
                                        "disable_ibgp",
                                        "enable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.RpfVectorEnable, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.RpfVectorEnable, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_ebgp.is_set or
                            self.disable_ibgp.is_set or
                            self.enable.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_ebgp.yfilter != YFilter.not_set or
                            self.disable_ibgp.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rpf-vector-enable" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_ebgp.is_set or self.allow_ebgp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_ebgp.get_name_leafdata())
                        if (self.disable_ibgp.is_set or self.disable_ibgp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable_ibgp.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-ebgp" or name == "disable-ibgp" or name == "enable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-ebgp"):
                            self.allow_ebgp = value
                            self.allow_ebgp.value_namespace = name_space
                            self.allow_ebgp.value_namespace_prefix = name_space_prefix
                        if(value_path == "disable-ibgp"):
                            self.disable_ibgp = value
                            self.disable_ibgp.value_namespace = name_space
                            self.disable_ibgp.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix


                class Ssm(Entity):
                    """
                    Configure IP Multicast SSM
                    
                    .. attribute:: disable
                    
                    	TRUE if SSM is disabled on this router
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: range
                    
                    	Access list of groups enabled with SSM
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Ssm, self).__init__()

                        self.yang_name = "ssm"
                        self.yang_parent_name = "ipv4"

                        self.disable = YLeaf(YType.boolean, "disable")

                        self.range = YLeaf(YType.str, "range")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable",
                                        "range") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.Ssm, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.Ssm, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.disable.is_set or
                            self.range.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable.yfilter != YFilter.not_set or
                            self.range.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ssm" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable.get_name_leafdata())
                        if (self.range.is_set or self.range.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.range.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable" or name == "range"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable"):
                            self.disable = value
                            self.disable.value_namespace = name_space
                            self.disable.value_namespace_prefix = name_space_prefix
                        if(value_path == "range"):
                            self.range = value
                            self.range.value_namespace = name_space
                            self.range.value_namespace_prefix = name_space_prefix


                class Injects(Entity):
                    """
                    Inject Explicit PIM RPF Vector Proxy's
                    
                    .. attribute:: inject
                    
                    	Inject Explicit PIM RPF Vector Proxy's
                    	**type**\: list of    :py:class:`Inject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Injects.Inject>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Injects, self).__init__()

                        self.yang_name = "injects"
                        self.yang_parent_name = "ipv4"

                        self.inject = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.Injects, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.Injects, self).__setattr__(name, value)


                    class Inject(Entity):
                        """
                        Inject Explicit PIM RPF Vector Proxy's
                        
                        .. attribute:: source_address  <key>
                        
                        	Source Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_length  <key>
                        
                        	Masklen
                        	**type**\:  int
                        
                        	**range:** 0..32
                        
                        .. attribute:: rpf_proxy_address
                        
                        	RPF Proxy Address
                        	**type**\:  list of str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Injects.Inject, self).__init__()

                            self.yang_name = "inject"
                            self.yang_parent_name = "injects"

                            self.source_address = YLeaf(YType.str, "source-address")

                            self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            self.rpf_proxy_address = YLeafList(YType.str, "rpf-proxy-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("source_address",
                                            "prefix_length",
                                            "rpf_proxy_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Injects.Inject, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Injects.Inject, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.rpf_proxy_address.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.source_address.is_set or
                                self.prefix_length.is_set)

                        def has_operation(self):
                            for leaf in self.rpf_proxy_address.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.source_address.yfilter != YFilter.not_set or
                                self.prefix_length.yfilter != YFilter.not_set or
                                self.rpf_proxy_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "inject" + "[source-address='" + self.source_address.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source_address.get_name_leafdata())
                            if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_length.get_name_leafdata())

                            leaf_name_data.extend(self.rpf_proxy_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "source-address" or name == "prefix-length" or name == "rpf-proxy-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "source-address"):
                                self.source_address = value
                                self.source_address.value_namespace = name_space
                                self.source_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-length"):
                                self.prefix_length = value
                                self.prefix_length.value_namespace = name_space
                                self.prefix_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "rpf-proxy-address"):
                                self.rpf_proxy_address.append(value)

                    def has_data(self):
                        for c in self.inject:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.inject:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "injects" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "inject"):
                            for c in self.inject:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv4.Injects.Inject()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.inject.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "inject"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class BidirRpAddresses(Entity):
                    """
                    Configure Bidirectional PIM Rendezvous Point
                    
                    .. attribute:: bidir_rp_address
                    
                    	Address of the Rendezvous Point
                    	**type**\: list of    :py:class:`BidirRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses.BidirRpAddress>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses, self).__init__()

                        self.yang_name = "bidir-rp-addresses"
                        self.yang_parent_name = "ipv4"

                        self.bidir_rp_address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses, self).__setattr__(name, value)


                    class BidirRpAddress(Entity):
                        """
                        Address of the Rendezvous Point
                        
                        .. attribute:: rp_address  <key>
                        
                        	RP address of Rendezvous Point
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: access_list_name
                        
                        	Access list of groups that should map to a given RP
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: auto_rp_override
                        
                        	TRUE Indicates if static RP config overrides AutoRP and BSR
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses.BidirRpAddress, self).__init__()

                            self.yang_name = "bidir-rp-address"
                            self.yang_parent_name = "bidir-rp-addresses"

                            self.rp_address = YLeaf(YType.str, "rp-address")

                            self.access_list_name = YLeaf(YType.str, "access-list-name")

                            self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rp_address",
                                            "access_list_name",
                                            "auto_rp_override") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.rp_address.is_set or
                                self.access_list_name.is_set or
                                self.auto_rp_override.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rp_address.yfilter != YFilter.not_set or
                                self.access_list_name.yfilter != YFilter.not_set or
                                self.auto_rp_override.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bidir-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rp_address.get_name_leafdata())
                            if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.access_list_name.get_name_leafdata())
                            if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rp-address"):
                                self.rp_address = value
                                self.rp_address.value_namespace = name_space
                                self.rp_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "access-list-name"):
                                self.access_list_name = value
                                self.access_list_name.value_namespace = name_space
                                self.access_list_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "auto-rp-override"):
                                self.auto_rp_override = value
                                self.auto_rp_override.value_namespace = name_space
                                self.auto_rp_override.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.bidir_rp_address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.bidir_rp_address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bidir-rp-addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bidir-rp-address"):
                            for c in self.bidir_rp_address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses.BidirRpAddress()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.bidir_rp_address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bidir-rp-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Bsr(Entity):
                    """
                    PIM BSR configuration
                    
                    .. attribute:: candidate_bsr
                    
                    	PIM Candidate BSR configuration
                    	**type**\:   :py:class:`CandidateBsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateBsr>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: candidate_rps
                    
                    	PIM RP configuration
                    	**type**\:   :py:class:`CandidateRps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Bsr, self).__init__()

                        self.yang_name = "bsr"
                        self.yang_parent_name = "ipv4"

                        self.candidate_bsr = None
                        self._children_name_map["candidate_bsr"] = "candidate-bsr"
                        self._children_yang_names.add("candidate-bsr")

                        self.candidate_rps = Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps()
                        self.candidate_rps.parent = self
                        self._children_name_map["candidate_rps"] = "candidate-rps"
                        self._children_yang_names.add("candidate-rps")


                    class CandidateBsr(Entity):
                        """
                        PIM Candidate BSR configuration
                        
                        .. attribute:: address
                        
                        	BSR Address configured
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        	**mandatory**\: True
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        	**mandatory**\: True
                        
                        
                        ----
                        .. attribute:: prefix_length
                        
                        	Hash Mask Length for this candidate BSR
                        	**type**\:  int
                        
                        	**range:** 0..32
                        
                        	**default value**\: 30
                        
                        .. attribute:: priority
                        
                        	Priority of the Candidate BSR
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        	**default value**\: 1
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateBsr, self).__init__()

                            self.yang_name = "candidate-bsr"
                            self.yang_parent_name = "bsr"
                            self.is_presence_container = True

                            self.address = YLeaf(YType.str, "address")

                            self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            self.priority = YLeaf(YType.uint32, "priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "prefix_length",
                                            "priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateBsr, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateBsr, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.prefix_length.is_set or
                                self.priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.prefix_length.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "candidate-bsr" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_length.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address" or name == "prefix-length" or name == "priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-length"):
                                self.prefix_length = value
                                self.prefix_length.value_namespace = name_space
                                self.prefix_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix


                    class CandidateRps(Entity):
                        """
                        PIM RP configuration
                        
                        .. attribute:: candidate_rp
                        
                        	Address of PIM SM BSR Candidate\-RP
                        	**type**\: list of    :py:class:`CandidateRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps.CandidateRp>`
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps, self).__init__()

                            self.yang_name = "candidate-rps"
                            self.yang_parent_name = "bsr"

                            self.candidate_rp = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps, self).__setattr__(name, value)


                        class CandidateRp(Entity):
                            """
                            Address of PIM SM BSR Candidate\-RP
                            
                            .. attribute:: address  <key>
                            
                            	Address of Candidate\-RP
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: mode  <key>
                            
                            	SM or Bidir
                            	**type**\:   :py:class:`PimProtocolMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimProtocolMode>`
                            
                            .. attribute:: group_list
                            
                            	Access\-list specifying the group range for the Candidate\-RP
                            	**type**\:  str
                            
                            	**length:** 1..64
                            
                            .. attribute:: interval
                            
                            	Advertisement interval
                            	**type**\:  int
                            
                            	**range:** 30..600
                            
                            	**default value**\: 60
                            
                            .. attribute:: priority
                            
                            	Priority of the CRP
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            	**default value**\: 192
                            
                            

                            """

                            _prefix = 'ipv4-pim-cfg'
                            _revision = '2016-06-01'

                            def __init__(self):
                                super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps.CandidateRp, self).__init__()

                                self.yang_name = "candidate-rp"
                                self.yang_parent_name = "candidate-rps"

                                self.address = YLeaf(YType.str, "address")

                                self.mode = YLeaf(YType.enumeration, "mode")

                                self.group_list = YLeaf(YType.str, "group-list")

                                self.interval = YLeaf(YType.uint32, "interval")

                                self.priority = YLeaf(YType.uint32, "priority")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("address",
                                                "mode",
                                                "group_list",
                                                "interval",
                                                "priority") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.address.is_set or
                                    self.mode.is_set or
                                    self.group_list.is_set or
                                    self.interval.is_set or
                                    self.priority.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.mode.yfilter != YFilter.not_set or
                                    self.group_list.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "candidate-rp" + "[address='" + self.address.get() + "']" + "[mode='" + self.mode.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mode.get_name_leafdata())
                                if (self.group_list.is_set or self.group_list.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.group_list.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "address" or name == "mode" or name == "group-list" or name == "interval" or name == "priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "mode"):
                                    self.mode = value
                                    self.mode.value_namespace = name_space
                                    self.mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "group-list"):
                                    self.group_list = value
                                    self.group_list.value_namespace = name_space
                                    self.group_list.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.candidate_rp:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.candidate_rp:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "candidate-rps" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "candidate-rp"):
                                for c in self.candidate_rp:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps.CandidateRp()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.candidate_rp.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "candidate-rp"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.candidate_rps is not None and self.candidate_rps.has_data()) or
                            (self.candidate_bsr is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.candidate_bsr is not None and self.candidate_bsr.has_operation()) or
                            (self.candidate_rps is not None and self.candidate_rps.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "candidate-bsr"):
                            if (self.candidate_bsr is None):
                                self.candidate_bsr = Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateBsr()
                                self.candidate_bsr.parent = self
                                self._children_name_map["candidate_bsr"] = "candidate-bsr"
                            return self.candidate_bsr

                        if (child_yang_name == "candidate-rps"):
                            if (self.candidate_rps is None):
                                self.candidate_rps = Pim.Vrfs.Vrf.Ipv4.Bsr.CandidateRps()
                                self.candidate_rps.parent = self
                                self._children_name_map["candidate_rps"] = "candidate-rps"
                            return self.candidate_rps

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "candidate-bsr" or name == "candidate-rps"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Paths(Entity):
                    """
                    Inject PIM RPF Vector Proxy's
                    
                    .. attribute:: path
                    
                    	Inject PIM RPF Vector Proxy's
                    	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Paths.Path>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Paths, self).__init__()

                        self.yang_name = "paths"
                        self.yang_parent_name = "ipv4"

                        self.path = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.Paths, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.Paths, self).__setattr__(name, value)


                    class Path(Entity):
                        """
                        Inject PIM RPF Vector Proxy's
                        
                        .. attribute:: source_address  <key>
                        
                        	Source Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_length  <key>
                        
                        	Masklen
                        	**type**\:  int
                        
                        	**range:** 0..32
                        
                        .. attribute:: rpf_proxy_address
                        
                        	RPF Proxy Address
                        	**type**\:  list of str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Paths.Path, self).__init__()

                            self.yang_name = "path"
                            self.yang_parent_name = "paths"

                            self.source_address = YLeaf(YType.str, "source-address")

                            self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            self.rpf_proxy_address = YLeafList(YType.str, "rpf-proxy-address")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("source_address",
                                            "prefix_length",
                                            "rpf_proxy_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Paths.Path, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Paths.Path, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.rpf_proxy_address.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.source_address.is_set or
                                self.prefix_length.is_set)

                        def has_operation(self):
                            for leaf in self.rpf_proxy_address.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.source_address.yfilter != YFilter.not_set or
                                self.prefix_length.yfilter != YFilter.not_set or
                                self.rpf_proxy_address.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path" + "[source-address='" + self.source_address.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source_address.get_name_leafdata())
                            if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_length.get_name_leafdata())

                            leaf_name_data.extend(self.rpf_proxy_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "source-address" or name == "prefix-length" or name == "rpf-proxy-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "source-address"):
                                self.source_address = value
                                self.source_address.value_namespace = name_space
                                self.source_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-length"):
                                self.prefix_length = value
                                self.prefix_length.value_namespace = name_space
                                self.prefix_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "rpf-proxy-address"):
                                self.rpf_proxy_address.append(value)

                    def has_data(self):
                        for c in self.path:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.path:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "paths" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "path"):
                            for c in self.path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv4.Paths.Path()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.path.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "path"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AllowRp(Entity):
                    """
                    Enable allow\-rp filtering for SM joins
                    
                    .. attribute:: group_list_name
                    
                    	Access\-list specifiying applicable groups
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: rp_list_name
                    
                    	Access\-list specifiying applicable RPs
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.AllowRp, self).__init__()

                        self.yang_name = "allow-rp"
                        self.yang_parent_name = "ipv4"
                        self.is_presence_container = True

                        self.group_list_name = YLeaf(YType.str, "group-list-name")

                        self.rp_list_name = YLeaf(YType.str, "rp-list-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("group_list_name",
                                        "rp_list_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.AllowRp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.AllowRp, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.group_list_name.is_set or
                            self.rp_list_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.group_list_name.yfilter != YFilter.not_set or
                            self.rp_list_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "allow-rp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.group_list_name.is_set or self.group_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.group_list_name.get_name_leafdata())
                        if (self.rp_list_name.is_set or self.rp_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rp_list_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "group-list-name" or name == "rp-list-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "group-list-name"):
                            self.group_list_name = value
                            self.group_list_name.value_namespace = name_space
                            self.group_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "rp-list-name"):
                            self.rp_list_name = value
                            self.rp_list_name.value_namespace = name_space
                            self.rp_list_name.value_namespace_prefix = name_space_prefix


                class Convergence(Entity):
                    """
                    Configure convergence parameters
                    
                    .. attribute:: link_down_prune_delay
                    
                    	Delay prunes if route join state transitions to not\-joined on link down
                    	**type**\:  int
                    
                    	**range:** 0..60
                    
                    	**units**\: second
                    
                    .. attribute:: rpf_conflict_join_delay
                    
                    	Dampen first join if RPF path is through one of the downstream neighbor
                    	**type**\:  int
                    
                    	**range:** 0..15
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Convergence, self).__init__()

                        self.yang_name = "convergence"
                        self.yang_parent_name = "ipv4"

                        self.link_down_prune_delay = YLeaf(YType.uint32, "link-down-prune-delay")

                        self.rpf_conflict_join_delay = YLeaf(YType.uint32, "rpf-conflict-join-delay")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("link_down_prune_delay",
                                        "rpf_conflict_join_delay") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.Convergence, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.Convergence, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.link_down_prune_delay.is_set or
                            self.rpf_conflict_join_delay.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.link_down_prune_delay.yfilter != YFilter.not_set or
                            self.rpf_conflict_join_delay.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "convergence" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.link_down_prune_delay.is_set or self.link_down_prune_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.link_down_prune_delay.get_name_leafdata())
                        if (self.rpf_conflict_join_delay.is_set or self.rpf_conflict_join_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rpf_conflict_join_delay.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "link-down-prune-delay" or name == "rpf-conflict-join-delay"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "link-down-prune-delay"):
                            self.link_down_prune_delay = value
                            self.link_down_prune_delay.value_namespace = name_space
                            self.link_down_prune_delay.value_namespace_prefix = name_space_prefix
                        if(value_path == "rpf-conflict-join-delay"):
                            self.rpf_conflict_join_delay = value
                            self.rpf_conflict_join_delay.value_namespace = name_space
                            self.rpf_conflict_join_delay.value_namespace_prefix = name_space_prefix


                class Interfaces(Entity):
                    """
                    Interface\-level Configuration
                    
                    .. attribute:: interface
                    
                    	The name of the interface
                    	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.Interfaces, self).__init__()

                        self.yang_name = "interfaces"
                        self.yang_parent_name = "ipv4"

                        self.interface = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.Interfaces, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.Interfaces, self).__setattr__(name, value)


                    class Interface(Entity):
                        """
                        The name of the interface
                        
                        .. attribute:: interface_name  <key>
                        
                        	The name of interface
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: bfd
                        
                        	BFD configuration
                        	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.Bfd>`
                        
                        .. attribute:: bsr_border
                        
                        	BSR Border configuration for Interface
                        	**type**\:  bool
                        
                        .. attribute:: dr_priority
                        
                        	Hello DR priority, preference given to larger value
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: enable
                        
                        	Enter PIM Interface processing
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: hello_interval
                        
                        	Hello interval in seconds
                        	**type**\:  int
                        
                        	**range:** 1..3600
                        
                        	**units**\: second
                        
                        .. attribute:: interface_enable
                        
                        	Enable PIM processing on the interface
                        	**type**\:  bool
                        
                        .. attribute:: join_prune_mtu
                        
                        	Join\-Prune MTU in Bytes
                        	**type**\:  int
                        
                        	**range:** 576..65535
                        
                        	**units**\: byte
                        
                        .. attribute:: jp_interval
                        
                        	Join\-Prune interval in seconds
                        	**type**\:  int
                        
                        	**range:** 10..600
                        
                        	**units**\: second
                        
                        .. attribute:: maximum_routes
                        
                        	Maximum number of allowed routes for this interface
                        	**type**\:   :py:class:`MaximumRoutes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.MaximumRoutes>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: neighbor_filter
                        
                        	Access\-list of neighbors to be filtered
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: override_interval
                        
                        	Override interval in milliseconds
                        	**type**\:  int
                        
                        	**range:** 400..65535
                        
                        	**units**\: millisecond
                        
                        .. attribute:: propagation_delay
                        
                        	Propagation delay in milli seconds
                        	**type**\:  int
                        
                        	**range:** 100..32767
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface, self).__init__()

                            self.yang_name = "interface"
                            self.yang_parent_name = "interfaces"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.bsr_border = YLeaf(YType.boolean, "bsr-border")

                            self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                            self.interface_enable = YLeaf(YType.boolean, "interface-enable")

                            self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                            self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                            self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                            self.override_interval = YLeaf(YType.uint32, "override-interval")

                            self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                            self.bfd = Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.Bfd()
                            self.bfd.parent = self
                            self._children_name_map["bfd"] = "bfd"
                            self._children_yang_names.add("bfd")

                            self.maximum_routes = None
                            self._children_name_map["maximum_routes"] = "maximum-routes"
                            self._children_yang_names.add("maximum-routes")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name",
                                            "bsr_border",
                                            "dr_priority",
                                            "enable",
                                            "hello_interval",
                                            "interface_enable",
                                            "join_prune_mtu",
                                            "jp_interval",
                                            "neighbor_filter",
                                            "override_interval",
                                            "propagation_delay") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface, self).__setattr__(name, value)


                        class MaximumRoutes(Entity):
                            """
                            Maximum number of allowed routes for this
                            interface
                            
                            .. attribute:: access_list_name
                            
                            	Access\-list to account for
                            	**type**\:  str
                            
                            	**length:** 1..64
                            
                            .. attribute:: maximum
                            
                            	Maximum number of routes for this interface
                            	**type**\:  int
                            
                            	**range:** 1..1100000
                            
                            	**mandatory**\: True
                            
                            .. attribute:: warning_threshold
                            
                            	Set threshold to print warning
                            	**type**\:  int
                            
                            	**range:** 1..1100000
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'ipv4-pim-cfg'
                            _revision = '2016-06-01'

                            def __init__(self):
                                super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.MaximumRoutes, self).__init__()

                                self.yang_name = "maximum-routes"
                                self.yang_parent_name = "interface"
                                self.is_presence_container = True

                                self.access_list_name = YLeaf(YType.str, "access-list-name")

                                self.maximum = YLeaf(YType.uint32, "maximum")

                                self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("access_list_name",
                                                "maximum",
                                                "warning_threshold") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.access_list_name.is_set or
                                    self.maximum.is_set or
                                    self.warning_threshold.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.access_list_name.yfilter != YFilter.not_set or
                                    self.maximum.yfilter != YFilter.not_set or
                                    self.warning_threshold.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "maximum-routes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.access_list_name.get_name_leafdata())
                                if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum.get_name_leafdata())
                                if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "access-list-name" or name == "maximum" or name == "warning-threshold"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "access-list-name"):
                                    self.access_list_name = value
                                    self.access_list_name.value_namespace = name_space
                                    self.access_list_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum"):
                                    self.maximum = value
                                    self.maximum.value_namespace = name_space
                                    self.maximum.value_namespace_prefix = name_space_prefix
                                if(value_path == "warning-threshold"):
                                    self.warning_threshold = value
                                    self.warning_threshold.value_namespace = name_space
                                    self.warning_threshold.value_namespace_prefix = name_space_prefix


                        class Bfd(Entity):
                            """
                            BFD configuration
                            
                            .. attribute:: detection_multiplier
                            
                            	Detection multiplier for BFD sessions created by PIM
                            	**type**\:  int
                            
                            	**range:** 2..50
                            
                            .. attribute:: enable
                            
                            	TRUE to enable BFD. FALSE to disable and to prevent inheritance from a parent
                            	**type**\:  bool
                            
                            .. attribute:: interval
                            
                            	Hello interval for BFD sessions created by PIM
                            	**type**\:  int
                            
                            	**range:** 3..30000
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'ipv4-pim-cfg'
                            _revision = '2016-06-01'

                            def __init__(self):
                                super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.Bfd, self).__init__()

                                self.yang_name = "bfd"
                                self.yang_parent_name = "interface"

                                self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("detection_multiplier",
                                                "enable",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.detection_multiplier.is_set or
                                    self.enable.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.detection_multiplier.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bfd" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "detection-multiplier" or name == "enable" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "detection-multiplier"):
                                    self.detection_multiplier = value
                                    self.detection_multiplier.value_namespace = name_space
                                    self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.interface_name.is_set or
                                self.bsr_border.is_set or
                                self.dr_priority.is_set or
                                self.enable.is_set or
                                self.hello_interval.is_set or
                                self.interface_enable.is_set or
                                self.join_prune_mtu.is_set or
                                self.jp_interval.is_set or
                                self.neighbor_filter.is_set or
                                self.override_interval.is_set or
                                self.propagation_delay.is_set or
                                (self.bfd is not None and self.bfd.has_data()) or
                                (self.maximum_routes is not None))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                self.bsr_border.yfilter != YFilter.not_set or
                                self.dr_priority.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.hello_interval.yfilter != YFilter.not_set or
                                self.interface_enable.yfilter != YFilter.not_set or
                                self.join_prune_mtu.yfilter != YFilter.not_set or
                                self.jp_interval.yfilter != YFilter.not_set or
                                self.neighbor_filter.yfilter != YFilter.not_set or
                                self.override_interval.yfilter != YFilter.not_set or
                                self.propagation_delay.yfilter != YFilter.not_set or
                                (self.bfd is not None and self.bfd.has_operation()) or
                                (self.maximum_routes is not None and self.maximum_routes.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                            if (self.bsr_border.is_set or self.bsr_border.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bsr_border.get_name_leafdata())
                            if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dr_priority.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_interval.get_name_leafdata())
                            if (self.interface_enable.is_set or self.interface_enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_enable.get_name_leafdata())
                            if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                            if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.jp_interval.get_name_leafdata())
                            if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                            if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.override_interval.get_name_leafdata())
                            if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bfd"):
                                if (self.bfd is None):
                                    self.bfd = Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.Bfd()
                                    self.bfd.parent = self
                                    self._children_name_map["bfd"] = "bfd"
                                return self.bfd

                            if (child_yang_name == "maximum-routes"):
                                if (self.maximum_routes is None):
                                    self.maximum_routes = Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface.MaximumRoutes()
                                    self.maximum_routes.parent = self
                                    self._children_name_map["maximum_routes"] = "maximum-routes"
                                return self.maximum_routes

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bfd" or name == "maximum-routes" or name == "interface-name" or name == "bsr-border" or name == "dr-priority" or name == "enable" or name == "hello-interval" or name == "interface-enable" or name == "join-prune-mtu" or name == "jp-interval" or name == "neighbor-filter" or name == "override-interval" or name == "propagation-delay"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "bsr-border"):
                                self.bsr_border = value
                                self.bsr_border.value_namespace = name_space
                                self.bsr_border.value_namespace_prefix = name_space_prefix
                            if(value_path == "dr-priority"):
                                self.dr_priority = value
                                self.dr_priority.value_namespace = name_space
                                self.dr_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-interval"):
                                self.hello_interval = value
                                self.hello_interval.value_namespace = name_space
                                self.hello_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface-enable"):
                                self.interface_enable = value
                                self.interface_enable.value_namespace = name_space
                                self.interface_enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "join-prune-mtu"):
                                self.join_prune_mtu = value
                                self.join_prune_mtu.value_namespace = name_space
                                self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                            if(value_path == "jp-interval"):
                                self.jp_interval = value
                                self.jp_interval.value_namespace = name_space
                                self.jp_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "neighbor-filter"):
                                self.neighbor_filter = value
                                self.neighbor_filter.value_namespace = name_space
                                self.neighbor_filter.value_namespace_prefix = name_space_prefix
                            if(value_path == "override-interval"):
                                self.override_interval = value
                                self.override_interval.value_namespace = name_space
                                self.override_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "propagation-delay"):
                                self.propagation_delay = value
                                self.propagation_delay.value_namespace = name_space
                                self.propagation_delay.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.interface:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.interface:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interfaces" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "interface"):
                            for c in self.interface:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv4.Interfaces.Interface()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.interface.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class CjMulticastOnlyFrrs(Entity):
                    """
                    Clone Join Multicast Only FRR
                    
                    .. attribute:: cj_multicast_only_frr
                    
                    	Clone Join Multicast Only FRR
                    	**type**\: list of    :py:class:`CjMulticastOnlyFrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs, self).__init__()

                        self.yang_name = "cj-multicast-only-frrs"
                        self.yang_parent_name = "ipv4"

                        self.cj_multicast_only_frr = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs, self).__setattr__(name, value)


                    class CjMulticastOnlyFrr(Entity):
                        """
                        Clone Join Multicast Only FRR
                        
                        .. attribute:: source  <key>
                        
                        	Original address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: primary  <key>
                        
                        	Primary address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: backup  <key>
                        
                        	Backup address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_length  <key>
                        
                        	Masklen
                        	**type**\:  int
                        
                        	**range:** 0..32
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr, self).__init__()

                            self.yang_name = "cj-multicast-only-frr"
                            self.yang_parent_name = "cj-multicast-only-frrs"

                            self.source = YLeaf(YType.str, "source")

                            self.primary = YLeaf(YType.str, "primary")

                            self.backup = YLeaf(YType.str, "backup")

                            self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("source",
                                            "primary",
                                            "backup",
                                            "prefix_length") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.source.is_set or
                                self.primary.is_set or
                                self.backup.is_set or
                                self.prefix_length.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.source.yfilter != YFilter.not_set or
                                self.primary.yfilter != YFilter.not_set or
                                self.backup.yfilter != YFilter.not_set or
                                self.prefix_length.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "cj-multicast-only-frr" + "[source='" + self.source.get() + "']" + "[primary='" + self.primary.get() + "']" + "[backup='" + self.backup.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source.get_name_leafdata())
                            if (self.primary.is_set or self.primary.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.primary.get_name_leafdata())
                            if (self.backup.is_set or self.backup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.backup.get_name_leafdata())
                            if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_length.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "source" or name == "primary" or name == "backup" or name == "prefix-length"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "source"):
                                self.source = value
                                self.source.value_namespace = name_space
                                self.source.value_namespace_prefix = name_space_prefix
                            if(value_path == "primary"):
                                self.primary = value
                                self.primary.value_namespace = name_space
                                self.primary.value_namespace_prefix = name_space_prefix
                            if(value_path == "backup"):
                                self.backup = value
                                self.backup.value_namespace = name_space
                                self.backup.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-length"):
                                self.prefix_length = value
                                self.prefix_length.value_namespace = name_space
                                self.prefix_length.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.cj_multicast_only_frr:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.cj_multicast_only_frr:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "cj-multicast-only-frrs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "cj-multicast-only-frr"):
                            for c in self.cj_multicast_only_frr:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.cj_multicast_only_frr.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "cj-multicast-only-frr"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.accept_register.is_set or
                        self.auto_rp_disable.is_set or
                        self.log_neighbor_changes.is_set or
                        self.multipath.is_set or
                        self.neighbor_check_on_receive.is_set or
                        self.neighbor_check_on_send.is_set or
                        self.neighbor_filter.is_set or
                        self.old_register_checksum.is_set or
                        self.register_source.is_set or
                        self.rp_static_deny.is_set or
                        self.spt_threshold_infinity.is_set or
                        self.ssm_allow_override.is_set or
                        self.suppress_data_registers.is_set or
                        self.suppress_rpf_prunes.is_set or
                        (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_data()) or
                        (self.bsr is not None and self.bsr.has_data()) or
                        (self.cj_multicast_only_frrs is not None and self.cj_multicast_only_frrs.has_data()) or
                        (self.convergence is not None and self.convergence.has_data()) or
                        (self.cs_multicast_only_frrs is not None and self.cs_multicast_only_frrs.has_data()) or
                        (self.inheritable_defaults is not None and self.inheritable_defaults.has_data()) or
                        (self.injects is not None and self.injects.has_data()) or
                        (self.interfaces is not None and self.interfaces.has_data()) or
                        (self.maximum is not None and self.maximum.has_data()) or
                        (self.multicast_only_frr is not None and self.multicast_only_frr.has_data()) or
                        (self.paths is not None and self.paths.has_data()) or
                        (self.rpf is not None and self.rpf.has_data()) or
                        (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_data()) or
                        (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_data()) or
                        (self.ssm is not None and self.ssm.has_data()) or
                        (self.allow_rp is not None) or
                        (self.rpf_vector_enable is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.accept_register.yfilter != YFilter.not_set or
                        self.auto_rp_disable.yfilter != YFilter.not_set or
                        self.log_neighbor_changes.yfilter != YFilter.not_set or
                        self.multipath.yfilter != YFilter.not_set or
                        self.neighbor_check_on_receive.yfilter != YFilter.not_set or
                        self.neighbor_check_on_send.yfilter != YFilter.not_set or
                        self.neighbor_filter.yfilter != YFilter.not_set or
                        self.old_register_checksum.yfilter != YFilter.not_set or
                        self.register_source.yfilter != YFilter.not_set or
                        self.rp_static_deny.yfilter != YFilter.not_set or
                        self.spt_threshold_infinity.yfilter != YFilter.not_set or
                        self.ssm_allow_override.yfilter != YFilter.not_set or
                        self.suppress_data_registers.yfilter != YFilter.not_set or
                        self.suppress_rpf_prunes.yfilter != YFilter.not_set or
                        (self.allow_rp is not None and self.allow_rp.has_operation()) or
                        (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_operation()) or
                        (self.bsr is not None and self.bsr.has_operation()) or
                        (self.cj_multicast_only_frrs is not None and self.cj_multicast_only_frrs.has_operation()) or
                        (self.convergence is not None and self.convergence.has_operation()) or
                        (self.cs_multicast_only_frrs is not None and self.cs_multicast_only_frrs.has_operation()) or
                        (self.inheritable_defaults is not None and self.inheritable_defaults.has_operation()) or
                        (self.injects is not None and self.injects.has_operation()) or
                        (self.interfaces is not None and self.interfaces.has_operation()) or
                        (self.maximum is not None and self.maximum.has_operation()) or
                        (self.multicast_only_frr is not None and self.multicast_only_frr.has_operation()) or
                        (self.paths is not None and self.paths.has_operation()) or
                        (self.rpf is not None and self.rpf.has_operation()) or
                        (self.rpf_vector_enable is not None and self.rpf_vector_enable.has_operation()) or
                        (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_operation()) or
                        (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_operation()) or
                        (self.ssm is not None and self.ssm.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv4" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.accept_register.is_set or self.accept_register.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.accept_register.get_name_leafdata())
                    if (self.auto_rp_disable.is_set or self.auto_rp_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.auto_rp_disable.get_name_leafdata())
                    if (self.log_neighbor_changes.is_set or self.log_neighbor_changes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.log_neighbor_changes.get_name_leafdata())
                    if (self.multipath.is_set or self.multipath.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.multipath.get_name_leafdata())
                    if (self.neighbor_check_on_receive.is_set or self.neighbor_check_on_receive.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_check_on_receive.get_name_leafdata())
                    if (self.neighbor_check_on_send.is_set or self.neighbor_check_on_send.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_check_on_send.get_name_leafdata())
                    if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                    if (self.old_register_checksum.is_set or self.old_register_checksum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.old_register_checksum.get_name_leafdata())
                    if (self.register_source.is_set or self.register_source.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.register_source.get_name_leafdata())
                    if (self.rp_static_deny.is_set or self.rp_static_deny.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rp_static_deny.get_name_leafdata())
                    if (self.spt_threshold_infinity.is_set or self.spt_threshold_infinity.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.spt_threshold_infinity.get_name_leafdata())
                    if (self.ssm_allow_override.is_set or self.ssm_allow_override.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ssm_allow_override.get_name_leafdata())
                    if (self.suppress_data_registers.is_set or self.suppress_data_registers.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.suppress_data_registers.get_name_leafdata())
                    if (self.suppress_rpf_prunes.is_set or self.suppress_rpf_prunes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.suppress_rpf_prunes.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "allow-rp"):
                        if (self.allow_rp is None):
                            self.allow_rp = Pim.Vrfs.Vrf.Ipv4.AllowRp()
                            self.allow_rp.parent = self
                            self._children_name_map["allow_rp"] = "allow-rp"
                        return self.allow_rp

                    if (child_yang_name == "bidir-rp-addresses"):
                        if (self.bidir_rp_addresses is None):
                            self.bidir_rp_addresses = Pim.Vrfs.Vrf.Ipv4.BidirRpAddresses()
                            self.bidir_rp_addresses.parent = self
                            self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                        return self.bidir_rp_addresses

                    if (child_yang_name == "bsr"):
                        if (self.bsr is None):
                            self.bsr = Pim.Vrfs.Vrf.Ipv4.Bsr()
                            self.bsr.parent = self
                            self._children_name_map["bsr"] = "bsr"
                        return self.bsr

                    if (child_yang_name == "cj-multicast-only-frrs"):
                        if (self.cj_multicast_only_frrs is None):
                            self.cj_multicast_only_frrs = Pim.Vrfs.Vrf.Ipv4.CjMulticastOnlyFrrs()
                            self.cj_multicast_only_frrs.parent = self
                            self._children_name_map["cj_multicast_only_frrs"] = "cj-multicast-only-frrs"
                        return self.cj_multicast_only_frrs

                    if (child_yang_name == "convergence"):
                        if (self.convergence is None):
                            self.convergence = Pim.Vrfs.Vrf.Ipv4.Convergence()
                            self.convergence.parent = self
                            self._children_name_map["convergence"] = "convergence"
                        return self.convergence

                    if (child_yang_name == "cs-multicast-only-frrs"):
                        if (self.cs_multicast_only_frrs is None):
                            self.cs_multicast_only_frrs = Pim.Vrfs.Vrf.Ipv4.CsMulticastOnlyFrrs()
                            self.cs_multicast_only_frrs.parent = self
                            self._children_name_map["cs_multicast_only_frrs"] = "cs-multicast-only-frrs"
                        return self.cs_multicast_only_frrs

                    if (child_yang_name == "inheritable-defaults"):
                        if (self.inheritable_defaults is None):
                            self.inheritable_defaults = Pim.Vrfs.Vrf.Ipv4.InheritableDefaults()
                            self.inheritable_defaults.parent = self
                            self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                        return self.inheritable_defaults

                    if (child_yang_name == "injects"):
                        if (self.injects is None):
                            self.injects = Pim.Vrfs.Vrf.Ipv4.Injects()
                            self.injects.parent = self
                            self._children_name_map["injects"] = "injects"
                        return self.injects

                    if (child_yang_name == "interfaces"):
                        if (self.interfaces is None):
                            self.interfaces = Pim.Vrfs.Vrf.Ipv4.Interfaces()
                            self.interfaces.parent = self
                            self._children_name_map["interfaces"] = "interfaces"
                        return self.interfaces

                    if (child_yang_name == "maximum"):
                        if (self.maximum is None):
                            self.maximum = Pim.Vrfs.Vrf.Ipv4.Maximum()
                            self.maximum.parent = self
                            self._children_name_map["maximum"] = "maximum"
                        return self.maximum

                    if (child_yang_name == "multicast-only-frr"):
                        if (self.multicast_only_frr is None):
                            self.multicast_only_frr = Pim.Vrfs.Vrf.Ipv4.MulticastOnlyFrr()
                            self.multicast_only_frr.parent = self
                            self._children_name_map["multicast_only_frr"] = "multicast-only-frr"
                        return self.multicast_only_frr

                    if (child_yang_name == "paths"):
                        if (self.paths is None):
                            self.paths = Pim.Vrfs.Vrf.Ipv4.Paths()
                            self.paths.parent = self
                            self._children_name_map["paths"] = "paths"
                        return self.paths

                    if (child_yang_name == "rpf"):
                        if (self.rpf is None):
                            self.rpf = Pim.Vrfs.Vrf.Ipv4.Rpf()
                            self.rpf.parent = self
                            self._children_name_map["rpf"] = "rpf"
                        return self.rpf

                    if (child_yang_name == "rpf-vector-enable"):
                        if (self.rpf_vector_enable is None):
                            self.rpf_vector_enable = Pim.Vrfs.Vrf.Ipv4.RpfVectorEnable()
                            self.rpf_vector_enable.parent = self
                            self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                        return self.rpf_vector_enable

                    if (child_yang_name == "sg-expiry-timer"):
                        if (self.sg_expiry_timer is None):
                            self.sg_expiry_timer = Pim.Vrfs.Vrf.Ipv4.SgExpiryTimer()
                            self.sg_expiry_timer.parent = self
                            self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                        return self.sg_expiry_timer

                    if (child_yang_name == "sparse-mode-rp-addresses"):
                        if (self.sparse_mode_rp_addresses is None):
                            self.sparse_mode_rp_addresses = Pim.Vrfs.Vrf.Ipv4.SparseModeRpAddresses()
                            self.sparse_mode_rp_addresses.parent = self
                            self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                        return self.sparse_mode_rp_addresses

                    if (child_yang_name == "ssm"):
                        if (self.ssm is None):
                            self.ssm = Pim.Vrfs.Vrf.Ipv4.Ssm()
                            self.ssm.parent = self
                            self._children_name_map["ssm"] = "ssm"
                        return self.ssm

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "allow-rp" or name == "bidir-rp-addresses" or name == "bsr" or name == "cj-multicast-only-frrs" or name == "convergence" or name == "cs-multicast-only-frrs" or name == "inheritable-defaults" or name == "injects" or name == "interfaces" or name == "maximum" or name == "multicast-only-frr" or name == "paths" or name == "rpf" or name == "rpf-vector-enable" or name == "sg-expiry-timer" or name == "sparse-mode-rp-addresses" or name == "ssm" or name == "accept-register" or name == "auto-rp-disable" or name == "log-neighbor-changes" or name == "multipath" or name == "neighbor-check-on-receive" or name == "neighbor-check-on-send" or name == "neighbor-filter" or name == "old-register-checksum" or name == "register-source" or name == "rp-static-deny" or name == "spt-threshold-infinity" or name == "ssm-allow-override" or name == "suppress-data-registers" or name == "suppress-rpf-prunes"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "accept-register"):
                        self.accept_register = value
                        self.accept_register.value_namespace = name_space
                        self.accept_register.value_namespace_prefix = name_space_prefix
                    if(value_path == "auto-rp-disable"):
                        self.auto_rp_disable = value
                        self.auto_rp_disable.value_namespace = name_space
                        self.auto_rp_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "log-neighbor-changes"):
                        self.log_neighbor_changes = value
                        self.log_neighbor_changes.value_namespace = name_space
                        self.log_neighbor_changes.value_namespace_prefix = name_space_prefix
                    if(value_path == "multipath"):
                        self.multipath = value
                        self.multipath.value_namespace = name_space
                        self.multipath.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-check-on-receive"):
                        self.neighbor_check_on_receive = value
                        self.neighbor_check_on_receive.value_namespace = name_space
                        self.neighbor_check_on_receive.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-check-on-send"):
                        self.neighbor_check_on_send = value
                        self.neighbor_check_on_send.value_namespace = name_space
                        self.neighbor_check_on_send.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-filter"):
                        self.neighbor_filter = value
                        self.neighbor_filter.value_namespace = name_space
                        self.neighbor_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "old-register-checksum"):
                        self.old_register_checksum = value
                        self.old_register_checksum.value_namespace = name_space
                        self.old_register_checksum.value_namespace_prefix = name_space_prefix
                    if(value_path == "register-source"):
                        self.register_source = value
                        self.register_source.value_namespace = name_space
                        self.register_source.value_namespace_prefix = name_space_prefix
                    if(value_path == "rp-static-deny"):
                        self.rp_static_deny = value
                        self.rp_static_deny.value_namespace = name_space
                        self.rp_static_deny.value_namespace_prefix = name_space_prefix
                    if(value_path == "spt-threshold-infinity"):
                        self.spt_threshold_infinity = value
                        self.spt_threshold_infinity.value_namespace = name_space
                        self.spt_threshold_infinity.value_namespace_prefix = name_space_prefix
                    if(value_path == "ssm-allow-override"):
                        self.ssm_allow_override = value
                        self.ssm_allow_override.value_namespace = name_space
                        self.ssm_allow_override.value_namespace_prefix = name_space_prefix
                    if(value_path == "suppress-data-registers"):
                        self.suppress_data_registers = value
                        self.suppress_data_registers.value_namespace = name_space
                        self.suppress_data_registers.value_namespace_prefix = name_space_prefix
                    if(value_path == "suppress-rpf-prunes"):
                        self.suppress_rpf_prunes = value
                        self.suppress_rpf_prunes.value_namespace = name_space
                        self.suppress_rpf_prunes.value_namespace_prefix = name_space_prefix


            class Ipv6(Entity):
                """
                IPV6 commands
                
                .. attribute:: accept_register
                
                	Access\-list which specifies unauthorized sources
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: allow_rp
                
                	Enable allow\-rp filtering for SM joins
                	**type**\:   :py:class:`AllowRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.AllowRp>`
                
                	**presence node**\: True
                
                .. attribute:: bidir_rp_addresses
                
                	Configure Bidirectional PIM Rendezvous Point
                	**type**\:   :py:class:`BidirRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses>`
                
                .. attribute:: bsr
                
                	PIM BSR configuration
                	**type**\:   :py:class:`Bsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Bsr>`
                
                .. attribute:: convergence
                
                	Configure convergence parameters
                	**type**\:   :py:class:`Convergence <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Convergence>`
                
                .. attribute:: embedded_rp_addresses
                
                	Set Embedded RP processing support
                	**type**\:   :py:class:`EmbeddedRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses>`
                
                .. attribute:: embedded_rp_disable
                
                	Set Embedded RP processing support
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: inheritable_defaults
                
                	Inheritable defaults
                	**type**\:   :py:class:`InheritableDefaults <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.InheritableDefaults>`
                
                .. attribute:: interfaces
                
                	Interface\-level Configuration
                	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Interfaces>`
                
                .. attribute:: log_neighbor_changes
                
                	PIM neighbor state change logging is turned on if configured
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: maximum
                
                	Configure PIM State Limits
                	**type**\:   :py:class:`Maximum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Maximum>`
                
                .. attribute:: multipath
                
                	Enable equal\-cost multipath routing
                	**type**\:   :py:class:`PimMultipath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimMultipath>`
                
                .. attribute:: neighbor_check_on_receive
                
                	Enable PIM neighbor checking when receiving PIM messages
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: neighbor_check_on_send
                
                	Enable PIM neighbor checking when sending join\-prunes
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: neighbor_filter
                
                	Access\-list of neighbors to be filtered
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: old_register_checksum
                
                	Generate registers compatible with older IOS versions
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: register_source
                
                	Source address to use for register messages
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: rp_static_deny
                
                	Configure static RP deny range
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: rpf
                
                	Configure RPF options
                	**type**\:   :py:class:`Rpf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Rpf>`
                
                .. attribute:: rpf_vector_enable
                
                	Enable PIM RPF Vector Proxy's
                	**type**\:   :py:class:`RpfVectorEnable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.RpfVectorEnable>`
                
                	**presence node**\: True
                
                .. attribute:: sg_expiry_timer
                
                	Configure expiry timer for S,G routes
                	**type**\:   :py:class:`SgExpiryTimer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.SgExpiryTimer>`
                
                .. attribute:: sparse_mode_rp_addresses
                
                	Configure Sparse\-Mode Rendezvous Point
                	**type**\:   :py:class:`SparseModeRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses>`
                
                .. attribute:: spt_threshold_infinity
                
                	Configure threshold of infinity for switching to SPT on last\-hop
                	**type**\:  str
                
                .. attribute:: ssm
                
                	Configure IP Multicast SSM
                	**type**\:   :py:class:`Ssm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Ssm>`
                
                .. attribute:: ssm_allow_override
                
                	Allow SSM ranges to be overridden by more specific ranges
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: suppress_data_registers
                
                	Suppress data registers after initial state setup
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: suppress_rpf_prunes
                
                	Suppress prunes triggered as a result of RPF changes
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.Vrfs.Vrf.Ipv6, self).__init__()

                    self.yang_name = "ipv6"
                    self.yang_parent_name = "vrf"

                    self.accept_register = YLeaf(YType.str, "accept-register")

                    self.embedded_rp_disable = YLeaf(YType.empty, "embedded-rp-disable")

                    self.log_neighbor_changes = YLeaf(YType.empty, "log-neighbor-changes")

                    self.multipath = YLeaf(YType.enumeration, "multipath")

                    self.neighbor_check_on_receive = YLeaf(YType.empty, "neighbor-check-on-receive")

                    self.neighbor_check_on_send = YLeaf(YType.empty, "neighbor-check-on-send")

                    self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                    self.old_register_checksum = YLeaf(YType.empty, "old-register-checksum")

                    self.register_source = YLeaf(YType.str, "register-source")

                    self.rp_static_deny = YLeaf(YType.str, "rp-static-deny")

                    self.spt_threshold_infinity = YLeaf(YType.str, "spt-threshold-infinity")

                    self.ssm_allow_override = YLeaf(YType.empty, "ssm-allow-override")

                    self.suppress_data_registers = YLeaf(YType.empty, "suppress-data-registers")

                    self.suppress_rpf_prunes = YLeaf(YType.empty, "suppress-rpf-prunes")

                    self.allow_rp = None
                    self._children_name_map["allow_rp"] = "allow-rp"
                    self._children_yang_names.add("allow-rp")

                    self.bidir_rp_addresses = Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses()
                    self.bidir_rp_addresses.parent = self
                    self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                    self._children_yang_names.add("bidir-rp-addresses")

                    self.bsr = Pim.Vrfs.Vrf.Ipv6.Bsr()
                    self.bsr.parent = self
                    self._children_name_map["bsr"] = "bsr"
                    self._children_yang_names.add("bsr")

                    self.convergence = Pim.Vrfs.Vrf.Ipv6.Convergence()
                    self.convergence.parent = self
                    self._children_name_map["convergence"] = "convergence"
                    self._children_yang_names.add("convergence")

                    self.embedded_rp_addresses = Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses()
                    self.embedded_rp_addresses.parent = self
                    self._children_name_map["embedded_rp_addresses"] = "embedded-rp-addresses"
                    self._children_yang_names.add("embedded-rp-addresses")

                    self.inheritable_defaults = Pim.Vrfs.Vrf.Ipv6.InheritableDefaults()
                    self.inheritable_defaults.parent = self
                    self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                    self._children_yang_names.add("inheritable-defaults")

                    self.interfaces = Pim.Vrfs.Vrf.Ipv6.Interfaces()
                    self.interfaces.parent = self
                    self._children_name_map["interfaces"] = "interfaces"
                    self._children_yang_names.add("interfaces")

                    self.maximum = Pim.Vrfs.Vrf.Ipv6.Maximum()
                    self.maximum.parent = self
                    self._children_name_map["maximum"] = "maximum"
                    self._children_yang_names.add("maximum")

                    self.rpf = Pim.Vrfs.Vrf.Ipv6.Rpf()
                    self.rpf.parent = self
                    self._children_name_map["rpf"] = "rpf"
                    self._children_yang_names.add("rpf")

                    self.rpf_vector_enable = None
                    self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                    self._children_yang_names.add("rpf-vector-enable")

                    self.sg_expiry_timer = Pim.Vrfs.Vrf.Ipv6.SgExpiryTimer()
                    self.sg_expiry_timer.parent = self
                    self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                    self._children_yang_names.add("sg-expiry-timer")

                    self.sparse_mode_rp_addresses = Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses()
                    self.sparse_mode_rp_addresses.parent = self
                    self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                    self._children_yang_names.add("sparse-mode-rp-addresses")

                    self.ssm = Pim.Vrfs.Vrf.Ipv6.Ssm()
                    self.ssm.parent = self
                    self._children_name_map["ssm"] = "ssm"
                    self._children_yang_names.add("ssm")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("accept_register",
                                    "embedded_rp_disable",
                                    "log_neighbor_changes",
                                    "multipath",
                                    "neighbor_check_on_receive",
                                    "neighbor_check_on_send",
                                    "neighbor_filter",
                                    "old_register_checksum",
                                    "register_source",
                                    "rp_static_deny",
                                    "spt_threshold_infinity",
                                    "ssm_allow_override",
                                    "suppress_data_registers",
                                    "suppress_rpf_prunes") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.Vrfs.Vrf.Ipv6, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.Vrfs.Vrf.Ipv6, self).__setattr__(name, value)


                class SparseModeRpAddresses(Entity):
                    """
                    Configure Sparse\-Mode Rendezvous Point
                    
                    .. attribute:: sparse_mode_rp_address
                    
                    	Address of the Rendezvous Point
                    	**type**\: list of    :py:class:`SparseModeRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses.SparseModeRpAddress>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses, self).__init__()

                        self.yang_name = "sparse-mode-rp-addresses"
                        self.yang_parent_name = "ipv6"

                        self.sparse_mode_rp_address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses, self).__setattr__(name, value)


                    class SparseModeRpAddress(Entity):
                        """
                        Address of the Rendezvous Point
                        
                        .. attribute:: rp_address  <key>
                        
                        	RP address of Rendezvous Point
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: access_list_name
                        
                        	Access list of groups that should map to a  given RP
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: auto_rp_override
                        
                        	TRUE Indicates if static RP config overrides AutoRP and BSR
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses.SparseModeRpAddress, self).__init__()

                            self.yang_name = "sparse-mode-rp-address"
                            self.yang_parent_name = "sparse-mode-rp-addresses"

                            self.rp_address = YLeaf(YType.str, "rp-address")

                            self.access_list_name = YLeaf(YType.str, "access-list-name")

                            self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rp_address",
                                            "access_list_name",
                                            "auto_rp_override") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.rp_address.is_set or
                                self.access_list_name.is_set or
                                self.auto_rp_override.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rp_address.yfilter != YFilter.not_set or
                                self.access_list_name.yfilter != YFilter.not_set or
                                self.auto_rp_override.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sparse-mode-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rp_address.get_name_leafdata())
                            if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.access_list_name.get_name_leafdata())
                            if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rp-address"):
                                self.rp_address = value
                                self.rp_address.value_namespace = name_space
                                self.rp_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "access-list-name"):
                                self.access_list_name = value
                                self.access_list_name.value_namespace = name_space
                                self.access_list_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "auto-rp-override"):
                                self.auto_rp_override = value
                                self.auto_rp_override.value_namespace = name_space
                                self.auto_rp_override.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.sparse_mode_rp_address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.sparse_mode_rp_address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sparse-mode-rp-addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "sparse-mode-rp-address"):
                            for c in self.sparse_mode_rp_address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses.SparseModeRpAddress()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.sparse_mode_rp_address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "sparse-mode-rp-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class InheritableDefaults(Entity):
                    """
                    Inheritable defaults
                    
                    .. attribute:: convergency
                    
                    	Convergency timeout in seconds
                    	**type**\:  int
                    
                    	**range:** 1800..2400
                    
                    	**units**\: second
                    
                    .. attribute:: dr_priority
                    
                    	Hello DR priority, preference given to larger value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: hello_interval
                    
                    	Hello interval in seconds
                    	**type**\:  int
                    
                    	**range:** 1..3600
                    
                    	**units**\: second
                    
                    .. attribute:: join_prune_mtu
                    
                    	Join\-Prune MTU in Bytes
                    	**type**\:  int
                    
                    	**range:** 576..65535
                    
                    	**units**\: byte
                    
                    .. attribute:: jp_interval
                    
                    	Join\-Prune interval in seconds
                    	**type**\:  int
                    
                    	**range:** 10..600
                    
                    	**units**\: second
                    
                    .. attribute:: override_interval
                    
                    	Override interval in milliseconds
                    	**type**\:  int
                    
                    	**range:** 400..65535
                    
                    	**units**\: millisecond
                    
                    .. attribute:: propagation_delay
                    
                    	Propagation delay in milli seconds
                    	**type**\:  int
                    
                    	**range:** 100..32767
                    
                    	**units**\: millisecond
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.InheritableDefaults, self).__init__()

                        self.yang_name = "inheritable-defaults"
                        self.yang_parent_name = "ipv6"

                        self.convergency = YLeaf(YType.uint32, "convergency")

                        self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                        self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                        self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                        self.override_interval = YLeaf(YType.uint32, "override-interval")

                        self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("convergency",
                                        "dr_priority",
                                        "hello_interval",
                                        "join_prune_mtu",
                                        "jp_interval",
                                        "override_interval",
                                        "propagation_delay") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.InheritableDefaults, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.InheritableDefaults, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.convergency.is_set or
                            self.dr_priority.is_set or
                            self.hello_interval.is_set or
                            self.join_prune_mtu.is_set or
                            self.jp_interval.is_set or
                            self.override_interval.is_set or
                            self.propagation_delay.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.convergency.yfilter != YFilter.not_set or
                            self.dr_priority.yfilter != YFilter.not_set or
                            self.hello_interval.yfilter != YFilter.not_set or
                            self.join_prune_mtu.yfilter != YFilter.not_set or
                            self.jp_interval.yfilter != YFilter.not_set or
                            self.override_interval.yfilter != YFilter.not_set or
                            self.propagation_delay.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "inheritable-defaults" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.convergency.is_set or self.convergency.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.convergency.get_name_leafdata())
                        if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dr_priority.get_name_leafdata())
                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                        if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                        if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.jp_interval.get_name_leafdata())
                        if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.override_interval.get_name_leafdata())
                        if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "convergency" or name == "dr-priority" or name == "hello-interval" or name == "join-prune-mtu" or name == "jp-interval" or name == "override-interval" or name == "propagation-delay"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "convergency"):
                            self.convergency = value
                            self.convergency.value_namespace = name_space
                            self.convergency.value_namespace_prefix = name_space_prefix
                        if(value_path == "dr-priority"):
                            self.dr_priority = value
                            self.dr_priority.value_namespace = name_space
                            self.dr_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "hello-interval"):
                            self.hello_interval = value
                            self.hello_interval.value_namespace = name_space
                            self.hello_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "join-prune-mtu"):
                            self.join_prune_mtu = value
                            self.join_prune_mtu.value_namespace = name_space
                            self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                        if(value_path == "jp-interval"):
                            self.jp_interval = value
                            self.jp_interval.value_namespace = name_space
                            self.jp_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "override-interval"):
                            self.override_interval = value
                            self.override_interval.value_namespace = name_space
                            self.override_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "propagation-delay"):
                            self.propagation_delay = value
                            self.propagation_delay.value_namespace = name_space
                            self.propagation_delay.value_namespace_prefix = name_space_prefix


                class Rpf(Entity):
                    """
                    Configure RPF options
                    
                    .. attribute:: route_policy
                    
                    	Route policy to select RPF topology
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.Rpf, self).__init__()

                        self.yang_name = "rpf"
                        self.yang_parent_name = "ipv6"

                        self.route_policy = YLeaf(YType.str, "route-policy")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("route_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.Rpf, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.Rpf, self).__setattr__(name, value)

                    def has_data(self):
                        return self.route_policy.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.route_policy.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rpf" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.route_policy.is_set or self.route_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "route-policy"):
                            self.route_policy = value
                            self.route_policy.value_namespace = name_space
                            self.route_policy.value_namespace_prefix = name_space_prefix


                class Maximum(Entity):
                    """
                    Configure PIM State Limits
                    
                    .. attribute:: bsr_candidate_rp_cache
                    
                    	Override default maximum and threshold for BSR C\-RP cache setting
                    	**type**\:   :py:class:`BsrCandidateRpCache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Maximum.BsrCandidateRpCache>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: bsr_group_mappings
                    
                    	Override default maximum and threshold for number of group mappings from BSR
                    	**type**\:   :py:class:`BsrGroupMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Maximum.BsrGroupMappings>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: group_mappings_auto_rp
                    
                    	Override default maximum for number of group mappings from autorp mapping agent
                    	**type**\:   :py:class:`GroupMappingsAutoRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Maximum.GroupMappingsAutoRp>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: register_states
                    
                    	Override default maximum for number of sparse\-mode source registers
                    	**type**\:   :py:class:`RegisterStates <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Maximum.RegisterStates>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: route_interfaces
                    
                    	Override default maximum for number of route\-interfaces
                    	**type**\:   :py:class:`RouteInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Maximum.RouteInterfaces>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: routes
                    
                    	Override default maximum for number of routes
                    	**type**\:   :py:class:`Routes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Maximum.Routes>`
                    
                    	**presence node**\: True
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.Maximum, self).__init__()

                        self.yang_name = "maximum"
                        self.yang_parent_name = "ipv6"

                        self.bsr_candidate_rp_cache = None
                        self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                        self._children_yang_names.add("bsr-candidate-rp-cache")

                        self.bsr_group_mappings = None
                        self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                        self._children_yang_names.add("bsr-group-mappings")

                        self.group_mappings_auto_rp = None
                        self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                        self._children_yang_names.add("group-mappings-auto-rp")

                        self.register_states = None
                        self._children_name_map["register_states"] = "register-states"
                        self._children_yang_names.add("register-states")

                        self.route_interfaces = None
                        self._children_name_map["route_interfaces"] = "route-interfaces"
                        self._children_yang_names.add("route-interfaces")

                        self.routes = None
                        self._children_name_map["routes"] = "routes"
                        self._children_yang_names.add("routes")


                    class GroupMappingsAutoRp(Entity):
                        """
                        Override default maximum for number of group
                        mappings from autorp mapping agent
                        
                        .. attribute:: maximum_group_ranges_auto_rp
                        
                        	Maximum number of PIM group mappings from autorp
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: threshold_group_ranges_auto_rp
                        
                        	Warning threshold number of PIM group mappings from autorp
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**default value**\: 450
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Maximum.GroupMappingsAutoRp, self).__init__()

                            self.yang_name = "group-mappings-auto-rp"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_group_ranges_auto_rp = YLeaf(YType.uint32, "maximum-group-ranges-auto-rp")

                            self.threshold_group_ranges_auto_rp = YLeaf(YType.uint32, "threshold-group-ranges-auto-rp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_group_ranges_auto_rp",
                                            "threshold_group_ranges_auto_rp") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_group_ranges_auto_rp.is_set or
                                self.threshold_group_ranges_auto_rp.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set or
                                self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "group-mappings-auto-rp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_group_ranges_auto_rp.is_set or self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_group_ranges_auto_rp.get_name_leafdata())
                            if (self.threshold_group_ranges_auto_rp.is_set or self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_group_ranges_auto_rp.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-group-ranges-auto-rp" or name == "threshold-group-ranges-auto-rp"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-group-ranges-auto-rp"):
                                self.maximum_group_ranges_auto_rp = value
                                self.maximum_group_ranges_auto_rp.value_namespace = name_space
                                self.maximum_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-group-ranges-auto-rp"):
                                self.threshold_group_ranges_auto_rp = value
                                self.threshold_group_ranges_auto_rp.value_namespace = name_space
                                self.threshold_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix


                    class BsrGroupMappings(Entity):
                        """
                        Override default maximum and threshold for
                        number of group mappings from BSR
                        
                        .. attribute:: bsr_maximum_group_ranges
                        
                        	Maximum number of PIM group mappings from BSR
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**default value**\: 500
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Maximum.BsrGroupMappings, self).__init__()

                            self.yang_name = "bsr-group-mappings"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.bsr_maximum_group_ranges = YLeaf(YType.uint32, "bsr-maximum-group-ranges")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bsr_maximum_group_ranges",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Maximum.BsrGroupMappings, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Maximum.BsrGroupMappings, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bsr_maximum_group_ranges.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bsr_maximum_group_ranges.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bsr-group-mappings" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bsr_maximum_group_ranges.is_set or self.bsr_maximum_group_ranges.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bsr_maximum_group_ranges.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bsr-maximum-group-ranges" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bsr-maximum-group-ranges"):
                                self.bsr_maximum_group_ranges = value
                                self.bsr_maximum_group_ranges.value_namespace = name_space
                                self.bsr_maximum_group_ranges.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class RegisterStates(Entity):
                        """
                        Override default maximum for number of
                        sparse\-mode source registers
                        
                        .. attribute:: maximum_register_states
                        
                        	Maximum number of PIM Sparse\-Mode register states
                        	**type**\:  int
                        
                        	**range:** 0..75000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 0..75000
                        
                        	**default value**\: 20000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Maximum.RegisterStates, self).__init__()

                            self.yang_name = "register-states"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_register_states = YLeaf(YType.uint32, "maximum-register-states")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_register_states",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Maximum.RegisterStates, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Maximum.RegisterStates, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_register_states.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_register_states.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "register-states" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_register_states.is_set or self.maximum_register_states.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_register_states.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-register-states" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-register-states"):
                                self.maximum_register_states = value
                                self.maximum_register_states.value_namespace = name_space
                                self.maximum_register_states.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class RouteInterfaces(Entity):
                        """
                        Override default maximum for number of
                        route\-interfaces
                        
                        .. attribute:: maximum_route_interfaces
                        
                        	Maximum number of PIM route\-interfaces
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        	**default value**\: 300000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Maximum.RouteInterfaces, self).__init__()

                            self.yang_name = "route-interfaces"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_route_interfaces = YLeaf(YType.uint32, "maximum-route-interfaces")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_route_interfaces",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Maximum.RouteInterfaces, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Maximum.RouteInterfaces, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_route_interfaces.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_route_interfaces.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "route-interfaces" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_route_interfaces.is_set or self.maximum_route_interfaces.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_route_interfaces.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-route-interfaces" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-route-interfaces"):
                                self.maximum_route_interfaces = value
                                self.maximum_route_interfaces.value_namespace = name_space
                                self.maximum_route_interfaces.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class BsrCandidateRpCache(Entity):
                        """
                        Override default maximum and threshold for BSR
                        C\-RP cache setting
                        
                        .. attribute:: bsr_maximum_candidate_rp_cache
                        
                        	Maximum number of BSR C\-RP cache setting
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..10000
                        
                        	**default value**\: 100
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Maximum.BsrCandidateRpCache, self).__init__()

                            self.yang_name = "bsr-candidate-rp-cache"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.bsr_maximum_candidate_rp_cache = YLeaf(YType.uint32, "bsr-maximum-candidate-rp-cache")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bsr_maximum_candidate_rp_cache",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bsr_maximum_candidate_rp_cache.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bsr-candidate-rp-cache" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bsr_maximum_candidate_rp_cache.is_set or self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bsr_maximum_candidate_rp_cache.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bsr-maximum-candidate-rp-cache" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bsr-maximum-candidate-rp-cache"):
                                self.bsr_maximum_candidate_rp_cache = value
                                self.bsr_maximum_candidate_rp_cache.value_namespace = name_space
                                self.bsr_maximum_candidate_rp_cache.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class Routes(Entity):
                        """
                        Override default maximum for number of routes
                        
                        .. attribute:: maximum_routes
                        
                        	Maximum number of PIM routes
                        	**type**\:  int
                        
                        	**range:** 1..200000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..200000
                        
                        	**default value**\: 100000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Maximum.Routes, self).__init__()

                            self.yang_name = "routes"
                            self.yang_parent_name = "maximum"
                            self.is_presence_container = True

                            self.maximum_routes = YLeaf(YType.uint32, "maximum-routes")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_routes",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Maximum.Routes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Maximum.Routes, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.maximum_routes.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_routes.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "routes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_routes.is_set or self.maximum_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_routes.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-routes" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-routes"):
                                self.maximum_routes = value
                                self.maximum_routes.value_namespace = name_space
                                self.maximum_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.bsr_candidate_rp_cache is not None) or
                            (self.bsr_group_mappings is not None) or
                            (self.group_mappings_auto_rp is not None) or
                            (self.register_states is not None) or
                            (self.route_interfaces is not None) or
                            (self.routes is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.bsr_candidate_rp_cache is not None and self.bsr_candidate_rp_cache.has_operation()) or
                            (self.bsr_group_mappings is not None and self.bsr_group_mappings.has_operation()) or
                            (self.group_mappings_auto_rp is not None and self.group_mappings_auto_rp.has_operation()) or
                            (self.register_states is not None and self.register_states.has_operation()) or
                            (self.route_interfaces is not None and self.route_interfaces.has_operation()) or
                            (self.routes is not None and self.routes.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "maximum" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bsr-candidate-rp-cache"):
                            if (self.bsr_candidate_rp_cache is None):
                                self.bsr_candidate_rp_cache = Pim.Vrfs.Vrf.Ipv6.Maximum.BsrCandidateRpCache()
                                self.bsr_candidate_rp_cache.parent = self
                                self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                            return self.bsr_candidate_rp_cache

                        if (child_yang_name == "bsr-group-mappings"):
                            if (self.bsr_group_mappings is None):
                                self.bsr_group_mappings = Pim.Vrfs.Vrf.Ipv6.Maximum.BsrGroupMappings()
                                self.bsr_group_mappings.parent = self
                                self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                            return self.bsr_group_mappings

                        if (child_yang_name == "group-mappings-auto-rp"):
                            if (self.group_mappings_auto_rp is None):
                                self.group_mappings_auto_rp = Pim.Vrfs.Vrf.Ipv6.Maximum.GroupMappingsAutoRp()
                                self.group_mappings_auto_rp.parent = self
                                self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                            return self.group_mappings_auto_rp

                        if (child_yang_name == "register-states"):
                            if (self.register_states is None):
                                self.register_states = Pim.Vrfs.Vrf.Ipv6.Maximum.RegisterStates()
                                self.register_states.parent = self
                                self._children_name_map["register_states"] = "register-states"
                            return self.register_states

                        if (child_yang_name == "route-interfaces"):
                            if (self.route_interfaces is None):
                                self.route_interfaces = Pim.Vrfs.Vrf.Ipv6.Maximum.RouteInterfaces()
                                self.route_interfaces.parent = self
                                self._children_name_map["route_interfaces"] = "route-interfaces"
                            return self.route_interfaces

                        if (child_yang_name == "routes"):
                            if (self.routes is None):
                                self.routes = Pim.Vrfs.Vrf.Ipv6.Maximum.Routes()
                                self.routes.parent = self
                                self._children_name_map["routes"] = "routes"
                            return self.routes

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-candidate-rp-cache" or name == "bsr-group-mappings" or name == "group-mappings-auto-rp" or name == "register-states" or name == "route-interfaces" or name == "routes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SgExpiryTimer(Entity):
                    """
                    Configure expiry timer for S,G routes
                    
                    .. attribute:: access_list_name
                    
                    	Access\-list of applicable S,G routes
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: interval
                    
                    	(S,G) expiry time in seconds
                    	**type**\:  int
                    
                    	**range:** 40..57600
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.SgExpiryTimer, self).__init__()

                        self.yang_name = "sg-expiry-timer"
                        self.yang_parent_name = "ipv6"

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                        self.interval = YLeaf(YType.uint32, "interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("access_list_name",
                                        "interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.SgExpiryTimer, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.SgExpiryTimer, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.access_list_name.is_set or
                            self.interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sg-expiry-timer" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "access-list-name" or name == "interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix


                class RpfVectorEnable(Entity):
                    """
                    Enable PIM RPF Vector Proxy's
                    
                    .. attribute:: allow_ebgp
                    
                    	Allow RPF Vector origination over eBGP sessions
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: disable_ibgp
                    
                    	Disable RPF Vector origination over iBGP sessions
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: enable
                    
                    	RPF Vector is turned on if configured
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    	**mandatory**\: True
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.RpfVectorEnable, self).__init__()

                        self.yang_name = "rpf-vector-enable"
                        self.yang_parent_name = "ipv6"
                        self.is_presence_container = True

                        self.allow_ebgp = YLeaf(YType.empty, "allow-ebgp")

                        self.disable_ibgp = YLeaf(YType.empty, "disable-ibgp")

                        self.enable = YLeaf(YType.empty, "enable")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_ebgp",
                                        "disable_ibgp",
                                        "enable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.RpfVectorEnable, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.RpfVectorEnable, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_ebgp.is_set or
                            self.disable_ibgp.is_set or
                            self.enable.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_ebgp.yfilter != YFilter.not_set or
                            self.disable_ibgp.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rpf-vector-enable" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_ebgp.is_set or self.allow_ebgp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_ebgp.get_name_leafdata())
                        if (self.disable_ibgp.is_set or self.disable_ibgp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable_ibgp.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-ebgp" or name == "disable-ibgp" or name == "enable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-ebgp"):
                            self.allow_ebgp = value
                            self.allow_ebgp.value_namespace = name_space
                            self.allow_ebgp.value_namespace_prefix = name_space_prefix
                        if(value_path == "disable-ibgp"):
                            self.disable_ibgp = value
                            self.disable_ibgp.value_namespace = name_space
                            self.disable_ibgp.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix


                class Ssm(Entity):
                    """
                    Configure IP Multicast SSM
                    
                    .. attribute:: disable
                    
                    	TRUE if SSM is disabled on this router
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: range
                    
                    	Access list of groups enabled with SSM
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.Ssm, self).__init__()

                        self.yang_name = "ssm"
                        self.yang_parent_name = "ipv6"

                        self.disable = YLeaf(YType.boolean, "disable")

                        self.range = YLeaf(YType.str, "range")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable",
                                        "range") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.Ssm, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.Ssm, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.disable.is_set or
                            self.range.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable.yfilter != YFilter.not_set or
                            self.range.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ssm" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable.get_name_leafdata())
                        if (self.range.is_set or self.range.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.range.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable" or name == "range"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable"):
                            self.disable = value
                            self.disable.value_namespace = name_space
                            self.disable.value_namespace_prefix = name_space_prefix
                        if(value_path == "range"):
                            self.range = value
                            self.range.value_namespace = name_space
                            self.range.value_namespace_prefix = name_space_prefix


                class BidirRpAddresses(Entity):
                    """
                    Configure Bidirectional PIM Rendezvous Point
                    
                    .. attribute:: bidir_rp_address
                    
                    	Address of the Rendezvous Point
                    	**type**\: list of    :py:class:`BidirRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses.BidirRpAddress>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses, self).__init__()

                        self.yang_name = "bidir-rp-addresses"
                        self.yang_parent_name = "ipv6"

                        self.bidir_rp_address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses, self).__setattr__(name, value)


                    class BidirRpAddress(Entity):
                        """
                        Address of the Rendezvous Point
                        
                        .. attribute:: rp_address  <key>
                        
                        	RP address of Rendezvous Point
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: access_list_name
                        
                        	Access list of groups that should map to a given RP
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: auto_rp_override
                        
                        	TRUE Indicates if static RP config overrides AutoRP and BSR
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses.BidirRpAddress, self).__init__()

                            self.yang_name = "bidir-rp-address"
                            self.yang_parent_name = "bidir-rp-addresses"

                            self.rp_address = YLeaf(YType.str, "rp-address")

                            self.access_list_name = YLeaf(YType.str, "access-list-name")

                            self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rp_address",
                                            "access_list_name",
                                            "auto_rp_override") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.rp_address.is_set or
                                self.access_list_name.is_set or
                                self.auto_rp_override.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rp_address.yfilter != YFilter.not_set or
                                self.access_list_name.yfilter != YFilter.not_set or
                                self.auto_rp_override.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bidir-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rp_address.get_name_leafdata())
                            if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.access_list_name.get_name_leafdata())
                            if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rp-address"):
                                self.rp_address = value
                                self.rp_address.value_namespace = name_space
                                self.rp_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "access-list-name"):
                                self.access_list_name = value
                                self.access_list_name.value_namespace = name_space
                                self.access_list_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "auto-rp-override"):
                                self.auto_rp_override = value
                                self.auto_rp_override.value_namespace = name_space
                                self.auto_rp_override.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.bidir_rp_address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.bidir_rp_address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bidir-rp-addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bidir-rp-address"):
                            for c in self.bidir_rp_address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses.BidirRpAddress()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.bidir_rp_address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bidir-rp-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Bsr(Entity):
                    """
                    PIM BSR configuration
                    
                    .. attribute:: candidate_bsr
                    
                    	PIM Candidate BSR configuration
                    	**type**\:   :py:class:`CandidateBsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateBsr>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: candidate_rps
                    
                    	PIM RP configuration
                    	**type**\:   :py:class:`CandidateRps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.Bsr, self).__init__()

                        self.yang_name = "bsr"
                        self.yang_parent_name = "ipv6"

                        self.candidate_bsr = None
                        self._children_name_map["candidate_bsr"] = "candidate-bsr"
                        self._children_yang_names.add("candidate-bsr")

                        self.candidate_rps = Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps()
                        self.candidate_rps.parent = self
                        self._children_name_map["candidate_rps"] = "candidate-rps"
                        self._children_yang_names.add("candidate-rps")


                    class CandidateBsr(Entity):
                        """
                        PIM Candidate BSR configuration
                        
                        .. attribute:: address
                        
                        	BSR Address configured
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        	**mandatory**\: True
                        
                        .. attribute:: prefix_length
                        
                        	Hash Mask Length for this candidate BSR
                        	**type**\:  int
                        
                        	**range:** 0..128
                        
                        	**default value**\: 126
                        
                        .. attribute:: priority
                        
                        	Priority of the Candidate BSR
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        	**default value**\: 1
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateBsr, self).__init__()

                            self.yang_name = "candidate-bsr"
                            self.yang_parent_name = "bsr"
                            self.is_presence_container = True

                            self.address = YLeaf(YType.str, "address")

                            self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            self.priority = YLeaf(YType.uint32, "priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "prefix_length",
                                            "priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateBsr, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateBsr, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.prefix_length.is_set or
                                self.priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.prefix_length.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "candidate-bsr" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_length.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address" or name == "prefix-length" or name == "priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-length"):
                                self.prefix_length = value
                                self.prefix_length.value_namespace = name_space
                                self.prefix_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix


                    class CandidateRps(Entity):
                        """
                        PIM RP configuration
                        
                        .. attribute:: candidate_rp
                        
                        	Address of PIM SM BSR Candidate\-RP
                        	**type**\: list of    :py:class:`CandidateRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps.CandidateRp>`
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps, self).__init__()

                            self.yang_name = "candidate-rps"
                            self.yang_parent_name = "bsr"

                            self.candidate_rp = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps, self).__setattr__(name, value)


                        class CandidateRp(Entity):
                            """
                            Address of PIM SM BSR Candidate\-RP
                            
                            .. attribute:: address  <key>
                            
                            	Address of Candidate\-RP
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: mode  <key>
                            
                            	SM or Bidir
                            	**type**\:   :py:class:`PimProtocolMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimProtocolMode>`
                            
                            .. attribute:: group_list
                            
                            	Access\-list specifying the group range for the Candidate\-RP
                            	**type**\:  str
                            
                            	**length:** 1..64
                            
                            .. attribute:: interval
                            
                            	Advertisement interval
                            	**type**\:  int
                            
                            	**range:** 30..600
                            
                            	**default value**\: 60
                            
                            .. attribute:: priority
                            
                            	Priority of the CRP
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            	**default value**\: 192
                            
                            

                            """

                            _prefix = 'ipv4-pim-cfg'
                            _revision = '2016-06-01'

                            def __init__(self):
                                super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps.CandidateRp, self).__init__()

                                self.yang_name = "candidate-rp"
                                self.yang_parent_name = "candidate-rps"

                                self.address = YLeaf(YType.str, "address")

                                self.mode = YLeaf(YType.enumeration, "mode")

                                self.group_list = YLeaf(YType.str, "group-list")

                                self.interval = YLeaf(YType.uint32, "interval")

                                self.priority = YLeaf(YType.uint32, "priority")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("address",
                                                "mode",
                                                "group_list",
                                                "interval",
                                                "priority") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.address.is_set or
                                    self.mode.is_set or
                                    self.group_list.is_set or
                                    self.interval.is_set or
                                    self.priority.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.mode.yfilter != YFilter.not_set or
                                    self.group_list.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "candidate-rp" + "[address='" + self.address.get() + "']" + "[mode='" + self.mode.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mode.get_name_leafdata())
                                if (self.group_list.is_set or self.group_list.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.group_list.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "address" or name == "mode" or name == "group-list" or name == "interval" or name == "priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "mode"):
                                    self.mode = value
                                    self.mode.value_namespace = name_space
                                    self.mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "group-list"):
                                    self.group_list = value
                                    self.group_list.value_namespace = name_space
                                    self.group_list.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.candidate_rp:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.candidate_rp:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "candidate-rps" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "candidate-rp"):
                                for c in self.candidate_rp:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps.CandidateRp()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.candidate_rp.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "candidate-rp"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.candidate_rps is not None and self.candidate_rps.has_data()) or
                            (self.candidate_bsr is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.candidate_bsr is not None and self.candidate_bsr.has_operation()) or
                            (self.candidate_rps is not None and self.candidate_rps.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "candidate-bsr"):
                            if (self.candidate_bsr is None):
                                self.candidate_bsr = Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateBsr()
                                self.candidate_bsr.parent = self
                                self._children_name_map["candidate_bsr"] = "candidate-bsr"
                            return self.candidate_bsr

                        if (child_yang_name == "candidate-rps"):
                            if (self.candidate_rps is None):
                                self.candidate_rps = Pim.Vrfs.Vrf.Ipv6.Bsr.CandidateRps()
                                self.candidate_rps.parent = self
                                self._children_name_map["candidate_rps"] = "candidate-rps"
                            return self.candidate_rps

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "candidate-bsr" or name == "candidate-rps"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AllowRp(Entity):
                    """
                    Enable allow\-rp filtering for SM joins
                    
                    .. attribute:: group_list_name
                    
                    	Access\-list specifiying applicable groups
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: rp_list_name
                    
                    	Access\-list specifiying applicable RPs
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.AllowRp, self).__init__()

                        self.yang_name = "allow-rp"
                        self.yang_parent_name = "ipv6"
                        self.is_presence_container = True

                        self.group_list_name = YLeaf(YType.str, "group-list-name")

                        self.rp_list_name = YLeaf(YType.str, "rp-list-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("group_list_name",
                                        "rp_list_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.AllowRp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.AllowRp, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.group_list_name.is_set or
                            self.rp_list_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.group_list_name.yfilter != YFilter.not_set or
                            self.rp_list_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "allow-rp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.group_list_name.is_set or self.group_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.group_list_name.get_name_leafdata())
                        if (self.rp_list_name.is_set or self.rp_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rp_list_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "group-list-name" or name == "rp-list-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "group-list-name"):
                            self.group_list_name = value
                            self.group_list_name.value_namespace = name_space
                            self.group_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "rp-list-name"):
                            self.rp_list_name = value
                            self.rp_list_name.value_namespace = name_space
                            self.rp_list_name.value_namespace_prefix = name_space_prefix


                class EmbeddedRpAddresses(Entity):
                    """
                    Set Embedded RP processing support
                    
                    .. attribute:: embedded_rp_address
                    
                    	Set Embedded RP processing support
                    	**type**\: list of    :py:class:`EmbeddedRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses, self).__init__()

                        self.yang_name = "embedded-rp-addresses"
                        self.yang_parent_name = "ipv6"

                        self.embedded_rp_address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses, self).__setattr__(name, value)


                    class EmbeddedRpAddress(Entity):
                        """
                        Set Embedded RP processing support
                        
                        .. attribute:: rp_address  <key>
                        
                        	RP address of the Rendezvous Point
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: access_list_name
                        
                        	Access list of groups that should map to a given RP
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        	**mandatory**\: True
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress, self).__init__()

                            self.yang_name = "embedded-rp-address"
                            self.yang_parent_name = "embedded-rp-addresses"

                            self.rp_address = YLeaf(YType.str, "rp-address")

                            self.access_list_name = YLeaf(YType.str, "access-list-name")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rp_address",
                                            "access_list_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.rp_address.is_set or
                                self.access_list_name.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rp_address.yfilter != YFilter.not_set or
                                self.access_list_name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "embedded-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rp_address.get_name_leafdata())
                            if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.access_list_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "rp-address" or name == "access-list-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rp-address"):
                                self.rp_address = value
                                self.rp_address.value_namespace = name_space
                                self.rp_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "access-list-name"):
                                self.access_list_name = value
                                self.access_list_name.value_namespace = name_space
                                self.access_list_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.embedded_rp_address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.embedded_rp_address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "embedded-rp-addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "embedded-rp-address"):
                            for c in self.embedded_rp_address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.embedded_rp_address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "embedded-rp-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Convergence(Entity):
                    """
                    Configure convergence parameters
                    
                    .. attribute:: link_down_prune_delay
                    
                    	Delay prunes if route join state transitions to not\-joined on link down
                    	**type**\:  int
                    
                    	**range:** 0..60
                    
                    	**units**\: second
                    
                    .. attribute:: rpf_conflict_join_delay
                    
                    	Dampen first join if RPF path is through one of the downstream neighbor
                    	**type**\:  int
                    
                    	**range:** 0..15
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.Convergence, self).__init__()

                        self.yang_name = "convergence"
                        self.yang_parent_name = "ipv6"

                        self.link_down_prune_delay = YLeaf(YType.uint32, "link-down-prune-delay")

                        self.rpf_conflict_join_delay = YLeaf(YType.uint32, "rpf-conflict-join-delay")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("link_down_prune_delay",
                                        "rpf_conflict_join_delay") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.Convergence, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.Convergence, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.link_down_prune_delay.is_set or
                            self.rpf_conflict_join_delay.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.link_down_prune_delay.yfilter != YFilter.not_set or
                            self.rpf_conflict_join_delay.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "convergence" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.link_down_prune_delay.is_set or self.link_down_prune_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.link_down_prune_delay.get_name_leafdata())
                        if (self.rpf_conflict_join_delay.is_set or self.rpf_conflict_join_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rpf_conflict_join_delay.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "link-down-prune-delay" or name == "rpf-conflict-join-delay"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "link-down-prune-delay"):
                            self.link_down_prune_delay = value
                            self.link_down_prune_delay.value_namespace = name_space
                            self.link_down_prune_delay.value_namespace_prefix = name_space_prefix
                        if(value_path == "rpf-conflict-join-delay"):
                            self.rpf_conflict_join_delay = value
                            self.rpf_conflict_join_delay.value_namespace = name_space
                            self.rpf_conflict_join_delay.value_namespace_prefix = name_space_prefix


                class Interfaces(Entity):
                    """
                    Interface\-level Configuration
                    
                    .. attribute:: interface
                    
                    	The name of the interface
                    	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.Vrfs.Vrf.Ipv6.Interfaces, self).__init__()

                        self.yang_name = "interfaces"
                        self.yang_parent_name = "ipv6"

                        self.interface = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.Vrfs.Vrf.Ipv6.Interfaces, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.Vrfs.Vrf.Ipv6.Interfaces, self).__setattr__(name, value)


                    class Interface(Entity):
                        """
                        The name of the interface
                        
                        .. attribute:: interface_name  <key>
                        
                        	The name of interface
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: bfd
                        
                        	BFD configuration
                        	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.Bfd>`
                        
                        .. attribute:: bsr_border
                        
                        	BSR Border configuration for Interface
                        	**type**\:  bool
                        
                        .. attribute:: dr_priority
                        
                        	Hello DR priority, preference given to larger value
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: enable
                        
                        	Enter PIM Interface processing
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: hello_interval
                        
                        	Hello interval in seconds
                        	**type**\:  int
                        
                        	**range:** 1..3600
                        
                        	**units**\: second
                        
                        .. attribute:: interface_enable
                        
                        	Enable PIM processing on the interface
                        	**type**\:  bool
                        
                        .. attribute:: join_prune_mtu
                        
                        	Join\-Prune MTU in Bytes
                        	**type**\:  int
                        
                        	**range:** 576..65535
                        
                        	**units**\: byte
                        
                        .. attribute:: jp_interval
                        
                        	Join\-Prune interval in seconds
                        	**type**\:  int
                        
                        	**range:** 10..600
                        
                        	**units**\: second
                        
                        .. attribute:: maximum_routes
                        
                        	Maximum number of allowed routes for this interface
                        	**type**\:   :py:class:`MaximumRoutes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.MaximumRoutes>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: neighbor_filter
                        
                        	Access\-list of neighbors to be filtered
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: override_interval
                        
                        	Override interval in milliseconds
                        	**type**\:  int
                        
                        	**range:** 400..65535
                        
                        	**units**\: millisecond
                        
                        .. attribute:: propagation_delay
                        
                        	Propagation delay in milli seconds
                        	**type**\:  int
                        
                        	**range:** 100..32767
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface, self).__init__()

                            self.yang_name = "interface"
                            self.yang_parent_name = "interfaces"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.bsr_border = YLeaf(YType.boolean, "bsr-border")

                            self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                            self.interface_enable = YLeaf(YType.boolean, "interface-enable")

                            self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                            self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                            self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                            self.override_interval = YLeaf(YType.uint32, "override-interval")

                            self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                            self.bfd = Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.Bfd()
                            self.bfd.parent = self
                            self._children_name_map["bfd"] = "bfd"
                            self._children_yang_names.add("bfd")

                            self.maximum_routes = None
                            self._children_name_map["maximum_routes"] = "maximum-routes"
                            self._children_yang_names.add("maximum-routes")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name",
                                            "bsr_border",
                                            "dr_priority",
                                            "enable",
                                            "hello_interval",
                                            "interface_enable",
                                            "join_prune_mtu",
                                            "jp_interval",
                                            "neighbor_filter",
                                            "override_interval",
                                            "propagation_delay") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface, self).__setattr__(name, value)


                        class MaximumRoutes(Entity):
                            """
                            Maximum number of allowed routes for this
                            interface
                            
                            .. attribute:: access_list_name
                            
                            	Access\-list to account for
                            	**type**\:  str
                            
                            	**length:** 1..64
                            
                            .. attribute:: maximum
                            
                            	Maximum number of routes for this interface
                            	**type**\:  int
                            
                            	**range:** 1..1100000
                            
                            	**mandatory**\: True
                            
                            .. attribute:: warning_threshold
                            
                            	Set threshold to print warning
                            	**type**\:  int
                            
                            	**range:** 1..1100000
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'ipv4-pim-cfg'
                            _revision = '2016-06-01'

                            def __init__(self):
                                super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.MaximumRoutes, self).__init__()

                                self.yang_name = "maximum-routes"
                                self.yang_parent_name = "interface"
                                self.is_presence_container = True

                                self.access_list_name = YLeaf(YType.str, "access-list-name")

                                self.maximum = YLeaf(YType.uint32, "maximum")

                                self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("access_list_name",
                                                "maximum",
                                                "warning_threshold") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.access_list_name.is_set or
                                    self.maximum.is_set or
                                    self.warning_threshold.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.access_list_name.yfilter != YFilter.not_set or
                                    self.maximum.yfilter != YFilter.not_set or
                                    self.warning_threshold.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "maximum-routes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.access_list_name.get_name_leafdata())
                                if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum.get_name_leafdata())
                                if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "access-list-name" or name == "maximum" or name == "warning-threshold"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "access-list-name"):
                                    self.access_list_name = value
                                    self.access_list_name.value_namespace = name_space
                                    self.access_list_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum"):
                                    self.maximum = value
                                    self.maximum.value_namespace = name_space
                                    self.maximum.value_namespace_prefix = name_space_prefix
                                if(value_path == "warning-threshold"):
                                    self.warning_threshold = value
                                    self.warning_threshold.value_namespace = name_space
                                    self.warning_threshold.value_namespace_prefix = name_space_prefix


                        class Bfd(Entity):
                            """
                            BFD configuration
                            
                            .. attribute:: detection_multiplier
                            
                            	Detection multiplier for BFD sessions created by PIM
                            	**type**\:  int
                            
                            	**range:** 2..50
                            
                            .. attribute:: enable
                            
                            	TRUE to enable BFD. FALSE to disable and to prevent inheritance from a parent
                            	**type**\:  bool
                            
                            .. attribute:: interval
                            
                            	Hello interval for BFD sessions created by PIM
                            	**type**\:  int
                            
                            	**range:** 3..30000
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'ipv4-pim-cfg'
                            _revision = '2016-06-01'

                            def __init__(self):
                                super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.Bfd, self).__init__()

                                self.yang_name = "bfd"
                                self.yang_parent_name = "interface"

                                self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("detection_multiplier",
                                                "enable",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.detection_multiplier.is_set or
                                    self.enable.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.detection_multiplier.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bfd" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "detection-multiplier" or name == "enable" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "detection-multiplier"):
                                    self.detection_multiplier = value
                                    self.detection_multiplier.value_namespace = name_space
                                    self.detection_multiplier.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.interface_name.is_set or
                                self.bsr_border.is_set or
                                self.dr_priority.is_set or
                                self.enable.is_set or
                                self.hello_interval.is_set or
                                self.interface_enable.is_set or
                                self.join_prune_mtu.is_set or
                                self.jp_interval.is_set or
                                self.neighbor_filter.is_set or
                                self.override_interval.is_set or
                                self.propagation_delay.is_set or
                                (self.bfd is not None and self.bfd.has_data()) or
                                (self.maximum_routes is not None))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                self.bsr_border.yfilter != YFilter.not_set or
                                self.dr_priority.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.hello_interval.yfilter != YFilter.not_set or
                                self.interface_enable.yfilter != YFilter.not_set or
                                self.join_prune_mtu.yfilter != YFilter.not_set or
                                self.jp_interval.yfilter != YFilter.not_set or
                                self.neighbor_filter.yfilter != YFilter.not_set or
                                self.override_interval.yfilter != YFilter.not_set or
                                self.propagation_delay.yfilter != YFilter.not_set or
                                (self.bfd is not None and self.bfd.has_operation()) or
                                (self.maximum_routes is not None and self.maximum_routes.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                            if (self.bsr_border.is_set or self.bsr_border.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bsr_border.get_name_leafdata())
                            if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dr_priority.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_interval.get_name_leafdata())
                            if (self.interface_enable.is_set or self.interface_enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_enable.get_name_leafdata())
                            if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                            if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.jp_interval.get_name_leafdata())
                            if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                            if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.override_interval.get_name_leafdata())
                            if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bfd"):
                                if (self.bfd is None):
                                    self.bfd = Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.Bfd()
                                    self.bfd.parent = self
                                    self._children_name_map["bfd"] = "bfd"
                                return self.bfd

                            if (child_yang_name == "maximum-routes"):
                                if (self.maximum_routes is None):
                                    self.maximum_routes = Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface.MaximumRoutes()
                                    self.maximum_routes.parent = self
                                    self._children_name_map["maximum_routes"] = "maximum-routes"
                                return self.maximum_routes

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bfd" or name == "maximum-routes" or name == "interface-name" or name == "bsr-border" or name == "dr-priority" or name == "enable" or name == "hello-interval" or name == "interface-enable" or name == "join-prune-mtu" or name == "jp-interval" or name == "neighbor-filter" or name == "override-interval" or name == "propagation-delay"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "bsr-border"):
                                self.bsr_border = value
                                self.bsr_border.value_namespace = name_space
                                self.bsr_border.value_namespace_prefix = name_space_prefix
                            if(value_path == "dr-priority"):
                                self.dr_priority = value
                                self.dr_priority.value_namespace = name_space
                                self.dr_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "hello-interval"):
                                self.hello_interval = value
                                self.hello_interval.value_namespace = name_space
                                self.hello_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface-enable"):
                                self.interface_enable = value
                                self.interface_enable.value_namespace = name_space
                                self.interface_enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "join-prune-mtu"):
                                self.join_prune_mtu = value
                                self.join_prune_mtu.value_namespace = name_space
                                self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                            if(value_path == "jp-interval"):
                                self.jp_interval = value
                                self.jp_interval.value_namespace = name_space
                                self.jp_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "neighbor-filter"):
                                self.neighbor_filter = value
                                self.neighbor_filter.value_namespace = name_space
                                self.neighbor_filter.value_namespace_prefix = name_space_prefix
                            if(value_path == "override-interval"):
                                self.override_interval = value
                                self.override_interval.value_namespace = name_space
                                self.override_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "propagation-delay"):
                                self.propagation_delay = value
                                self.propagation_delay.value_namespace = name_space
                                self.propagation_delay.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.interface:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.interface:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interfaces" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "interface"):
                            for c in self.interface:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.Vrfs.Vrf.Ipv6.Interfaces.Interface()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.interface.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.accept_register.is_set or
                        self.embedded_rp_disable.is_set or
                        self.log_neighbor_changes.is_set or
                        self.multipath.is_set or
                        self.neighbor_check_on_receive.is_set or
                        self.neighbor_check_on_send.is_set or
                        self.neighbor_filter.is_set or
                        self.old_register_checksum.is_set or
                        self.register_source.is_set or
                        self.rp_static_deny.is_set or
                        self.spt_threshold_infinity.is_set or
                        self.ssm_allow_override.is_set or
                        self.suppress_data_registers.is_set or
                        self.suppress_rpf_prunes.is_set or
                        (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_data()) or
                        (self.bsr is not None and self.bsr.has_data()) or
                        (self.convergence is not None and self.convergence.has_data()) or
                        (self.embedded_rp_addresses is not None and self.embedded_rp_addresses.has_data()) or
                        (self.inheritable_defaults is not None and self.inheritable_defaults.has_data()) or
                        (self.interfaces is not None and self.interfaces.has_data()) or
                        (self.maximum is not None and self.maximum.has_data()) or
                        (self.rpf is not None and self.rpf.has_data()) or
                        (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_data()) or
                        (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_data()) or
                        (self.ssm is not None and self.ssm.has_data()) or
                        (self.allow_rp is not None) or
                        (self.rpf_vector_enable is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.accept_register.yfilter != YFilter.not_set or
                        self.embedded_rp_disable.yfilter != YFilter.not_set or
                        self.log_neighbor_changes.yfilter != YFilter.not_set or
                        self.multipath.yfilter != YFilter.not_set or
                        self.neighbor_check_on_receive.yfilter != YFilter.not_set or
                        self.neighbor_check_on_send.yfilter != YFilter.not_set or
                        self.neighbor_filter.yfilter != YFilter.not_set or
                        self.old_register_checksum.yfilter != YFilter.not_set or
                        self.register_source.yfilter != YFilter.not_set or
                        self.rp_static_deny.yfilter != YFilter.not_set or
                        self.spt_threshold_infinity.yfilter != YFilter.not_set or
                        self.ssm_allow_override.yfilter != YFilter.not_set or
                        self.suppress_data_registers.yfilter != YFilter.not_set or
                        self.suppress_rpf_prunes.yfilter != YFilter.not_set or
                        (self.allow_rp is not None and self.allow_rp.has_operation()) or
                        (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_operation()) or
                        (self.bsr is not None and self.bsr.has_operation()) or
                        (self.convergence is not None and self.convergence.has_operation()) or
                        (self.embedded_rp_addresses is not None and self.embedded_rp_addresses.has_operation()) or
                        (self.inheritable_defaults is not None and self.inheritable_defaults.has_operation()) or
                        (self.interfaces is not None and self.interfaces.has_operation()) or
                        (self.maximum is not None and self.maximum.has_operation()) or
                        (self.rpf is not None and self.rpf.has_operation()) or
                        (self.rpf_vector_enable is not None and self.rpf_vector_enable.has_operation()) or
                        (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_operation()) or
                        (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_operation()) or
                        (self.ssm is not None and self.ssm.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv6" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.accept_register.is_set or self.accept_register.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.accept_register.get_name_leafdata())
                    if (self.embedded_rp_disable.is_set or self.embedded_rp_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.embedded_rp_disable.get_name_leafdata())
                    if (self.log_neighbor_changes.is_set or self.log_neighbor_changes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.log_neighbor_changes.get_name_leafdata())
                    if (self.multipath.is_set or self.multipath.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.multipath.get_name_leafdata())
                    if (self.neighbor_check_on_receive.is_set or self.neighbor_check_on_receive.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_check_on_receive.get_name_leafdata())
                    if (self.neighbor_check_on_send.is_set or self.neighbor_check_on_send.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_check_on_send.get_name_leafdata())
                    if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                    if (self.old_register_checksum.is_set or self.old_register_checksum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.old_register_checksum.get_name_leafdata())
                    if (self.register_source.is_set or self.register_source.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.register_source.get_name_leafdata())
                    if (self.rp_static_deny.is_set or self.rp_static_deny.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rp_static_deny.get_name_leafdata())
                    if (self.spt_threshold_infinity.is_set or self.spt_threshold_infinity.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.spt_threshold_infinity.get_name_leafdata())
                    if (self.ssm_allow_override.is_set or self.ssm_allow_override.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ssm_allow_override.get_name_leafdata())
                    if (self.suppress_data_registers.is_set or self.suppress_data_registers.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.suppress_data_registers.get_name_leafdata())
                    if (self.suppress_rpf_prunes.is_set or self.suppress_rpf_prunes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.suppress_rpf_prunes.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "allow-rp"):
                        if (self.allow_rp is None):
                            self.allow_rp = Pim.Vrfs.Vrf.Ipv6.AllowRp()
                            self.allow_rp.parent = self
                            self._children_name_map["allow_rp"] = "allow-rp"
                        return self.allow_rp

                    if (child_yang_name == "bidir-rp-addresses"):
                        if (self.bidir_rp_addresses is None):
                            self.bidir_rp_addresses = Pim.Vrfs.Vrf.Ipv6.BidirRpAddresses()
                            self.bidir_rp_addresses.parent = self
                            self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                        return self.bidir_rp_addresses

                    if (child_yang_name == "bsr"):
                        if (self.bsr is None):
                            self.bsr = Pim.Vrfs.Vrf.Ipv6.Bsr()
                            self.bsr.parent = self
                            self._children_name_map["bsr"] = "bsr"
                        return self.bsr

                    if (child_yang_name == "convergence"):
                        if (self.convergence is None):
                            self.convergence = Pim.Vrfs.Vrf.Ipv6.Convergence()
                            self.convergence.parent = self
                            self._children_name_map["convergence"] = "convergence"
                        return self.convergence

                    if (child_yang_name == "embedded-rp-addresses"):
                        if (self.embedded_rp_addresses is None):
                            self.embedded_rp_addresses = Pim.Vrfs.Vrf.Ipv6.EmbeddedRpAddresses()
                            self.embedded_rp_addresses.parent = self
                            self._children_name_map["embedded_rp_addresses"] = "embedded-rp-addresses"
                        return self.embedded_rp_addresses

                    if (child_yang_name == "inheritable-defaults"):
                        if (self.inheritable_defaults is None):
                            self.inheritable_defaults = Pim.Vrfs.Vrf.Ipv6.InheritableDefaults()
                            self.inheritable_defaults.parent = self
                            self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                        return self.inheritable_defaults

                    if (child_yang_name == "interfaces"):
                        if (self.interfaces is None):
                            self.interfaces = Pim.Vrfs.Vrf.Ipv6.Interfaces()
                            self.interfaces.parent = self
                            self._children_name_map["interfaces"] = "interfaces"
                        return self.interfaces

                    if (child_yang_name == "maximum"):
                        if (self.maximum is None):
                            self.maximum = Pim.Vrfs.Vrf.Ipv6.Maximum()
                            self.maximum.parent = self
                            self._children_name_map["maximum"] = "maximum"
                        return self.maximum

                    if (child_yang_name == "rpf"):
                        if (self.rpf is None):
                            self.rpf = Pim.Vrfs.Vrf.Ipv6.Rpf()
                            self.rpf.parent = self
                            self._children_name_map["rpf"] = "rpf"
                        return self.rpf

                    if (child_yang_name == "rpf-vector-enable"):
                        if (self.rpf_vector_enable is None):
                            self.rpf_vector_enable = Pim.Vrfs.Vrf.Ipv6.RpfVectorEnable()
                            self.rpf_vector_enable.parent = self
                            self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                        return self.rpf_vector_enable

                    if (child_yang_name == "sg-expiry-timer"):
                        if (self.sg_expiry_timer is None):
                            self.sg_expiry_timer = Pim.Vrfs.Vrf.Ipv6.SgExpiryTimer()
                            self.sg_expiry_timer.parent = self
                            self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                        return self.sg_expiry_timer

                    if (child_yang_name == "sparse-mode-rp-addresses"):
                        if (self.sparse_mode_rp_addresses is None):
                            self.sparse_mode_rp_addresses = Pim.Vrfs.Vrf.Ipv6.SparseModeRpAddresses()
                            self.sparse_mode_rp_addresses.parent = self
                            self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                        return self.sparse_mode_rp_addresses

                    if (child_yang_name == "ssm"):
                        if (self.ssm is None):
                            self.ssm = Pim.Vrfs.Vrf.Ipv6.Ssm()
                            self.ssm.parent = self
                            self._children_name_map["ssm"] = "ssm"
                        return self.ssm

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "allow-rp" or name == "bidir-rp-addresses" or name == "bsr" or name == "convergence" or name == "embedded-rp-addresses" or name == "inheritable-defaults" or name == "interfaces" or name == "maximum" or name == "rpf" or name == "rpf-vector-enable" or name == "sg-expiry-timer" or name == "sparse-mode-rp-addresses" or name == "ssm" or name == "accept-register" or name == "embedded-rp-disable" or name == "log-neighbor-changes" or name == "multipath" or name == "neighbor-check-on-receive" or name == "neighbor-check-on-send" or name == "neighbor-filter" or name == "old-register-checksum" or name == "register-source" or name == "rp-static-deny" or name == "spt-threshold-infinity" or name == "ssm-allow-override" or name == "suppress-data-registers" or name == "suppress-rpf-prunes"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "accept-register"):
                        self.accept_register = value
                        self.accept_register.value_namespace = name_space
                        self.accept_register.value_namespace_prefix = name_space_prefix
                    if(value_path == "embedded-rp-disable"):
                        self.embedded_rp_disable = value
                        self.embedded_rp_disable.value_namespace = name_space
                        self.embedded_rp_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "log-neighbor-changes"):
                        self.log_neighbor_changes = value
                        self.log_neighbor_changes.value_namespace = name_space
                        self.log_neighbor_changes.value_namespace_prefix = name_space_prefix
                    if(value_path == "multipath"):
                        self.multipath = value
                        self.multipath.value_namespace = name_space
                        self.multipath.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-check-on-receive"):
                        self.neighbor_check_on_receive = value
                        self.neighbor_check_on_receive.value_namespace = name_space
                        self.neighbor_check_on_receive.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-check-on-send"):
                        self.neighbor_check_on_send = value
                        self.neighbor_check_on_send.value_namespace = name_space
                        self.neighbor_check_on_send.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-filter"):
                        self.neighbor_filter = value
                        self.neighbor_filter.value_namespace = name_space
                        self.neighbor_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "old-register-checksum"):
                        self.old_register_checksum = value
                        self.old_register_checksum.value_namespace = name_space
                        self.old_register_checksum.value_namespace_prefix = name_space_prefix
                    if(value_path == "register-source"):
                        self.register_source = value
                        self.register_source.value_namespace = name_space
                        self.register_source.value_namespace_prefix = name_space_prefix
                    if(value_path == "rp-static-deny"):
                        self.rp_static_deny = value
                        self.rp_static_deny.value_namespace = name_space
                        self.rp_static_deny.value_namespace_prefix = name_space_prefix
                    if(value_path == "spt-threshold-infinity"):
                        self.spt_threshold_infinity = value
                        self.spt_threshold_infinity.value_namespace = name_space
                        self.spt_threshold_infinity.value_namespace_prefix = name_space_prefix
                    if(value_path == "ssm-allow-override"):
                        self.ssm_allow_override = value
                        self.ssm_allow_override.value_namespace = name_space
                        self.ssm_allow_override.value_namespace_prefix = name_space_prefix
                    if(value_path == "suppress-data-registers"):
                        self.suppress_data_registers = value
                        self.suppress_data_registers.value_namespace = name_space
                        self.suppress_data_registers.value_namespace_prefix = name_space_prefix
                    if(value_path == "suppress-rpf-prunes"):
                        self.suppress_rpf_prunes = value
                        self.suppress_rpf_prunes.value_namespace = name_space
                        self.suppress_rpf_prunes.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.vrf_name.is_set or
                    (self.ipv4 is not None and self.ipv4.has_data()) or
                    (self.ipv6 is not None and self.ipv6.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.ipv4 is not None and self.ipv4.has_operation()) or
                    (self.ipv6 is not None and self.ipv6.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "vrf" + "[vrf-name='" + self.vrf_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/vrfs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv4"):
                    if (self.ipv4 is None):
                        self.ipv4 = Pim.Vrfs.Vrf.Ipv4()
                        self.ipv4.parent = self
                        self._children_name_map["ipv4"] = "ipv4"
                    return self.ipv4

                if (child_yang_name == "ipv6"):
                    if (self.ipv6 is None):
                        self.ipv6 = Pim.Vrfs.Vrf.Ipv6()
                        self.ipv6.parent = self
                        self._children_name_map["ipv6"] = "ipv6"
                    return self.ipv6

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv4" or name == "ipv6" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.vrf:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.vrf:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "vrfs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "vrf"):
                for c in self.vrf:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Pim.Vrfs.Vrf()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.vrf.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "vrf"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class DefaultContext(Entity):
        """
        Default Context
        
        .. attribute:: ipv4
        
        	IPV4 commands
        	**type**\:   :py:class:`Ipv4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4>`
        
        .. attribute:: ipv6
        
        	IPV6 commands
        	**type**\:   :py:class:`Ipv6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6>`
        
        

        This class is a :ref:`presence class<presence-class>`

        """

        _prefix = 'ipv4-pim-cfg'
        _revision = '2016-06-01'

        def __init__(self):
            super(Pim.DefaultContext, self).__init__()

            self.yang_name = "default-context"
            self.yang_parent_name = "pim"
            self.is_presence_container = True

            self.ipv4 = Pim.DefaultContext.Ipv4()
            self.ipv4.parent = self
            self._children_name_map["ipv4"] = "ipv4"
            self._children_yang_names.add("ipv4")

            self.ipv6 = Pim.DefaultContext.Ipv6()
            self.ipv6.parent = self
            self._children_name_map["ipv6"] = "ipv6"
            self._children_yang_names.add("ipv6")


        class Ipv6(Entity):
            """
            IPV6 commands
            
            .. attribute:: accept_register
            
            	Access\-list which specifies unauthorized sources
            	**type**\:  str
            
            	**length:** 1..64
            
            .. attribute:: allow_rp
            
            	Enable allow\-rp filtering for SM joins
            	**type**\:   :py:class:`AllowRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.AllowRp>`
            
            	**presence node**\: True
            
            .. attribute:: bidir_rp_addresses
            
            	Configure Bidirectional PIM Rendezvous Point
            	**type**\:   :py:class:`BidirRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.BidirRpAddresses>`
            
            .. attribute:: bsr
            
            	PIM BSR configuration
            	**type**\:   :py:class:`Bsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Bsr>`
            
            .. attribute:: convergence
            
            	Configure convergence parameters
            	**type**\:   :py:class:`Convergence <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Convergence>`
            
            .. attribute:: embedded_rp_addresses
            
            	Set Embedded RP processing support
            	**type**\:   :py:class:`EmbeddedRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.EmbeddedRpAddresses>`
            
            .. attribute:: embedded_rp_disable
            
            	Set Embedded RP processing support
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: inheritable_defaults
            
            	Inheritable defaults
            	**type**\:   :py:class:`InheritableDefaults <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.InheritableDefaults>`
            
            .. attribute:: interfaces
            
            	Interface\-level Configuration
            	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Interfaces>`
            
            .. attribute:: log_neighbor_changes
            
            	PIM neighbor state change logging is turned on if configured
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: maximum
            
            	Configure PIM State Limits
            	**type**\:   :py:class:`Maximum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum>`
            
            .. attribute:: multipath
            
            	Enable equal\-cost multipath routing
            	**type**\:   :py:class:`PimMultipath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimMultipath>`
            
            .. attribute:: neighbor_check_on_receive
            
            	Enable PIM neighbor checking when receiving PIM messages
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: neighbor_check_on_send
            
            	Enable PIM neighbor checking when sending join\-prunes
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: neighbor_filter
            
            	Access\-list of neighbors to be filtered
            	**type**\:  str
            
            	**length:** 1..64
            
            .. attribute:: nsf
            
            	Configure Non\-stop forwarding (NSF) options
            	**type**\:   :py:class:`Nsf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Nsf>`
            
            .. attribute:: old_register_checksum
            
            	Generate registers compatible with older IOS versions
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: register_source
            
            	Source address to use for register messages
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: rp_static_deny
            
            	Configure static RP deny range
            	**type**\:  str
            
            	**length:** 1..64
            
            .. attribute:: rpf
            
            	Configure RPF options
            	**type**\:   :py:class:`Rpf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Rpf>`
            
            .. attribute:: rpf_vector_enable
            
            	Enable PIM RPF Vector Proxy's
            	**type**\:   :py:class:`RpfVectorEnable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.RpfVectorEnable>`
            
            	**presence node**\: True
            
            .. attribute:: sg_expiry_timer
            
            	Configure expiry timer for S,G routes
            	**type**\:   :py:class:`SgExpiryTimer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.SgExpiryTimer>`
            
            .. attribute:: sparse_mode_rp_addresses
            
            	Configure Sparse\-Mode Rendezvous Point
            	**type**\:   :py:class:`SparseModeRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.SparseModeRpAddresses>`
            
            .. attribute:: spt_threshold_infinity
            
            	Configure threshold of infinity for switching to SPT on last\-hop
            	**type**\:  str
            
            .. attribute:: ssm
            
            	Configure IP Multicast SSM
            	**type**\:   :py:class:`Ssm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Ssm>`
            
            .. attribute:: ssm_allow_override
            
            	Allow SSM ranges to be overridden by more specific ranges
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: suppress_data_registers
            
            	Suppress data registers after initial state setup
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: suppress_rpf_prunes
            
            	Suppress prunes triggered as a result of RPF changes
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ipv4-pim-cfg'
            _revision = '2016-06-01'

            def __init__(self):
                super(Pim.DefaultContext.Ipv6, self).__init__()

                self.yang_name = "ipv6"
                self.yang_parent_name = "default-context"

                self.accept_register = YLeaf(YType.str, "accept-register")

                self.embedded_rp_disable = YLeaf(YType.empty, "embedded-rp-disable")

                self.log_neighbor_changes = YLeaf(YType.empty, "log-neighbor-changes")

                self.multipath = YLeaf(YType.enumeration, "multipath")

                self.neighbor_check_on_receive = YLeaf(YType.empty, "neighbor-check-on-receive")

                self.neighbor_check_on_send = YLeaf(YType.empty, "neighbor-check-on-send")

                self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                self.old_register_checksum = YLeaf(YType.empty, "old-register-checksum")

                self.register_source = YLeaf(YType.str, "register-source")

                self.rp_static_deny = YLeaf(YType.str, "rp-static-deny")

                self.spt_threshold_infinity = YLeaf(YType.str, "spt-threshold-infinity")

                self.ssm_allow_override = YLeaf(YType.empty, "ssm-allow-override")

                self.suppress_data_registers = YLeaf(YType.empty, "suppress-data-registers")

                self.suppress_rpf_prunes = YLeaf(YType.empty, "suppress-rpf-prunes")

                self.allow_rp = None
                self._children_name_map["allow_rp"] = "allow-rp"
                self._children_yang_names.add("allow-rp")

                self.bidir_rp_addresses = Pim.DefaultContext.Ipv6.BidirRpAddresses()
                self.bidir_rp_addresses.parent = self
                self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                self._children_yang_names.add("bidir-rp-addresses")

                self.bsr = Pim.DefaultContext.Ipv6.Bsr()
                self.bsr.parent = self
                self._children_name_map["bsr"] = "bsr"
                self._children_yang_names.add("bsr")

                self.convergence = Pim.DefaultContext.Ipv6.Convergence()
                self.convergence.parent = self
                self._children_name_map["convergence"] = "convergence"
                self._children_yang_names.add("convergence")

                self.embedded_rp_addresses = Pim.DefaultContext.Ipv6.EmbeddedRpAddresses()
                self.embedded_rp_addresses.parent = self
                self._children_name_map["embedded_rp_addresses"] = "embedded-rp-addresses"
                self._children_yang_names.add("embedded-rp-addresses")

                self.inheritable_defaults = Pim.DefaultContext.Ipv6.InheritableDefaults()
                self.inheritable_defaults.parent = self
                self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                self._children_yang_names.add("inheritable-defaults")

                self.interfaces = Pim.DefaultContext.Ipv6.Interfaces()
                self.interfaces.parent = self
                self._children_name_map["interfaces"] = "interfaces"
                self._children_yang_names.add("interfaces")

                self.maximum = Pim.DefaultContext.Ipv6.Maximum()
                self.maximum.parent = self
                self._children_name_map["maximum"] = "maximum"
                self._children_yang_names.add("maximum")

                self.nsf = Pim.DefaultContext.Ipv6.Nsf()
                self.nsf.parent = self
                self._children_name_map["nsf"] = "nsf"
                self._children_yang_names.add("nsf")

                self.rpf = Pim.DefaultContext.Ipv6.Rpf()
                self.rpf.parent = self
                self._children_name_map["rpf"] = "rpf"
                self._children_yang_names.add("rpf")

                self.rpf_vector_enable = None
                self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                self._children_yang_names.add("rpf-vector-enable")

                self.sg_expiry_timer = Pim.DefaultContext.Ipv6.SgExpiryTimer()
                self.sg_expiry_timer.parent = self
                self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                self._children_yang_names.add("sg-expiry-timer")

                self.sparse_mode_rp_addresses = Pim.DefaultContext.Ipv6.SparseModeRpAddresses()
                self.sparse_mode_rp_addresses.parent = self
                self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                self._children_yang_names.add("sparse-mode-rp-addresses")

                self.ssm = Pim.DefaultContext.Ipv6.Ssm()
                self.ssm.parent = self
                self._children_name_map["ssm"] = "ssm"
                self._children_yang_names.add("ssm")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("accept_register",
                                "embedded_rp_disable",
                                "log_neighbor_changes",
                                "multipath",
                                "neighbor_check_on_receive",
                                "neighbor_check_on_send",
                                "neighbor_filter",
                                "old_register_checksum",
                                "register_source",
                                "rp_static_deny",
                                "spt_threshold_infinity",
                                "ssm_allow_override",
                                "suppress_data_registers",
                                "suppress_rpf_prunes") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pim.DefaultContext.Ipv6, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pim.DefaultContext.Ipv6, self).__setattr__(name, value)


            class Interfaces(Entity):
                """
                Interface\-level Configuration
                
                .. attribute:: interface
                
                	The name of the interface
                	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Interfaces.Interface>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.Interfaces, self).__init__()

                    self.yang_name = "interfaces"
                    self.yang_parent_name = "ipv6"

                    self.interface = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.Interfaces, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.Interfaces, self).__setattr__(name, value)


                class Interface(Entity):
                    """
                    The name of the interface
                    
                    .. attribute:: interface_name  <key>
                    
                    	The name of interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: bfd
                    
                    	BFD configuration
                    	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Interfaces.Interface.Bfd>`
                    
                    .. attribute:: bsr_border
                    
                    	BSR Border configuration for Interface
                    	**type**\:  bool
                    
                    .. attribute:: dr_priority
                    
                    	Hello DR priority, preference given to larger value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: enable
                    
                    	Enter PIM Interface processing
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: hello_interval
                    
                    	Hello interval in seconds
                    	**type**\:  int
                    
                    	**range:** 1..3600
                    
                    	**units**\: second
                    
                    .. attribute:: interface_enable
                    
                    	Enable PIM processing on the interface
                    	**type**\:  bool
                    
                    .. attribute:: join_prune_mtu
                    
                    	Join\-Prune MTU in Bytes
                    	**type**\:  int
                    
                    	**range:** 576..65535
                    
                    	**units**\: byte
                    
                    .. attribute:: jp_interval
                    
                    	Join\-Prune interval in seconds
                    	**type**\:  int
                    
                    	**range:** 10..600
                    
                    	**units**\: second
                    
                    .. attribute:: maximum_routes
                    
                    	Maximum number of allowed routes for this interface
                    	**type**\:   :py:class:`MaximumRoutes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Interfaces.Interface.MaximumRoutes>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: neighbor_filter
                    
                    	Access\-list of neighbors to be filtered
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: override_interval
                    
                    	Override interval in milliseconds
                    	**type**\:  int
                    
                    	**range:** 400..65535
                    
                    	**units**\: millisecond
                    
                    .. attribute:: propagation_delay
                    
                    	Propagation delay in milli seconds
                    	**type**\:  int
                    
                    	**range:** 100..32767
                    
                    	**units**\: millisecond
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Interfaces.Interface, self).__init__()

                        self.yang_name = "interface"
                        self.yang_parent_name = "interfaces"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.bsr_border = YLeaf(YType.boolean, "bsr-border")

                        self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                        self.interface_enable = YLeaf(YType.boolean, "interface-enable")

                        self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                        self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                        self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                        self.override_interval = YLeaf(YType.uint32, "override-interval")

                        self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                        self.bfd = Pim.DefaultContext.Ipv6.Interfaces.Interface.Bfd()
                        self.bfd.parent = self
                        self._children_name_map["bfd"] = "bfd"
                        self._children_yang_names.add("bfd")

                        self.maximum_routes = None
                        self._children_name_map["maximum_routes"] = "maximum-routes"
                        self._children_yang_names.add("maximum-routes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name",
                                        "bsr_border",
                                        "dr_priority",
                                        "enable",
                                        "hello_interval",
                                        "interface_enable",
                                        "join_prune_mtu",
                                        "jp_interval",
                                        "neighbor_filter",
                                        "override_interval",
                                        "propagation_delay") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Interfaces.Interface, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Interfaces.Interface, self).__setattr__(name, value)


                    class MaximumRoutes(Entity):
                        """
                        Maximum number of allowed routes for this
                        interface
                        
                        .. attribute:: access_list_name
                        
                        	Access\-list to account for
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: maximum
                        
                        	Maximum number of routes for this interface
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.DefaultContext.Ipv6.Interfaces.Interface.MaximumRoutes, self).__init__()

                            self.yang_name = "maximum-routes"
                            self.yang_parent_name = "interface"
                            self.is_presence_container = True

                            self.access_list_name = YLeaf(YType.str, "access-list-name")

                            self.maximum = YLeaf(YType.uint32, "maximum")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("access_list_name",
                                            "maximum",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.DefaultContext.Ipv6.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.DefaultContext.Ipv6.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.access_list_name.is_set or
                                self.maximum.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.access_list_name.yfilter != YFilter.not_set or
                                self.maximum.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "maximum-routes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.access_list_name.get_name_leafdata())
                            if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "access-list-name" or name == "maximum" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "access-list-name"):
                                self.access_list_name = value
                                self.access_list_name.value_namespace = name_space
                                self.access_list_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "maximum"):
                                self.maximum = value
                                self.maximum.value_namespace = name_space
                                self.maximum.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class Bfd(Entity):
                        """
                        BFD configuration
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection multiplier for BFD sessions created by PIM
                        	**type**\:  int
                        
                        	**range:** 2..50
                        
                        .. attribute:: enable
                        
                        	TRUE to enable BFD. FALSE to disable and to prevent inheritance from a parent
                        	**type**\:  bool
                        
                        .. attribute:: interval
                        
                        	Hello interval for BFD sessions created by PIM
                        	**type**\:  int
                        
                        	**range:** 3..30000
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.DefaultContext.Ipv6.Interfaces.Interface.Bfd, self).__init__()

                            self.yang_name = "bfd"
                            self.yang_parent_name = "interface"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.interval = YLeaf(YType.uint32, "interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "enable",
                                            "interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.DefaultContext.Ipv6.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.DefaultContext.Ipv6.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.enable.is_set or
                                self.interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfd" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "enable" or name == "interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "interval"):
                                self.interval = value
                                self.interval.value_namespace = name_space
                                self.interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            self.bsr_border.is_set or
                            self.dr_priority.is_set or
                            self.enable.is_set or
                            self.hello_interval.is_set or
                            self.interface_enable.is_set or
                            self.join_prune_mtu.is_set or
                            self.jp_interval.is_set or
                            self.neighbor_filter.is_set or
                            self.override_interval.is_set or
                            self.propagation_delay.is_set or
                            (self.bfd is not None and self.bfd.has_data()) or
                            (self.maximum_routes is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.bsr_border.yfilter != YFilter.not_set or
                            self.dr_priority.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.hello_interval.yfilter != YFilter.not_set or
                            self.interface_enable.yfilter != YFilter.not_set or
                            self.join_prune_mtu.yfilter != YFilter.not_set or
                            self.jp_interval.yfilter != YFilter.not_set or
                            self.neighbor_filter.yfilter != YFilter.not_set or
                            self.override_interval.yfilter != YFilter.not_set or
                            self.propagation_delay.yfilter != YFilter.not_set or
                            (self.bfd is not None and self.bfd.has_operation()) or
                            (self.maximum_routes is not None and self.maximum_routes.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/interfaces/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.bsr_border.is_set or self.bsr_border.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_border.get_name_leafdata())
                        if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dr_priority.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                        if (self.interface_enable.is_set or self.interface_enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_enable.get_name_leafdata())
                        if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                        if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.jp_interval.get_name_leafdata())
                        if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                        if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.override_interval.get_name_leafdata())
                        if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfd"):
                            if (self.bfd is None):
                                self.bfd = Pim.DefaultContext.Ipv6.Interfaces.Interface.Bfd()
                                self.bfd.parent = self
                                self._children_name_map["bfd"] = "bfd"
                            return self.bfd

                        if (child_yang_name == "maximum-routes"):
                            if (self.maximum_routes is None):
                                self.maximum_routes = Pim.DefaultContext.Ipv6.Interfaces.Interface.MaximumRoutes()
                                self.maximum_routes.parent = self
                                self._children_name_map["maximum_routes"] = "maximum-routes"
                            return self.maximum_routes

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfd" or name == "maximum-routes" or name == "interface-name" or name == "bsr-border" or name == "dr-priority" or name == "enable" or name == "hello-interval" or name == "interface-enable" or name == "join-prune-mtu" or name == "jp-interval" or name == "neighbor-filter" or name == "override-interval" or name == "propagation-delay"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "bsr-border"):
                            self.bsr_border = value
                            self.bsr_border.value_namespace = name_space
                            self.bsr_border.value_namespace_prefix = name_space_prefix
                        if(value_path == "dr-priority"):
                            self.dr_priority = value
                            self.dr_priority.value_namespace = name_space
                            self.dr_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "hello-interval"):
                            self.hello_interval = value
                            self.hello_interval.value_namespace = name_space
                            self.hello_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-enable"):
                            self.interface_enable = value
                            self.interface_enable.value_namespace = name_space
                            self.interface_enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "join-prune-mtu"):
                            self.join_prune_mtu = value
                            self.join_prune_mtu.value_namespace = name_space
                            self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                        if(value_path == "jp-interval"):
                            self.jp_interval = value
                            self.jp_interval.value_namespace = name_space
                            self.jp_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "neighbor-filter"):
                            self.neighbor_filter = value
                            self.neighbor_filter.value_namespace = name_space
                            self.neighbor_filter.value_namespace_prefix = name_space_prefix
                        if(value_path == "override-interval"):
                            self.override_interval = value
                            self.override_interval.value_namespace = name_space
                            self.override_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "propagation-delay"):
                            self.propagation_delay = value
                            self.propagation_delay.value_namespace = name_space
                            self.propagation_delay.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.interface:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.interface:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interfaces" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface"):
                        for c in self.interface:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv6.Interfaces.Interface()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.interface.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class SparseModeRpAddresses(Entity):
                """
                Configure Sparse\-Mode Rendezvous Point
                
                .. attribute:: sparse_mode_rp_address
                
                	Address of the Rendezvous Point
                	**type**\: list of    :py:class:`SparseModeRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.SparseModeRpAddresses.SparseModeRpAddress>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.SparseModeRpAddresses, self).__init__()

                    self.yang_name = "sparse-mode-rp-addresses"
                    self.yang_parent_name = "ipv6"

                    self.sparse_mode_rp_address = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.SparseModeRpAddresses, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.SparseModeRpAddresses, self).__setattr__(name, value)


                class SparseModeRpAddress(Entity):
                    """
                    Address of the Rendezvous Point
                    
                    .. attribute:: rp_address  <key>
                    
                    	RP address of Rendezvous Point
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: access_list_name
                    
                    	Access list of groups that should map to a  given RP
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: auto_rp_override
                    
                    	TRUE Indicates if static RP config overrides AutoRP and BSR
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.SparseModeRpAddresses.SparseModeRpAddress, self).__init__()

                        self.yang_name = "sparse-mode-rp-address"
                        self.yang_parent_name = "sparse-mode-rp-addresses"

                        self.rp_address = YLeaf(YType.str, "rp-address")

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                        self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("rp_address",
                                        "access_list_name",
                                        "auto_rp_override") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.rp_address.is_set or
                            self.access_list_name.is_set or
                            self.auto_rp_override.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.rp_address.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set or
                            self.auto_rp_override.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sparse-mode-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/sparse-mode-rp-addresses/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rp_address.get_name_leafdata())
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())
                        if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "rp-address"):
                            self.rp_address = value
                            self.rp_address.value_namespace = name_space
                            self.rp_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "auto-rp-override"):
                            self.auto_rp_override = value
                            self.auto_rp_override.value_namespace = name_space
                            self.auto_rp_override.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.sparse_mode_rp_address:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.sparse_mode_rp_address:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "sparse-mode-rp-addresses" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "sparse-mode-rp-address"):
                        for c in self.sparse_mode_rp_address:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv6.SparseModeRpAddresses.SparseModeRpAddress()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.sparse_mode_rp_address.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "sparse-mode-rp-address"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class InheritableDefaults(Entity):
                """
                Inheritable defaults
                
                .. attribute:: convergency
                
                	Convergency timeout in seconds
                	**type**\:  int
                
                	**range:** 1800..2400
                
                	**units**\: second
                
                .. attribute:: dr_priority
                
                	Hello DR priority, preference given to larger value
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_interval
                
                	Hello interval in seconds
                	**type**\:  int
                
                	**range:** 1..3600
                
                	**units**\: second
                
                .. attribute:: join_prune_mtu
                
                	Join\-Prune MTU in Bytes
                	**type**\:  int
                
                	**range:** 576..65535
                
                	**units**\: byte
                
                .. attribute:: jp_interval
                
                	Join\-Prune interval in seconds
                	**type**\:  int
                
                	**range:** 10..600
                
                	**units**\: second
                
                .. attribute:: override_interval
                
                	Override interval in milliseconds
                	**type**\:  int
                
                	**range:** 400..65535
                
                	**units**\: millisecond
                
                .. attribute:: propagation_delay
                
                	Propagation delay in milli seconds
                	**type**\:  int
                
                	**range:** 100..32767
                
                	**units**\: millisecond
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.InheritableDefaults, self).__init__()

                    self.yang_name = "inheritable-defaults"
                    self.yang_parent_name = "ipv6"

                    self.convergency = YLeaf(YType.uint32, "convergency")

                    self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                    self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                    self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                    self.override_interval = YLeaf(YType.uint32, "override-interval")

                    self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("convergency",
                                    "dr_priority",
                                    "hello_interval",
                                    "join_prune_mtu",
                                    "jp_interval",
                                    "override_interval",
                                    "propagation_delay") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.InheritableDefaults, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.InheritableDefaults, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.convergency.is_set or
                        self.dr_priority.is_set or
                        self.hello_interval.is_set or
                        self.join_prune_mtu.is_set or
                        self.jp_interval.is_set or
                        self.override_interval.is_set or
                        self.propagation_delay.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.convergency.yfilter != YFilter.not_set or
                        self.dr_priority.yfilter != YFilter.not_set or
                        self.hello_interval.yfilter != YFilter.not_set or
                        self.join_prune_mtu.yfilter != YFilter.not_set or
                        self.jp_interval.yfilter != YFilter.not_set or
                        self.override_interval.yfilter != YFilter.not_set or
                        self.propagation_delay.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "inheritable-defaults" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.convergency.is_set or self.convergency.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.convergency.get_name_leafdata())
                    if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.dr_priority.get_name_leafdata())
                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                    if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                    if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.jp_interval.get_name_leafdata())
                    if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.override_interval.get_name_leafdata())
                    if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "convergency" or name == "dr-priority" or name == "hello-interval" or name == "join-prune-mtu" or name == "jp-interval" or name == "override-interval" or name == "propagation-delay"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "convergency"):
                        self.convergency = value
                        self.convergency.value_namespace = name_space
                        self.convergency.value_namespace_prefix = name_space_prefix
                    if(value_path == "dr-priority"):
                        self.dr_priority = value
                        self.dr_priority.value_namespace = name_space
                        self.dr_priority.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-interval"):
                        self.hello_interval = value
                        self.hello_interval.value_namespace = name_space
                        self.hello_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "join-prune-mtu"):
                        self.join_prune_mtu = value
                        self.join_prune_mtu.value_namespace = name_space
                        self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                    if(value_path == "jp-interval"):
                        self.jp_interval = value
                        self.jp_interval.value_namespace = name_space
                        self.jp_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "override-interval"):
                        self.override_interval = value
                        self.override_interval.value_namespace = name_space
                        self.override_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "propagation-delay"):
                        self.propagation_delay = value
                        self.propagation_delay.value_namespace = name_space
                        self.propagation_delay.value_namespace_prefix = name_space_prefix


            class Rpf(Entity):
                """
                Configure RPF options
                
                .. attribute:: route_policy
                
                	Route policy to select RPF topology
                	**type**\:  str
                
                	**length:** 1..64
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.Rpf, self).__init__()

                    self.yang_name = "rpf"
                    self.yang_parent_name = "ipv6"

                    self.route_policy = YLeaf(YType.str, "route-policy")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("route_policy") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.Rpf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.Rpf, self).__setattr__(name, value)

                def has_data(self):
                    return self.route_policy.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.route_policy.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rpf" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.route_policy.is_set or self.route_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_policy.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "route-policy"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "route-policy"):
                        self.route_policy = value
                        self.route_policy.value_namespace = name_space
                        self.route_policy.value_namespace_prefix = name_space_prefix


            class SgExpiryTimer(Entity):
                """
                Configure expiry timer for S,G routes
                
                .. attribute:: access_list_name
                
                	Access\-list of applicable S,G routes
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: interval
                
                	(S,G) expiry time in seconds
                	**type**\:  int
                
                	**range:** 40..57600
                
                	**units**\: second
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.SgExpiryTimer, self).__init__()

                    self.yang_name = "sg-expiry-timer"
                    self.yang_parent_name = "ipv6"

                    self.access_list_name = YLeaf(YType.str, "access-list-name")

                    self.interval = YLeaf(YType.uint32, "interval")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("access_list_name",
                                    "interval") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.SgExpiryTimer, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.SgExpiryTimer, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.access_list_name.is_set or
                        self.interval.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.access_list_name.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "sg-expiry-timer" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.access_list_name.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "access-list-name" or name == "interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "access-list-name"):
                        self.access_list_name = value
                        self.access_list_name.value_namespace = name_space
                        self.access_list_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix


            class RpfVectorEnable(Entity):
                """
                Enable PIM RPF Vector Proxy's
                
                .. attribute:: allow_ebgp
                
                	Allow RPF Vector origination over eBGP sessions
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: disable_ibgp
                
                	Disable RPF Vector origination over iBGP sessions
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: enable
                
                	RPF Vector is turned on if configured
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                	**mandatory**\: True
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.RpfVectorEnable, self).__init__()

                    self.yang_name = "rpf-vector-enable"
                    self.yang_parent_name = "ipv6"
                    self.is_presence_container = True

                    self.allow_ebgp = YLeaf(YType.empty, "allow-ebgp")

                    self.disable_ibgp = YLeaf(YType.empty, "disable-ibgp")

                    self.enable = YLeaf(YType.empty, "enable")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("allow_ebgp",
                                    "disable_ibgp",
                                    "enable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.RpfVectorEnable, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.RpfVectorEnable, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.allow_ebgp.is_set or
                        self.disable_ibgp.is_set or
                        self.enable.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.allow_ebgp.yfilter != YFilter.not_set or
                        self.disable_ibgp.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rpf-vector-enable" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.allow_ebgp.is_set or self.allow_ebgp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.allow_ebgp.get_name_leafdata())
                    if (self.disable_ibgp.is_set or self.disable_ibgp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disable_ibgp.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "allow-ebgp" or name == "disable-ibgp" or name == "enable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "allow-ebgp"):
                        self.allow_ebgp = value
                        self.allow_ebgp.value_namespace = name_space
                        self.allow_ebgp.value_namespace_prefix = name_space_prefix
                    if(value_path == "disable-ibgp"):
                        self.disable_ibgp = value
                        self.disable_ibgp.value_namespace = name_space
                        self.disable_ibgp.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix


            class Nsf(Entity):
                """
                Configure Non\-stop forwarding (NSF) options
                
                .. attribute:: lifetime
                
                	Override default maximum lifetime for PIM NSF mode
                	**type**\:  int
                
                	**range:** 10..600
                
                	**units**\: second
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.Nsf, self).__init__()

                    self.yang_name = "nsf"
                    self.yang_parent_name = "ipv6"

                    self.lifetime = YLeaf(YType.uint32, "lifetime")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lifetime") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.Nsf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.Nsf, self).__setattr__(name, value)

                def has_data(self):
                    return self.lifetime.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lifetime.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nsf" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lifetime.is_set or self.lifetime.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lifetime.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lifetime"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lifetime"):
                        self.lifetime = value
                        self.lifetime.value_namespace = name_space
                        self.lifetime.value_namespace_prefix = name_space_prefix


            class Maximum(Entity):
                """
                Configure PIM State Limits
                
                .. attribute:: bsr_candidate_rp_cache
                
                	Override default maximum and threshold for BSR C\-RP cache setting
                	**type**\:   :py:class:`BsrCandidateRpCache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.BsrCandidateRpCache>`
                
                	**presence node**\: True
                
                .. attribute:: bsr_global_candidate_rp_cache
                
                	Override default global maximum and threshold for C\-RP set in BSR
                	**type**\:   :py:class:`BsrGlobalCandidateRpCache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.BsrGlobalCandidateRpCache>`
                
                	**presence node**\: True
                
                .. attribute:: bsr_global_group_mappings
                
                	Override default global maximum and threshold for PIM group mapping ranges from BSR
                	**type**\:   :py:class:`BsrGlobalGroupMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.BsrGlobalGroupMappings>`
                
                	**presence node**\: True
                
                .. attribute:: bsr_group_mappings
                
                	Override default maximum and threshold for number of group mappings from BSR
                	**type**\:   :py:class:`BsrGroupMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.BsrGroupMappings>`
                
                	**presence node**\: True
                
                .. attribute:: global_group_mappings_auto_rp
                
                	Maximum for number of group mappings from autorp mapping agent
                	**type**\:   :py:class:`GlobalGroupMappingsAutoRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.GlobalGroupMappingsAutoRp>`
                
                	**presence node**\: True
                
                .. attribute:: global_high_priority_packet_queue
                
                	Maximum packet queue size in bytes
                	**type**\:  int
                
                	**range:** 0..2147483648
                
                	**units**\: byte
                
                .. attribute:: global_low_priority_packet_queue
                
                	Maximum packet queue size in bytes
                	**type**\:  int
                
                	**range:** 0..2147483648
                
                	**units**\: byte
                
                .. attribute:: global_register_states
                
                	Override default maximum for number of sparse\-mode source registers
                	**type**\:   :py:class:`GlobalRegisterStates <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.GlobalRegisterStates>`
                
                	**presence node**\: True
                
                .. attribute:: global_route_interfaces
                
                	Override default maximum for number of route\-interfaces
                	**type**\:   :py:class:`GlobalRouteInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.GlobalRouteInterfaces>`
                
                	**presence node**\: True
                
                .. attribute:: global_routes
                
                	Override default maximum for number of routes
                	**type**\:   :py:class:`GlobalRoutes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.GlobalRoutes>`
                
                	**presence node**\: True
                
                .. attribute:: group_mappings_auto_rp
                
                	Override default maximum for number of group mappings from autorp mapping agent
                	**type**\:   :py:class:`GroupMappingsAutoRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.GroupMappingsAutoRp>`
                
                	**presence node**\: True
                
                .. attribute:: register_states
                
                	Override default maximum for number of sparse\-mode source registers
                	**type**\:   :py:class:`RegisterStates <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.RegisterStates>`
                
                	**presence node**\: True
                
                .. attribute:: route_interfaces
                
                	Override default maximum for number of route\-interfaces
                	**type**\:   :py:class:`RouteInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.RouteInterfaces>`
                
                	**presence node**\: True
                
                .. attribute:: routes
                
                	Override default maximum for number of routes
                	**type**\:   :py:class:`Routes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Maximum.Routes>`
                
                	**presence node**\: True
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.Maximum, self).__init__()

                    self.yang_name = "maximum"
                    self.yang_parent_name = "ipv6"

                    self.global_high_priority_packet_queue = YLeaf(YType.uint32, "global-high-priority-packet-queue")

                    self.global_low_priority_packet_queue = YLeaf(YType.uint32, "global-low-priority-packet-queue")

                    self.bsr_candidate_rp_cache = None
                    self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                    self._children_yang_names.add("bsr-candidate-rp-cache")

                    self.bsr_global_candidate_rp_cache = None
                    self._children_name_map["bsr_global_candidate_rp_cache"] = "bsr-global-candidate-rp-cache"
                    self._children_yang_names.add("bsr-global-candidate-rp-cache")

                    self.bsr_global_group_mappings = None
                    self._children_name_map["bsr_global_group_mappings"] = "bsr-global-group-mappings"
                    self._children_yang_names.add("bsr-global-group-mappings")

                    self.bsr_group_mappings = None
                    self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                    self._children_yang_names.add("bsr-group-mappings")

                    self.global_group_mappings_auto_rp = None
                    self._children_name_map["global_group_mappings_auto_rp"] = "global-group-mappings-auto-rp"
                    self._children_yang_names.add("global-group-mappings-auto-rp")

                    self.global_register_states = None
                    self._children_name_map["global_register_states"] = "global-register-states"
                    self._children_yang_names.add("global-register-states")

                    self.global_route_interfaces = None
                    self._children_name_map["global_route_interfaces"] = "global-route-interfaces"
                    self._children_yang_names.add("global-route-interfaces")

                    self.global_routes = None
                    self._children_name_map["global_routes"] = "global-routes"
                    self._children_yang_names.add("global-routes")

                    self.group_mappings_auto_rp = None
                    self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                    self._children_yang_names.add("group-mappings-auto-rp")

                    self.register_states = None
                    self._children_name_map["register_states"] = "register-states"
                    self._children_yang_names.add("register-states")

                    self.route_interfaces = None
                    self._children_name_map["route_interfaces"] = "route-interfaces"
                    self._children_yang_names.add("route-interfaces")

                    self.routes = None
                    self._children_name_map["routes"] = "routes"
                    self._children_yang_names.add("routes")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("global_high_priority_packet_queue",
                                    "global_low_priority_packet_queue") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.Maximum, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.Maximum, self).__setattr__(name, value)


                class BsrGlobalGroupMappings(Entity):
                    """
                    Override default global maximum and threshold
                    for PIM group mapping ranges from BSR
                    
                    .. attribute:: bsr_maximum_global_group_mappings
                    
                    	Global Maximum number of PIM group mapping ranges from BSR
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 500
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.BsrGlobalGroupMappings, self).__init__()

                        self.yang_name = "bsr-global-group-mappings"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_global_group_mappings = YLeaf(YType.uint32, "bsr-maximum-global-group-mappings")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_global_group_mappings",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.BsrGlobalGroupMappings, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.BsrGlobalGroupMappings, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_global_group_mappings.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_global_group_mappings.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-global-group-mappings" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_global_group_mappings.is_set or self.bsr_maximum_global_group_mappings.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_global_group_mappings.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-global-group-mappings" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-global-group-mappings"):
                            self.bsr_maximum_global_group_mappings = value
                            self.bsr_maximum_global_group_mappings.value_namespace = name_space
                            self.bsr_maximum_global_group_mappings.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalRoutes(Entity):
                    """
                    Override default maximum for number of routes
                    
                    .. attribute:: maximum_routes
                    
                    	Maximum number of PIM routes
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**default value**\: 100000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.GlobalRoutes, self).__init__()

                        self.yang_name = "global-routes"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_routes = YLeaf(YType.uint32, "maximum-routes")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_routes",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.GlobalRoutes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.GlobalRoutes, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_routes.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_routes.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-routes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_routes.is_set or self.maximum_routes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_routes.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-routes" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-routes"):
                            self.maximum_routes = value
                            self.maximum_routes.value_namespace = name_space
                            self.maximum_routes.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalGroupMappingsAutoRp(Entity):
                    """
                    Maximum for number of group mappings from
                    autorp mapping agent
                    
                    .. attribute:: maximum_global_group_ranges_auto_rp
                    
                    	Maximum number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: threshold_global_group_ranges_auto_rp
                    
                    	Warning threshold number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 450
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.GlobalGroupMappingsAutoRp, self).__init__()

                        self.yang_name = "global-group-mappings-auto-rp"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_global_group_ranges_auto_rp = YLeaf(YType.uint32, "maximum-global-group-ranges-auto-rp")

                        self.threshold_global_group_ranges_auto_rp = YLeaf(YType.uint32, "threshold-global-group-ranges-auto-rp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_global_group_ranges_auto_rp",
                                        "threshold_global_group_ranges_auto_rp") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.GlobalGroupMappingsAutoRp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.GlobalGroupMappingsAutoRp, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_global_group_ranges_auto_rp.is_set or
                            self.threshold_global_group_ranges_auto_rp.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_global_group_ranges_auto_rp.yfilter != YFilter.not_set or
                            self.threshold_global_group_ranges_auto_rp.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-group-mappings-auto-rp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_global_group_ranges_auto_rp.is_set or self.maximum_global_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_global_group_ranges_auto_rp.get_name_leafdata())
                        if (self.threshold_global_group_ranges_auto_rp.is_set or self.threshold_global_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_global_group_ranges_auto_rp.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-global-group-ranges-auto-rp" or name == "threshold-global-group-ranges-auto-rp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-global-group-ranges-auto-rp"):
                            self.maximum_global_group_ranges_auto_rp = value
                            self.maximum_global_group_ranges_auto_rp.value_namespace = name_space
                            self.maximum_global_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold-global-group-ranges-auto-rp"):
                            self.threshold_global_group_ranges_auto_rp = value
                            self.threshold_global_group_ranges_auto_rp.value_namespace = name_space
                            self.threshold_global_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix


                class BsrGlobalCandidateRpCache(Entity):
                    """
                    Override default global maximum and threshold
                    for C\-RP set in BSR
                    
                    .. attribute:: bsr_maximum_global_candidate_rp_cache
                    
                    	Global Maximum number of PIM C\-RP Sets from BSR
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 100
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.BsrGlobalCandidateRpCache, self).__init__()

                        self.yang_name = "bsr-global-candidate-rp-cache"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_global_candidate_rp_cache = YLeaf(YType.uint32, "bsr-maximum-global-candidate-rp-cache")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_global_candidate_rp_cache",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.BsrGlobalCandidateRpCache, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.BsrGlobalCandidateRpCache, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_global_candidate_rp_cache.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_global_candidate_rp_cache.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-global-candidate-rp-cache" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_global_candidate_rp_cache.is_set or self.bsr_maximum_global_candidate_rp_cache.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_global_candidate_rp_cache.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-global-candidate-rp-cache" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-global-candidate-rp-cache"):
                            self.bsr_maximum_global_candidate_rp_cache = value
                            self.bsr_maximum_global_candidate_rp_cache.value_namespace = name_space
                            self.bsr_maximum_global_candidate_rp_cache.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalRegisterStates(Entity):
                    """
                    Override default maximum for number of
                    sparse\-mode source registers
                    
                    .. attribute:: maximum_register_states
                    
                    	Maximum number of PIM Sparse\-Mode register states
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**default value**\: 20000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.GlobalRegisterStates, self).__init__()

                        self.yang_name = "global-register-states"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_register_states = YLeaf(YType.uint32, "maximum-register-states")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_register_states",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.GlobalRegisterStates, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.GlobalRegisterStates, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_register_states.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_register_states.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-register-states" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_register_states.is_set or self.maximum_register_states.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_register_states.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-register-states" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-register-states"):
                            self.maximum_register_states = value
                            self.maximum_register_states.value_namespace = name_space
                            self.maximum_register_states.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalRouteInterfaces(Entity):
                    """
                    Override default maximum for number of
                    route\-interfaces
                    
                    .. attribute:: maximum_route_interfaces
                    
                    	Maximum number of PIM route\-interfaces
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**default value**\: 300000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.GlobalRouteInterfaces, self).__init__()

                        self.yang_name = "global-route-interfaces"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_route_interfaces = YLeaf(YType.uint32, "maximum-route-interfaces")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_route_interfaces",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.GlobalRouteInterfaces, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.GlobalRouteInterfaces, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_route_interfaces.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_route_interfaces.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-route-interfaces" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_route_interfaces.is_set or self.maximum_route_interfaces.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_route_interfaces.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-route-interfaces" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-route-interfaces"):
                            self.maximum_route_interfaces = value
                            self.maximum_route_interfaces.value_namespace = name_space
                            self.maximum_route_interfaces.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GroupMappingsAutoRp(Entity):
                    """
                    Override default maximum for number of group
                    mappings from autorp mapping agent
                    
                    .. attribute:: maximum_group_ranges_auto_rp
                    
                    	Maximum number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: threshold_group_ranges_auto_rp
                    
                    	Warning threshold number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 450
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.GroupMappingsAutoRp, self).__init__()

                        self.yang_name = "group-mappings-auto-rp"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_group_ranges_auto_rp = YLeaf(YType.uint32, "maximum-group-ranges-auto-rp")

                        self.threshold_group_ranges_auto_rp = YLeaf(YType.uint32, "threshold-group-ranges-auto-rp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_group_ranges_auto_rp",
                                        "threshold_group_ranges_auto_rp") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_group_ranges_auto_rp.is_set or
                            self.threshold_group_ranges_auto_rp.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set or
                            self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "group-mappings-auto-rp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_group_ranges_auto_rp.is_set or self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_group_ranges_auto_rp.get_name_leafdata())
                        if (self.threshold_group_ranges_auto_rp.is_set or self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_group_ranges_auto_rp.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-group-ranges-auto-rp" or name == "threshold-group-ranges-auto-rp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-group-ranges-auto-rp"):
                            self.maximum_group_ranges_auto_rp = value
                            self.maximum_group_ranges_auto_rp.value_namespace = name_space
                            self.maximum_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold-group-ranges-auto-rp"):
                            self.threshold_group_ranges_auto_rp = value
                            self.threshold_group_ranges_auto_rp.value_namespace = name_space
                            self.threshold_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix


                class BsrGroupMappings(Entity):
                    """
                    Override default maximum and threshold for
                    number of group mappings from BSR
                    
                    .. attribute:: bsr_maximum_group_ranges
                    
                    	Maximum number of PIM group mappings from BSR
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 500
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.BsrGroupMappings, self).__init__()

                        self.yang_name = "bsr-group-mappings"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_group_ranges = YLeaf(YType.uint32, "bsr-maximum-group-ranges")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_group_ranges",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.BsrGroupMappings, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.BsrGroupMappings, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_group_ranges.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_group_ranges.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-group-mappings" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_group_ranges.is_set or self.bsr_maximum_group_ranges.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_group_ranges.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-group-ranges" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-group-ranges"):
                            self.bsr_maximum_group_ranges = value
                            self.bsr_maximum_group_ranges.value_namespace = name_space
                            self.bsr_maximum_group_ranges.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class RegisterStates(Entity):
                    """
                    Override default maximum for number of
                    sparse\-mode source registers
                    
                    .. attribute:: maximum_register_states
                    
                    	Maximum number of PIM Sparse\-Mode register states
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**default value**\: 20000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.RegisterStates, self).__init__()

                        self.yang_name = "register-states"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_register_states = YLeaf(YType.uint32, "maximum-register-states")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_register_states",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.RegisterStates, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.RegisterStates, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_register_states.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_register_states.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "register-states" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_register_states.is_set or self.maximum_register_states.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_register_states.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-register-states" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-register-states"):
                            self.maximum_register_states = value
                            self.maximum_register_states.value_namespace = name_space
                            self.maximum_register_states.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class RouteInterfaces(Entity):
                    """
                    Override default maximum for number of
                    route\-interfaces
                    
                    .. attribute:: maximum_route_interfaces
                    
                    	Maximum number of PIM route\-interfaces
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**default value**\: 300000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.RouteInterfaces, self).__init__()

                        self.yang_name = "route-interfaces"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_route_interfaces = YLeaf(YType.uint32, "maximum-route-interfaces")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_route_interfaces",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.RouteInterfaces, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.RouteInterfaces, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_route_interfaces.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_route_interfaces.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "route-interfaces" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_route_interfaces.is_set or self.maximum_route_interfaces.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_route_interfaces.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-route-interfaces" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-route-interfaces"):
                            self.maximum_route_interfaces = value
                            self.maximum_route_interfaces.value_namespace = name_space
                            self.maximum_route_interfaces.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class BsrCandidateRpCache(Entity):
                    """
                    Override default maximum and threshold for BSR
                    C\-RP cache setting
                    
                    .. attribute:: bsr_maximum_candidate_rp_cache
                    
                    	Maximum number of BSR C\-RP cache setting
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 100
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.BsrCandidateRpCache, self).__init__()

                        self.yang_name = "bsr-candidate-rp-cache"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_candidate_rp_cache = YLeaf(YType.uint32, "bsr-maximum-candidate-rp-cache")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_candidate_rp_cache",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_candidate_rp_cache.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-candidate-rp-cache" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_candidate_rp_cache.is_set or self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_candidate_rp_cache.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-candidate-rp-cache" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-candidate-rp-cache"):
                            self.bsr_maximum_candidate_rp_cache = value
                            self.bsr_maximum_candidate_rp_cache.value_namespace = name_space
                            self.bsr_maximum_candidate_rp_cache.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class Routes(Entity):
                    """
                    Override default maximum for number of routes
                    
                    .. attribute:: maximum_routes
                    
                    	Maximum number of PIM routes
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**default value**\: 100000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Maximum.Routes, self).__init__()

                        self.yang_name = "routes"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_routes = YLeaf(YType.uint32, "maximum-routes")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_routes",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Maximum.Routes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Maximum.Routes, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_routes.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_routes.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "routes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_routes.is_set or self.maximum_routes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_routes.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-routes" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-routes"):
                            self.maximum_routes = value
                            self.maximum_routes.value_namespace = name_space
                            self.maximum_routes.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.global_high_priority_packet_queue.is_set or
                        self.global_low_priority_packet_queue.is_set or
                        (self.bsr_candidate_rp_cache is not None) or
                        (self.bsr_global_candidate_rp_cache is not None) or
                        (self.bsr_global_group_mappings is not None) or
                        (self.bsr_group_mappings is not None) or
                        (self.global_group_mappings_auto_rp is not None) or
                        (self.global_register_states is not None) or
                        (self.global_route_interfaces is not None) or
                        (self.global_routes is not None) or
                        (self.group_mappings_auto_rp is not None) or
                        (self.register_states is not None) or
                        (self.route_interfaces is not None) or
                        (self.routes is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.global_high_priority_packet_queue.yfilter != YFilter.not_set or
                        self.global_low_priority_packet_queue.yfilter != YFilter.not_set or
                        (self.bsr_candidate_rp_cache is not None and self.bsr_candidate_rp_cache.has_operation()) or
                        (self.bsr_global_candidate_rp_cache is not None and self.bsr_global_candidate_rp_cache.has_operation()) or
                        (self.bsr_global_group_mappings is not None and self.bsr_global_group_mappings.has_operation()) or
                        (self.bsr_group_mappings is not None and self.bsr_group_mappings.has_operation()) or
                        (self.global_group_mappings_auto_rp is not None and self.global_group_mappings_auto_rp.has_operation()) or
                        (self.global_register_states is not None and self.global_register_states.has_operation()) or
                        (self.global_route_interfaces is not None and self.global_route_interfaces.has_operation()) or
                        (self.global_routes is not None and self.global_routes.has_operation()) or
                        (self.group_mappings_auto_rp is not None and self.group_mappings_auto_rp.has_operation()) or
                        (self.register_states is not None and self.register_states.has_operation()) or
                        (self.route_interfaces is not None and self.route_interfaces.has_operation()) or
                        (self.routes is not None and self.routes.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "maximum" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.global_high_priority_packet_queue.is_set or self.global_high_priority_packet_queue.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_high_priority_packet_queue.get_name_leafdata())
                    if (self.global_low_priority_packet_queue.is_set or self.global_low_priority_packet_queue.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_low_priority_packet_queue.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bsr-candidate-rp-cache"):
                        if (self.bsr_candidate_rp_cache is None):
                            self.bsr_candidate_rp_cache = Pim.DefaultContext.Ipv6.Maximum.BsrCandidateRpCache()
                            self.bsr_candidate_rp_cache.parent = self
                            self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                        return self.bsr_candidate_rp_cache

                    if (child_yang_name == "bsr-global-candidate-rp-cache"):
                        if (self.bsr_global_candidate_rp_cache is None):
                            self.bsr_global_candidate_rp_cache = Pim.DefaultContext.Ipv6.Maximum.BsrGlobalCandidateRpCache()
                            self.bsr_global_candidate_rp_cache.parent = self
                            self._children_name_map["bsr_global_candidate_rp_cache"] = "bsr-global-candidate-rp-cache"
                        return self.bsr_global_candidate_rp_cache

                    if (child_yang_name == "bsr-global-group-mappings"):
                        if (self.bsr_global_group_mappings is None):
                            self.bsr_global_group_mappings = Pim.DefaultContext.Ipv6.Maximum.BsrGlobalGroupMappings()
                            self.bsr_global_group_mappings.parent = self
                            self._children_name_map["bsr_global_group_mappings"] = "bsr-global-group-mappings"
                        return self.bsr_global_group_mappings

                    if (child_yang_name == "bsr-group-mappings"):
                        if (self.bsr_group_mappings is None):
                            self.bsr_group_mappings = Pim.DefaultContext.Ipv6.Maximum.BsrGroupMappings()
                            self.bsr_group_mappings.parent = self
                            self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                        return self.bsr_group_mappings

                    if (child_yang_name == "global-group-mappings-auto-rp"):
                        if (self.global_group_mappings_auto_rp is None):
                            self.global_group_mappings_auto_rp = Pim.DefaultContext.Ipv6.Maximum.GlobalGroupMappingsAutoRp()
                            self.global_group_mappings_auto_rp.parent = self
                            self._children_name_map["global_group_mappings_auto_rp"] = "global-group-mappings-auto-rp"
                        return self.global_group_mappings_auto_rp

                    if (child_yang_name == "global-register-states"):
                        if (self.global_register_states is None):
                            self.global_register_states = Pim.DefaultContext.Ipv6.Maximum.GlobalRegisterStates()
                            self.global_register_states.parent = self
                            self._children_name_map["global_register_states"] = "global-register-states"
                        return self.global_register_states

                    if (child_yang_name == "global-route-interfaces"):
                        if (self.global_route_interfaces is None):
                            self.global_route_interfaces = Pim.DefaultContext.Ipv6.Maximum.GlobalRouteInterfaces()
                            self.global_route_interfaces.parent = self
                            self._children_name_map["global_route_interfaces"] = "global-route-interfaces"
                        return self.global_route_interfaces

                    if (child_yang_name == "global-routes"):
                        if (self.global_routes is None):
                            self.global_routes = Pim.DefaultContext.Ipv6.Maximum.GlobalRoutes()
                            self.global_routes.parent = self
                            self._children_name_map["global_routes"] = "global-routes"
                        return self.global_routes

                    if (child_yang_name == "group-mappings-auto-rp"):
                        if (self.group_mappings_auto_rp is None):
                            self.group_mappings_auto_rp = Pim.DefaultContext.Ipv6.Maximum.GroupMappingsAutoRp()
                            self.group_mappings_auto_rp.parent = self
                            self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                        return self.group_mappings_auto_rp

                    if (child_yang_name == "register-states"):
                        if (self.register_states is None):
                            self.register_states = Pim.DefaultContext.Ipv6.Maximum.RegisterStates()
                            self.register_states.parent = self
                            self._children_name_map["register_states"] = "register-states"
                        return self.register_states

                    if (child_yang_name == "route-interfaces"):
                        if (self.route_interfaces is None):
                            self.route_interfaces = Pim.DefaultContext.Ipv6.Maximum.RouteInterfaces()
                            self.route_interfaces.parent = self
                            self._children_name_map["route_interfaces"] = "route-interfaces"
                        return self.route_interfaces

                    if (child_yang_name == "routes"):
                        if (self.routes is None):
                            self.routes = Pim.DefaultContext.Ipv6.Maximum.Routes()
                            self.routes.parent = self
                            self._children_name_map["routes"] = "routes"
                        return self.routes

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bsr-candidate-rp-cache" or name == "bsr-global-candidate-rp-cache" or name == "bsr-global-group-mappings" or name == "bsr-group-mappings" or name == "global-group-mappings-auto-rp" or name == "global-register-states" or name == "global-route-interfaces" or name == "global-routes" or name == "group-mappings-auto-rp" or name == "register-states" or name == "route-interfaces" or name == "routes" or name == "global-high-priority-packet-queue" or name == "global-low-priority-packet-queue"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "global-high-priority-packet-queue"):
                        self.global_high_priority_packet_queue = value
                        self.global_high_priority_packet_queue.value_namespace = name_space
                        self.global_high_priority_packet_queue.value_namespace_prefix = name_space_prefix
                    if(value_path == "global-low-priority-packet-queue"):
                        self.global_low_priority_packet_queue = value
                        self.global_low_priority_packet_queue.value_namespace = name_space
                        self.global_low_priority_packet_queue.value_namespace_prefix = name_space_prefix


            class Ssm(Entity):
                """
                Configure IP Multicast SSM
                
                .. attribute:: disable
                
                	TRUE if SSM is disabled on this router
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: range
                
                	Access list of groups enabled with SSM
                	**type**\:  str
                
                	**length:** 1..64
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.Ssm, self).__init__()

                    self.yang_name = "ssm"
                    self.yang_parent_name = "ipv6"

                    self.disable = YLeaf(YType.boolean, "disable")

                    self.range = YLeaf(YType.str, "range")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("disable",
                                    "range") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.Ssm, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.Ssm, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.disable.is_set or
                        self.range.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.disable.yfilter != YFilter.not_set or
                        self.range.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ssm" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disable.get_name_leafdata())
                    if (self.range.is_set or self.range.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.range.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "disable" or name == "range"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "disable"):
                        self.disable = value
                        self.disable.value_namespace = name_space
                        self.disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "range"):
                        self.range = value
                        self.range.value_namespace = name_space
                        self.range.value_namespace_prefix = name_space_prefix


            class BidirRpAddresses(Entity):
                """
                Configure Bidirectional PIM Rendezvous Point
                
                .. attribute:: bidir_rp_address
                
                	Address of the Rendezvous Point
                	**type**\: list of    :py:class:`BidirRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.BidirRpAddresses.BidirRpAddress>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.BidirRpAddresses, self).__init__()

                    self.yang_name = "bidir-rp-addresses"
                    self.yang_parent_name = "ipv6"

                    self.bidir_rp_address = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.BidirRpAddresses, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.BidirRpAddresses, self).__setattr__(name, value)


                class BidirRpAddress(Entity):
                    """
                    Address of the Rendezvous Point
                    
                    .. attribute:: rp_address  <key>
                    
                    	RP address of Rendezvous Point
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: access_list_name
                    
                    	Access list of groups that should map to a given RP
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: auto_rp_override
                    
                    	TRUE Indicates if static RP config overrides AutoRP and BSR
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.BidirRpAddresses.BidirRpAddress, self).__init__()

                        self.yang_name = "bidir-rp-address"
                        self.yang_parent_name = "bidir-rp-addresses"

                        self.rp_address = YLeaf(YType.str, "rp-address")

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                        self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("rp_address",
                                        "access_list_name",
                                        "auto_rp_override") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.rp_address.is_set or
                            self.access_list_name.is_set or
                            self.auto_rp_override.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.rp_address.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set or
                            self.auto_rp_override.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bidir-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/bidir-rp-addresses/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rp_address.get_name_leafdata())
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())
                        if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "rp-address"):
                            self.rp_address = value
                            self.rp_address.value_namespace = name_space
                            self.rp_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "auto-rp-override"):
                            self.auto_rp_override = value
                            self.auto_rp_override.value_namespace = name_space
                            self.auto_rp_override.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.bidir_rp_address:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.bidir_rp_address:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "bidir-rp-addresses" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bidir-rp-address"):
                        for c in self.bidir_rp_address:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv6.BidirRpAddresses.BidirRpAddress()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.bidir_rp_address.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bidir-rp-address"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Bsr(Entity):
                """
                PIM BSR configuration
                
                .. attribute:: candidate_bsr
                
                	PIM Candidate BSR configuration
                	**type**\:   :py:class:`CandidateBsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Bsr.CandidateBsr>`
                
                	**presence node**\: True
                
                .. attribute:: candidate_rps
                
                	PIM RP configuration
                	**type**\:   :py:class:`CandidateRps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Bsr.CandidateRps>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.Bsr, self).__init__()

                    self.yang_name = "bsr"
                    self.yang_parent_name = "ipv6"

                    self.candidate_bsr = None
                    self._children_name_map["candidate_bsr"] = "candidate-bsr"
                    self._children_yang_names.add("candidate-bsr")

                    self.candidate_rps = Pim.DefaultContext.Ipv6.Bsr.CandidateRps()
                    self.candidate_rps.parent = self
                    self._children_name_map["candidate_rps"] = "candidate-rps"
                    self._children_yang_names.add("candidate-rps")


                class CandidateBsr(Entity):
                    """
                    PIM Candidate BSR configuration
                    
                    .. attribute:: address
                    
                    	BSR Address configured
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    	**mandatory**\: True
                    
                    .. attribute:: prefix_length
                    
                    	Hash Mask Length for this candidate BSR
                    	**type**\:  int
                    
                    	**range:** 0..128
                    
                    	**default value**\: 126
                    
                    .. attribute:: priority
                    
                    	Priority of the Candidate BSR
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    	**default value**\: 1
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Bsr.CandidateBsr, self).__init__()

                        self.yang_name = "candidate-bsr"
                        self.yang_parent_name = "bsr"
                        self.is_presence_container = True

                        self.address = YLeaf(YType.str, "address")

                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                        self.priority = YLeaf(YType.uint32, "priority")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("address",
                                        "prefix_length",
                                        "priority") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Bsr.CandidateBsr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Bsr.CandidateBsr, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.address.is_set or
                            self.prefix_length.is_set or
                            self.priority.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.address.yfilter != YFilter.not_set or
                            self.prefix_length.yfilter != YFilter.not_set or
                            self.priority.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "candidate-bsr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/bsr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address.get_name_leafdata())
                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_length.get_name_leafdata())
                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.priority.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "address" or name == "prefix-length" or name == "priority"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "address"):
                            self.address = value
                            self.address.value_namespace = name_space
                            self.address.value_namespace_prefix = name_space_prefix
                        if(value_path == "prefix-length"):
                            self.prefix_length = value
                            self.prefix_length.value_namespace = name_space
                            self.prefix_length.value_namespace_prefix = name_space_prefix
                        if(value_path == "priority"):
                            self.priority = value
                            self.priority.value_namespace = name_space
                            self.priority.value_namespace_prefix = name_space_prefix


                class CandidateRps(Entity):
                    """
                    PIM RP configuration
                    
                    .. attribute:: candidate_rp
                    
                    	Address of PIM SM BSR Candidate\-RP
                    	**type**\: list of    :py:class:`CandidateRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.Bsr.CandidateRps.CandidateRp>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.Bsr.CandidateRps, self).__init__()

                        self.yang_name = "candidate-rps"
                        self.yang_parent_name = "bsr"

                        self.candidate_rp = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.Bsr.CandidateRps, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.Bsr.CandidateRps, self).__setattr__(name, value)


                    class CandidateRp(Entity):
                        """
                        Address of PIM SM BSR Candidate\-RP
                        
                        .. attribute:: address  <key>
                        
                        	Address of Candidate\-RP
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: mode  <key>
                        
                        	SM or Bidir
                        	**type**\:   :py:class:`PimProtocolMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimProtocolMode>`
                        
                        .. attribute:: group_list
                        
                        	Access\-list specifying the group range for the Candidate\-RP
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: interval
                        
                        	Advertisement interval
                        	**type**\:  int
                        
                        	**range:** 30..600
                        
                        	**default value**\: 60
                        
                        .. attribute:: priority
                        
                        	Priority of the CRP
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        	**default value**\: 192
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.DefaultContext.Ipv6.Bsr.CandidateRps.CandidateRp, self).__init__()

                            self.yang_name = "candidate-rp"
                            self.yang_parent_name = "candidate-rps"

                            self.address = YLeaf(YType.str, "address")

                            self.mode = YLeaf(YType.enumeration, "mode")

                            self.group_list = YLeaf(YType.str, "group-list")

                            self.interval = YLeaf(YType.uint32, "interval")

                            self.priority = YLeaf(YType.uint32, "priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "mode",
                                            "group_list",
                                            "interval",
                                            "priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.DefaultContext.Ipv6.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.DefaultContext.Ipv6.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.mode.is_set or
                                self.group_list.is_set or
                                self.interval.is_set or
                                self.priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.mode.yfilter != YFilter.not_set or
                                self.group_list.yfilter != YFilter.not_set or
                                self.interval.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "candidate-rp" + "[address='" + self.address.get() + "']" + "[mode='" + self.mode.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/bsr/candidate-rps/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mode.get_name_leafdata())
                            if (self.group_list.is_set or self.group_list.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.group_list.get_name_leafdata())
                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interval.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address" or name == "mode" or name == "group-list" or name == "interval" or name == "priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "mode"):
                                self.mode = value
                                self.mode.value_namespace = name_space
                                self.mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "group-list"):
                                self.group_list = value
                                self.group_list.value_namespace = name_space
                                self.group_list.value_namespace_prefix = name_space_prefix
                            if(value_path == "interval"):
                                self.interval = value
                                self.interval.value_namespace = name_space
                                self.interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.candidate_rp:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.candidate_rp:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "candidate-rps" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/bsr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "candidate-rp"):
                            for c in self.candidate_rp:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.DefaultContext.Ipv6.Bsr.CandidateRps.CandidateRp()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.candidate_rp.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "candidate-rp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.candidate_rps is not None and self.candidate_rps.has_data()) or
                        (self.candidate_bsr is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.candidate_bsr is not None and self.candidate_bsr.has_operation()) or
                        (self.candidate_rps is not None and self.candidate_rps.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "bsr" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "candidate-bsr"):
                        if (self.candidate_bsr is None):
                            self.candidate_bsr = Pim.DefaultContext.Ipv6.Bsr.CandidateBsr()
                            self.candidate_bsr.parent = self
                            self._children_name_map["candidate_bsr"] = "candidate-bsr"
                        return self.candidate_bsr

                    if (child_yang_name == "candidate-rps"):
                        if (self.candidate_rps is None):
                            self.candidate_rps = Pim.DefaultContext.Ipv6.Bsr.CandidateRps()
                            self.candidate_rps.parent = self
                            self._children_name_map["candidate_rps"] = "candidate-rps"
                        return self.candidate_rps

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "candidate-bsr" or name == "candidate-rps"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AllowRp(Entity):
                """
                Enable allow\-rp filtering for SM joins
                
                .. attribute:: group_list_name
                
                	Access\-list specifiying applicable groups
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: rp_list_name
                
                	Access\-list specifiying applicable RPs
                	**type**\:  str
                
                	**length:** 1..64
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.AllowRp, self).__init__()

                    self.yang_name = "allow-rp"
                    self.yang_parent_name = "ipv6"
                    self.is_presence_container = True

                    self.group_list_name = YLeaf(YType.str, "group-list-name")

                    self.rp_list_name = YLeaf(YType.str, "rp-list-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("group_list_name",
                                    "rp_list_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.AllowRp, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.AllowRp, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.group_list_name.is_set or
                        self.rp_list_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.group_list_name.yfilter != YFilter.not_set or
                        self.rp_list_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "allow-rp" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.group_list_name.is_set or self.group_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.group_list_name.get_name_leafdata())
                    if (self.rp_list_name.is_set or self.rp_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rp_list_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "group-list-name" or name == "rp-list-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "group-list-name"):
                        self.group_list_name = value
                        self.group_list_name.value_namespace = name_space
                        self.group_list_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "rp-list-name"):
                        self.rp_list_name = value
                        self.rp_list_name.value_namespace = name_space
                        self.rp_list_name.value_namespace_prefix = name_space_prefix


            class EmbeddedRpAddresses(Entity):
                """
                Set Embedded RP processing support
                
                .. attribute:: embedded_rp_address
                
                	Set Embedded RP processing support
                	**type**\: list of    :py:class:`EmbeddedRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.EmbeddedRpAddresses, self).__init__()

                    self.yang_name = "embedded-rp-addresses"
                    self.yang_parent_name = "ipv6"

                    self.embedded_rp_address = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.EmbeddedRpAddresses, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.EmbeddedRpAddresses, self).__setattr__(name, value)


                class EmbeddedRpAddress(Entity):
                    """
                    Set Embedded RP processing support
                    
                    .. attribute:: rp_address  <key>
                    
                    	RP address of the Rendezvous Point
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: access_list_name
                    
                    	Access list of groups that should map to a given RP
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress, self).__init__()

                        self.yang_name = "embedded-rp-address"
                        self.yang_parent_name = "embedded-rp-addresses"

                        self.rp_address = YLeaf(YType.str, "rp-address")

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("rp_address",
                                        "access_list_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.rp_address.is_set or
                            self.access_list_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.rp_address.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "embedded-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/embedded-rp-addresses/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rp_address.get_name_leafdata())
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rp-address" or name == "access-list-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "rp-address"):
                            self.rp_address = value
                            self.rp_address.value_namespace = name_space
                            self.rp_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.embedded_rp_address:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.embedded_rp_address:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "embedded-rp-addresses" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "embedded-rp-address"):
                        for c in self.embedded_rp_address:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv6.EmbeddedRpAddresses.EmbeddedRpAddress()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.embedded_rp_address.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "embedded-rp-address"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Convergence(Entity):
                """
                Configure convergence parameters
                
                .. attribute:: link_down_prune_delay
                
                	Delay prunes if route join state transitions to not\-joined on link down
                	**type**\:  int
                
                	**range:** 0..60
                
                	**units**\: second
                
                .. attribute:: rpf_conflict_join_delay
                
                	Dampen first join if RPF path is through one of the downstream neighbor
                	**type**\:  int
                
                	**range:** 0..15
                
                	**units**\: second
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv6.Convergence, self).__init__()

                    self.yang_name = "convergence"
                    self.yang_parent_name = "ipv6"

                    self.link_down_prune_delay = YLeaf(YType.uint32, "link-down-prune-delay")

                    self.rpf_conflict_join_delay = YLeaf(YType.uint32, "rpf-conflict-join-delay")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("link_down_prune_delay",
                                    "rpf_conflict_join_delay") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv6.Convergence, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv6.Convergence, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.link_down_prune_delay.is_set or
                        self.rpf_conflict_join_delay.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.link_down_prune_delay.yfilter != YFilter.not_set or
                        self.rpf_conflict_join_delay.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "convergence" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv6/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.link_down_prune_delay.is_set or self.link_down_prune_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.link_down_prune_delay.get_name_leafdata())
                    if (self.rpf_conflict_join_delay.is_set or self.rpf_conflict_join_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rpf_conflict_join_delay.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "link-down-prune-delay" or name == "rpf-conflict-join-delay"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "link-down-prune-delay"):
                        self.link_down_prune_delay = value
                        self.link_down_prune_delay.value_namespace = name_space
                        self.link_down_prune_delay.value_namespace_prefix = name_space_prefix
                    if(value_path == "rpf-conflict-join-delay"):
                        self.rpf_conflict_join_delay = value
                        self.rpf_conflict_join_delay.value_namespace = name_space
                        self.rpf_conflict_join_delay.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.accept_register.is_set or
                    self.embedded_rp_disable.is_set or
                    self.log_neighbor_changes.is_set or
                    self.multipath.is_set or
                    self.neighbor_check_on_receive.is_set or
                    self.neighbor_check_on_send.is_set or
                    self.neighbor_filter.is_set or
                    self.old_register_checksum.is_set or
                    self.register_source.is_set or
                    self.rp_static_deny.is_set or
                    self.spt_threshold_infinity.is_set or
                    self.ssm_allow_override.is_set or
                    self.suppress_data_registers.is_set or
                    self.suppress_rpf_prunes.is_set or
                    (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_data()) or
                    (self.bsr is not None and self.bsr.has_data()) or
                    (self.convergence is not None and self.convergence.has_data()) or
                    (self.embedded_rp_addresses is not None and self.embedded_rp_addresses.has_data()) or
                    (self.inheritable_defaults is not None and self.inheritable_defaults.has_data()) or
                    (self.interfaces is not None and self.interfaces.has_data()) or
                    (self.maximum is not None and self.maximum.has_data()) or
                    (self.nsf is not None and self.nsf.has_data()) or
                    (self.rpf is not None and self.rpf.has_data()) or
                    (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_data()) or
                    (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_data()) or
                    (self.ssm is not None and self.ssm.has_data()) or
                    (self.allow_rp is not None) or
                    (self.rpf_vector_enable is not None))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.accept_register.yfilter != YFilter.not_set or
                    self.embedded_rp_disable.yfilter != YFilter.not_set or
                    self.log_neighbor_changes.yfilter != YFilter.not_set or
                    self.multipath.yfilter != YFilter.not_set or
                    self.neighbor_check_on_receive.yfilter != YFilter.not_set or
                    self.neighbor_check_on_send.yfilter != YFilter.not_set or
                    self.neighbor_filter.yfilter != YFilter.not_set or
                    self.old_register_checksum.yfilter != YFilter.not_set or
                    self.register_source.yfilter != YFilter.not_set or
                    self.rp_static_deny.yfilter != YFilter.not_set or
                    self.spt_threshold_infinity.yfilter != YFilter.not_set or
                    self.ssm_allow_override.yfilter != YFilter.not_set or
                    self.suppress_data_registers.yfilter != YFilter.not_set or
                    self.suppress_rpf_prunes.yfilter != YFilter.not_set or
                    (self.allow_rp is not None and self.allow_rp.has_operation()) or
                    (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_operation()) or
                    (self.bsr is not None and self.bsr.has_operation()) or
                    (self.convergence is not None and self.convergence.has_operation()) or
                    (self.embedded_rp_addresses is not None and self.embedded_rp_addresses.has_operation()) or
                    (self.inheritable_defaults is not None and self.inheritable_defaults.has_operation()) or
                    (self.interfaces is not None and self.interfaces.has_operation()) or
                    (self.maximum is not None and self.maximum.has_operation()) or
                    (self.nsf is not None and self.nsf.has_operation()) or
                    (self.rpf is not None and self.rpf.has_operation()) or
                    (self.rpf_vector_enable is not None and self.rpf_vector_enable.has_operation()) or
                    (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_operation()) or
                    (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_operation()) or
                    (self.ssm is not None and self.ssm.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.accept_register.is_set or self.accept_register.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.accept_register.get_name_leafdata())
                if (self.embedded_rp_disable.is_set or self.embedded_rp_disable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.embedded_rp_disable.get_name_leafdata())
                if (self.log_neighbor_changes.is_set or self.log_neighbor_changes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.log_neighbor_changes.get_name_leafdata())
                if (self.multipath.is_set or self.multipath.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.multipath.get_name_leafdata())
                if (self.neighbor_check_on_receive.is_set or self.neighbor_check_on_receive.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_check_on_receive.get_name_leafdata())
                if (self.neighbor_check_on_send.is_set or self.neighbor_check_on_send.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_check_on_send.get_name_leafdata())
                if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                if (self.old_register_checksum.is_set or self.old_register_checksum.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.old_register_checksum.get_name_leafdata())
                if (self.register_source.is_set or self.register_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.register_source.get_name_leafdata())
                if (self.rp_static_deny.is_set or self.rp_static_deny.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.rp_static_deny.get_name_leafdata())
                if (self.spt_threshold_infinity.is_set or self.spt_threshold_infinity.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.spt_threshold_infinity.get_name_leafdata())
                if (self.ssm_allow_override.is_set or self.ssm_allow_override.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ssm_allow_override.get_name_leafdata())
                if (self.suppress_data_registers.is_set or self.suppress_data_registers.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.suppress_data_registers.get_name_leafdata())
                if (self.suppress_rpf_prunes.is_set or self.suppress_rpf_prunes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.suppress_rpf_prunes.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "allow-rp"):
                    if (self.allow_rp is None):
                        self.allow_rp = Pim.DefaultContext.Ipv6.AllowRp()
                        self.allow_rp.parent = self
                        self._children_name_map["allow_rp"] = "allow-rp"
                    return self.allow_rp

                if (child_yang_name == "bidir-rp-addresses"):
                    if (self.bidir_rp_addresses is None):
                        self.bidir_rp_addresses = Pim.DefaultContext.Ipv6.BidirRpAddresses()
                        self.bidir_rp_addresses.parent = self
                        self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                    return self.bidir_rp_addresses

                if (child_yang_name == "bsr"):
                    if (self.bsr is None):
                        self.bsr = Pim.DefaultContext.Ipv6.Bsr()
                        self.bsr.parent = self
                        self._children_name_map["bsr"] = "bsr"
                    return self.bsr

                if (child_yang_name == "convergence"):
                    if (self.convergence is None):
                        self.convergence = Pim.DefaultContext.Ipv6.Convergence()
                        self.convergence.parent = self
                        self._children_name_map["convergence"] = "convergence"
                    return self.convergence

                if (child_yang_name == "embedded-rp-addresses"):
                    if (self.embedded_rp_addresses is None):
                        self.embedded_rp_addresses = Pim.DefaultContext.Ipv6.EmbeddedRpAddresses()
                        self.embedded_rp_addresses.parent = self
                        self._children_name_map["embedded_rp_addresses"] = "embedded-rp-addresses"
                    return self.embedded_rp_addresses

                if (child_yang_name == "inheritable-defaults"):
                    if (self.inheritable_defaults is None):
                        self.inheritable_defaults = Pim.DefaultContext.Ipv6.InheritableDefaults()
                        self.inheritable_defaults.parent = self
                        self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                    return self.inheritable_defaults

                if (child_yang_name == "interfaces"):
                    if (self.interfaces is None):
                        self.interfaces = Pim.DefaultContext.Ipv6.Interfaces()
                        self.interfaces.parent = self
                        self._children_name_map["interfaces"] = "interfaces"
                    return self.interfaces

                if (child_yang_name == "maximum"):
                    if (self.maximum is None):
                        self.maximum = Pim.DefaultContext.Ipv6.Maximum()
                        self.maximum.parent = self
                        self._children_name_map["maximum"] = "maximum"
                    return self.maximum

                if (child_yang_name == "nsf"):
                    if (self.nsf is None):
                        self.nsf = Pim.DefaultContext.Ipv6.Nsf()
                        self.nsf.parent = self
                        self._children_name_map["nsf"] = "nsf"
                    return self.nsf

                if (child_yang_name == "rpf"):
                    if (self.rpf is None):
                        self.rpf = Pim.DefaultContext.Ipv6.Rpf()
                        self.rpf.parent = self
                        self._children_name_map["rpf"] = "rpf"
                    return self.rpf

                if (child_yang_name == "rpf-vector-enable"):
                    if (self.rpf_vector_enable is None):
                        self.rpf_vector_enable = Pim.DefaultContext.Ipv6.RpfVectorEnable()
                        self.rpf_vector_enable.parent = self
                        self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                    return self.rpf_vector_enable

                if (child_yang_name == "sg-expiry-timer"):
                    if (self.sg_expiry_timer is None):
                        self.sg_expiry_timer = Pim.DefaultContext.Ipv6.SgExpiryTimer()
                        self.sg_expiry_timer.parent = self
                        self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                    return self.sg_expiry_timer

                if (child_yang_name == "sparse-mode-rp-addresses"):
                    if (self.sparse_mode_rp_addresses is None):
                        self.sparse_mode_rp_addresses = Pim.DefaultContext.Ipv6.SparseModeRpAddresses()
                        self.sparse_mode_rp_addresses.parent = self
                        self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                    return self.sparse_mode_rp_addresses

                if (child_yang_name == "ssm"):
                    if (self.ssm is None):
                        self.ssm = Pim.DefaultContext.Ipv6.Ssm()
                        self.ssm.parent = self
                        self._children_name_map["ssm"] = "ssm"
                    return self.ssm

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "allow-rp" or name == "bidir-rp-addresses" or name == "bsr" or name == "convergence" or name == "embedded-rp-addresses" or name == "inheritable-defaults" or name == "interfaces" or name == "maximum" or name == "nsf" or name == "rpf" or name == "rpf-vector-enable" or name == "sg-expiry-timer" or name == "sparse-mode-rp-addresses" or name == "ssm" or name == "accept-register" or name == "embedded-rp-disable" or name == "log-neighbor-changes" or name == "multipath" or name == "neighbor-check-on-receive" or name == "neighbor-check-on-send" or name == "neighbor-filter" or name == "old-register-checksum" or name == "register-source" or name == "rp-static-deny" or name == "spt-threshold-infinity" or name == "ssm-allow-override" or name == "suppress-data-registers" or name == "suppress-rpf-prunes"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "accept-register"):
                    self.accept_register = value
                    self.accept_register.value_namespace = name_space
                    self.accept_register.value_namespace_prefix = name_space_prefix
                if(value_path == "embedded-rp-disable"):
                    self.embedded_rp_disable = value
                    self.embedded_rp_disable.value_namespace = name_space
                    self.embedded_rp_disable.value_namespace_prefix = name_space_prefix
                if(value_path == "log-neighbor-changes"):
                    self.log_neighbor_changes = value
                    self.log_neighbor_changes.value_namespace = name_space
                    self.log_neighbor_changes.value_namespace_prefix = name_space_prefix
                if(value_path == "multipath"):
                    self.multipath = value
                    self.multipath.value_namespace = name_space
                    self.multipath.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-check-on-receive"):
                    self.neighbor_check_on_receive = value
                    self.neighbor_check_on_receive.value_namespace = name_space
                    self.neighbor_check_on_receive.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-check-on-send"):
                    self.neighbor_check_on_send = value
                    self.neighbor_check_on_send.value_namespace = name_space
                    self.neighbor_check_on_send.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-filter"):
                    self.neighbor_filter = value
                    self.neighbor_filter.value_namespace = name_space
                    self.neighbor_filter.value_namespace_prefix = name_space_prefix
                if(value_path == "old-register-checksum"):
                    self.old_register_checksum = value
                    self.old_register_checksum.value_namespace = name_space
                    self.old_register_checksum.value_namespace_prefix = name_space_prefix
                if(value_path == "register-source"):
                    self.register_source = value
                    self.register_source.value_namespace = name_space
                    self.register_source.value_namespace_prefix = name_space_prefix
                if(value_path == "rp-static-deny"):
                    self.rp_static_deny = value
                    self.rp_static_deny.value_namespace = name_space
                    self.rp_static_deny.value_namespace_prefix = name_space_prefix
                if(value_path == "spt-threshold-infinity"):
                    self.spt_threshold_infinity = value
                    self.spt_threshold_infinity.value_namespace = name_space
                    self.spt_threshold_infinity.value_namespace_prefix = name_space_prefix
                if(value_path == "ssm-allow-override"):
                    self.ssm_allow_override = value
                    self.ssm_allow_override.value_namespace = name_space
                    self.ssm_allow_override.value_namespace_prefix = name_space_prefix
                if(value_path == "suppress-data-registers"):
                    self.suppress_data_registers = value
                    self.suppress_data_registers.value_namespace = name_space
                    self.suppress_data_registers.value_namespace_prefix = name_space_prefix
                if(value_path == "suppress-rpf-prunes"):
                    self.suppress_rpf_prunes = value
                    self.suppress_rpf_prunes.value_namespace = name_space
                    self.suppress_rpf_prunes.value_namespace_prefix = name_space_prefix


        class Ipv4(Entity):
            """
            IPV4 commands
            
            .. attribute:: accept_register
            
            	Access\-list which specifies unauthorized sources
            	**type**\:  str
            
            	**length:** 1..64
            
            .. attribute:: allow_rp
            
            	Enable allow\-rp filtering for SM joins
            	**type**\:   :py:class:`AllowRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.AllowRp>`
            
            	**presence node**\: True
            
            .. attribute:: auto_rp_candidate_rps
            
            	Configure Candidate\-RPs
            	**type**\:   :py:class:`AutoRpCandidateRps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.AutoRpCandidateRps>`
            
            .. attribute:: auto_rp_disable
            
            	Disable Rendezvous Point discovery through the AutoRP protocol
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: auto_rp_mapping_agent
            
            	Configure AutoRP Mapping Agent
            	**type**\:   :py:class:`AutoRpMappingAgent <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.AutoRpMappingAgent>`
            
            .. attribute:: bidir_rp_addresses
            
            	Configure Bidirectional PIM Rendezvous Point
            	**type**\:   :py:class:`BidirRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.BidirRpAddresses>`
            
            .. attribute:: bsr
            
            	PIM BSR configuration
            	**type**\:   :py:class:`Bsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Bsr>`
            
            .. attribute:: cj_multicast_only_frrs
            
            	Clone Join Multicast Only FRR
            	**type**\:   :py:class:`CjMulticastOnlyFrrs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs>`
            
            .. attribute:: convergence
            
            	Configure convergence parameters
            	**type**\:   :py:class:`Convergence <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Convergence>`
            
            .. attribute:: cs_multicast_only_frrs
            
            	Clone Source Multicast Only FRR
            	**type**\:   :py:class:`CsMulticastOnlyFrrs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs>`
            
            .. attribute:: inheritable_defaults
            
            	Inheritable defaults
            	**type**\:   :py:class:`InheritableDefaults <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.InheritableDefaults>`
            
            .. attribute:: injects
            
            	Inject Explicit PIM RPF Vector Proxy's
            	**type**\:   :py:class:`Injects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Injects>`
            
            .. attribute:: interfaces
            
            	Interface\-level Configuration
            	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Interfaces>`
            
            .. attribute:: log_neighbor_changes
            
            	PIM neighbor state change logging is turned on if configured
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: maximum
            
            	Configure PIM State Limits
            	**type**\:   :py:class:`Maximum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum>`
            
            .. attribute:: multicast_only_frr
            
            	Multicast Only FRR
            	**type**\:   :py:class:`MulticastOnlyFrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.MulticastOnlyFrr>`
            
            .. attribute:: multipath
            
            	Enable equal\-cost multipath routing
            	**type**\:   :py:class:`PimMultipath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimMultipath>`
            
            .. attribute:: neighbor_check_on_receive
            
            	Enable PIM neighbor checking when receiving PIM messages
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: neighbor_check_on_send
            
            	Enable PIM neighbor checking when sending join\-prunes
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: neighbor_filter
            
            	Access\-list of neighbors to be filtered
            	**type**\:  str
            
            	**length:** 1..64
            
            .. attribute:: nsf
            
            	Configure Non\-stop forwarding (NSF) options
            	**type**\:   :py:class:`Nsf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Nsf>`
            
            .. attribute:: old_register_checksum
            
            	Generate registers compatible with older IOS versions
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: paths
            
            	Inject PIM RPF Vector Proxy's
            	**type**\:   :py:class:`Paths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Paths>`
            
            .. attribute:: register_source
            
            	Source address to use for register messages
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: rp_static_deny
            
            	Configure static RP deny range
            	**type**\:  str
            
            	**length:** 1..64
            
            .. attribute:: rpf
            
            	Configure RPF options
            	**type**\:   :py:class:`Rpf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Rpf>`
            
            .. attribute:: rpf_redirect
            
            	Configure RPF\-redirect feature
            	**type**\:   :py:class:`RpfRedirect <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.RpfRedirect>`
            
            .. attribute:: rpf_vector_enable
            
            	Enable PIM RPF Vector Proxy's
            	**type**\:   :py:class:`RpfVectorEnable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.RpfVectorEnable>`
            
            	**presence node**\: True
            
            .. attribute:: sg_expiry_timer
            
            	Configure expiry timer for S,G routes
            	**type**\:   :py:class:`SgExpiryTimer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.SgExpiryTimer>`
            
            .. attribute:: sparse_mode_rp_addresses
            
            	Configure Sparse\-Mode Rendezvous Point
            	**type**\:   :py:class:`SparseModeRpAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.SparseModeRpAddresses>`
            
            .. attribute:: spt_threshold_infinity
            
            	Configure threshold of infinity for switching to SPT on last\-hop
            	**type**\:  str
            
            .. attribute:: ssm
            
            	Configure IP Multicast SSM
            	**type**\:   :py:class:`Ssm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Ssm>`
            
            .. attribute:: ssm_allow_override
            
            	Allow SSM ranges to be overridden by more specific ranges
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: suppress_data_registers
            
            	Suppress data registers after initial state setup
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: suppress_rpf_prunes
            
            	Suppress prunes triggered as a result of RPF changes
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'ipv4-pim-cfg'
            _revision = '2016-06-01'

            def __init__(self):
                super(Pim.DefaultContext.Ipv4, self).__init__()

                self.yang_name = "ipv4"
                self.yang_parent_name = "default-context"

                self.accept_register = YLeaf(YType.str, "accept-register")

                self.auto_rp_disable = YLeaf(YType.empty, "auto-rp-disable")

                self.log_neighbor_changes = YLeaf(YType.empty, "log-neighbor-changes")

                self.multipath = YLeaf(YType.enumeration, "multipath")

                self.neighbor_check_on_receive = YLeaf(YType.empty, "neighbor-check-on-receive")

                self.neighbor_check_on_send = YLeaf(YType.empty, "neighbor-check-on-send")

                self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                self.old_register_checksum = YLeaf(YType.empty, "old-register-checksum")

                self.register_source = YLeaf(YType.str, "register-source")

                self.rp_static_deny = YLeaf(YType.str, "rp-static-deny")

                self.spt_threshold_infinity = YLeaf(YType.str, "spt-threshold-infinity")

                self.ssm_allow_override = YLeaf(YType.empty, "ssm-allow-override")

                self.suppress_data_registers = YLeaf(YType.empty, "suppress-data-registers")

                self.suppress_rpf_prunes = YLeaf(YType.empty, "suppress-rpf-prunes")

                self.allow_rp = None
                self._children_name_map["allow_rp"] = "allow-rp"
                self._children_yang_names.add("allow-rp")

                self.auto_rp_candidate_rps = Pim.DefaultContext.Ipv4.AutoRpCandidateRps()
                self.auto_rp_candidate_rps.parent = self
                self._children_name_map["auto_rp_candidate_rps"] = "auto-rp-candidate-rps"
                self._children_yang_names.add("auto-rp-candidate-rps")

                self.auto_rp_mapping_agent = Pim.DefaultContext.Ipv4.AutoRpMappingAgent()
                self.auto_rp_mapping_agent.parent = self
                self._children_name_map["auto_rp_mapping_agent"] = "auto-rp-mapping-agent"
                self._children_yang_names.add("auto-rp-mapping-agent")

                self.bidir_rp_addresses = Pim.DefaultContext.Ipv4.BidirRpAddresses()
                self.bidir_rp_addresses.parent = self
                self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                self._children_yang_names.add("bidir-rp-addresses")

                self.bsr = Pim.DefaultContext.Ipv4.Bsr()
                self.bsr.parent = self
                self._children_name_map["bsr"] = "bsr"
                self._children_yang_names.add("bsr")

                self.cj_multicast_only_frrs = Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs()
                self.cj_multicast_only_frrs.parent = self
                self._children_name_map["cj_multicast_only_frrs"] = "cj-multicast-only-frrs"
                self._children_yang_names.add("cj-multicast-only-frrs")

                self.convergence = Pim.DefaultContext.Ipv4.Convergence()
                self.convergence.parent = self
                self._children_name_map["convergence"] = "convergence"
                self._children_yang_names.add("convergence")

                self.cs_multicast_only_frrs = Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs()
                self.cs_multicast_only_frrs.parent = self
                self._children_name_map["cs_multicast_only_frrs"] = "cs-multicast-only-frrs"
                self._children_yang_names.add("cs-multicast-only-frrs")

                self.inheritable_defaults = Pim.DefaultContext.Ipv4.InheritableDefaults()
                self.inheritable_defaults.parent = self
                self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                self._children_yang_names.add("inheritable-defaults")

                self.injects = Pim.DefaultContext.Ipv4.Injects()
                self.injects.parent = self
                self._children_name_map["injects"] = "injects"
                self._children_yang_names.add("injects")

                self.interfaces = Pim.DefaultContext.Ipv4.Interfaces()
                self.interfaces.parent = self
                self._children_name_map["interfaces"] = "interfaces"
                self._children_yang_names.add("interfaces")

                self.maximum = Pim.DefaultContext.Ipv4.Maximum()
                self.maximum.parent = self
                self._children_name_map["maximum"] = "maximum"
                self._children_yang_names.add("maximum")

                self.multicast_only_frr = Pim.DefaultContext.Ipv4.MulticastOnlyFrr()
                self.multicast_only_frr.parent = self
                self._children_name_map["multicast_only_frr"] = "multicast-only-frr"
                self._children_yang_names.add("multicast-only-frr")

                self.nsf = Pim.DefaultContext.Ipv4.Nsf()
                self.nsf.parent = self
                self._children_name_map["nsf"] = "nsf"
                self._children_yang_names.add("nsf")

                self.paths = Pim.DefaultContext.Ipv4.Paths()
                self.paths.parent = self
                self._children_name_map["paths"] = "paths"
                self._children_yang_names.add("paths")

                self.rpf = Pim.DefaultContext.Ipv4.Rpf()
                self.rpf.parent = self
                self._children_name_map["rpf"] = "rpf"
                self._children_yang_names.add("rpf")

                self.rpf_redirect = Pim.DefaultContext.Ipv4.RpfRedirect()
                self.rpf_redirect.parent = self
                self._children_name_map["rpf_redirect"] = "rpf-redirect"
                self._children_yang_names.add("rpf-redirect")

                self.rpf_vector_enable = None
                self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                self._children_yang_names.add("rpf-vector-enable")

                self.sg_expiry_timer = Pim.DefaultContext.Ipv4.SgExpiryTimer()
                self.sg_expiry_timer.parent = self
                self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                self._children_yang_names.add("sg-expiry-timer")

                self.sparse_mode_rp_addresses = Pim.DefaultContext.Ipv4.SparseModeRpAddresses()
                self.sparse_mode_rp_addresses.parent = self
                self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                self._children_yang_names.add("sparse-mode-rp-addresses")

                self.ssm = Pim.DefaultContext.Ipv4.Ssm()
                self.ssm.parent = self
                self._children_name_map["ssm"] = "ssm"
                self._children_yang_names.add("ssm")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("accept_register",
                                "auto_rp_disable",
                                "log_neighbor_changes",
                                "multipath",
                                "neighbor_check_on_receive",
                                "neighbor_check_on_send",
                                "neighbor_filter",
                                "old_register_checksum",
                                "register_source",
                                "rp_static_deny",
                                "spt_threshold_infinity",
                                "ssm_allow_override",
                                "suppress_data_registers",
                                "suppress_rpf_prunes") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Pim.DefaultContext.Ipv4, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Pim.DefaultContext.Ipv4, self).__setattr__(name, value)


            class RpfRedirect(Entity):
                """
                Configure RPF\-redirect feature
                
                .. attribute:: route_policy
                
                	Route policy to select RPF topology
                	**type**\:  str
                
                	**length:** 1..64
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.RpfRedirect, self).__init__()

                    self.yang_name = "rpf-redirect"
                    self.yang_parent_name = "ipv4"

                    self.route_policy = YLeaf(YType.str, "route-policy")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("route_policy") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.RpfRedirect, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.RpfRedirect, self).__setattr__(name, value)

                def has_data(self):
                    return self.route_policy.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.route_policy.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rpf-redirect" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.route_policy.is_set or self.route_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_policy.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "route-policy"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "route-policy"):
                        self.route_policy = value
                        self.route_policy.value_namespace = name_space
                        self.route_policy.value_namespace_prefix = name_space_prefix


            class Interfaces(Entity):
                """
                Interface\-level Configuration
                
                .. attribute:: interface
                
                	The name of the interface
                	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Interfaces.Interface>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Interfaces, self).__init__()

                    self.yang_name = "interfaces"
                    self.yang_parent_name = "ipv4"

                    self.interface = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Interfaces, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Interfaces, self).__setattr__(name, value)


                class Interface(Entity):
                    """
                    The name of the interface
                    
                    .. attribute:: interface_name  <key>
                    
                    	The name of interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: bfd
                    
                    	BFD configuration
                    	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Interfaces.Interface.Bfd>`
                    
                    .. attribute:: bsr_border
                    
                    	BSR Border configuration for Interface
                    	**type**\:  bool
                    
                    .. attribute:: dr_priority
                    
                    	Hello DR priority, preference given to larger value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: enable
                    
                    	Enter PIM Interface processing
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: hello_interval
                    
                    	Hello interval in seconds
                    	**type**\:  int
                    
                    	**range:** 1..3600
                    
                    	**units**\: second
                    
                    .. attribute:: interface_enable
                    
                    	Enable PIM processing on the interface
                    	**type**\:  bool
                    
                    .. attribute:: join_prune_mtu
                    
                    	Join\-Prune MTU in Bytes
                    	**type**\:  int
                    
                    	**range:** 576..65535
                    
                    	**units**\: byte
                    
                    .. attribute:: jp_interval
                    
                    	Join\-Prune interval in seconds
                    	**type**\:  int
                    
                    	**range:** 10..600
                    
                    	**units**\: second
                    
                    .. attribute:: maximum_routes
                    
                    	Maximum number of allowed routes for this interface
                    	**type**\:   :py:class:`MaximumRoutes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Interfaces.Interface.MaximumRoutes>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: neighbor_filter
                    
                    	Access\-list of neighbors to be filtered
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: override_interval
                    
                    	Override interval in milliseconds
                    	**type**\:  int
                    
                    	**range:** 400..65535
                    
                    	**units**\: millisecond
                    
                    .. attribute:: propagation_delay
                    
                    	Propagation delay in milli seconds
                    	**type**\:  int
                    
                    	**range:** 100..32767
                    
                    	**units**\: millisecond
                    
                    .. attribute:: redirect_bundle
                    
                    	Configure RPF\-redirect bundle for interface. Applicable for IPv4 only
                    	**type**\:   :py:class:`RedirectBundle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Interfaces.Interface.RedirectBundle>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Interfaces.Interface, self).__init__()

                        self.yang_name = "interface"
                        self.yang_parent_name = "interfaces"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.bsr_border = YLeaf(YType.boolean, "bsr-border")

                        self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                        self.interface_enable = YLeaf(YType.boolean, "interface-enable")

                        self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                        self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                        self.neighbor_filter = YLeaf(YType.str, "neighbor-filter")

                        self.override_interval = YLeaf(YType.uint32, "override-interval")

                        self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                        self.bfd = Pim.DefaultContext.Ipv4.Interfaces.Interface.Bfd()
                        self.bfd.parent = self
                        self._children_name_map["bfd"] = "bfd"
                        self._children_yang_names.add("bfd")

                        self.maximum_routes = None
                        self._children_name_map["maximum_routes"] = "maximum-routes"
                        self._children_yang_names.add("maximum-routes")

                        self.redirect_bundle = Pim.DefaultContext.Ipv4.Interfaces.Interface.RedirectBundle()
                        self.redirect_bundle.parent = self
                        self._children_name_map["redirect_bundle"] = "redirect-bundle"
                        self._children_yang_names.add("redirect-bundle")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name",
                                        "bsr_border",
                                        "dr_priority",
                                        "enable",
                                        "hello_interval",
                                        "interface_enable",
                                        "join_prune_mtu",
                                        "jp_interval",
                                        "neighbor_filter",
                                        "override_interval",
                                        "propagation_delay") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Interfaces.Interface, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Interfaces.Interface, self).__setattr__(name, value)


                    class RedirectBundle(Entity):
                        """
                        Configure RPF\-redirect bundle for interface.
                        Applicable for IPv4 only
                        
                        .. attribute:: bundle_name
                        
                        	Bundle name
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: interface_bandwidth
                        
                        	Interface bandwidth in Kbps
                        	**type**\:  int
                        
                        	**range:** 0..100000000
                        
                        	**units**\: kbit/s
                        
                        .. attribute:: threshold_bandwidth
                        
                        	Threshold bandwidth in Kbps
                        	**type**\:  int
                        
                        	**range:** 0..100000000
                        
                        	**units**\: kbit/s
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.DefaultContext.Ipv4.Interfaces.Interface.RedirectBundle, self).__init__()

                            self.yang_name = "redirect-bundle"
                            self.yang_parent_name = "interface"

                            self.bundle_name = YLeaf(YType.str, "bundle-name")

                            self.interface_bandwidth = YLeaf(YType.uint32, "interface-bandwidth")

                            self.threshold_bandwidth = YLeaf(YType.uint32, "threshold-bandwidth")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bundle_name",
                                            "interface_bandwidth",
                                            "threshold_bandwidth") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.DefaultContext.Ipv4.Interfaces.Interface.RedirectBundle, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.DefaultContext.Ipv4.Interfaces.Interface.RedirectBundle, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bundle_name.is_set or
                                self.interface_bandwidth.is_set or
                                self.threshold_bandwidth.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bundle_name.yfilter != YFilter.not_set or
                                self.interface_bandwidth.yfilter != YFilter.not_set or
                                self.threshold_bandwidth.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "redirect-bundle" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bundle_name.is_set or self.bundle_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bundle_name.get_name_leafdata())
                            if (self.interface_bandwidth.is_set or self.interface_bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_bandwidth.get_name_leafdata())
                            if (self.threshold_bandwidth.is_set or self.threshold_bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_bandwidth.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bundle-name" or name == "interface-bandwidth" or name == "threshold-bandwidth"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bundle-name"):
                                self.bundle_name = value
                                self.bundle_name.value_namespace = name_space
                                self.bundle_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface-bandwidth"):
                                self.interface_bandwidth = value
                                self.interface_bandwidth.value_namespace = name_space
                                self.interface_bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-bandwidth"):
                                self.threshold_bandwidth = value
                                self.threshold_bandwidth.value_namespace = name_space
                                self.threshold_bandwidth.value_namespace_prefix = name_space_prefix


                    class MaximumRoutes(Entity):
                        """
                        Maximum number of allowed routes for this
                        interface
                        
                        .. attribute:: access_list_name
                        
                        	Access\-list to account for
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: maximum
                        
                        	Maximum number of routes for this interface
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        	**mandatory**\: True
                        
                        .. attribute:: warning_threshold
                        
                        	Set threshold to print warning
                        	**type**\:  int
                        
                        	**range:** 1..1100000
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.DefaultContext.Ipv4.Interfaces.Interface.MaximumRoutes, self).__init__()

                            self.yang_name = "maximum-routes"
                            self.yang_parent_name = "interface"
                            self.is_presence_container = True

                            self.access_list_name = YLeaf(YType.str, "access-list-name")

                            self.maximum = YLeaf(YType.uint32, "maximum")

                            self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("access_list_name",
                                            "maximum",
                                            "warning_threshold") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.DefaultContext.Ipv4.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.DefaultContext.Ipv4.Interfaces.Interface.MaximumRoutes, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.access_list_name.is_set or
                                self.maximum.is_set or
                                self.warning_threshold.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.access_list_name.yfilter != YFilter.not_set or
                                self.maximum.yfilter != YFilter.not_set or
                                self.warning_threshold.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "maximum-routes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.access_list_name.get_name_leafdata())
                            if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum.get_name_leafdata())
                            if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "access-list-name" or name == "maximum" or name == "warning-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "access-list-name"):
                                self.access_list_name = value
                                self.access_list_name.value_namespace = name_space
                                self.access_list_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "maximum"):
                                self.maximum = value
                                self.maximum.value_namespace = name_space
                                self.maximum.value_namespace_prefix = name_space_prefix
                            if(value_path == "warning-threshold"):
                                self.warning_threshold = value
                                self.warning_threshold.value_namespace = name_space
                                self.warning_threshold.value_namespace_prefix = name_space_prefix


                    class Bfd(Entity):
                        """
                        BFD configuration
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection multiplier for BFD sessions created by PIM
                        	**type**\:  int
                        
                        	**range:** 2..50
                        
                        .. attribute:: enable
                        
                        	TRUE to enable BFD. FALSE to disable and to prevent inheritance from a parent
                        	**type**\:  bool
                        
                        .. attribute:: interval
                        
                        	Hello interval for BFD sessions created by PIM
                        	**type**\:  int
                        
                        	**range:** 3..30000
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.DefaultContext.Ipv4.Interfaces.Interface.Bfd, self).__init__()

                            self.yang_name = "bfd"
                            self.yang_parent_name = "interface"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.interval = YLeaf(YType.uint32, "interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "enable",
                                            "interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.DefaultContext.Ipv4.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.DefaultContext.Ipv4.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.enable.is_set or
                                self.interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfd" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "enable" or name == "interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "interval"):
                                self.interval = value
                                self.interval.value_namespace = name_space
                                self.interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            self.bsr_border.is_set or
                            self.dr_priority.is_set or
                            self.enable.is_set or
                            self.hello_interval.is_set or
                            self.interface_enable.is_set or
                            self.join_prune_mtu.is_set or
                            self.jp_interval.is_set or
                            self.neighbor_filter.is_set or
                            self.override_interval.is_set or
                            self.propagation_delay.is_set or
                            (self.bfd is not None and self.bfd.has_data()) or
                            (self.redirect_bundle is not None and self.redirect_bundle.has_data()) or
                            (self.maximum_routes is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.bsr_border.yfilter != YFilter.not_set or
                            self.dr_priority.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.hello_interval.yfilter != YFilter.not_set or
                            self.interface_enable.yfilter != YFilter.not_set or
                            self.join_prune_mtu.yfilter != YFilter.not_set or
                            self.jp_interval.yfilter != YFilter.not_set or
                            self.neighbor_filter.yfilter != YFilter.not_set or
                            self.override_interval.yfilter != YFilter.not_set or
                            self.propagation_delay.yfilter != YFilter.not_set or
                            (self.bfd is not None and self.bfd.has_operation()) or
                            (self.maximum_routes is not None and self.maximum_routes.has_operation()) or
                            (self.redirect_bundle is not None and self.redirect_bundle.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/interfaces/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.bsr_border.is_set or self.bsr_border.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_border.get_name_leafdata())
                        if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dr_priority.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                        if (self.interface_enable.is_set or self.interface_enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_enable.get_name_leafdata())
                        if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                        if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.jp_interval.get_name_leafdata())
                        if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                        if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.override_interval.get_name_leafdata())
                        if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfd"):
                            if (self.bfd is None):
                                self.bfd = Pim.DefaultContext.Ipv4.Interfaces.Interface.Bfd()
                                self.bfd.parent = self
                                self._children_name_map["bfd"] = "bfd"
                            return self.bfd

                        if (child_yang_name == "maximum-routes"):
                            if (self.maximum_routes is None):
                                self.maximum_routes = Pim.DefaultContext.Ipv4.Interfaces.Interface.MaximumRoutes()
                                self.maximum_routes.parent = self
                                self._children_name_map["maximum_routes"] = "maximum-routes"
                            return self.maximum_routes

                        if (child_yang_name == "redirect-bundle"):
                            if (self.redirect_bundle is None):
                                self.redirect_bundle = Pim.DefaultContext.Ipv4.Interfaces.Interface.RedirectBundle()
                                self.redirect_bundle.parent = self
                                self._children_name_map["redirect_bundle"] = "redirect-bundle"
                            return self.redirect_bundle

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfd" or name == "maximum-routes" or name == "redirect-bundle" or name == "interface-name" or name == "bsr-border" or name == "dr-priority" or name == "enable" or name == "hello-interval" or name == "interface-enable" or name == "join-prune-mtu" or name == "jp-interval" or name == "neighbor-filter" or name == "override-interval" or name == "propagation-delay"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "bsr-border"):
                            self.bsr_border = value
                            self.bsr_border.value_namespace = name_space
                            self.bsr_border.value_namespace_prefix = name_space_prefix
                        if(value_path == "dr-priority"):
                            self.dr_priority = value
                            self.dr_priority.value_namespace = name_space
                            self.dr_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "hello-interval"):
                            self.hello_interval = value
                            self.hello_interval.value_namespace = name_space
                            self.hello_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-enable"):
                            self.interface_enable = value
                            self.interface_enable.value_namespace = name_space
                            self.interface_enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "join-prune-mtu"):
                            self.join_prune_mtu = value
                            self.join_prune_mtu.value_namespace = name_space
                            self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                        if(value_path == "jp-interval"):
                            self.jp_interval = value
                            self.jp_interval.value_namespace = name_space
                            self.jp_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "neighbor-filter"):
                            self.neighbor_filter = value
                            self.neighbor_filter.value_namespace = name_space
                            self.neighbor_filter.value_namespace_prefix = name_space_prefix
                        if(value_path == "override-interval"):
                            self.override_interval = value
                            self.override_interval.value_namespace = name_space
                            self.override_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "propagation-delay"):
                            self.propagation_delay = value
                            self.propagation_delay.value_namespace = name_space
                            self.propagation_delay.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.interface:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.interface:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interfaces" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface"):
                        for c in self.interface:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.Interfaces.Interface()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.interface.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AutoRpCandidateRps(Entity):
                """
                Configure Candidate\-RPs
                
                .. attribute:: auto_rp_candidate_rp
                
                	Specifications for a Candidate\-RP
                	**type**\: list of    :py:class:`AutoRpCandidateRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.AutoRpCandidateRps.AutoRpCandidateRp>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.AutoRpCandidateRps, self).__init__()

                    self.yang_name = "auto-rp-candidate-rps"
                    self.yang_parent_name = "ipv4"

                    self.auto_rp_candidate_rp = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.AutoRpCandidateRps, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.AutoRpCandidateRps, self).__setattr__(name, value)


                class AutoRpCandidateRp(Entity):
                    """
                    Specifications for a Candidate\-RP
                    
                    .. attribute:: interface_name  <key>
                    
                    	Interface from which Candidate\-RP packets will be sourced
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: protocol_mode  <key>
                    
                    	Protocol Mode
                    	**type**\:   :py:class:`AutoRpProtocolMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_autorp_datatypes.AutoRpProtocolMode>`
                    
                    .. attribute:: access_list_name
                    
                    	Access\-list specifying the group range for the Candidate\-RP
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    	**default value**\: 224-4
                    
                    .. attribute:: announce_period
                    
                    	Time between announcements <in seconds> 
                    	**type**\:  int
                    
                    	**range:** 1..600
                    
                    	**units**\: second
                    
                    	**default value**\: 60
                    
                    .. attribute:: ttl
                    
                    	TTL in Hops
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.AutoRpCandidateRps.AutoRpCandidateRp, self).__init__()

                        self.yang_name = "auto-rp-candidate-rp"
                        self.yang_parent_name = "auto-rp-candidate-rps"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.protocol_mode = YLeaf(YType.enumeration, "protocol-mode")

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                        self.announce_period = YLeaf(YType.uint32, "announce-period")

                        self.ttl = YLeaf(YType.uint32, "ttl")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name",
                                        "protocol_mode",
                                        "access_list_name",
                                        "announce_period",
                                        "ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.AutoRpCandidateRps.AutoRpCandidateRp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.AutoRpCandidateRps.AutoRpCandidateRp, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            self.protocol_mode.is_set or
                            self.access_list_name.is_set or
                            self.announce_period.is_set or
                            self.ttl.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.protocol_mode.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set or
                            self.announce_period.yfilter != YFilter.not_set or
                            self.ttl.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "auto-rp-candidate-rp" + "[interface-name='" + self.interface_name.get() + "']" + "[protocol-mode='" + self.protocol_mode.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/auto-rp-candidate-rps/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.protocol_mode.is_set or self.protocol_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protocol_mode.get_name_leafdata())
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())
                        if (self.announce_period.is_set or self.announce_period.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.announce_period.get_name_leafdata())
                        if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface-name" or name == "protocol-mode" or name == "access-list-name" or name == "announce-period" or name == "ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "protocol-mode"):
                            self.protocol_mode = value
                            self.protocol_mode.value_namespace = name_space
                            self.protocol_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "announce-period"):
                            self.announce_period = value
                            self.announce_period.value_namespace = name_space
                            self.announce_period.value_namespace_prefix = name_space_prefix
                        if(value_path == "ttl"):
                            self.ttl = value
                            self.ttl.value_namespace = name_space
                            self.ttl.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.auto_rp_candidate_rp:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.auto_rp_candidate_rp:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "auto-rp-candidate-rps" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "auto-rp-candidate-rp"):
                        for c in self.auto_rp_candidate_rp:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.AutoRpCandidateRps.AutoRpCandidateRp()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.auto_rp_candidate_rp.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "auto-rp-candidate-rp"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AutoRpMappingAgent(Entity):
                """
                Configure AutoRP Mapping Agent
                
                .. attribute:: cache_limit
                
                	Mapping Agent cache size limit
                	**type**\:   :py:class:`CacheLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.AutoRpMappingAgent.CacheLimit>`
                
                	**presence node**\: True
                
                .. attribute:: parameters
                
                	Specifications for Mapping Agent configured on this box
                	**type**\:   :py:class:`Parameters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.AutoRpMappingAgent.Parameters>`
                
                	**presence node**\: True
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.AutoRpMappingAgent, self).__init__()

                    self.yang_name = "auto-rp-mapping-agent"
                    self.yang_parent_name = "ipv4"

                    self.cache_limit = None
                    self._children_name_map["cache_limit"] = "cache-limit"
                    self._children_yang_names.add("cache-limit")

                    self.parameters = None
                    self._children_name_map["parameters"] = "parameters"
                    self._children_yang_names.add("parameters")


                class Parameters(Entity):
                    """
                    Specifications for Mapping Agent configured
                    on this box
                    
                    .. attribute:: announce_period
                    
                    	Time between discovery messages <in seconds>
                    	**type**\:  int
                    
                    	**range:** 1..600
                    
                    	**units**\: second
                    
                    	**default value**\: 60
                    
                    .. attribute:: interface_name
                    
                    	Interface from which mapping packets will be sourced 
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    	**mandatory**\: True
                    
                    .. attribute:: ttl
                    
                    	TTL in Hops
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    	**mandatory**\: True
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.AutoRpMappingAgent.Parameters, self).__init__()

                        self.yang_name = "parameters"
                        self.yang_parent_name = "auto-rp-mapping-agent"
                        self.is_presence_container = True

                        self.announce_period = YLeaf(YType.uint32, "announce-period")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.ttl = YLeaf(YType.uint32, "ttl")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("announce_period",
                                        "interface_name",
                                        "ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.AutoRpMappingAgent.Parameters, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.AutoRpMappingAgent.Parameters, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.announce_period.is_set or
                            self.interface_name.is_set or
                            self.ttl.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.announce_period.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.ttl.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "parameters" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/auto-rp-mapping-agent/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.announce_period.is_set or self.announce_period.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.announce_period.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "announce-period" or name == "interface-name" or name == "ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "announce-period"):
                            self.announce_period = value
                            self.announce_period.value_namespace = name_space
                            self.announce_period.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ttl"):
                            self.ttl = value
                            self.ttl.value_namespace = name_space
                            self.ttl.value_namespace_prefix = name_space_prefix


                class CacheLimit(Entity):
                    """
                    Mapping Agent cache size limit
                    
                    .. attribute:: maximum_cache_entry
                    
                    	Maximum number of mapping cache entries
                    	**type**\:  int
                    
                    	**range:** 1..1000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: threshold_cache_entry
                    
                    	Warning threshold number of cache entries
                    	**type**\:  int
                    
                    	**range:** 1..1000
                    
                    	**default value**\: 450
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.AutoRpMappingAgent.CacheLimit, self).__init__()

                        self.yang_name = "cache-limit"
                        self.yang_parent_name = "auto-rp-mapping-agent"
                        self.is_presence_container = True

                        self.maximum_cache_entry = YLeaf(YType.uint32, "maximum-cache-entry")

                        self.threshold_cache_entry = YLeaf(YType.uint32, "threshold-cache-entry")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_cache_entry",
                                        "threshold_cache_entry") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.AutoRpMappingAgent.CacheLimit, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.AutoRpMappingAgent.CacheLimit, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_cache_entry.is_set or
                            self.threshold_cache_entry.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_cache_entry.yfilter != YFilter.not_set or
                            self.threshold_cache_entry.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "cache-limit" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/auto-rp-mapping-agent/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_cache_entry.is_set or self.maximum_cache_entry.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_cache_entry.get_name_leafdata())
                        if (self.threshold_cache_entry.is_set or self.threshold_cache_entry.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_cache_entry.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-cache-entry" or name == "threshold-cache-entry"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-cache-entry"):
                            self.maximum_cache_entry = value
                            self.maximum_cache_entry.value_namespace = name_space
                            self.maximum_cache_entry.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold-cache-entry"):
                            self.threshold_cache_entry = value
                            self.threshold_cache_entry.value_namespace = name_space
                            self.threshold_cache_entry.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.cache_limit is not None) or
                        (self.parameters is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.cache_limit is not None and self.cache_limit.has_operation()) or
                        (self.parameters is not None and self.parameters.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "auto-rp-mapping-agent" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "cache-limit"):
                        if (self.cache_limit is None):
                            self.cache_limit = Pim.DefaultContext.Ipv4.AutoRpMappingAgent.CacheLimit()
                            self.cache_limit.parent = self
                            self._children_name_map["cache_limit"] = "cache-limit"
                        return self.cache_limit

                    if (child_yang_name == "parameters"):
                        if (self.parameters is None):
                            self.parameters = Pim.DefaultContext.Ipv4.AutoRpMappingAgent.Parameters()
                            self.parameters.parent = self
                            self._children_name_map["parameters"] = "parameters"
                        return self.parameters

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "cache-limit" or name == "parameters"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class SparseModeRpAddresses(Entity):
                """
                Configure Sparse\-Mode Rendezvous Point
                
                .. attribute:: sparse_mode_rp_address
                
                	Address of the Rendezvous Point
                	**type**\: list of    :py:class:`SparseModeRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.SparseModeRpAddresses.SparseModeRpAddress>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.SparseModeRpAddresses, self).__init__()

                    self.yang_name = "sparse-mode-rp-addresses"
                    self.yang_parent_name = "ipv4"

                    self.sparse_mode_rp_address = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.SparseModeRpAddresses, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.SparseModeRpAddresses, self).__setattr__(name, value)


                class SparseModeRpAddress(Entity):
                    """
                    Address of the Rendezvous Point
                    
                    .. attribute:: rp_address  <key>
                    
                    	RP address of Rendezvous Point
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: access_list_name
                    
                    	Access list of groups that should map to a  given RP
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: auto_rp_override
                    
                    	TRUE Indicates if static RP config overrides AutoRP and BSR
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.SparseModeRpAddresses.SparseModeRpAddress, self).__init__()

                        self.yang_name = "sparse-mode-rp-address"
                        self.yang_parent_name = "sparse-mode-rp-addresses"

                        self.rp_address = YLeaf(YType.str, "rp-address")

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                        self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("rp_address",
                                        "access_list_name",
                                        "auto_rp_override") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.SparseModeRpAddresses.SparseModeRpAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.rp_address.is_set or
                            self.access_list_name.is_set or
                            self.auto_rp_override.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.rp_address.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set or
                            self.auto_rp_override.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sparse-mode-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/sparse-mode-rp-addresses/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rp_address.get_name_leafdata())
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())
                        if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "rp-address"):
                            self.rp_address = value
                            self.rp_address.value_namespace = name_space
                            self.rp_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "auto-rp-override"):
                            self.auto_rp_override = value
                            self.auto_rp_override.value_namespace = name_space
                            self.auto_rp_override.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.sparse_mode_rp_address:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.sparse_mode_rp_address:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "sparse-mode-rp-addresses" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "sparse-mode-rp-address"):
                        for c in self.sparse_mode_rp_address:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.SparseModeRpAddresses.SparseModeRpAddress()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.sparse_mode_rp_address.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "sparse-mode-rp-address"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class MulticastOnlyFrr(Entity):
                """
                Multicast Only FRR
                
                .. attribute:: enable
                
                	Enable Multicast Only FRR
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: flow_multicast_only_frr
                
                	Access\-list specifying SG that should do FLOW MOFRR
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: non_revertive_multicast_only_frr
                
                	Non\-revertive Multicast Only FRR
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: rib_multicast_only_frr
                
                	Access\-list specifying SG that should do RIB MOFRR
                	**type**\:  str
                
                	**length:** 1..64
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.MulticastOnlyFrr, self).__init__()

                    self.yang_name = "multicast-only-frr"
                    self.yang_parent_name = "ipv4"

                    self.enable = YLeaf(YType.empty, "enable")

                    self.flow_multicast_only_frr = YLeaf(YType.str, "flow-multicast-only-frr")

                    self.non_revertive_multicast_only_frr = YLeaf(YType.empty, "non-revertive-multicast-only-frr")

                    self.rib_multicast_only_frr = YLeaf(YType.str, "rib-multicast-only-frr")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enable",
                                    "flow_multicast_only_frr",
                                    "non_revertive_multicast_only_frr",
                                    "rib_multicast_only_frr") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.MulticastOnlyFrr, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.MulticastOnlyFrr, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.enable.is_set or
                        self.flow_multicast_only_frr.is_set or
                        self.non_revertive_multicast_only_frr.is_set or
                        self.rib_multicast_only_frr.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.flow_multicast_only_frr.yfilter != YFilter.not_set or
                        self.non_revertive_multicast_only_frr.yfilter != YFilter.not_set or
                        self.rib_multicast_only_frr.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "multicast-only-frr" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.flow_multicast_only_frr.is_set or self.flow_multicast_only_frr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.flow_multicast_only_frr.get_name_leafdata())
                    if (self.non_revertive_multicast_only_frr.is_set or self.non_revertive_multicast_only_frr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.non_revertive_multicast_only_frr.get_name_leafdata())
                    if (self.rib_multicast_only_frr.is_set or self.rib_multicast_only_frr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rib_multicast_only_frr.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enable" or name == "flow-multicast-only-frr" or name == "non-revertive-multicast-only-frr" or name == "rib-multicast-only-frr"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "flow-multicast-only-frr"):
                        self.flow_multicast_only_frr = value
                        self.flow_multicast_only_frr.value_namespace = name_space
                        self.flow_multicast_only_frr.value_namespace_prefix = name_space_prefix
                    if(value_path == "non-revertive-multicast-only-frr"):
                        self.non_revertive_multicast_only_frr = value
                        self.non_revertive_multicast_only_frr.value_namespace = name_space
                        self.non_revertive_multicast_only_frr.value_namespace_prefix = name_space_prefix
                    if(value_path == "rib-multicast-only-frr"):
                        self.rib_multicast_only_frr = value
                        self.rib_multicast_only_frr.value_namespace = name_space
                        self.rib_multicast_only_frr.value_namespace_prefix = name_space_prefix


            class CsMulticastOnlyFrrs(Entity):
                """
                Clone Source Multicast Only FRR
                
                .. attribute:: cs_multicast_only_frr
                
                	Clone Source Multicast Only FRR
                	**type**\: list of    :py:class:`CsMulticastOnlyFrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs, self).__init__()

                    self.yang_name = "cs-multicast-only-frrs"
                    self.yang_parent_name = "ipv4"

                    self.cs_multicast_only_frr = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs, self).__setattr__(name, value)


                class CsMulticastOnlyFrr(Entity):
                    """
                    Clone Source Multicast Only FRR
                    
                    .. attribute:: source  <key>
                    
                    	Original address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: primary  <key>
                    
                    	Primary address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: backup  <key>
                    
                    	Backup address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: prefix_length  <key>
                    
                    	Masklen
                    	**type**\:  int
                    
                    	**range:** 0..32
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr, self).__init__()

                        self.yang_name = "cs-multicast-only-frr"
                        self.yang_parent_name = "cs-multicast-only-frrs"

                        self.source = YLeaf(YType.str, "source")

                        self.primary = YLeaf(YType.str, "primary")

                        self.backup = YLeaf(YType.str, "backup")

                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("source",
                                        "primary",
                                        "backup",
                                        "prefix_length") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.source.is_set or
                            self.primary.is_set or
                            self.backup.is_set or
                            self.prefix_length.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.source.yfilter != YFilter.not_set or
                            self.primary.yfilter != YFilter.not_set or
                            self.backup.yfilter != YFilter.not_set or
                            self.prefix_length.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "cs-multicast-only-frr" + "[source='" + self.source.get() + "']" + "[primary='" + self.primary.get() + "']" + "[backup='" + self.backup.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/cs-multicast-only-frrs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source.get_name_leafdata())
                        if (self.primary.is_set or self.primary.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.primary.get_name_leafdata())
                        if (self.backup.is_set or self.backup.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.backup.get_name_leafdata())
                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_length.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "source" or name == "primary" or name == "backup" or name == "prefix-length"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "source"):
                            self.source = value
                            self.source.value_namespace = name_space
                            self.source.value_namespace_prefix = name_space_prefix
                        if(value_path == "primary"):
                            self.primary = value
                            self.primary.value_namespace = name_space
                            self.primary.value_namespace_prefix = name_space_prefix
                        if(value_path == "backup"):
                            self.backup = value
                            self.backup.value_namespace = name_space
                            self.backup.value_namespace_prefix = name_space_prefix
                        if(value_path == "prefix-length"):
                            self.prefix_length = value
                            self.prefix_length.value_namespace = name_space
                            self.prefix_length.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.cs_multicast_only_frr:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.cs_multicast_only_frr:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "cs-multicast-only-frrs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "cs-multicast-only-frr"):
                        for c in self.cs_multicast_only_frr:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs.CsMulticastOnlyFrr()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.cs_multicast_only_frr.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "cs-multicast-only-frr"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class InheritableDefaults(Entity):
                """
                Inheritable defaults
                
                .. attribute:: convergency
                
                	Convergency timeout in seconds
                	**type**\:  int
                
                	**range:** 1800..2400
                
                	**units**\: second
                
                .. attribute:: dr_priority
                
                	Hello DR priority, preference given to larger value
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_interval
                
                	Hello interval in seconds
                	**type**\:  int
                
                	**range:** 1..3600
                
                	**units**\: second
                
                .. attribute:: join_prune_mtu
                
                	Join\-Prune MTU in Bytes
                	**type**\:  int
                
                	**range:** 576..65535
                
                	**units**\: byte
                
                .. attribute:: jp_interval
                
                	Join\-Prune interval in seconds
                	**type**\:  int
                
                	**range:** 10..600
                
                	**units**\: second
                
                .. attribute:: override_interval
                
                	Override interval in milliseconds
                	**type**\:  int
                
                	**range:** 400..65535
                
                	**units**\: millisecond
                
                .. attribute:: propagation_delay
                
                	Propagation delay in milli seconds
                	**type**\:  int
                
                	**range:** 100..32767
                
                	**units**\: millisecond
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.InheritableDefaults, self).__init__()

                    self.yang_name = "inheritable-defaults"
                    self.yang_parent_name = "ipv4"

                    self.convergency = YLeaf(YType.uint32, "convergency")

                    self.dr_priority = YLeaf(YType.uint32, "dr-priority")

                    self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                    self.join_prune_mtu = YLeaf(YType.uint32, "join-prune-mtu")

                    self.jp_interval = YLeaf(YType.uint32, "jp-interval")

                    self.override_interval = YLeaf(YType.uint32, "override-interval")

                    self.propagation_delay = YLeaf(YType.uint32, "propagation-delay")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("convergency",
                                    "dr_priority",
                                    "hello_interval",
                                    "join_prune_mtu",
                                    "jp_interval",
                                    "override_interval",
                                    "propagation_delay") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.InheritableDefaults, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.InheritableDefaults, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.convergency.is_set or
                        self.dr_priority.is_set or
                        self.hello_interval.is_set or
                        self.join_prune_mtu.is_set or
                        self.jp_interval.is_set or
                        self.override_interval.is_set or
                        self.propagation_delay.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.convergency.yfilter != YFilter.not_set or
                        self.dr_priority.yfilter != YFilter.not_set or
                        self.hello_interval.yfilter != YFilter.not_set or
                        self.join_prune_mtu.yfilter != YFilter.not_set or
                        self.jp_interval.yfilter != YFilter.not_set or
                        self.override_interval.yfilter != YFilter.not_set or
                        self.propagation_delay.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "inheritable-defaults" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.convergency.is_set or self.convergency.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.convergency.get_name_leafdata())
                    if (self.dr_priority.is_set or self.dr_priority.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.dr_priority.get_name_leafdata())
                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                    if (self.join_prune_mtu.is_set or self.join_prune_mtu.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.join_prune_mtu.get_name_leafdata())
                    if (self.jp_interval.is_set or self.jp_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.jp_interval.get_name_leafdata())
                    if (self.override_interval.is_set or self.override_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.override_interval.get_name_leafdata())
                    if (self.propagation_delay.is_set or self.propagation_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.propagation_delay.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "convergency" or name == "dr-priority" or name == "hello-interval" or name == "join-prune-mtu" or name == "jp-interval" or name == "override-interval" or name == "propagation-delay"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "convergency"):
                        self.convergency = value
                        self.convergency.value_namespace = name_space
                        self.convergency.value_namespace_prefix = name_space_prefix
                    if(value_path == "dr-priority"):
                        self.dr_priority = value
                        self.dr_priority.value_namespace = name_space
                        self.dr_priority.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-interval"):
                        self.hello_interval = value
                        self.hello_interval.value_namespace = name_space
                        self.hello_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "join-prune-mtu"):
                        self.join_prune_mtu = value
                        self.join_prune_mtu.value_namespace = name_space
                        self.join_prune_mtu.value_namespace_prefix = name_space_prefix
                    if(value_path == "jp-interval"):
                        self.jp_interval = value
                        self.jp_interval.value_namespace = name_space
                        self.jp_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "override-interval"):
                        self.override_interval = value
                        self.override_interval.value_namespace = name_space
                        self.override_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "propagation-delay"):
                        self.propagation_delay = value
                        self.propagation_delay.value_namespace = name_space
                        self.propagation_delay.value_namespace_prefix = name_space_prefix


            class Rpf(Entity):
                """
                Configure RPF options
                
                .. attribute:: route_policy
                
                	Route policy to select RPF topology
                	**type**\:  str
                
                	**length:** 1..64
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Rpf, self).__init__()

                    self.yang_name = "rpf"
                    self.yang_parent_name = "ipv4"

                    self.route_policy = YLeaf(YType.str, "route-policy")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("route_policy") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Rpf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Rpf, self).__setattr__(name, value)

                def has_data(self):
                    return self.route_policy.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.route_policy.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rpf" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.route_policy.is_set or self.route_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_policy.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "route-policy"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "route-policy"):
                        self.route_policy = value
                        self.route_policy.value_namespace = name_space
                        self.route_policy.value_namespace_prefix = name_space_prefix


            class SgExpiryTimer(Entity):
                """
                Configure expiry timer for S,G routes
                
                .. attribute:: access_list_name
                
                	Access\-list of applicable S,G routes
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: interval
                
                	(S,G) expiry time in seconds
                	**type**\:  int
                
                	**range:** 40..57600
                
                	**units**\: second
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.SgExpiryTimer, self).__init__()

                    self.yang_name = "sg-expiry-timer"
                    self.yang_parent_name = "ipv4"

                    self.access_list_name = YLeaf(YType.str, "access-list-name")

                    self.interval = YLeaf(YType.uint32, "interval")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("access_list_name",
                                    "interval") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.SgExpiryTimer, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.SgExpiryTimer, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.access_list_name.is_set or
                        self.interval.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.access_list_name.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "sg-expiry-timer" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.access_list_name.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "access-list-name" or name == "interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "access-list-name"):
                        self.access_list_name = value
                        self.access_list_name.value_namespace = name_space
                        self.access_list_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix


            class RpfVectorEnable(Entity):
                """
                Enable PIM RPF Vector Proxy's
                
                .. attribute:: allow_ebgp
                
                	Allow RPF Vector origination over eBGP sessions
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: disable_ibgp
                
                	Disable RPF Vector origination over iBGP sessions
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: enable
                
                	RPF Vector is turned on if configured
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                	**mandatory**\: True
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.RpfVectorEnable, self).__init__()

                    self.yang_name = "rpf-vector-enable"
                    self.yang_parent_name = "ipv4"
                    self.is_presence_container = True

                    self.allow_ebgp = YLeaf(YType.empty, "allow-ebgp")

                    self.disable_ibgp = YLeaf(YType.empty, "disable-ibgp")

                    self.enable = YLeaf(YType.empty, "enable")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("allow_ebgp",
                                    "disable_ibgp",
                                    "enable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.RpfVectorEnable, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.RpfVectorEnable, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.allow_ebgp.is_set or
                        self.disable_ibgp.is_set or
                        self.enable.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.allow_ebgp.yfilter != YFilter.not_set or
                        self.disable_ibgp.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rpf-vector-enable" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.allow_ebgp.is_set or self.allow_ebgp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.allow_ebgp.get_name_leafdata())
                    if (self.disable_ibgp.is_set or self.disable_ibgp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disable_ibgp.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "allow-ebgp" or name == "disable-ibgp" or name == "enable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "allow-ebgp"):
                        self.allow_ebgp = value
                        self.allow_ebgp.value_namespace = name_space
                        self.allow_ebgp.value_namespace_prefix = name_space_prefix
                    if(value_path == "disable-ibgp"):
                        self.disable_ibgp = value
                        self.disable_ibgp.value_namespace = name_space
                        self.disable_ibgp.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix


            class Nsf(Entity):
                """
                Configure Non\-stop forwarding (NSF) options
                
                .. attribute:: lifetime
                
                	Override default maximum lifetime for PIM NSF mode
                	**type**\:  int
                
                	**range:** 10..600
                
                	**units**\: second
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Nsf, self).__init__()

                    self.yang_name = "nsf"
                    self.yang_parent_name = "ipv4"

                    self.lifetime = YLeaf(YType.uint32, "lifetime")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lifetime") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Nsf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Nsf, self).__setattr__(name, value)

                def has_data(self):
                    return self.lifetime.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lifetime.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nsf" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lifetime.is_set or self.lifetime.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lifetime.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lifetime"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lifetime"):
                        self.lifetime = value
                        self.lifetime.value_namespace = name_space
                        self.lifetime.value_namespace_prefix = name_space_prefix


            class Maximum(Entity):
                """
                Configure PIM State Limits
                
                .. attribute:: bsr_candidate_rp_cache
                
                	Override default maximum and threshold for BSR C\-RP cache setting
                	**type**\:   :py:class:`BsrCandidateRpCache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.BsrCandidateRpCache>`
                
                	**presence node**\: True
                
                .. attribute:: bsr_global_candidate_rp_cache
                
                	Override default global maximum and threshold for C\-RP set in BSR
                	**type**\:   :py:class:`BsrGlobalCandidateRpCache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.BsrGlobalCandidateRpCache>`
                
                	**presence node**\: True
                
                .. attribute:: bsr_global_group_mappings
                
                	Override default global maximum and threshold for PIM group mapping ranges from BSR
                	**type**\:   :py:class:`BsrGlobalGroupMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.BsrGlobalGroupMappings>`
                
                	**presence node**\: True
                
                .. attribute:: bsr_group_mappings
                
                	Override default maximum and threshold for number of group mappings from BSR
                	**type**\:   :py:class:`BsrGroupMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.BsrGroupMappings>`
                
                	**presence node**\: True
                
                .. attribute:: global_group_mappings_auto_rp
                
                	Maximum for number of group mappings from autorp mapping agent
                	**type**\:   :py:class:`GlobalGroupMappingsAutoRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.GlobalGroupMappingsAutoRp>`
                
                	**presence node**\: True
                
                .. attribute:: global_high_priority_packet_queue
                
                	Maximum packet queue size in bytes
                	**type**\:  int
                
                	**range:** 0..2147483648
                
                	**units**\: byte
                
                .. attribute:: global_low_priority_packet_queue
                
                	Maximum packet queue size in bytes
                	**type**\:  int
                
                	**range:** 0..2147483648
                
                	**units**\: byte
                
                .. attribute:: global_register_states
                
                	Override default maximum for number of sparse\-mode source registers
                	**type**\:   :py:class:`GlobalRegisterStates <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.GlobalRegisterStates>`
                
                	**presence node**\: True
                
                .. attribute:: global_route_interfaces
                
                	Override default maximum for number of route\-interfaces
                	**type**\:   :py:class:`GlobalRouteInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.GlobalRouteInterfaces>`
                
                	**presence node**\: True
                
                .. attribute:: global_routes
                
                	Override default maximum for number of routes
                	**type**\:   :py:class:`GlobalRoutes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.GlobalRoutes>`
                
                	**presence node**\: True
                
                .. attribute:: group_mappings_auto_rp
                
                	Override default maximum for number of group mappings from autorp mapping agent
                	**type**\:   :py:class:`GroupMappingsAutoRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.GroupMappingsAutoRp>`
                
                	**presence node**\: True
                
                .. attribute:: register_states
                
                	Override default maximum for number of sparse\-mode source registers
                	**type**\:   :py:class:`RegisterStates <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.RegisterStates>`
                
                	**presence node**\: True
                
                .. attribute:: route_interfaces
                
                	Override default maximum for number of route\-interfaces
                	**type**\:   :py:class:`RouteInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.RouteInterfaces>`
                
                	**presence node**\: True
                
                .. attribute:: routes
                
                	Override default maximum for number of routes
                	**type**\:   :py:class:`Routes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Maximum.Routes>`
                
                	**presence node**\: True
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Maximum, self).__init__()

                    self.yang_name = "maximum"
                    self.yang_parent_name = "ipv4"

                    self.global_high_priority_packet_queue = YLeaf(YType.uint32, "global-high-priority-packet-queue")

                    self.global_low_priority_packet_queue = YLeaf(YType.uint32, "global-low-priority-packet-queue")

                    self.bsr_candidate_rp_cache = None
                    self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                    self._children_yang_names.add("bsr-candidate-rp-cache")

                    self.bsr_global_candidate_rp_cache = None
                    self._children_name_map["bsr_global_candidate_rp_cache"] = "bsr-global-candidate-rp-cache"
                    self._children_yang_names.add("bsr-global-candidate-rp-cache")

                    self.bsr_global_group_mappings = None
                    self._children_name_map["bsr_global_group_mappings"] = "bsr-global-group-mappings"
                    self._children_yang_names.add("bsr-global-group-mappings")

                    self.bsr_group_mappings = None
                    self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                    self._children_yang_names.add("bsr-group-mappings")

                    self.global_group_mappings_auto_rp = None
                    self._children_name_map["global_group_mappings_auto_rp"] = "global-group-mappings-auto-rp"
                    self._children_yang_names.add("global-group-mappings-auto-rp")

                    self.global_register_states = None
                    self._children_name_map["global_register_states"] = "global-register-states"
                    self._children_yang_names.add("global-register-states")

                    self.global_route_interfaces = None
                    self._children_name_map["global_route_interfaces"] = "global-route-interfaces"
                    self._children_yang_names.add("global-route-interfaces")

                    self.global_routes = None
                    self._children_name_map["global_routes"] = "global-routes"
                    self._children_yang_names.add("global-routes")

                    self.group_mappings_auto_rp = None
                    self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                    self._children_yang_names.add("group-mappings-auto-rp")

                    self.register_states = None
                    self._children_name_map["register_states"] = "register-states"
                    self._children_yang_names.add("register-states")

                    self.route_interfaces = None
                    self._children_name_map["route_interfaces"] = "route-interfaces"
                    self._children_yang_names.add("route-interfaces")

                    self.routes = None
                    self._children_name_map["routes"] = "routes"
                    self._children_yang_names.add("routes")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("global_high_priority_packet_queue",
                                    "global_low_priority_packet_queue") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Maximum, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Maximum, self).__setattr__(name, value)


                class BsrGlobalGroupMappings(Entity):
                    """
                    Override default global maximum and threshold
                    for PIM group mapping ranges from BSR
                    
                    .. attribute:: bsr_maximum_global_group_mappings
                    
                    	Global Maximum number of PIM group mapping ranges from BSR
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 500
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.BsrGlobalGroupMappings, self).__init__()

                        self.yang_name = "bsr-global-group-mappings"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_global_group_mappings = YLeaf(YType.uint32, "bsr-maximum-global-group-mappings")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_global_group_mappings",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.BsrGlobalGroupMappings, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.BsrGlobalGroupMappings, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_global_group_mappings.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_global_group_mappings.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-global-group-mappings" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_global_group_mappings.is_set or self.bsr_maximum_global_group_mappings.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_global_group_mappings.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-global-group-mappings" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-global-group-mappings"):
                            self.bsr_maximum_global_group_mappings = value
                            self.bsr_maximum_global_group_mappings.value_namespace = name_space
                            self.bsr_maximum_global_group_mappings.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalRoutes(Entity):
                    """
                    Override default maximum for number of routes
                    
                    .. attribute:: maximum_routes
                    
                    	Maximum number of PIM routes
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**default value**\: 100000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.GlobalRoutes, self).__init__()

                        self.yang_name = "global-routes"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_routes = YLeaf(YType.uint32, "maximum-routes")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_routes",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.GlobalRoutes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.GlobalRoutes, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_routes.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_routes.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-routes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_routes.is_set or self.maximum_routes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_routes.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-routes" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-routes"):
                            self.maximum_routes = value
                            self.maximum_routes.value_namespace = name_space
                            self.maximum_routes.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalGroupMappingsAutoRp(Entity):
                    """
                    Maximum for number of group mappings from
                    autorp mapping agent
                    
                    .. attribute:: maximum_global_group_ranges_auto_rp
                    
                    	Maximum number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: threshold_global_group_ranges_auto_rp
                    
                    	Warning threshold number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 450
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.GlobalGroupMappingsAutoRp, self).__init__()

                        self.yang_name = "global-group-mappings-auto-rp"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_global_group_ranges_auto_rp = YLeaf(YType.uint32, "maximum-global-group-ranges-auto-rp")

                        self.threshold_global_group_ranges_auto_rp = YLeaf(YType.uint32, "threshold-global-group-ranges-auto-rp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_global_group_ranges_auto_rp",
                                        "threshold_global_group_ranges_auto_rp") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.GlobalGroupMappingsAutoRp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.GlobalGroupMappingsAutoRp, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_global_group_ranges_auto_rp.is_set or
                            self.threshold_global_group_ranges_auto_rp.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_global_group_ranges_auto_rp.yfilter != YFilter.not_set or
                            self.threshold_global_group_ranges_auto_rp.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-group-mappings-auto-rp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_global_group_ranges_auto_rp.is_set or self.maximum_global_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_global_group_ranges_auto_rp.get_name_leafdata())
                        if (self.threshold_global_group_ranges_auto_rp.is_set or self.threshold_global_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_global_group_ranges_auto_rp.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-global-group-ranges-auto-rp" or name == "threshold-global-group-ranges-auto-rp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-global-group-ranges-auto-rp"):
                            self.maximum_global_group_ranges_auto_rp = value
                            self.maximum_global_group_ranges_auto_rp.value_namespace = name_space
                            self.maximum_global_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold-global-group-ranges-auto-rp"):
                            self.threshold_global_group_ranges_auto_rp = value
                            self.threshold_global_group_ranges_auto_rp.value_namespace = name_space
                            self.threshold_global_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix


                class BsrGlobalCandidateRpCache(Entity):
                    """
                    Override default global maximum and threshold
                    for C\-RP set in BSR
                    
                    .. attribute:: bsr_maximum_global_candidate_rp_cache
                    
                    	Global Maximum number of PIM C\-RP Sets from BSR
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 100
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.BsrGlobalCandidateRpCache, self).__init__()

                        self.yang_name = "bsr-global-candidate-rp-cache"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_global_candidate_rp_cache = YLeaf(YType.uint32, "bsr-maximum-global-candidate-rp-cache")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_global_candidate_rp_cache",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.BsrGlobalCandidateRpCache, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.BsrGlobalCandidateRpCache, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_global_candidate_rp_cache.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_global_candidate_rp_cache.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-global-candidate-rp-cache" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_global_candidate_rp_cache.is_set or self.bsr_maximum_global_candidate_rp_cache.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_global_candidate_rp_cache.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-global-candidate-rp-cache" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-global-candidate-rp-cache"):
                            self.bsr_maximum_global_candidate_rp_cache = value
                            self.bsr_maximum_global_candidate_rp_cache.value_namespace = name_space
                            self.bsr_maximum_global_candidate_rp_cache.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalRegisterStates(Entity):
                    """
                    Override default maximum for number of
                    sparse\-mode source registers
                    
                    .. attribute:: maximum_register_states
                    
                    	Maximum number of PIM Sparse\-Mode register states
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**default value**\: 20000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.GlobalRegisterStates, self).__init__()

                        self.yang_name = "global-register-states"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_register_states = YLeaf(YType.uint32, "maximum-register-states")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_register_states",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.GlobalRegisterStates, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.GlobalRegisterStates, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_register_states.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_register_states.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-register-states" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_register_states.is_set or self.maximum_register_states.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_register_states.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-register-states" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-register-states"):
                            self.maximum_register_states = value
                            self.maximum_register_states.value_namespace = name_space
                            self.maximum_register_states.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GlobalRouteInterfaces(Entity):
                    """
                    Override default maximum for number of
                    route\-interfaces
                    
                    .. attribute:: maximum_route_interfaces
                    
                    	Maximum number of PIM route\-interfaces
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**default value**\: 300000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.GlobalRouteInterfaces, self).__init__()

                        self.yang_name = "global-route-interfaces"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_route_interfaces = YLeaf(YType.uint32, "maximum-route-interfaces")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_route_interfaces",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.GlobalRouteInterfaces, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.GlobalRouteInterfaces, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_route_interfaces.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_route_interfaces.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "global-route-interfaces" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_route_interfaces.is_set or self.maximum_route_interfaces.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_route_interfaces.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-route-interfaces" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-route-interfaces"):
                            self.maximum_route_interfaces = value
                            self.maximum_route_interfaces.value_namespace = name_space
                            self.maximum_route_interfaces.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class GroupMappingsAutoRp(Entity):
                    """
                    Override default maximum for number of group
                    mappings from autorp mapping agent
                    
                    .. attribute:: maximum_group_ranges_auto_rp
                    
                    	Maximum number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: threshold_group_ranges_auto_rp
                    
                    	Warning threshold number of PIM group mappings from autorp
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 450
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.GroupMappingsAutoRp, self).__init__()

                        self.yang_name = "group-mappings-auto-rp"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_group_ranges_auto_rp = YLeaf(YType.uint32, "maximum-group-ranges-auto-rp")

                        self.threshold_group_ranges_auto_rp = YLeaf(YType.uint32, "threshold-group-ranges-auto-rp")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_group_ranges_auto_rp",
                                        "threshold_group_ranges_auto_rp") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.GroupMappingsAutoRp, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_group_ranges_auto_rp.is_set or
                            self.threshold_group_ranges_auto_rp.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set or
                            self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "group-mappings-auto-rp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_group_ranges_auto_rp.is_set or self.maximum_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_group_ranges_auto_rp.get_name_leafdata())
                        if (self.threshold_group_ranges_auto_rp.is_set or self.threshold_group_ranges_auto_rp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_group_ranges_auto_rp.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-group-ranges-auto-rp" or name == "threshold-group-ranges-auto-rp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-group-ranges-auto-rp"):
                            self.maximum_group_ranges_auto_rp = value
                            self.maximum_group_ranges_auto_rp.value_namespace = name_space
                            self.maximum_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold-group-ranges-auto-rp"):
                            self.threshold_group_ranges_auto_rp = value
                            self.threshold_group_ranges_auto_rp.value_namespace = name_space
                            self.threshold_group_ranges_auto_rp.value_namespace_prefix = name_space_prefix


                class BsrGroupMappings(Entity):
                    """
                    Override default maximum and threshold for
                    number of group mappings from BSR
                    
                    .. attribute:: bsr_maximum_group_ranges
                    
                    	Maximum number of PIM group mappings from BSR
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 500
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.BsrGroupMappings, self).__init__()

                        self.yang_name = "bsr-group-mappings"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_group_ranges = YLeaf(YType.uint32, "bsr-maximum-group-ranges")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_group_ranges",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.BsrGroupMappings, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.BsrGroupMappings, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_group_ranges.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_group_ranges.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-group-mappings" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_group_ranges.is_set or self.bsr_maximum_group_ranges.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_group_ranges.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-group-ranges" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-group-ranges"):
                            self.bsr_maximum_group_ranges = value
                            self.bsr_maximum_group_ranges.value_namespace = name_space
                            self.bsr_maximum_group_ranges.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class RegisterStates(Entity):
                    """
                    Override default maximum for number of
                    sparse\-mode source registers
                    
                    .. attribute:: maximum_register_states
                    
                    	Maximum number of PIM Sparse\-Mode register states
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 0..75000
                    
                    	**default value**\: 20000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.RegisterStates, self).__init__()

                        self.yang_name = "register-states"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_register_states = YLeaf(YType.uint32, "maximum-register-states")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_register_states",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.RegisterStates, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.RegisterStates, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_register_states.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_register_states.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "register-states" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_register_states.is_set or self.maximum_register_states.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_register_states.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-register-states" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-register-states"):
                            self.maximum_register_states = value
                            self.maximum_register_states.value_namespace = name_space
                            self.maximum_register_states.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class RouteInterfaces(Entity):
                    """
                    Override default maximum for number of
                    route\-interfaces
                    
                    .. attribute:: maximum_route_interfaces
                    
                    	Maximum number of PIM route\-interfaces
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..1100000
                    
                    	**default value**\: 300000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.RouteInterfaces, self).__init__()

                        self.yang_name = "route-interfaces"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_route_interfaces = YLeaf(YType.uint32, "maximum-route-interfaces")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_route_interfaces",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.RouteInterfaces, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.RouteInterfaces, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_route_interfaces.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_route_interfaces.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "route-interfaces" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_route_interfaces.is_set or self.maximum_route_interfaces.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_route_interfaces.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-route-interfaces" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-route-interfaces"):
                            self.maximum_route_interfaces = value
                            self.maximum_route_interfaces.value_namespace = name_space
                            self.maximum_route_interfaces.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class BsrCandidateRpCache(Entity):
                    """
                    Override default maximum and threshold for BSR
                    C\-RP cache setting
                    
                    .. attribute:: bsr_maximum_candidate_rp_cache
                    
                    	Maximum number of BSR C\-RP cache setting
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..10000
                    
                    	**default value**\: 100
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.BsrCandidateRpCache, self).__init__()

                        self.yang_name = "bsr-candidate-rp-cache"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.bsr_maximum_candidate_rp_cache = YLeaf(YType.uint32, "bsr-maximum-candidate-rp-cache")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bsr_maximum_candidate_rp_cache",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.BsrCandidateRpCache, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bsr_maximum_candidate_rp_cache.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bsr-candidate-rp-cache" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bsr_maximum_candidate_rp_cache.is_set or self.bsr_maximum_candidate_rp_cache.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bsr_maximum_candidate_rp_cache.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bsr-maximum-candidate-rp-cache" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bsr-maximum-candidate-rp-cache"):
                            self.bsr_maximum_candidate_rp_cache = value
                            self.bsr_maximum_candidate_rp_cache.value_namespace = name_space
                            self.bsr_maximum_candidate_rp_cache.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix


                class Routes(Entity):
                    """
                    Override default maximum for number of routes
                    
                    .. attribute:: maximum_routes
                    
                    	Maximum number of PIM routes
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**mandatory**\: True
                    
                    .. attribute:: warning_threshold
                    
                    	Set threshold to print warning
                    	**type**\:  int
                    
                    	**range:** 1..200000
                    
                    	**default value**\: 100000
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Maximum.Routes, self).__init__()

                        self.yang_name = "routes"
                        self.yang_parent_name = "maximum"
                        self.is_presence_container = True

                        self.maximum_routes = YLeaf(YType.uint32, "maximum-routes")

                        self.warning_threshold = YLeaf(YType.uint32, "warning-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_routes",
                                        "warning_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Maximum.Routes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Maximum.Routes, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum_routes.is_set or
                            self.warning_threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_routes.yfilter != YFilter.not_set or
                            self.warning_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "routes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/maximum/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_routes.is_set or self.maximum_routes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_routes.get_name_leafdata())
                        if (self.warning_threshold.is_set or self.warning_threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.warning_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-routes" or name == "warning-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-routes"):
                            self.maximum_routes = value
                            self.maximum_routes.value_namespace = name_space
                            self.maximum_routes.value_namespace_prefix = name_space_prefix
                        if(value_path == "warning-threshold"):
                            self.warning_threshold = value
                            self.warning_threshold.value_namespace = name_space
                            self.warning_threshold.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.global_high_priority_packet_queue.is_set or
                        self.global_low_priority_packet_queue.is_set or
                        (self.bsr_candidate_rp_cache is not None) or
                        (self.bsr_global_candidate_rp_cache is not None) or
                        (self.bsr_global_group_mappings is not None) or
                        (self.bsr_group_mappings is not None) or
                        (self.global_group_mappings_auto_rp is not None) or
                        (self.global_register_states is not None) or
                        (self.global_route_interfaces is not None) or
                        (self.global_routes is not None) or
                        (self.group_mappings_auto_rp is not None) or
                        (self.register_states is not None) or
                        (self.route_interfaces is not None) or
                        (self.routes is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.global_high_priority_packet_queue.yfilter != YFilter.not_set or
                        self.global_low_priority_packet_queue.yfilter != YFilter.not_set or
                        (self.bsr_candidate_rp_cache is not None and self.bsr_candidate_rp_cache.has_operation()) or
                        (self.bsr_global_candidate_rp_cache is not None and self.bsr_global_candidate_rp_cache.has_operation()) or
                        (self.bsr_global_group_mappings is not None and self.bsr_global_group_mappings.has_operation()) or
                        (self.bsr_group_mappings is not None and self.bsr_group_mappings.has_operation()) or
                        (self.global_group_mappings_auto_rp is not None and self.global_group_mappings_auto_rp.has_operation()) or
                        (self.global_register_states is not None and self.global_register_states.has_operation()) or
                        (self.global_route_interfaces is not None and self.global_route_interfaces.has_operation()) or
                        (self.global_routes is not None and self.global_routes.has_operation()) or
                        (self.group_mappings_auto_rp is not None and self.group_mappings_auto_rp.has_operation()) or
                        (self.register_states is not None and self.register_states.has_operation()) or
                        (self.route_interfaces is not None and self.route_interfaces.has_operation()) or
                        (self.routes is not None and self.routes.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "maximum" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.global_high_priority_packet_queue.is_set or self.global_high_priority_packet_queue.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_high_priority_packet_queue.get_name_leafdata())
                    if (self.global_low_priority_packet_queue.is_set or self.global_low_priority_packet_queue.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_low_priority_packet_queue.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bsr-candidate-rp-cache"):
                        if (self.bsr_candidate_rp_cache is None):
                            self.bsr_candidate_rp_cache = Pim.DefaultContext.Ipv4.Maximum.BsrCandidateRpCache()
                            self.bsr_candidate_rp_cache.parent = self
                            self._children_name_map["bsr_candidate_rp_cache"] = "bsr-candidate-rp-cache"
                        return self.bsr_candidate_rp_cache

                    if (child_yang_name == "bsr-global-candidate-rp-cache"):
                        if (self.bsr_global_candidate_rp_cache is None):
                            self.bsr_global_candidate_rp_cache = Pim.DefaultContext.Ipv4.Maximum.BsrGlobalCandidateRpCache()
                            self.bsr_global_candidate_rp_cache.parent = self
                            self._children_name_map["bsr_global_candidate_rp_cache"] = "bsr-global-candidate-rp-cache"
                        return self.bsr_global_candidate_rp_cache

                    if (child_yang_name == "bsr-global-group-mappings"):
                        if (self.bsr_global_group_mappings is None):
                            self.bsr_global_group_mappings = Pim.DefaultContext.Ipv4.Maximum.BsrGlobalGroupMappings()
                            self.bsr_global_group_mappings.parent = self
                            self._children_name_map["bsr_global_group_mappings"] = "bsr-global-group-mappings"
                        return self.bsr_global_group_mappings

                    if (child_yang_name == "bsr-group-mappings"):
                        if (self.bsr_group_mappings is None):
                            self.bsr_group_mappings = Pim.DefaultContext.Ipv4.Maximum.BsrGroupMappings()
                            self.bsr_group_mappings.parent = self
                            self._children_name_map["bsr_group_mappings"] = "bsr-group-mappings"
                        return self.bsr_group_mappings

                    if (child_yang_name == "global-group-mappings-auto-rp"):
                        if (self.global_group_mappings_auto_rp is None):
                            self.global_group_mappings_auto_rp = Pim.DefaultContext.Ipv4.Maximum.GlobalGroupMappingsAutoRp()
                            self.global_group_mappings_auto_rp.parent = self
                            self._children_name_map["global_group_mappings_auto_rp"] = "global-group-mappings-auto-rp"
                        return self.global_group_mappings_auto_rp

                    if (child_yang_name == "global-register-states"):
                        if (self.global_register_states is None):
                            self.global_register_states = Pim.DefaultContext.Ipv4.Maximum.GlobalRegisterStates()
                            self.global_register_states.parent = self
                            self._children_name_map["global_register_states"] = "global-register-states"
                        return self.global_register_states

                    if (child_yang_name == "global-route-interfaces"):
                        if (self.global_route_interfaces is None):
                            self.global_route_interfaces = Pim.DefaultContext.Ipv4.Maximum.GlobalRouteInterfaces()
                            self.global_route_interfaces.parent = self
                            self._children_name_map["global_route_interfaces"] = "global-route-interfaces"
                        return self.global_route_interfaces

                    if (child_yang_name == "global-routes"):
                        if (self.global_routes is None):
                            self.global_routes = Pim.DefaultContext.Ipv4.Maximum.GlobalRoutes()
                            self.global_routes.parent = self
                            self._children_name_map["global_routes"] = "global-routes"
                        return self.global_routes

                    if (child_yang_name == "group-mappings-auto-rp"):
                        if (self.group_mappings_auto_rp is None):
                            self.group_mappings_auto_rp = Pim.DefaultContext.Ipv4.Maximum.GroupMappingsAutoRp()
                            self.group_mappings_auto_rp.parent = self
                            self._children_name_map["group_mappings_auto_rp"] = "group-mappings-auto-rp"
                        return self.group_mappings_auto_rp

                    if (child_yang_name == "register-states"):
                        if (self.register_states is None):
                            self.register_states = Pim.DefaultContext.Ipv4.Maximum.RegisterStates()
                            self.register_states.parent = self
                            self._children_name_map["register_states"] = "register-states"
                        return self.register_states

                    if (child_yang_name == "route-interfaces"):
                        if (self.route_interfaces is None):
                            self.route_interfaces = Pim.DefaultContext.Ipv4.Maximum.RouteInterfaces()
                            self.route_interfaces.parent = self
                            self._children_name_map["route_interfaces"] = "route-interfaces"
                        return self.route_interfaces

                    if (child_yang_name == "routes"):
                        if (self.routes is None):
                            self.routes = Pim.DefaultContext.Ipv4.Maximum.Routes()
                            self.routes.parent = self
                            self._children_name_map["routes"] = "routes"
                        return self.routes

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bsr-candidate-rp-cache" or name == "bsr-global-candidate-rp-cache" or name == "bsr-global-group-mappings" or name == "bsr-group-mappings" or name == "global-group-mappings-auto-rp" or name == "global-register-states" or name == "global-route-interfaces" or name == "global-routes" or name == "group-mappings-auto-rp" or name == "register-states" or name == "route-interfaces" or name == "routes" or name == "global-high-priority-packet-queue" or name == "global-low-priority-packet-queue"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "global-high-priority-packet-queue"):
                        self.global_high_priority_packet_queue = value
                        self.global_high_priority_packet_queue.value_namespace = name_space
                        self.global_high_priority_packet_queue.value_namespace_prefix = name_space_prefix
                    if(value_path == "global-low-priority-packet-queue"):
                        self.global_low_priority_packet_queue = value
                        self.global_low_priority_packet_queue.value_namespace = name_space
                        self.global_low_priority_packet_queue.value_namespace_prefix = name_space_prefix


            class Ssm(Entity):
                """
                Configure IP Multicast SSM
                
                .. attribute:: disable
                
                	TRUE if SSM is disabled on this router
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: range
                
                	Access list of groups enabled with SSM
                	**type**\:  str
                
                	**length:** 1..64
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Ssm, self).__init__()

                    self.yang_name = "ssm"
                    self.yang_parent_name = "ipv4"

                    self.disable = YLeaf(YType.boolean, "disable")

                    self.range = YLeaf(YType.str, "range")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("disable",
                                    "range") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Ssm, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Ssm, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.disable.is_set or
                        self.range.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.disable.yfilter != YFilter.not_set or
                        self.range.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ssm" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disable.get_name_leafdata())
                    if (self.range.is_set or self.range.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.range.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "disable" or name == "range"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "disable"):
                        self.disable = value
                        self.disable.value_namespace = name_space
                        self.disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "range"):
                        self.range = value
                        self.range.value_namespace = name_space
                        self.range.value_namespace_prefix = name_space_prefix


            class Injects(Entity):
                """
                Inject Explicit PIM RPF Vector Proxy's
                
                .. attribute:: inject
                
                	Inject Explicit PIM RPF Vector Proxy's
                	**type**\: list of    :py:class:`Inject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Injects.Inject>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Injects, self).__init__()

                    self.yang_name = "injects"
                    self.yang_parent_name = "ipv4"

                    self.inject = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Injects, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Injects, self).__setattr__(name, value)


                class Inject(Entity):
                    """
                    Inject Explicit PIM RPF Vector Proxy's
                    
                    .. attribute:: source_address  <key>
                    
                    	Source Address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: prefix_length  <key>
                    
                    	Masklen
                    	**type**\:  int
                    
                    	**range:** 0..32
                    
                    .. attribute:: rpf_proxy_address
                    
                    	RPF Proxy Address
                    	**type**\:  list of str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Injects.Inject, self).__init__()

                        self.yang_name = "inject"
                        self.yang_parent_name = "injects"

                        self.source_address = YLeaf(YType.str, "source-address")

                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                        self.rpf_proxy_address = YLeafList(YType.str, "rpf-proxy-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("source_address",
                                        "prefix_length",
                                        "rpf_proxy_address") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Injects.Inject, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Injects.Inject, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.rpf_proxy_address.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.source_address.is_set or
                            self.prefix_length.is_set)

                    def has_operation(self):
                        for leaf in self.rpf_proxy_address.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.source_address.yfilter != YFilter.not_set or
                            self.prefix_length.yfilter != YFilter.not_set or
                            self.rpf_proxy_address.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "inject" + "[source-address='" + self.source_address.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/injects/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_address.get_name_leafdata())
                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_length.get_name_leafdata())

                        leaf_name_data.extend(self.rpf_proxy_address.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "source-address" or name == "prefix-length" or name == "rpf-proxy-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "source-address"):
                            self.source_address = value
                            self.source_address.value_namespace = name_space
                            self.source_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "prefix-length"):
                            self.prefix_length = value
                            self.prefix_length.value_namespace = name_space
                            self.prefix_length.value_namespace_prefix = name_space_prefix
                        if(value_path == "rpf-proxy-address"):
                            self.rpf_proxy_address.append(value)

                def has_data(self):
                    for c in self.inject:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.inject:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "injects" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "inject"):
                        for c in self.inject:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.Injects.Inject()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.inject.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "inject"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class BidirRpAddresses(Entity):
                """
                Configure Bidirectional PIM Rendezvous Point
                
                .. attribute:: bidir_rp_address
                
                	Address of the Rendezvous Point
                	**type**\: list of    :py:class:`BidirRpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.BidirRpAddresses.BidirRpAddress>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.BidirRpAddresses, self).__init__()

                    self.yang_name = "bidir-rp-addresses"
                    self.yang_parent_name = "ipv4"

                    self.bidir_rp_address = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.BidirRpAddresses, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.BidirRpAddresses, self).__setattr__(name, value)


                class BidirRpAddress(Entity):
                    """
                    Address of the Rendezvous Point
                    
                    .. attribute:: rp_address  <key>
                    
                    	RP address of Rendezvous Point
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: access_list_name
                    
                    	Access list of groups that should map to a given RP
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: auto_rp_override
                    
                    	TRUE Indicates if static RP config overrides AutoRP and BSR
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.BidirRpAddresses.BidirRpAddress, self).__init__()

                        self.yang_name = "bidir-rp-address"
                        self.yang_parent_name = "bidir-rp-addresses"

                        self.rp_address = YLeaf(YType.str, "rp-address")

                        self.access_list_name = YLeaf(YType.str, "access-list-name")

                        self.auto_rp_override = YLeaf(YType.boolean, "auto-rp-override")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("rp_address",
                                        "access_list_name",
                                        "auto_rp_override") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.BidirRpAddresses.BidirRpAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.rp_address.is_set or
                            self.access_list_name.is_set or
                            self.auto_rp_override.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.rp_address.yfilter != YFilter.not_set or
                            self.access_list_name.yfilter != YFilter.not_set or
                            self.auto_rp_override.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bidir-rp-address" + "[rp-address='" + self.rp_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/bidir-rp-addresses/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.rp_address.is_set or self.rp_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rp_address.get_name_leafdata())
                        if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_list_name.get_name_leafdata())
                        if (self.auto_rp_override.is_set or self.auto_rp_override.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.auto_rp_override.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "rp-address" or name == "access-list-name" or name == "auto-rp-override"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "rp-address"):
                            self.rp_address = value
                            self.rp_address.value_namespace = name_space
                            self.rp_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "access-list-name"):
                            self.access_list_name = value
                            self.access_list_name.value_namespace = name_space
                            self.access_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "auto-rp-override"):
                            self.auto_rp_override = value
                            self.auto_rp_override.value_namespace = name_space
                            self.auto_rp_override.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.bidir_rp_address:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.bidir_rp_address:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "bidir-rp-addresses" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bidir-rp-address"):
                        for c in self.bidir_rp_address:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.BidirRpAddresses.BidirRpAddress()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.bidir_rp_address.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bidir-rp-address"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Bsr(Entity):
                """
                PIM BSR configuration
                
                .. attribute:: candidate_bsr
                
                	PIM Candidate BSR configuration
                	**type**\:   :py:class:`CandidateBsr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Bsr.CandidateBsr>`
                
                	**presence node**\: True
                
                .. attribute:: candidate_rps
                
                	PIM RP configuration
                	**type**\:   :py:class:`CandidateRps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Bsr.CandidateRps>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Bsr, self).__init__()

                    self.yang_name = "bsr"
                    self.yang_parent_name = "ipv4"

                    self.candidate_bsr = None
                    self._children_name_map["candidate_bsr"] = "candidate-bsr"
                    self._children_yang_names.add("candidate-bsr")

                    self.candidate_rps = Pim.DefaultContext.Ipv4.Bsr.CandidateRps()
                    self.candidate_rps.parent = self
                    self._children_name_map["candidate_rps"] = "candidate-rps"
                    self._children_yang_names.add("candidate-rps")


                class CandidateBsr(Entity):
                    """
                    PIM Candidate BSR configuration
                    
                    .. attribute:: address
                    
                    	BSR Address configured
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    	**mandatory**\: True
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    	**mandatory**\: True
                    
                    
                    ----
                    .. attribute:: prefix_length
                    
                    	Hash Mask Length for this candidate BSR
                    	**type**\:  int
                    
                    	**range:** 0..32
                    
                    	**default value**\: 30
                    
                    .. attribute:: priority
                    
                    	Priority of the Candidate BSR
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    	**default value**\: 1
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Bsr.CandidateBsr, self).__init__()

                        self.yang_name = "candidate-bsr"
                        self.yang_parent_name = "bsr"
                        self.is_presence_container = True

                        self.address = YLeaf(YType.str, "address")

                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                        self.priority = YLeaf(YType.uint32, "priority")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("address",
                                        "prefix_length",
                                        "priority") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Bsr.CandidateBsr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Bsr.CandidateBsr, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.address.is_set or
                            self.prefix_length.is_set or
                            self.priority.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.address.yfilter != YFilter.not_set or
                            self.prefix_length.yfilter != YFilter.not_set or
                            self.priority.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "candidate-bsr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/bsr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address.get_name_leafdata())
                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_length.get_name_leafdata())
                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.priority.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "address" or name == "prefix-length" or name == "priority"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "address"):
                            self.address = value
                            self.address.value_namespace = name_space
                            self.address.value_namespace_prefix = name_space_prefix
                        if(value_path == "prefix-length"):
                            self.prefix_length = value
                            self.prefix_length.value_namespace = name_space
                            self.prefix_length.value_namespace_prefix = name_space_prefix
                        if(value_path == "priority"):
                            self.priority = value
                            self.priority.value_namespace = name_space
                            self.priority.value_namespace_prefix = name_space_prefix


                class CandidateRps(Entity):
                    """
                    PIM RP configuration
                    
                    .. attribute:: candidate_rp
                    
                    	Address of PIM SM BSR Candidate\-RP
                    	**type**\: list of    :py:class:`CandidateRp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Bsr.CandidateRps.CandidateRp>`
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Bsr.CandidateRps, self).__init__()

                        self.yang_name = "candidate-rps"
                        self.yang_parent_name = "bsr"

                        self.candidate_rp = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Bsr.CandidateRps, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Bsr.CandidateRps, self).__setattr__(name, value)


                    class CandidateRp(Entity):
                        """
                        Address of PIM SM BSR Candidate\-RP
                        
                        .. attribute:: address  <key>
                        
                        	Address of Candidate\-RP
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: mode  <key>
                        
                        	SM or Bidir
                        	**type**\:   :py:class:`PimProtocolMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.PimProtocolMode>`
                        
                        .. attribute:: group_list
                        
                        	Access\-list specifying the group range for the Candidate\-RP
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: interval
                        
                        	Advertisement interval
                        	**type**\:  int
                        
                        	**range:** 30..600
                        
                        	**default value**\: 60
                        
                        .. attribute:: priority
                        
                        	Priority of the CRP
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        	**default value**\: 192
                        
                        

                        """

                        _prefix = 'ipv4-pim-cfg'
                        _revision = '2016-06-01'

                        def __init__(self):
                            super(Pim.DefaultContext.Ipv4.Bsr.CandidateRps.CandidateRp, self).__init__()

                            self.yang_name = "candidate-rp"
                            self.yang_parent_name = "candidate-rps"

                            self.address = YLeaf(YType.str, "address")

                            self.mode = YLeaf(YType.enumeration, "mode")

                            self.group_list = YLeaf(YType.str, "group-list")

                            self.interval = YLeaf(YType.uint32, "interval")

                            self.priority = YLeaf(YType.uint32, "priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "mode",
                                            "group_list",
                                            "interval",
                                            "priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Pim.DefaultContext.Ipv4.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Pim.DefaultContext.Ipv4.Bsr.CandidateRps.CandidateRp, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.mode.is_set or
                                self.group_list.is_set or
                                self.interval.is_set or
                                self.priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.mode.yfilter != YFilter.not_set or
                                self.group_list.yfilter != YFilter.not_set or
                                self.interval.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "candidate-rp" + "[address='" + self.address.get() + "']" + "[mode='" + self.mode.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/bsr/candidate-rps/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mode.get_name_leafdata())
                            if (self.group_list.is_set or self.group_list.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.group_list.get_name_leafdata())
                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interval.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address" or name == "mode" or name == "group-list" or name == "interval" or name == "priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "mode"):
                                self.mode = value
                                self.mode.value_namespace = name_space
                                self.mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "group-list"):
                                self.group_list = value
                                self.group_list.value_namespace = name_space
                                self.group_list.value_namespace_prefix = name_space_prefix
                            if(value_path == "interval"):
                                self.interval = value
                                self.interval.value_namespace = name_space
                                self.interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.candidate_rp:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.candidate_rp:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "candidate-rps" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/bsr/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "candidate-rp"):
                            for c in self.candidate_rp:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Pim.DefaultContext.Ipv4.Bsr.CandidateRps.CandidateRp()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.candidate_rp.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "candidate-rp"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.candidate_rps is not None and self.candidate_rps.has_data()) or
                        (self.candidate_bsr is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.candidate_bsr is not None and self.candidate_bsr.has_operation()) or
                        (self.candidate_rps is not None and self.candidate_rps.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "bsr" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "candidate-bsr"):
                        if (self.candidate_bsr is None):
                            self.candidate_bsr = Pim.DefaultContext.Ipv4.Bsr.CandidateBsr()
                            self.candidate_bsr.parent = self
                            self._children_name_map["candidate_bsr"] = "candidate-bsr"
                        return self.candidate_bsr

                    if (child_yang_name == "candidate-rps"):
                        if (self.candidate_rps is None):
                            self.candidate_rps = Pim.DefaultContext.Ipv4.Bsr.CandidateRps()
                            self.candidate_rps.parent = self
                            self._children_name_map["candidate_rps"] = "candidate-rps"
                        return self.candidate_rps

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "candidate-bsr" or name == "candidate-rps"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Paths(Entity):
                """
                Inject PIM RPF Vector Proxy's
                
                .. attribute:: path
                
                	Inject PIM RPF Vector Proxy's
                	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.Paths.Path>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Paths, self).__init__()

                    self.yang_name = "paths"
                    self.yang_parent_name = "ipv4"

                    self.path = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Paths, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Paths, self).__setattr__(name, value)


                class Path(Entity):
                    """
                    Inject PIM RPF Vector Proxy's
                    
                    .. attribute:: source_address  <key>
                    
                    	Source Address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: prefix_length  <key>
                    
                    	Masklen
                    	**type**\:  int
                    
                    	**range:** 0..32
                    
                    .. attribute:: rpf_proxy_address
                    
                    	RPF Proxy Address
                    	**type**\:  list of str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.Paths.Path, self).__init__()

                        self.yang_name = "path"
                        self.yang_parent_name = "paths"

                        self.source_address = YLeaf(YType.str, "source-address")

                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                        self.rpf_proxy_address = YLeafList(YType.str, "rpf-proxy-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("source_address",
                                        "prefix_length",
                                        "rpf_proxy_address") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.Paths.Path, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.Paths.Path, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.rpf_proxy_address.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.source_address.is_set or
                            self.prefix_length.is_set)

                    def has_operation(self):
                        for leaf in self.rpf_proxy_address.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.source_address.yfilter != YFilter.not_set or
                            self.prefix_length.yfilter != YFilter.not_set or
                            self.rpf_proxy_address.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "path" + "[source-address='" + self.source_address.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/paths/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_address.get_name_leafdata())
                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_length.get_name_leafdata())

                        leaf_name_data.extend(self.rpf_proxy_address.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "source-address" or name == "prefix-length" or name == "rpf-proxy-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "source-address"):
                            self.source_address = value
                            self.source_address.value_namespace = name_space
                            self.source_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "prefix-length"):
                            self.prefix_length = value
                            self.prefix_length.value_namespace = name_space
                            self.prefix_length.value_namespace_prefix = name_space_prefix
                        if(value_path == "rpf-proxy-address"):
                            self.rpf_proxy_address.append(value)

                def has_data(self):
                    for c in self.path:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.path:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "paths" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "path"):
                        for c in self.path:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.Paths.Path()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.path.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "path"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AllowRp(Entity):
                """
                Enable allow\-rp filtering for SM joins
                
                .. attribute:: group_list_name
                
                	Access\-list specifiying applicable groups
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: rp_list_name
                
                	Access\-list specifiying applicable RPs
                	**type**\:  str
                
                	**length:** 1..64
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.AllowRp, self).__init__()

                    self.yang_name = "allow-rp"
                    self.yang_parent_name = "ipv4"
                    self.is_presence_container = True

                    self.group_list_name = YLeaf(YType.str, "group-list-name")

                    self.rp_list_name = YLeaf(YType.str, "rp-list-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("group_list_name",
                                    "rp_list_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.AllowRp, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.AllowRp, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.group_list_name.is_set or
                        self.rp_list_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.group_list_name.yfilter != YFilter.not_set or
                        self.rp_list_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "allow-rp" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.group_list_name.is_set or self.group_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.group_list_name.get_name_leafdata())
                    if (self.rp_list_name.is_set or self.rp_list_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rp_list_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "group-list-name" or name == "rp-list-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "group-list-name"):
                        self.group_list_name = value
                        self.group_list_name.value_namespace = name_space
                        self.group_list_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "rp-list-name"):
                        self.rp_list_name = value
                        self.rp_list_name.value_namespace = name_space
                        self.rp_list_name.value_namespace_prefix = name_space_prefix


            class Convergence(Entity):
                """
                Configure convergence parameters
                
                .. attribute:: link_down_prune_delay
                
                	Delay prunes if route join state transitions to not\-joined on link down
                	**type**\:  int
                
                	**range:** 0..60
                
                	**units**\: second
                
                .. attribute:: rpf_conflict_join_delay
                
                	Dampen first join if RPF path is through one of the downstream neighbor
                	**type**\:  int
                
                	**range:** 0..15
                
                	**units**\: second
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.Convergence, self).__init__()

                    self.yang_name = "convergence"
                    self.yang_parent_name = "ipv4"

                    self.link_down_prune_delay = YLeaf(YType.uint32, "link-down-prune-delay")

                    self.rpf_conflict_join_delay = YLeaf(YType.uint32, "rpf-conflict-join-delay")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("link_down_prune_delay",
                                    "rpf_conflict_join_delay") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.Convergence, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.Convergence, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.link_down_prune_delay.is_set or
                        self.rpf_conflict_join_delay.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.link_down_prune_delay.yfilter != YFilter.not_set or
                        self.rpf_conflict_join_delay.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "convergence" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.link_down_prune_delay.is_set or self.link_down_prune_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.link_down_prune_delay.get_name_leafdata())
                    if (self.rpf_conflict_join_delay.is_set or self.rpf_conflict_join_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rpf_conflict_join_delay.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "link-down-prune-delay" or name == "rpf-conflict-join-delay"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "link-down-prune-delay"):
                        self.link_down_prune_delay = value
                        self.link_down_prune_delay.value_namespace = name_space
                        self.link_down_prune_delay.value_namespace_prefix = name_space_prefix
                    if(value_path == "rpf-conflict-join-delay"):
                        self.rpf_conflict_join_delay = value
                        self.rpf_conflict_join_delay.value_namespace = name_space
                        self.rpf_conflict_join_delay.value_namespace_prefix = name_space_prefix


            class CjMulticastOnlyFrrs(Entity):
                """
                Clone Join Multicast Only FRR
                
                .. attribute:: cj_multicast_only_frr
                
                	Clone Join Multicast Only FRR
                	**type**\: list of    :py:class:`CjMulticastOnlyFrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ipv4_pim_cfg.Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr>`
                
                

                """

                _prefix = 'ipv4-pim-cfg'
                _revision = '2016-06-01'

                def __init__(self):
                    super(Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs, self).__init__()

                    self.yang_name = "cj-multicast-only-frrs"
                    self.yang_parent_name = "ipv4"

                    self.cj_multicast_only_frr = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs, self).__setattr__(name, value)


                class CjMulticastOnlyFrr(Entity):
                    """
                    Clone Join Multicast Only FRR
                    
                    .. attribute:: source  <key>
                    
                    	Original address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: primary  <key>
                    
                    	Primary address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: backup  <key>
                    
                    	Backup address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: prefix_length  <key>
                    
                    	Masklen
                    	**type**\:  int
                    
                    	**range:** 0..32
                    
                    

                    """

                    _prefix = 'ipv4-pim-cfg'
                    _revision = '2016-06-01'

                    def __init__(self):
                        super(Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr, self).__init__()

                        self.yang_name = "cj-multicast-only-frr"
                        self.yang_parent_name = "cj-multicast-only-frrs"

                        self.source = YLeaf(YType.str, "source")

                        self.primary = YLeaf(YType.str, "primary")

                        self.backup = YLeaf(YType.str, "backup")

                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("source",
                                        "primary",
                                        "backup",
                                        "prefix_length") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.source.is_set or
                            self.primary.is_set or
                            self.backup.is_set or
                            self.prefix_length.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.source.yfilter != YFilter.not_set or
                            self.primary.yfilter != YFilter.not_set or
                            self.backup.yfilter != YFilter.not_set or
                            self.prefix_length.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "cj-multicast-only-frr" + "[source='" + self.source.get() + "']" + "[primary='" + self.primary.get() + "']" + "[backup='" + self.backup.get() + "']" + "[prefix-length='" + self.prefix_length.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/cj-multicast-only-frrs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source.get_name_leafdata())
                        if (self.primary.is_set or self.primary.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.primary.get_name_leafdata())
                        if (self.backup.is_set or self.backup.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.backup.get_name_leafdata())
                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_length.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "source" or name == "primary" or name == "backup" or name == "prefix-length"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "source"):
                            self.source = value
                            self.source.value_namespace = name_space
                            self.source.value_namespace_prefix = name_space_prefix
                        if(value_path == "primary"):
                            self.primary = value
                            self.primary.value_namespace = name_space
                            self.primary.value_namespace_prefix = name_space_prefix
                        if(value_path == "backup"):
                            self.backup = value
                            self.backup.value_namespace = name_space
                            self.backup.value_namespace_prefix = name_space_prefix
                        if(value_path == "prefix-length"):
                            self.prefix_length = value
                            self.prefix_length.value_namespace = name_space
                            self.prefix_length.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.cj_multicast_only_frr:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.cj_multicast_only_frr:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "cj-multicast-only-frrs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/ipv4/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "cj-multicast-only-frr"):
                        for c in self.cj_multicast_only_frr:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs.CjMulticastOnlyFrr()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.cj_multicast_only_frr.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "cj-multicast-only-frr"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.accept_register.is_set or
                    self.auto_rp_disable.is_set or
                    self.log_neighbor_changes.is_set or
                    self.multipath.is_set or
                    self.neighbor_check_on_receive.is_set or
                    self.neighbor_check_on_send.is_set or
                    self.neighbor_filter.is_set or
                    self.old_register_checksum.is_set or
                    self.register_source.is_set or
                    self.rp_static_deny.is_set or
                    self.spt_threshold_infinity.is_set or
                    self.ssm_allow_override.is_set or
                    self.suppress_data_registers.is_set or
                    self.suppress_rpf_prunes.is_set or
                    (self.auto_rp_candidate_rps is not None and self.auto_rp_candidate_rps.has_data()) or
                    (self.auto_rp_mapping_agent is not None and self.auto_rp_mapping_agent.has_data()) or
                    (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_data()) or
                    (self.bsr is not None and self.bsr.has_data()) or
                    (self.cj_multicast_only_frrs is not None and self.cj_multicast_only_frrs.has_data()) or
                    (self.convergence is not None and self.convergence.has_data()) or
                    (self.cs_multicast_only_frrs is not None and self.cs_multicast_only_frrs.has_data()) or
                    (self.inheritable_defaults is not None and self.inheritable_defaults.has_data()) or
                    (self.injects is not None and self.injects.has_data()) or
                    (self.interfaces is not None and self.interfaces.has_data()) or
                    (self.maximum is not None and self.maximum.has_data()) or
                    (self.multicast_only_frr is not None and self.multicast_only_frr.has_data()) or
                    (self.nsf is not None and self.nsf.has_data()) or
                    (self.paths is not None and self.paths.has_data()) or
                    (self.rpf is not None and self.rpf.has_data()) or
                    (self.rpf_redirect is not None and self.rpf_redirect.has_data()) or
                    (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_data()) or
                    (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_data()) or
                    (self.ssm is not None and self.ssm.has_data()) or
                    (self.allow_rp is not None) or
                    (self.rpf_vector_enable is not None))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.accept_register.yfilter != YFilter.not_set or
                    self.auto_rp_disable.yfilter != YFilter.not_set or
                    self.log_neighbor_changes.yfilter != YFilter.not_set or
                    self.multipath.yfilter != YFilter.not_set or
                    self.neighbor_check_on_receive.yfilter != YFilter.not_set or
                    self.neighbor_check_on_send.yfilter != YFilter.not_set or
                    self.neighbor_filter.yfilter != YFilter.not_set or
                    self.old_register_checksum.yfilter != YFilter.not_set or
                    self.register_source.yfilter != YFilter.not_set or
                    self.rp_static_deny.yfilter != YFilter.not_set or
                    self.spt_threshold_infinity.yfilter != YFilter.not_set or
                    self.ssm_allow_override.yfilter != YFilter.not_set or
                    self.suppress_data_registers.yfilter != YFilter.not_set or
                    self.suppress_rpf_prunes.yfilter != YFilter.not_set or
                    (self.allow_rp is not None and self.allow_rp.has_operation()) or
                    (self.auto_rp_candidate_rps is not None and self.auto_rp_candidate_rps.has_operation()) or
                    (self.auto_rp_mapping_agent is not None and self.auto_rp_mapping_agent.has_operation()) or
                    (self.bidir_rp_addresses is not None and self.bidir_rp_addresses.has_operation()) or
                    (self.bsr is not None and self.bsr.has_operation()) or
                    (self.cj_multicast_only_frrs is not None and self.cj_multicast_only_frrs.has_operation()) or
                    (self.convergence is not None and self.convergence.has_operation()) or
                    (self.cs_multicast_only_frrs is not None and self.cs_multicast_only_frrs.has_operation()) or
                    (self.inheritable_defaults is not None and self.inheritable_defaults.has_operation()) or
                    (self.injects is not None and self.injects.has_operation()) or
                    (self.interfaces is not None and self.interfaces.has_operation()) or
                    (self.maximum is not None and self.maximum.has_operation()) or
                    (self.multicast_only_frr is not None and self.multicast_only_frr.has_operation()) or
                    (self.nsf is not None and self.nsf.has_operation()) or
                    (self.paths is not None and self.paths.has_operation()) or
                    (self.rpf is not None and self.rpf.has_operation()) or
                    (self.rpf_redirect is not None and self.rpf_redirect.has_operation()) or
                    (self.rpf_vector_enable is not None and self.rpf_vector_enable.has_operation()) or
                    (self.sg_expiry_timer is not None and self.sg_expiry_timer.has_operation()) or
                    (self.sparse_mode_rp_addresses is not None and self.sparse_mode_rp_addresses.has_operation()) or
                    (self.ssm is not None and self.ssm.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/default-context/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.accept_register.is_set or self.accept_register.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.accept_register.get_name_leafdata())
                if (self.auto_rp_disable.is_set or self.auto_rp_disable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.auto_rp_disable.get_name_leafdata())
                if (self.log_neighbor_changes.is_set or self.log_neighbor_changes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.log_neighbor_changes.get_name_leafdata())
                if (self.multipath.is_set or self.multipath.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.multipath.get_name_leafdata())
                if (self.neighbor_check_on_receive.is_set or self.neighbor_check_on_receive.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_check_on_receive.get_name_leafdata())
                if (self.neighbor_check_on_send.is_set or self.neighbor_check_on_send.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_check_on_send.get_name_leafdata())
                if (self.neighbor_filter.is_set or self.neighbor_filter.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_filter.get_name_leafdata())
                if (self.old_register_checksum.is_set or self.old_register_checksum.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.old_register_checksum.get_name_leafdata())
                if (self.register_source.is_set or self.register_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.register_source.get_name_leafdata())
                if (self.rp_static_deny.is_set or self.rp_static_deny.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.rp_static_deny.get_name_leafdata())
                if (self.spt_threshold_infinity.is_set or self.spt_threshold_infinity.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.spt_threshold_infinity.get_name_leafdata())
                if (self.ssm_allow_override.is_set or self.ssm_allow_override.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ssm_allow_override.get_name_leafdata())
                if (self.suppress_data_registers.is_set or self.suppress_data_registers.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.suppress_data_registers.get_name_leafdata())
                if (self.suppress_rpf_prunes.is_set or self.suppress_rpf_prunes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.suppress_rpf_prunes.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "allow-rp"):
                    if (self.allow_rp is None):
                        self.allow_rp = Pim.DefaultContext.Ipv4.AllowRp()
                        self.allow_rp.parent = self
                        self._children_name_map["allow_rp"] = "allow-rp"
                    return self.allow_rp

                if (child_yang_name == "auto-rp-candidate-rps"):
                    if (self.auto_rp_candidate_rps is None):
                        self.auto_rp_candidate_rps = Pim.DefaultContext.Ipv4.AutoRpCandidateRps()
                        self.auto_rp_candidate_rps.parent = self
                        self._children_name_map["auto_rp_candidate_rps"] = "auto-rp-candidate-rps"
                    return self.auto_rp_candidate_rps

                if (child_yang_name == "auto-rp-mapping-agent"):
                    if (self.auto_rp_mapping_agent is None):
                        self.auto_rp_mapping_agent = Pim.DefaultContext.Ipv4.AutoRpMappingAgent()
                        self.auto_rp_mapping_agent.parent = self
                        self._children_name_map["auto_rp_mapping_agent"] = "auto-rp-mapping-agent"
                    return self.auto_rp_mapping_agent

                if (child_yang_name == "bidir-rp-addresses"):
                    if (self.bidir_rp_addresses is None):
                        self.bidir_rp_addresses = Pim.DefaultContext.Ipv4.BidirRpAddresses()
                        self.bidir_rp_addresses.parent = self
                        self._children_name_map["bidir_rp_addresses"] = "bidir-rp-addresses"
                    return self.bidir_rp_addresses

                if (child_yang_name == "bsr"):
                    if (self.bsr is None):
                        self.bsr = Pim.DefaultContext.Ipv4.Bsr()
                        self.bsr.parent = self
                        self._children_name_map["bsr"] = "bsr"
                    return self.bsr

                if (child_yang_name == "cj-multicast-only-frrs"):
                    if (self.cj_multicast_only_frrs is None):
                        self.cj_multicast_only_frrs = Pim.DefaultContext.Ipv4.CjMulticastOnlyFrrs()
                        self.cj_multicast_only_frrs.parent = self
                        self._children_name_map["cj_multicast_only_frrs"] = "cj-multicast-only-frrs"
                    return self.cj_multicast_only_frrs

                if (child_yang_name == "convergence"):
                    if (self.convergence is None):
                        self.convergence = Pim.DefaultContext.Ipv4.Convergence()
                        self.convergence.parent = self
                        self._children_name_map["convergence"] = "convergence"
                    return self.convergence

                if (child_yang_name == "cs-multicast-only-frrs"):
                    if (self.cs_multicast_only_frrs is None):
                        self.cs_multicast_only_frrs = Pim.DefaultContext.Ipv4.CsMulticastOnlyFrrs()
                        self.cs_multicast_only_frrs.parent = self
                        self._children_name_map["cs_multicast_only_frrs"] = "cs-multicast-only-frrs"
                    return self.cs_multicast_only_frrs

                if (child_yang_name == "inheritable-defaults"):
                    if (self.inheritable_defaults is None):
                        self.inheritable_defaults = Pim.DefaultContext.Ipv4.InheritableDefaults()
                        self.inheritable_defaults.parent = self
                        self._children_name_map["inheritable_defaults"] = "inheritable-defaults"
                    return self.inheritable_defaults

                if (child_yang_name == "injects"):
                    if (self.injects is None):
                        self.injects = Pim.DefaultContext.Ipv4.Injects()
                        self.injects.parent = self
                        self._children_name_map["injects"] = "injects"
                    return self.injects

                if (child_yang_name == "interfaces"):
                    if (self.interfaces is None):
                        self.interfaces = Pim.DefaultContext.Ipv4.Interfaces()
                        self.interfaces.parent = self
                        self._children_name_map["interfaces"] = "interfaces"
                    return self.interfaces

                if (child_yang_name == "maximum"):
                    if (self.maximum is None):
                        self.maximum = Pim.DefaultContext.Ipv4.Maximum()
                        self.maximum.parent = self
                        self._children_name_map["maximum"] = "maximum"
                    return self.maximum

                if (child_yang_name == "multicast-only-frr"):
                    if (self.multicast_only_frr is None):
                        self.multicast_only_frr = Pim.DefaultContext.Ipv4.MulticastOnlyFrr()
                        self.multicast_only_frr.parent = self
                        self._children_name_map["multicast_only_frr"] = "multicast-only-frr"
                    return self.multicast_only_frr

                if (child_yang_name == "nsf"):
                    if (self.nsf is None):
                        self.nsf = Pim.DefaultContext.Ipv4.Nsf()
                        self.nsf.parent = self
                        self._children_name_map["nsf"] = "nsf"
                    return self.nsf

                if (child_yang_name == "paths"):
                    if (self.paths is None):
                        self.paths = Pim.DefaultContext.Ipv4.Paths()
                        self.paths.parent = self
                        self._children_name_map["paths"] = "paths"
                    return self.paths

                if (child_yang_name == "rpf"):
                    if (self.rpf is None):
                        self.rpf = Pim.DefaultContext.Ipv4.Rpf()
                        self.rpf.parent = self
                        self._children_name_map["rpf"] = "rpf"
                    return self.rpf

                if (child_yang_name == "rpf-redirect"):
                    if (self.rpf_redirect is None):
                        self.rpf_redirect = Pim.DefaultContext.Ipv4.RpfRedirect()
                        self.rpf_redirect.parent = self
                        self._children_name_map["rpf_redirect"] = "rpf-redirect"
                    return self.rpf_redirect

                if (child_yang_name == "rpf-vector-enable"):
                    if (self.rpf_vector_enable is None):
                        self.rpf_vector_enable = Pim.DefaultContext.Ipv4.RpfVectorEnable()
                        self.rpf_vector_enable.parent = self
                        self._children_name_map["rpf_vector_enable"] = "rpf-vector-enable"
                    return self.rpf_vector_enable

                if (child_yang_name == "sg-expiry-timer"):
                    if (self.sg_expiry_timer is None):
                        self.sg_expiry_timer = Pim.DefaultContext.Ipv4.SgExpiryTimer()
                        self.sg_expiry_timer.parent = self
                        self._children_name_map["sg_expiry_timer"] = "sg-expiry-timer"
                    return self.sg_expiry_timer

                if (child_yang_name == "sparse-mode-rp-addresses"):
                    if (self.sparse_mode_rp_addresses is None):
                        self.sparse_mode_rp_addresses = Pim.DefaultContext.Ipv4.SparseModeRpAddresses()
                        self.sparse_mode_rp_addresses.parent = self
                        self._children_name_map["sparse_mode_rp_addresses"] = "sparse-mode-rp-addresses"
                    return self.sparse_mode_rp_addresses

                if (child_yang_name == "ssm"):
                    if (self.ssm is None):
                        self.ssm = Pim.DefaultContext.Ipv4.Ssm()
                        self.ssm.parent = self
                        self._children_name_map["ssm"] = "ssm"
                    return self.ssm

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "allow-rp" or name == "auto-rp-candidate-rps" or name == "auto-rp-mapping-agent" or name == "bidir-rp-addresses" or name == "bsr" or name == "cj-multicast-only-frrs" or name == "convergence" or name == "cs-multicast-only-frrs" or name == "inheritable-defaults" or name == "injects" or name == "interfaces" or name == "maximum" or name == "multicast-only-frr" or name == "nsf" or name == "paths" or name == "rpf" or name == "rpf-redirect" or name == "rpf-vector-enable" or name == "sg-expiry-timer" or name == "sparse-mode-rp-addresses" or name == "ssm" or name == "accept-register" or name == "auto-rp-disable" or name == "log-neighbor-changes" or name == "multipath" or name == "neighbor-check-on-receive" or name == "neighbor-check-on-send" or name == "neighbor-filter" or name == "old-register-checksum" or name == "register-source" or name == "rp-static-deny" or name == "spt-threshold-infinity" or name == "ssm-allow-override" or name == "suppress-data-registers" or name == "suppress-rpf-prunes"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "accept-register"):
                    self.accept_register = value
                    self.accept_register.value_namespace = name_space
                    self.accept_register.value_namespace_prefix = name_space_prefix
                if(value_path == "auto-rp-disable"):
                    self.auto_rp_disable = value
                    self.auto_rp_disable.value_namespace = name_space
                    self.auto_rp_disable.value_namespace_prefix = name_space_prefix
                if(value_path == "log-neighbor-changes"):
                    self.log_neighbor_changes = value
                    self.log_neighbor_changes.value_namespace = name_space
                    self.log_neighbor_changes.value_namespace_prefix = name_space_prefix
                if(value_path == "multipath"):
                    self.multipath = value
                    self.multipath.value_namespace = name_space
                    self.multipath.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-check-on-receive"):
                    self.neighbor_check_on_receive = value
                    self.neighbor_check_on_receive.value_namespace = name_space
                    self.neighbor_check_on_receive.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-check-on-send"):
                    self.neighbor_check_on_send = value
                    self.neighbor_check_on_send.value_namespace = name_space
                    self.neighbor_check_on_send.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-filter"):
                    self.neighbor_filter = value
                    self.neighbor_filter.value_namespace = name_space
                    self.neighbor_filter.value_namespace_prefix = name_space_prefix
                if(value_path == "old-register-checksum"):
                    self.old_register_checksum = value
                    self.old_register_checksum.value_namespace = name_space
                    self.old_register_checksum.value_namespace_prefix = name_space_prefix
                if(value_path == "register-source"):
                    self.register_source = value
                    self.register_source.value_namespace = name_space
                    self.register_source.value_namespace_prefix = name_space_prefix
                if(value_path == "rp-static-deny"):
                    self.rp_static_deny = value
                    self.rp_static_deny.value_namespace = name_space
                    self.rp_static_deny.value_namespace_prefix = name_space_prefix
                if(value_path == "spt-threshold-infinity"):
                    self.spt_threshold_infinity = value
                    self.spt_threshold_infinity.value_namespace = name_space
                    self.spt_threshold_infinity.value_namespace_prefix = name_space_prefix
                if(value_path == "ssm-allow-override"):
                    self.ssm_allow_override = value
                    self.ssm_allow_override.value_namespace = name_space
                    self.ssm_allow_override.value_namespace_prefix = name_space_prefix
                if(value_path == "suppress-data-registers"):
                    self.suppress_data_registers = value
                    self.suppress_data_registers.value_namespace = name_space
                    self.suppress_data_registers.value_namespace_prefix = name_space_prefix
                if(value_path == "suppress-rpf-prunes"):
                    self.suppress_rpf_prunes = value
                    self.suppress_rpf_prunes.value_namespace = name_space
                    self.suppress_rpf_prunes.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                (self.ipv4 is not None and self.ipv4.has_data()) or
                (self.ipv6 is not None and self.ipv6.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ipv4 is not None and self.ipv4.has_operation()) or
                (self.ipv6 is not None and self.ipv6.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "default-context" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4"):
                if (self.ipv4 is None):
                    self.ipv4 = Pim.DefaultContext.Ipv4()
                    self.ipv4.parent = self
                    self._children_name_map["ipv4"] = "ipv4"
                return self.ipv4

            if (child_yang_name == "ipv6"):
                if (self.ipv6 is None):
                    self.ipv6 = Pim.DefaultContext.Ipv6()
                    self.ipv6.parent = self
                    self._children_name_map["ipv6"] = "ipv6"
                return self.ipv6

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4" or name == "ipv6"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.vrfs is not None and self.vrfs.has_data()) or
            (self.default_context is not None))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.default_context is not None and self.default_context.has_operation()) or
            (self.vrfs is not None and self.vrfs.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-ipv4-pim-cfg:pim" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "default-context"):
            if (self.default_context is None):
                self.default_context = Pim.DefaultContext()
                self.default_context.parent = self
                self._children_name_map["default_context"] = "default-context"
            return self.default_context

        if (child_yang_name == "vrfs"):
            if (self.vrfs is None):
                self.vrfs = Pim.Vrfs()
                self.vrfs.parent = self
                self._children_name_map["vrfs"] = "vrfs"
            return self.vrfs

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "default-context" or name == "vrfs"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Pim()
        return self._top_entity

